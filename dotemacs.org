#+TITLE: .emacs.d files
#+PROPERTY: header-args       :tangle-mode (identity #o444)
#+PROPERTY: header-args+      :mkdirp yes
#+PROPERTY: tangle-target-dir .files

#+STARTUP: overview

* basic tweaks
** language
[[info:emacs#Language Environments][emacs#Language Environments]]

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  ;; language and locale
  (set-language-environment "Japanese")
  (setq system-time-locale "C")

  ;; coding system
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
  (set-selection-coding-system 'utf-8-unix)

  ;; prefer-coding-system take effect equally to follows
  (set-buffer-file-coding-system 'utf-8-unix)
  (set-file-name-coding-system 'utf-8-unix)
  (set-terminal-coding-system 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (setq locale-coding-system 'utf-8-unix)
#+end_src
** visual facets

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  ;; do not use basic GUI facets
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)

  ;; fringe is preferably as thin as possible
  (set-fringe-mode 10)

  ;; do not use visual bell
  (setf visible-bell nil)

  ;; conceal distractions at startup
  (setf initial-scratch-message "")
  (setf inhibit-startup-screen t)
#+end_src
** file hnadling
File-related tweaks including [[info:emacs#Customize Save][Customizing Saving of Files]].

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (use-package files
    :custom
    (mode-require-final-newline 'visit-save)
    (make-backup-files nil)
    (delete-auto-save-files t)
    (enable-remote-dir-locals t)
    :config
    (setq delete-by-moving-to-trash t))

  (use-package saveplace
    :custom
    (save-place-version-control t)
    :config
    (save-place-mode 1))

  (auto-compression-mode 1)

  (setq auto-save-interval 100)
  (setq auto-save-timeout 10)
#+end_src
** modifier keys

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (cond
   ((string= window-system "x")
    (setf x-alt-keysym  'alt
          x-meta-keysym 'meta))
   ((string= window-system "ns")
    ;; IME inline patch
    (setf mac-use-input-method-on-system nil)
    (setf mac-control-modifier       'control
          mac-command-modifier       'meta
          mac-option-modifier        'super
          mac-right-option-modifier  'alt
          mac-right-control-modifier 'super
          mac-function-modifier      'hyper)))
#+end_src
** mark/region
Variables need to be carefully tweaked with [[info:emacs#Mark][manual]].

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  ;; (setq set-mark-command-repeat-pop t)
  (setf mark-ring-max 32)
  (setf highlight-nonselected-windows t)

  ;; text in region will be deleted
  (delete-selection-mode t)
#+end_src

** minibuffer
[[help:savehist-mode][savehist-mode]] saves minibuffer history and additionals.

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (savehist-mode 1)

  (setf history-length 1500)
  (setf history-delete-duplicates t)

  ;; allow y/n answer for an either-or selection
  (fset 'yes-or-no-p 'y-or-n-p)

  (add-hook 'minibuffer-setup-hook 'my/minibuffer-setup-function)

  (defun my/minibuffer-setup-function ()
    ;; disable input method in mini buffer
    (when current-input-method
      (deactivate-input-method))
    ;; decrease font size to 90% in minibuffer
    (setq-local face-remapping-alist '((default :height 0.9))))

  (bind-keys :map minibuffer-local-map
             ("C-r" . counsel-minibuffer-history)
             ("C-M-y" . counsel-yank-pop))

  (setf enable-recursive-minibuffers t)
  (minibuffer-depth-indicate-mode 1)
#+end_src

** displaying

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (setf scroll-step 1)

  (setf text-scale-mode-step 1.0625)

  ;; let the cursor blinking
  (setf blink-cursor-blinks 15)
  (setf blink-cursor-delay 0.7)
  (setf blink-cursor-interval 0.35)
  (blink-cursor-mode 1)

  ;; use emacs in full screen mode
  (when (member (window-system) '(x ns w32))
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+end_src

** text handling

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (setq-default fill-column 80)

  ;; avoid curved quote in docstring (emacs25)
  (setf text-quoting-style 'straight)

  ;; use spaces instead of a horizontal tab
  (setq-default indent-tabs-mode nil)

  (add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src

** performance

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (setq gc-cons-threshold (* 10 gc-cons-threshold))
  (setq message-log-max 10000)
  (setq shell-command-switch "-c")
  (setq undo-outer-limit 64000000)

  (setq-default bidi-display-reordering nil)

  (setq next-screen-context-lines 2)
#+end_src

** customization

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (setf custom-file
        (expand-file-name "custom.el" user-emacs-directory))
#+end_src

** killing

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (custom-set-variables '(yank-pop-change-selection t))
#+end_src
* built-in packages
** auto revert
[[info:emacs#Auto Revert][Auto Revert]]: Keeping buffers automatically up-to-date.

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (use-package autorevert
    :diminish (global-auto-revert-mode auto-revert-mode)
    :custom
    (auto-revert-verbose nil)
    (global-auto-revert-non-file-buffers t)
    :config
    (global-auto-revert-mode 1))
#+end_src
** uniquify
[[info:emacs#Uniquify][Uniquify]] makes buffer names unique.

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward)
    ;; (uniquify-ignore-buffers-re "*[^*]+*")
    )
#+end_src
** recentf
[[info:emacs#File Conveniences][emacs#File Conveniences]]

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (use-package recentf
    :custom
    (recentf-exclude '(".gz" ".xz" ".zip"))
    (recentf-max-saved-items 200)
    (recentf-max-menu-items 15)
    (recentf-auto-cleanup "1:23am")
    :config
    ;; (recentf-load-list)
    (recentf-mode 1))
#+end_src

* external packages
** ivy

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/init.el")
  (use-package ivy
    :straight t
    :config
    (bind-keys :map ivy-minibuffer-map
               ("M-y" . ivy-next-line)
               ;; ("M-w" . ivy-kill-ring-save)
               )
    )
#+end_src

* original packages
** org-password-store

#+begin_src emacs-lisp :tangle (expand-tangle-target ".config/emacs/org-password-store.el")
  (use-package password-store
    :straight t
    :custom
    (password-store-time-before-clipboard-restore 25))

  (defcustom my/org-password-store-property "PASSWORD_STORE"
    "Property used in my/password-store feature to get password-store entry name attached to current org entry.")

  (defmacro with-password-store-entry (entry &rest body)
    "Eval BODY which can refer password-store ENTRY.."
    (declare (indent defun))
    `(let ((entry (or ,entry
                      (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                      (password-store--completing-read t))))
       ,@body))

  (defmacro with-password-store-entry-field (entry field &rest body)
    "Eval BODY which can refer password-store ENTRY and FIELD..

  Plus, OBDY can refer value of FIELD named field-value."
    (declare (indent defun))
    `(let* ((entry (or ,entry
                       (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                       (password-store--completing-read t)))
            (field (or ,field
                       (password-store-read-field entry)))
            (field-value (password-store-get-field entry field)))
       ,@body))

  (defun my/password-store-copy ()
    "Add password for ENTRY into the kill ring.

  `password-store-copy' is responsible for managing the kill ring."
    (interactive)
    (with-password-store-entry nil
      (password-store-copy entry)))

  (defun my/password-store-copy-field ()
    "Add field for entry into the kill ring.

  entry and field is determined by appropriate manner."
    (interactive)
    (with-password-store-entry-field nil nil
      (password-store-copy-field entry field)))

  (defun my/password-store-url (&optional arg)
    "Browse url stored in entry by appropriate manner determined by ARG."
    (interactive "P")
    (with-password-store-entry-field nil "url"
      (cl-case (prefix-numeric-value arg)
        (16 (browse-url field-value))
        (4 (eww-browse-url field-value))
        (t (open-url field-value)))))

  (defun my/password-store-show-field ()
    "Show a field value in the minibuffer.

  Password-store entry and field used to derive this value are from org property
  or selected by user."
    (interactive)
    (with-password-store-entry-field nil nil
      (message "%s: %s" field field-value)))

  (defun my/password-store-create ()
    (interactive)
    (let* ((input (read-string "Entry-name or URL: "))
           (domain (when (string-match-p browse-url-button-regexp input)
                     (string-trim-right
                      (shell-command-to-string (format "echo %s | awk -F[/:] '{print $4}'"
                                                       (shell-quote-argument input)))))))
      (with-password-store-entry (cond
                                  ((> (length domain) 0) domain)
                                  (input))
        (when (derived-mode-p 'org-mode)
          (org-entry-put (point) my/org-password-store-property entry))
        (password-store-edit entry))))

  (defun my/password-store-edit ()
    (interactive)
    (with-password-store-entry nil
      (password-store-edit entry)))

  ;; TODO: make my/password-store-insert as soon after
  ;;     : password-store--run-insert has been implemented

  (defun my/password-store-remove ()
    (interactive)
    (with-password-store-entry nil
      (password-store-remove entry)
      (when (derived-mode-p 'org-mode)
        (org-entry-delete (point) my/org-password-store-property))))

  (defun my/password-store-web-login ()
    (interactive)
    (with-password-store-entry-field nil "username"
      (password-store-copy entry)
      (sleep-for 0.2) ; work around for overlapping message
      (if field-value
          (message "%s: %s" field field-value)
        (message (string-trim-right
                  (concat
                   (when-let ((email (assoc "email" (password-store-parse-entry entry))))
                     (format "%s: %s\n" (car email) (cdr email)))
                   (when-let ((second (nth 1 (password-store-parse-entry entry))))
                     (format "%s: %s\n" (car second) (cdr second)))))))
      (sleep-for 3)
      (funcall-interactively #'my/password-store-url '(16))))

  (advice-add #'password-store-clear :before #'my/password-store-clear)

  (defun my/password-store-clear (&optional field)
    "Overwrite clipboard data so that password once saved in clipboard is deleted
   for security risk.

  FIELD originally for messaging is ignored in this function."
    (interactive)
    (when password-store-kill-ring-pointer
      (kill-new "")
      (setcar kill-ring-yank-pointer "")))

  (with-eval-after-load 'hydra
    (defhydra hydra-password-store (global-map "C-o p"
                                               :color teal)
      "Password store"
      ("cc" my/password-store-copy)
      ("cf" my/password-store-copy-field)
      ("s" my/password-store-show-field)
      ("w" my/password-store-url)
      ("l" my/password-store-web-login)
      ("n" my/password-store-create)
      ("e" my/password-store-edit)
      ("v" my/password-store-edit)
      ("k" my/password-store-remove)
      ("q" nil "quit")))
#+end_src
* helper scripts
** extract_headings
#+begin_src python :tangle (expand-tangle-target ".local/bin/extract_headings") :tangle-mode (identity #o755)
  #!/usr/bin/env python3

  # This script extract most probable page heading.

  import sys
  import lxml.html as html
  from lxml import etree
  import difflib

  if len(sys.argv) == 1:
      INPUT_STR = sys.stdin.read()
      ROOT = html.fromstring(INPUT_STR).getroottree()
  else:
      sys.exit(1)

  OUT_ROOT = etree.Element("headings")

  # extract title text
  title = ''
  title_text_arr = ROOT.xpath('//title[1]//text()')
  if len(title_text_arr):
      title = title_text_arr[0]
      OUT_ROOT.set("title", title.strip())

  htag_text_arr = ROOT.xpath('//*[self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6]')
  for i in range(len(htag_text_arr)):
      text = ''
      texts = htag_text_arr[i].xpath('.//text()')
      if len(texts) == 1:
          text = texts[0].strip()
      elif len(texts) > 1:
          text = ''.join(map(str.strip, texts))
      else:
          continue
      proximity = difflib.SequenceMatcher(None, title, text).ratio()
      heading = etree.Element(htag_text_arr[i].tag)
      heading.text = text
      heading.set('proximity', str(proximity))
      OUT_ROOT.append(heading)

  out_root_str = etree.tostring(OUT_ROOT, encoding='utf-8', method='xml', pretty_print=True)
  if type(out_root_str) is bytes:
      out_root_str = out_root_str.decode()
  print(out_root_str)
#+end_src
** strip_ruby
A program strips all ruby tags in a HTML stream. All HTML contents are expected to be from STDIN and go out as STDOUT. This procedure is mainly for html files converted from pdf and epub files.
Stripping rules are:
- <ruby> tag will be stripped
- <rt> tree for furigana tree will be removed
- <rp> tree contains parenthes for non-ruby-support brouwser will be removed
- <rb> tag for delimiter will be stripped
- <rtc> tree for semantic word will be removed

#+begin_src python :tangle (expand-tangle-target ".local/bin/strip_ruby") :tangle-mode (identity #o755)
  #!/usr/bin/env python3

  import sys
  import lxml.html as html

  INPUT_STR = sys.stdin.read()
  ROOT = html.fromstring(INPUT_STR).getroottree()

  for ruby in ROOT.xpath('//ruby'):
      for rt in ruby.xpath('//rt'):
          rt.drop_tree()
      for rp in ruby.xpath('//rp'):
          rp.drop_tree()
      for rb in ruby.xpath('//rb'):
          rb.drop_tag()
      for rtc in ruby.xpath('//rtc'):
          rtc.drop_tree()
      ruby.drop_tag()

  CONTENT = html.tostring(ROOT, encoding="utf-8", method='html', pretty_print=True)
  print(CONTENT.decode())
#+end_src
