#+TITLE: bin
#+PROPERTY: header-args       :tangle-mode (identity #o755)
#+PROPERTY: header-args+      :mkdirp yes
#+PROPERTY: tangle-target-dir .files

* Local file clean-up (tidyup)
- tidyup
  #+begin_src python :tangle (expand-tangle-target ".local/bin/tidyup")
  #!/usr/bin/env python3

  import os
  import time
  import datetime
  import shutil
  import glob
  from send2trash import send2trash

  TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
  TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                     list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                     + glob.glob(os.path.join(os.environ['HOME'], 'var/tmp/*')))

  MAX_STAY_DAYS_IN_TRASH = 7
  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

  suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
  def humansize(nbytes):
      i = 0
      while nbytes >= 1024 and i < len(suffixes)-1:
          nbytes /= 1024.
          i += 1
      f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
      return '%s %s' % (f, suffixes[i])

  def get_size(start_path = '.'):
      total_size = 0
      for dirpath, dirnames, filenames in os.walk(start_path):
          for f in filenames:
              fp = os.path.join(dirpath, f)
              # skip if it is symbolic link
              if not os.path.islink(fp):
                  total_size += os.path.getsize(fp)

      return total_size

  print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))

  NOW = time.time()

  print('--{0} starts to move files neglected more than {1} days to trash box.\n'
        .format(os.path.basename(__file__),
                MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

  tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
  for a_file in [item for sublist in tidyup_lists for item in sublist]:
      atime = os.lstat(a_file).st_atime
      delta_atime = datetime.timedelta(seconds=(NOW - atime))
      if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
          send2trash(a_file)
          print('moveed to trash: {}'.format(a_file))

  print('--{0} starts to remove files staying more than {1} days in trash box.'
        .format(os.path.basename(__file__),
                MAX_STAY_DAYS_IN_TRASH))

  rbytes_total = 0
  for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
      lstat = os.lstat(trash_file)
      delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
      if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
          method = 'removed'
          fname = os.path.basename(trash_file)
          if os.path.islink(trash_file):
              method = 'unlinked'
              fsize = 'N/A'
              os.unlink(trash_file)
          elif os.path.isfile(trash_file):
              rbytes = os.path.getsize(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              os.remove(trash_file)
          elif os.path.isdir(trash_file):
              rbytes = get_size(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              fname += '/'
              shutil.rmtree(trash_file)
          print('{}: [{:>9}] {}'.format(method, fsize, fname))

  print('--{0} removes [{1}] in total.\n'
        .format(os.path.basename(__file__),
                humansize(rbytes_total)))

  print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                   datetime.datetime.now()))
#+end_src
* Database back-up script
- PostgreSQL
#+begin_src bash :tangle (expand-tangle-target ".local/bin/postgres_backup")
  #!/usr/bin/env bash

  # Usage: $ postgres_backup <db_name> <backup_dir>

  POSTGRES_DBNAME=$1
  BACKUP_DIR=$2
  DATE="$(date +%Y%m%d_%H%M)"

  pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

  exit 0
#+end_src

* Snapshots taking
- snapshot.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/snapshot.sh")
    #!/usr/bin/env bash

    DATETIME=`date "+%Y%m%d-%H%M"`
    BTRFS_MNT="/mnt/ssd01"

    # take a snapshot in btrfs
    if mountpoint ${BTRFS_MNT} >/dev/null 2>&1; then
      btrfs subvolume snapshot "${BTRFS_MNT}/doc" "${BTRFS_MNT}/snapshots/doc-${DATETIME}"
    fi
  #+end_src
* backup scripts
- back_btrfs.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_btrfs.sh")
    #!/usr/bin/env bash

    src_dev=/mnt/ssd01
    src_snap_dir="${src_dev}"/snapshots
    src_back_dir="${src_dev}"/backups
    dst_dev=/mnt/hdd01
    dst_back_dir="${dst_dev}"/backups

    parent=$(ls -d "${src_back_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)
    snap_earliest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | head -1 | xargs basename)
    snap_latest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)

    # backup root snapshot if nothing exists
    if [ -z "${parent}" ] && [ -n "${snap_earliest}" ]; then
      btrfs subvolume snapshot -r "${src_snap_dir}/${snap_earliest}" "${src_back_dir}/${snap_earliest}"
      pwsudo btrfs send "${src_back_dir}/${snap_earliest}" | sudo btrfs receive "${dst_back_dir}"
      parent="${snap_earliest}"
    fi

    # backup latest snapshot by sending differential data
    if [ -n "${parent}" ] && [[ "${parent}" < "${snap_latest}" ]]; then
      btrfs subvolume snapshot  -r "${src_snap_dir}/${snap_latest}" "${src_back_dir}/${snap_latest}"
      pwsudo btrfs send -p "${src_back_dir}/${parent}" "${src_back_dir}/${snap_latest}" | sudo btrfs receive "${dst_back_dir}"
    fi
  #+end_src
- back_rsync.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_rsync.sh")
    #!/usr/bin/env bash

    OPT="-aPh"
    LINK="--link-dest=../last/"
    DEST="ns01:~/share/backups"
    DATETIME=`date "+%Y%m%d-%H%M"`

    ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

    # take a snapshot for pc01
    if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
      rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
    else
      rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
    fi

    # take a snapshot for sv04
    if mountpoint ${HOME}/mnt/sv04 >/dev/null 2>&1; then
      if ssh ns01 "[ -h ~/share/backups/sv04/last ]"; then
        rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt ${HOME}/mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
      else
        rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt ${HOME}/mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
      fi
    fi
 #+end_src
  + rsync exclude file for pc01
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
      + var
      + var/log
      + var/log/**
      - var/lib/dash
      + var/lib
      + var/lib/**
      + work
      + work/**
      + git
      + git/**
      - *
    #+end_src
  + rsync exclude file for sv04
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
      + var
      + var/backup
      + var/backup/**
      - *
    #+end_src

* nhp
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-tangle-target ".local/bin/nhp")
  #!/usr/bin/env bash

  readonly MAIL_FROM="<<email()>>"
  readonly MAIL_TO="<<email()>>"

  function usage() {
    cat <<_EOT_
  Usage:
    $(basename "$0") [options] command|exefile

  Description:
    $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

  Options:
    -l <logfile>  log file name
    -p <pidfile>  process id file name
    -h            help

  _EOT_
    exit 1
  }

  if [ "${OPTIND}" = 1 ]; then
    while getopts l:p:h OPT
    do
      case ${OPT} in
      l)
        opt_logfile=${OPTARG}
        ;;
      p)
        opt_pidfile=${OPTARG}
        ;;
      h)
        usage
        ;;
      \?)
        echo "Try to enter the h option." 1>&2
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi

  shift $((OPTIND - 1))

  function mailtome() {
    local _command=$1
    local _whole_command=$2
    local _logfile_rel=$4

    if [ "$3" -eq 0 ]; then
      _result='success'
    else
      _result='failed'
    fi
    _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

    mailfrom=${MAIL_FROM}
    mailto=${MAIL_TO}
    subject="${_result}: ${_command} @ $(uname -n)"
    msg1="command line      : ${_whole_command}"
    msg2="exit status(nohup): $3"
    msg3="execution time    : $5"
    msg4="pwd               : $(pwd)"
    msg5="Log data (stdout/stderr) is stored in following file:"
    msg6="${_logfile}"

    {
      echo "${msg1}"
      echo "${msg2}"
      echo "${msg3}"
      echo "${msg4}"
      echo "${msg5}"
      echo "${msg6}"
    } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
  }
  export -f mailtome

  if [ $# -eq 1 ] && [ -x "$1" ]; then
    utility="$1"
  elif [ $# -gt 0 ] && type "$1" >/dev/null; then
    utility="$*"
  else
    exit 1
  fi

  LOG_DIR=${HOME}/var/log/$(basename "$0")
  fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

  if [ ! -d "${LOG_DIR}" ]; then
    mkdir -p "${LOG_DIR}"
  fi

  if [ -v "opt_logfile" ]; then
    logfile=${opt_logfile}
  else
    logfile="${LOG_DIR}/${fname_default}.log"
  fi

  if [ -v "opt_pidfile" ]; then
    pidfile=${opt_pidfile}
  else
    pidfile="${LOG_DIR}/${fname_default}.pid"
  fi

  (
    start_time=$(date +%s)
    nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
    PID=$!
    echo $PID >"${pidfile}"
    wait $PID
    EXIT_STATUS=$?
    end_time=$(date +%s)
    exec_time=$((end_time-start_time))
    ((h=exec_time/3600))
    ((m=(exec_time%3600)/60))
    ((s=exec_time%60))
    exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
    mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
  )
  echo "$1 has finished successfully"

  exit 0
#+end_src

* sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-tangle-target ".local/bin/sendmail.py")
  #!/usr/bin/env python3

  import sys
  import argparse
  import subprocess
  import smtplib
  import ssl
  from email.mime.text import MIMEText
  from email.utils import formatdate

  def sendmail(mail_to, mail_from, subject, message):
      smtp_host = 'smtp.daisychain.jp'
      smtp_port = '465'
      smtp_user = '<<email()>>'.split(sep='@')[0]
      smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

      mime_msg = MIMEText(message)
      mime_msg['Subject'] = subject
      mime_msg['From'] = mail_from
      mime_msg['To'] = mail_to
      mime_msg["Date"] = formatdate(None, True)

      if smtp_port == '465':
          context = ssl.create_default_context()
          smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

      if smtp is not None:
          smtp.login(smtp_user, smtp_pass)
          smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
          smtp.quit()


  DESC = 'sendmail.py sends mail'
  parser = argparse.ArgumentParser(description=DESC)
  parser.add_argument('-s', '--subject')
  parser.add_argument('-f', '--mailfrom')
  parser.add_argument('to')
  args = parser.parse_args()

  message = sys.stdin.read()
  sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

* pwsudo
#+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/pwsudo")
  #!/usr/bin/env bash

  _userid=$(whoami)
  _hostname=$(hostname)

  if pass show "${_hostname}/${_userid}" >/dev/null 2>&1; then
    pass show "${_hostname}/${_userid}" | head -1 | sudo -S $*
  else
    sudo $*
  fi
#+end_src
