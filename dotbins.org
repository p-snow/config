#+SETUPFILE: ./export.setup

#+TITLE: Utility Programs (.bin)
#+PROPERTY: header-args       :tangle-mode (identity #o755)
#+PROPERTY: header-args+      :mkdirp yes
#+PROPERTY: tangle-target-dir .files

* Declutters

These scripts (declutter_xxx) keep things decluttered.

- trash
  #+begin_src python :tangle (expand-tangle-target ".local/bin/declutter_trash")
    #!/usr/bin/env python3

    import os
    import time
    import datetime
    import shutil
    import glob
    from send2trash import send2trash

    TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
    TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                       list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                       + glob.glob(os.path.join(os.environ['HOME'], 'var/tmp/*')))

    MAX_STAY_DAYS_IN_TRASH = 7
    MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    def humansize(nbytes):
        i = 0
        while nbytes >= 1024 and i < len(suffixes)-1:
            nbytes /= 1024.
            i += 1
        f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
        return '%s %s' % (f, suffixes[i])

    def get_size(start_path = '.'):
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(start_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                # skip if it is symbolic link
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)

        return total_size

    print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                       datetime.datetime.now()))

    NOW = time.time()

    print('--{0} starts to move files neglected more than {1} days to trash box.\n'
          .format(os.path.basename(__file__),
                  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

    tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
    for a_file in [item for sublist in tidyup_lists for item in sublist]:
        atime = os.lstat(a_file).st_atime
        delta_atime = datetime.timedelta(seconds=(NOW - atime))
        if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
            try:
                send2trash(a_file)
            except OSError as error:
                print(error)
            else:
                print('moveed to trash: {}'.format(a_file))

    print('--{0} starts to remove files staying more than {1} days in trash box.'
          .format(os.path.basename(__file__),
                  MAX_STAY_DAYS_IN_TRASH))

    rbytes_total = 0
    for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
        lstat = os.lstat(trash_file)
        delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
        if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
            method = 'removed'
            fname = os.path.basename(trash_file)
            if os.path.islink(trash_file):
                method = 'unlinked'
                fsize = 'N/A'
                os.unlink(trash_file)
            elif os.path.isfile(trash_file):
                rbytes = os.path.getsize(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                os.remove(trash_file)
            elif os.path.isdir(trash_file):
                rbytes = get_size(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                fname += '/'
                shutil.rmtree(trash_file)
            print('{}: [{:>9}] {}'.format(method, fsize, fname))

    print('--{0} removes [{1}] in total.\n'
          .format(os.path.basename(__file__),
                  humansize(rbytes_total)))

    print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))
#+end_src
- home directory (ruby implementation)
  #+begin_src ruby :tangle (expand-tangle-target ".local/bin/declutter_home")
    #!/usr/bin/env ruby
    # coding: utf-8

    TRASHES = ["*~", "#*#", ".#*#", "._*", ".DS_Store"]

    class Sweep
      def self.sweep(base_dir)
        puts base_dir
        TRASHES.each do |trash|
          tfiles = File.join("%s/**" % base_dir, trash)
          Dir.glob(tfiles).each do |f|
            if File.delete(f) > 0
              puts "Removed: " + f
            else
              puts "CANNOT Removed: " + f
            end
          end
        end
      end
    end

    ARGV.each do |arg|
      if Dir.exist?(arg) then
        Sweep.sweep(arg)
      end
    end
  #+end_src
- home directory (python implementation)
  #+begin_src python :tangle (expand-tangle-target ".local/bin/declutter_home_py")
    #!/usr/bin/env python3

    import sys
    import os
    import glob
    import argparse

    TRASH_REGEXPS = ["*~", "#*", ".#*", "._*", ".DS_Store", "*.dvi", "*.aux", "*.bbl"]

    class Sweepy:
        @classmethod
        def sweep_with_regexp(self, base_dir, recursive=False):
            for trash_regexp in TRASH_REGEXPS:
                files = glob.glob("%s/**/" % base_dir + trash_regexp, recursive=recursive)
                for file in files:
                    if os.path.isfile(file):
                        os.remove(file)
                        print("Removed: " + file)
        @classmethod
        def sweep_broken_symlink(self, base_dir, recursive=False):
            files = glob.glob("%s/*" % base_dir, recursive=recursive)
            dotfiles = glob.glob("%s/.*" % base_dir, recursive=recursive)
            for file in (files + dotfiles):
                if os.path.islink(file):
                    if not os.path.exists(os.readlink(file)):
                        os.unlink(file)
                        print("Unlinked: " + file)

    parser = argparse.ArgumentParser(description='Removes all desired files')
    parser.add_argument('dir', metavar='dir', nargs='?', action='store',
                        help='base directory to search')
    parser.add_argument('-r', dest='recursive', action="store_true", default=False)
    args = parser.parse_args()
    if args.recursive:
        Sweepy.sweep_with_regexp(args.dir, recursive=True)
        Sweepy.sweep_broken_symlink(args.dir, recursive=True)
    else:
        Sweepy.sweep_with_regexp(args.dir, recursive=False)
        Sweepy.sweep_broken_symlink(args.dir, recursive=False)
  #+end_src
* Database back-up scripts
- PostgreSQL
  #+begin_src bash :tangle (expand-tangle-target ".local/bin/postgres_backup")
    #!/usr/bin/env bash

    # Usage: $ postgres_backup <db_name> <backup_dir>

    POSTGRES_DBNAME=$1
    BACKUP_DIR=$2
    DATE="$(date +%Y%m%d_%H%M)"

    pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

    exit 0
  #+end_src

- MySQL
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/mysql_backup")
    #!/usr/bin/env bash

    BACKUP_DIR=~/var/backups/mysql
    RAW_SQL="$(date +%Y%m%d_%H%M)_backup.sql"
    TAR_SQL="${RAW_SQL}.txz"

    (
      cd "${BACKUP_DIR}" || exit 1
      mysqldump --opt --all-databases --events --default-character-set=binary -u root > "${RAW_SQL}"
      tar cfJ "${TAR_SQL}" "${RAW_SQL}"
      rm -f "${RAW_SQL}"
    ) || exit 1

    exit 0
  #+end_src

* Snapshots taking
- snapshot.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/snapshot.sh")
    #!/usr/bin/env bash

    DATETIME=`date "+%Y%m%d-%H%M"`
    BTRFS_MNT="/mnt/ssd01"

    # take a snapshot in btrfs
    if mountpoint ${BTRFS_MNT} >/dev/null 2>&1; then
      btrfs subvolume snapshot "${BTRFS_MNT}/doc" "${BTRFS_MNT}/snapshots/doc-${DATETIME}"
    fi
  #+end_src
* backup scripts
- back_btrfs.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_btrfs.sh")
    #!/usr/bin/env bash

    src_dev=/mnt/ssd01
    src_snap_dir="${src_dev}"/snapshots
    src_back_dir="${src_dev}"/backups
    dst_dev=/mnt/hdd01
    dst_back_dir="${dst_dev}"/backups

    parent=$(ls -d "${src_back_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)
    snap_earliest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | head -1 | xargs basename)
    snap_latest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)

    # backup root snapshot if nothing exists
    if [ -z "${parent}" ] && [ -n "${snap_earliest}" ]; then
      btrfs subvolume snapshot -r "${src_snap_dir}/${snap_earliest}" "${src_back_dir}/${snap_earliest}"
      pwsudo btrfs send "${src_back_dir}/${snap_earliest}" | sudo btrfs receive "${dst_back_dir}"
      parent="${snap_earliest}"
    fi

    # backup latest snapshot by sending differential data
    if [ -n "${parent}" ] && [[ "${parent}" < "${snap_latest}" ]]; then
      btrfs subvolume snapshot  -r "${src_snap_dir}/${snap_latest}" "${src_back_dir}/${snap_latest}"
      pwsudo btrfs send -p "${src_back_dir}/${parent}" "${src_back_dir}/${snap_latest}" | sudo btrfs receive "${dst_back_dir}"
    fi
  #+end_src
- back_rsync.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_rsync.sh")
    #!/usr/bin/env bash

    OPT="-aPh"
    LINK="--link-dest=../last/"
    DEST="ns01:~/share/backups"
    DATETIME=`date "+%Y%m%d-%H%M"`

    ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

    # take a snapshot for pc01
    if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
      rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
    else
      rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
    fi

    # take a snapshot for sv04
    if mountpoint /mnt/sv04 >/dev/null 2>&1; then
      if ssh ns01 "[ -h ~/share/backups/sv04/last ]"; then
        rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
      else
        rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
      fi
    fi
 #+end_src
  + rsync exclude file for pc01
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
      + var
      + var/log
      + var/log/**
      - var/lib/dash
      + var/lib
      + var/lib/**
      + work
      + work/**
      + git
      + git/**
      - *
    #+end_src
  + rsync exclude file for sv04
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
      + var
      + var/backup
      + var/backup/**
      - *
    #+end_src
* filetype

This program determine type of the file.

#+begin_src ruby :tangle (expand-tangle-target ".local/lib/filetype.rb")
  #!/usr/bin/env ruby

  require 'pathname'
  require 'uri'
  require 'shellwords'

  class FileType
    ZIP_PREFIXES = ['Zip archive data']

    def self.type(filename, file_cmd_opt = "")
      if  File.exists?(filename)
        local_opt = ""
        if File.symlink?(filename)
          local_opt += "--dereference"
        end
        `file --brief #{file_cmd_opt} #{local_opt} #{Shellwords.shellescape(filename)}`.strip
      elsif filename =~ /https?:\/\/www\.youtube\.com.*/
        `youtube-dl -f worst -q #{Shellwords.shellescape(filename)} -o - 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      elsif filename =~ URI::DEFAULT_PARSER.make_regexp
        `curl --location --range 0-9999 #{Shellwords.shellescape(filename)} 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      else
        ''
      end
    end

    def self.mime_type(filename)
      type(filename, "--mime-type")
    end

    def self.block_device?(file)
      type(file).start_with?('block special') &&
        mime_type(file) == 'inode/blockdevice'
    end

    def self.iso9660?(file)
      mime_type(file) == 'application/x-iso9660-image'
    end

    def self.video_dvd_image?(file)
      iso9660?(file) && type(file).start_with?('UDF filesystem data')
    end

    def self.html?(file)
      type(file).start_with?("HTML document")
    end

    def self.pdf?(file)
      type(file).start_with?("PDF document")
    end

    def self.epub?(file)
      type(file) == "EPUB document"
    end

    def self.mobi?(file)
      type(file).start_with?("Mobipocket E-book")
    end

    def self.pgp?(file)
      type(file).start_with?("PGP")
    end

    def self.tarpgp?(file)
      pgp?(file) && file.end_with?('.tar.gpg')
    end

    def self.zip?(file)
      type(file).start_with?(*ZIP_PREFIXES)
    end

    def self.video?(file)
      mime_type(file).start_with?("video/")
    end

    def self.audio?(file)
      mime_type(file).start_with?('audio/')
    end

    def self.image?(file)
      mime_type(file).start_with?("image/")
    end

    def self.playable?(file)
      if File.directory?(file)
        Dir.foreach(file) do |fname|
          next if [".", ".."].include?(fname)
          return false unless playable?("#{file}/#{fname}")
        end
        true
      elsif file =~ /https?:\/\/www\.youtube\.com.*/
        true
      else
        type(file).start_with?("ISO Media", "Audio file") ||
          mime_type(file).start_with?("video", "audio", "image")
      end
    end

    def self.dvd_dir?(file)
      false unless mime_type(file) == 'inode/directory'
      File.exist?(Pathname.new(file).join("VIDEO_TS")) ||
        File.exist?(Pathname.new(file).join("video_ts"))
    end
  end
#+end_src
* mediautil

Utility ruby program for manipulating image, audio and video file.

#+begin_src ruby :tangle (expand-tangle-target ".local/bin/mediautil")
  #!/usr/bin/env ruby

  require 'thor'
  require 'open3'
  require 'fileutils'
  require 'tempfile'
  require 'tmpdir'

  require 'filetype'

  class MediaUtil < Thor
    OUTFILE_SUFFIX = "_out"
    DEFAULT_VIDEO_EXT = ".mkv"

    class Names < Struct.new(:in_f, :out_f)
      def in_file()
        in_f
      end
      def out_file(extension = nil)
        if out_f
          out_f
        else
          bn = File.basename(in_f, ".*").gsub(/ /, '_')
          ext = ((extension) ? extension : File.extname(in_file))
          default_out = bn + ext
          if File.file?(default_out)
            10.times do |i|
              try_name = bn + "_" + (i+1).to_s + ext
              unless File.file?(try_name)
                return try_name
              end
            end
          end
          default_out
        end
      end
      def title()
        File.basename(out_file, ".*")
      end
    end
    class Commander < Struct.new(:log, :dry)
      def execute(command)
        if dry
          puts command
        else
          log_str, s_code = Open3.capture2e(command)
          if log
            user_cmd = caller.first.scan(/`(.*)'/).flatten.first.to_s
            log_fname = Time.now.strftime("%Y%m%d_%H%M%S_") + user_cmd + ".log"
            File.open(log_fname, "w") do |f|
              f.puts(log_str)
            end
          else
            puts log_str
          end
          exit false unless s_code.success?
          # exit false
        end
      end
    end

    class_option :log, aliases: "L", :type => :boolean,
                 :desc => "log stdout and stderr instead they reveal in terminal"
    class_option :dryrun, aliases: "D", :type => :boolean

    desc "info <file>", "show information about the video file or DVD directory"
    option :short, aliases: "s", :type => :boolean
    def info(target)
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(target) || FileType.audio?(target)
        commander.execute("ffprobe \"#{target}\" -hide_banner -show_entries format")
      elsif FileType.image?(target)
        if options[:short]
          commander.execute("identify #{target}")
        else
          commander.execute("identify -verbose #{target}")
        end
      elsif FileType.block_device?(target) ||
            FileType.video_dvd_image?(target) ||
            FileType.dvd_dir?(target)
        commander.execute("HandBrakeCLI -i \"#{target}\" --title 0")
      else
        STDERR.puts "Unknown Media Format"
        exit false
      end
    end

    default_command :encode
    desc "encode", "encode video file"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :vencoder, aliases: "e", :type => :string,
           :banner => "libx265|libx264",
           :desc => "video encoder"
    option :vquality, aliases: "q", :type => :string,
           :banner => "24.0",
           :desc => "video encoding quality"
    option :vbitrate, aliases: "b", :type => :string,
           :banner => "1000",
           :desc => "video encoding bitrate in kbps"
    option :aencoder, aliases: "E", :type => :string,
           :banner => "fdk_aac",
           :desc => "audio encoder"
    option :aquality, aliases: "Q", :type => :string,
           :banner => "100.0",
           :desc => "audio encoding quality"
    option :abitrate, aliases: "B", :type => :string,
           :banner => "128",
           :desc => "audio encoding bitrate in kbps"
    option :display, aliases: "d", :type => :string,
           :banner => "1920:1080",
           :desc => 'display (width:height) in which encoded video fit'
    option :fps, aliases: "f", :type => :string,
           :banner => "30",
           :desc => 'max frame rate'
    option :ffmpeg, :type => :string
    def encode()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      vconf = aconf = pconf = nil
      if options[:vencoder] || options[:vquality]
        vconf = VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
      end
      if options[:aencoder] || options[:aquality]
        aconf = AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
      end
      if options[:display] || options[:fps]
        pconf = PictureConfig.new
        pconf.fit_size(options[:display]) if options[:display]
        pconf.decrease_framerate(options[:fps]) if options[:fps]
      end

      if FileType.video?(equip.in_file) then
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                         [FFMPEGOptSet.new(equip.out_file, [vconf, aconf, pconf, "-map_metadata 0", options[:ffmpeg]])]))
      elsif FileType.audio?(equip.in_file) then
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                         [FFMPEGOptSet.new(equip.out_file, [aconf])]))
      elsif FileType.image?(equip.in_file) then
        pconf = ImageConfig.new
        commander.execute(ImageMagick.command(equip.in_file,
                                              equip.out_file,
                                              pconf))
      else
        STDERR.puts "Unknown Media Format"
        exit false
      end
    end

    desc 'cdencode', 'rip and encode CD contents'
    option :device, aliases: 'd', :type => :string,
           :desc => 'Device file'
    option :format, aliases: 'f', :type => :string,
           :banner => 'flac,ogg,m4a', :default => 'flac:-8',
           :desc => 'formats with additinal argument like compression level'
    def cdencode()
      commander = Commander.new(options[:log], options[:dryrun])

      abcde_args = []
      abcde_args << "-d #{options[:device]}" if options[:device]
      abcde_args << '-a default'
      if options[:format] then
        abcde_args << "-o '#{options[:format]}'"
      end
      abcde_args << '-G' # getalbumart
      abcde_args << '-x' # Eject CD

      commander.execute("abcde #{abcde_args.join(' ')}")
    end

    desc 'dvdrip', 'rip(backup) DVD contents'
    option :device, aliases: 'd', :type => :string,
           :desc => 'DVD device file'
    option :out, aliases: 'o', :type => :string,
           :desc => 'output directory name'
    option :name, aliases: 'n', :type => :string,
           :desc => 'root directory name of backup data'
    def dvdrip()
      commander = Commander.new(options[:log], options[:dryrun])

      dvdbackup_opts = ['dvdbackup']
      dvdbackup_opts << '--input=%s' % options[:device] if options[:device]
      dvdbackup_opts << '--output=%s' % options[:out] if options[:out]
      dvdbackup_opts << '--name=%s' % options[:name] if options[:name]
      dvdbackup_opts << '--mirror'
      dvdbackup_opts << '--progress'
      dvdbackup_opts << '--verbose'

      commander.execute(dvdbackup_opts.join(' '))
    end

    desc 'dvdencode', 'encode DVD contents'
    option :in, aliases: 'i', :type => :string, :required => true,
           :desc => 'input source, DVD device file or backuped DVD file'
    option :out, aliases: 'o', :type => :string,
           :desc => 'output directory name'
    option :vencoder, aliases: "e", :type => :string,
           :banner => "x265|x264",
           :desc => "video encoder"
    option :vquality, aliases: "q", :type => :string,
           :banner => "24.0",
           :desc => "video encoding quality"
    option :vbitrate, aliases: "b", :type => :string,
           :banner => "1000",
           :desc => "video bitrate in kbps"
    option :aencoder, aliases: "E", :type => :string,
           :banner => "fdk_aac",
           :desc => "audio encoder"
    option :aquality, aliases: "Q", :type => :string,
           :banner => "100.0",
           :desc => "audio encoding quality"
    option :abitrate, aliases: "B", :type => :string,
           :banner => "128",
           :desc => "audio bitrate in kbps"
    option :title, aliases: 't', :type => :string,
           :banner => '1|2|3|...',
           :desc => 'title number'
    option :chapters, aliases: 'c', :type => :string,
           :banner => '1|1-3|1,3,5|...',
           :desc => 'chapter numbers'
    option :audio, aliases: 'a', :type => :string,
           :banner => '1,2,3',
           :desc => 'audio channel'
    option :subtitle, aliases: 's', :type => :string,
           :banner => '1,2',
           :desc => 'subtitle channel'
    option :handbrake, :type => :string,
           :banner => '--handbrake \"--mixdown 5point1,stereo\"',
           :desc => 'HandBrakeCLI options'
    def dvdencode()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.block_device?(equip.in_file) ||
         FileType.video_dvd_image?(equip.in_file) ||
         FileType.dvd_dir?(equip.in_file)
        configs = []
        configs << VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
        configs << AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
        dconf = DVDConfig.new
        dconf.title = options[:title] if options[:title]
        dconf.chapters = options[:chapters] if options[:chapters]
        dconf.audio = options[:audio] if options[:audio]
        dconf.subtitle = options[:subtitle] if options[:subtitle]
        configs << dconf
        commander.execute(HandBrakeCLI.command(equip.in_file,
                                               equip.out_file(DEFAULT_VIDEO_EXT),
                                               configs,
                                               options[:handbrake]))
      end
    end

    desc 'mount <dir>', 'Mount CD/DVD media to dir.'
    option :device, aliases: "d", :type => :string, :required => true,
           :desc => 'device or iso file to mount',
           :banner => '--mount /dev/dvd|image.iso'
    option :type, aliases: 't', :type => :string,
           :desc => 'mount DVD-Video',
           :banner => '--type data|video'
    def mount(dir)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['mount']
      if options[:type] == 'video' || FileType.video_dvd_image?(options[:device])
        cmd_opts << ['-t', 'iso9660', '-o', 'loop']
      end
      cmd_opts << options[:device]
      cmd_opts << dir

      Dir.mkdir(dir) if !Dir.exist?(dir) && !options[:dryrun]
      commander.execute("sudo #{cmd_opts.join(' ')}")
    end

    desc 'umount', 'unmount dir'
    option :remove, aliases: 'r', :type => :boolean,
           :desc => 'remove dir after unmounting'
    def umount(dir)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['umount']
      cmd_opts << dir

      commander.execute("sudo #{cmd_opts.join(' ')}")

      if options[:remove]
        FileUtils.rmdir(dir)
      end
    end

    desc 'mkiso', 'make ISO image file.'
    option :type, aliases: 't', :type => :string, :required => true,
           :desc => 'DVD image type. Data or Video DVD.',
           :banner => '--type data|video'
    option :volume, aliases: 'V', :type => :string,
           :desc => 'Volume Label'
    option :out, aliases: 'o', :type => :string,
           :desc => 'ISO image file name.',
           :banner => '--out movie.iso'
    def mkiso(file)
      names = Names.new(file, options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      mkisofs_opts = ['mkisofs']
      mkisofs_opts << ["-V", "\"#{options[:volume]}\""] if options[:volume]
      if options[:type] == "data"
        mkisofs_opts << ["-r", "-l", "-J"]
      elsif options[:type]
        mkisofs_opts << "-dvd-video"
      else
        exit 1
      end
      mkisofs_opts << ["-o", "\"#{names.out_file('.iso')}\""]
      mkisofs_opts << "\"#{file}\""

      commander.execute(mkisofs_opts.join(" "))
    end

    desc 'dvdburn <file>', 'Burn file to DVD.'
    option :iso, aliases: 'I', :type => :boolean,
           :desc => 'Set this option if <file> is ISO 9660 compliant.'
    option :volume, aliases: 'V', :type => :string, :default => 'DVD_VIDEO',
           :desc => 'Volume Label'
    option :video, aliases: 'v', :type => :boolean,
           :desc => 'Create DVD video image file to burn.'
    option :speed, aliases: 's', :type => :string, :default => '4',
           :desc => 'Burning Speed',
           :banner => 'n'
    option :device, aliases: 'd', :type => :string,
           :desc => 'Device file', :default => '/dev/sr0'
    def dvdburn(file)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['growisofs']
      cmd_opts << '-dvd-compat'
      cmd_opts << '-speed=%s' % options[:speed]
      if FileType.iso9660?(file) || options[:iso]
        cmd_opts << '-Z %s=%s' % [options[:device], file]
      else
        cmd_opts << '-Z %s' % options[:device]
        mkisofs_opts = []
        mkisofs_opts << ['-V', "\"#{options[:volume]}\""] if options[:volume]
        if options[:video]
          mkisofs_opts << '-dvd-video'
        else # Data-DVD
          mkisofs_opts << ['-r', '-l', '-R']
        end
        mkisofs_opts << file
        cmd_opts << mkisofs_opts
      end

      commander.execute(cmd_opts.join(' '))
    end

    desc "cdburn", "burn files to CD device"
    option :in, aliases: "i", :type => :string, :required => true,
           :desc => "Root Directory for image file"
    option :volume, aliases: "v", :type => :string, :required => true,
           :desc => "Volume ID"
    option :device, aliases: "d", :type => :string,
           :desc => "Device file", :default => "/dev/sr0"
    def cdburn()
      commander = Commander.new(options[:log], options[:dryrun])

      commander.execute("mkisofs -V \"#{options[:volume]}\" -J -r #{options[:in]} | cdrecord -v dev=#{options[:device]} -waiti -")
    end

    desc "screenshot", "take a screenshot of a video at a time"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :time, aliases: "t", :type => :string,
           :desc => "ex. 00:10:22.300"
    def screenshot()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])
      if FileType.video?(equip.in_file) then
        args = ['ffmpeg']
        args << ('-ss %s' % options[:time]) if options[:time]
        args << '-i %s' % equip.in_file
        args << '-vframes 1'
        args << '-q:v 2'
        args << equip.out_file('.jpg')
        commander.execute(args.join(' '))
      end
    end

    desc "clip", "clip a video with specific time span"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :time_begin, aliases: "b", :type => :string,
           :desc => "ex. 00:10:22.300"
    option :time_end, aliases: "e", :type => :string
    def clip()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(equip.in_file) then
        if options[:time_begin] or options[:time_end] then
          in_opts = []
          in_opts << "-ss #{options[:time_begin]}" if options[:time_begin]
          in_opts << "-to #{options[:time_end]}" if options[:time_end]
          out_opts = []
          out_opts << "-vcodec copy"
          out_opts << "-acodec copy"
          out_opts << "-map_metadata 0"
          commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, in_opts)],
                                           [FFMPEGOptSet.new(equip.out_file, out_opts)]))
        end
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "crop", "extract a specific rectangle of a image/video"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :width, aliases: "w", :type => :numeric, :required => true
    option :height, aliases: "h", :type => :numeric, :required => true
    option :xpos, aliases: "x", :type => :numeric,
           :desc => "x coordinate of an original image where cropped image of top-left corner overlaps"
    option :ypos, aliases: "y", :type => :numeric
    def crop()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      width = options[:width]
      height = options[:height]
      xpos = options[:xpos] ? options[:xpos] : 0
      ypos = options[:ypos] ? options[:ypos] : 0
      if FileType.image?(names.in_file) then
        opt = '-crop %dx%d+%dx%d' % [width, height, xpos, ypos]
        commander.execute("convert #{opt} #{names.in_file} #{names.out_file}")
      elsif FileType.video?(names.in_file) then
        args = ['ffmpeg']
        args << '-i %s' % names.in_file
        args << '-vf crop=%d:%d:%d:%d' % [width, height, xpos, ypos]
        args << "-map_metadata 0"
        args << names.out_file
        commander.execute(args.join(' '))
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "trim", "trim a image/video with automated detection"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :threshold, aliases: "t", :type => :string,
           :desc => "threshold where trimming begin and end"
    def trim()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.image?(names.in_file) then
        commander.execute("convert -trim #{names.in_file} #{names.out_file}")
      elsif FileType.audio?(names.in_file) then
        threshold = (options[:threshold]) ? options[:threshold] : "-40dB"
        commander.execute("ffmpeg -i #{names.in_file} -af \"silenceremove=start_periods=1:start_duration=0:start_threshold=#{threshold}:detection=peak\" #{names.out_file}")
      end
    end

    desc "resize", "resize the image"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :width, aliases: "w", :type => :string,
           :banner => "e.g. 300",
           :desc => "resized image width"
    option :height, aliases: "h", :type => :string,
           :banner => "e.g. 200",
           :desc => "resized image height"
    option :operation, aliases: "p", :type => :string,
           :banner => "enlarge|shrink",
           :desc => "permitted operation for resizing"
    def resize()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(names.in_file) then
        if options[:width] and options[:height]
          out_opts = []
          out_opts << format("-vf scale=%s:%s,setsar=1:1", options[:width], options[:height])
          commander.execute(FFMPEG.command([FFMPEGOptSet.new(names.in_file, [])],
                                           [FFMPEGOptSet.new(names.out_file, out_opts)]))
        end
      elsif FileType.image?(names.in_file) then
        return if options[:width] == nil && options[:height] == nil
        if options[:operation] == "enlarge"
          op = "<"
        elsif options[:operation] == "shrink"
          op = ">"
        else
          op = ""
        end
        geometry = format("%sx%s%s", options[:width], options[:height], op)
        commander.execute("convert -resize #{geometry} #{names.in_file} #{names.out_file}")
      end
    end

    desc "concat", "concat multiple files"
    option :in, aliases: "i", :type => :array, :required => true
    option :out, aliases: "o", :type => :string
    def concat()
      names = Names.new(options[:in][0], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      srcs = options[:in]
      output = names.out_file

      if srcs.all? { |src| FileType.video?(src) }
        src_list = ""
        src_file = Tempfile.open()
        chap_file = Tempfile.open()
        chap_file.write("### Create Chapterfile ###\n")
        files_to_remove = []
        time_accumulated = Time.new(0)
        srcs.each_with_index do |src, index|
          valid_src =
            if src =~ /^\p{Ascii}+$/
              src
            else
              Dir::Tmpname.create('base') do |src_dup|
                FileUtils.cp(src, src_dup)
                files_to_remove << src_dup
                src_dup
              end
            end
          src_file.write("file '#{File.expand_path(valid_src)}'\n")
          chap_file.write("CHAPTER#{index + 1}=#{time_accumulated.strftime('%H:%M:%S.%L')}\n")
          chap_file.write("CHAPTER#{index + 1}NAME=#{File.basename(src, File.extname(src))}\n")
          duration = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "#{src}"`.strip().to_f()
          time_accumulated += duration
        end
        src_file.flush
        commander.execute("ffmpeg -n -f concat -safe 0 -i #{src_file.path} -c:v copy -c:a copy -c:s copy -map 0:v -map 0:a -map 0:s? #{output}")
        src_file.close
        chap_file.flush
        commander.execute("MP4Box -chap #{chap_file.path} #{output}")
        chap_file.close
        src_file.unlink
        chap_file.unlink
        FileUtils.rm_f(files_to_remove)
      elsif srcs.all? { |src| FileType.image?(src) }
        commander.execute "convert #{srcs.join(' ')} #{output}"
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "diff", "measure the difference by providing SSIM value"
    option :out, aliases: "o", :type => :string
    def diff(file1, file2)
      commander = Commander.new(options[:log], options[:dryrun])

      if ((FileType.video?(file1) and FileType.video?(file2)) or
          (FileType.image?(file1) and FileType.image?(file2))) then
        if options[:out] then
          commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim=#{options[:out]} -an -f null -")
        else
          commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim -an -f null -")
        end
      end
    end

    desc "mux", "mux to one file which has streams correspond with input files"
    option :video, aliases: "v", :type => :string, :required => true
    option :audio, aliases: "a", :type => :string, :required => true
    option :audio_delay, aliases: "d", :type => :string
    option :out, aliases: "o", :type => :string
    def mux()
      names = Names.new(options[:video], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      in_optsets = []
      in_optsets << FFMPEGOptSet.new(options[:video], [])
      aconf = []
      aconf << "-itsoffset #{options[:audio_delay]}" if options[:audio_delay]
      in_optsets << FFMPEGOptSet.new(options[:audio], aconf)
      commander.execute(FFMPEG.command(in_optsets,
                                       [FFMPEGOptSet.new(names.out_file, [])]))
    end
  end

  class MainConfig
    attr_accessor :start, :end
  end

  class VideoConfig
    attr_accessor :encode, :quality, :bitrate, :preset, :tune, :profile, :level

    DEFAULT_ENCODE = 'vp9'
    DEFAULT_QUALITY = '26'
    DEFAULT_BITRATE = '1000'

    def initialize(encode, quality=nil, bitrate=nil)
      @encode = encode
      @quality = quality
      @bitrate = bitrate

      case @encode
      when "x265"
        @preset = "veryslow"
        @tune = "ssim"
        @profile = "main"
        @level = nil
      when "x264"
        @preset = "veryslow"
        @tune = "film"
        @profile = "main"
        @level = "4.1"
      end
    end
  end

  class PictureConfig
    # conversion options
    attr_accessor :vf_opts, :fps

    def initialize()
      @vf_opts = []
      @vf_opts << "format=yuv420p"
    end

    # down-size to fit to display (width:heigh) in keeping aspect ratio
    def fit_size(display_size)
      @vf_opts << "scale=#{display_size}:force_original_aspect_ratio=decrease"
      @vf_opts << "pad=((iw+1)/2)*2:((ih+1)/2)*2" # avoid width/height to odd
    end

    def decrease_framerate(fps)
      @fps = fps
    end
  end

  class AudioConfig
    attr_accessor :encode, :quality, :bitrate

    DEFAULT_ENCODE = 'opus'
    DEFAULT_QUALITY = '100'
    DEFAULT_BITRATE = '128'

    def initialize(encode, quality=nil, bitrate=nil)
      # @encode = (encode ? encode : DEFAULT_ENCODE)
      @encode = encode
      @quality = quality
      @bitrate = bitrate
    end

    def quality
      case @encode
      when 'opus'
      else
        @quality
      end
    end

    def bitrate
      case @encode
      when 'opus'
        (@bitrate ? @bitrate : DEFAULT_BITRATE)
      else
        @bitrate
      end
    end
  end

  class DVDConfig
    attr_accessor :title, :chapters, :audio, :subtitle, :options
    attr_accessor :chapter_marker

    def initialize
      @chapter_marker = true
    end
  end

  class ImageConfig
    attr_reader :quality # 1~100
  end

  class FFMPEGOptSet < Struct.new(:fname, :optset)
  end

  class FFMPEG
    def self.command(in_optsets, out_optsets)
      opts = ["ffmpeg"]

      infilep = proc do |fname, optset|
        opt_arr = []
        optset.each do |opt|
          if opt.instance_of?(String)
            opt_arr << opt
          end
        end
        opt_arr << ["-i", "\"#{fname}\""]
        next opt_arr
      end
      in_optsets.each do |in_optset|
        opts << infilep.call(in_optset.fname, in_optset.optset)
      end

      outfilep = proc do |fname, optset|
        oopts = []
        optset.each do |opt|
          if opt.instance_of?(VideoConfig)
            case opt.encode
            when 'av1'
              oopts << format("-c:v librav1e")
              if opt.bitrate
                oopts << format("-b:v %sk", opt.bitrate)
              end
            when 'vp9'
              oopts << format("-c:v libvpx-vp9")
              if opt.quality
                oopts << format("-crf %s", opt.quality)
                oopts << format("-b:v 0")
              elsif opt.bitrate
                oopts << format("-b:v %s", opt.bitrate)
              end
            when 'h265'
              oopts << format("-c:v libx265")
              oopts << format("-crf %s", opt.quality)
              oopts << format("-preset %s", opt.preset) if opt.preset
              oopts << format("-tune %s", opt.tune) if opt.tune
              # Currently, ffmpeg â€‹does not support setting profiles on x265
              oopts << format("-profile:v %s", opt.profile) if opt.profile && opt.encoder == 'x264'
              oopts << format("-level %s", opt.level) if opt.level
            else
              oopts << format("-c:v copy")
            end
          elsif opt.instance_of?(AudioConfig)
            case opt.encode
            when 'opus'
              oopts << format("-c:a lib%s", opt.encode)
              oopts << format("-b:a %sk", opt.bitrate) if opt.bitrate
            when 'aac'
              oopts << format("-c:a libfdk_aac")
              if opt.quality
                oopts << format("-aq %s", opt.quality)
                oopts << format("-b:a 0")
              elsif opt.bitrate
                oopts << format("-b:a %s", opt.bitrate)
              end
            else
              oopts << format("-c:a copy")
            end
          elsif opt.instance_of?(PictureConfig)
            oopts << format("-vf \"%s\"", opt.vf_opts.join(",")) if opt.vf_opts && opt.vf_opts.any?
            oopts << format("-r %s", opt.fps) if opt.fps
          elsif opt.instance_of?(String)
            oopts << opt
          end
        end
        oopts << "\"#{fname}\""
        next oopts
      end
      out_optsets.each do |out_optset|
        opts << outfilep.call(out_optset.fname, out_optset.optset)
      end

      opts.join(" ")
    end
  end

  class HandBrakeCLI
    def self.command(input, output, configs, raw_option)
      cmd_opts = ["HandBrakeCLI"]
      cmd_opts << format("--input \"%s\"", input)
      cmd_opts << format("--output \"%s\"", output)
      configs.each do |config|
        if config.instance_of?(VideoConfig)
          case config.encode
          when 'vp9'
            cmd_opts << format("--encoder VP9")
            if config.quality
              cmd_opts << format("--quality %s", config.quality)
              cmd_opts << format("--vb 0")
            elsif config.bitrate
              cmd_opts << format("--vb %s", config.bitrate)
            end
            cmd_opts << format("--encoder-preset veryslow")
          when 'h265' || 'hevc'
            cmd_opts << format("--encoder x265")
            if config.quality
              cmd_opts << format("--quality %s", config.quality)
              cmd_opts << format("--vb 0")
            elsif config.bitrate
              cmd_opts << format("--vb %s", config.bitrate)
            end
            cmd_opts << format("--encoder-preset %s", config.preset) if config.preset
            cmd_opts << format("--encoder-tune %s", config.tune) if config.tune
            cmd_opts << format("--encoder-profile %s", config.profile) if config.profile
            cmd_opts << format("--encoder-level %s", config.level) if config.level
          else
            cmd_opts << format("--encoder %s", config.encode) if config.encode
            cmd_opts << format("--quality %s", config.quality) if config.quality
            cmd_opts << format("--vb %s", config.bitrate) if config.bitrate
          end
        elsif config.instance_of?(AudioConfig)
          case config.encode
          when 'opus'
            cmd_opts << format("--aencoder %s", config.encode)
            cmd_opts << format("--aq %s", config.quality) if config.quality
            cmd_opts << format("--ab %s", config.bitrate) if config.bitrate
          when 'aac'
            cmd_opts << format("--aencoder ca_haac")
            if config.quality
              cmd_opts << format("--aq %s", config.quality)
              cmd_opts << format("--ab 0")
            elsif config.bitrate
              cmd_opts << format("--ab %s", config.bitrate)
            end
          else
            cmd_opts << format("--aencoder copy")
          end
        elsif config.instance_of?(DVDConfig)
          cmd_opts << (config.title ? format("--title %s", config.title) : "--main-feature")
          cmd_opts << format("--chapters %s", config.chapters) if config.chapters
          cmd_opts << "--markers" if config.chapter_marker
          cmd_opts << (config.audio ? format("--audio %s", config.audio) : "--all-audio" )
          cmd_opts << (config.subtitle ? format("--subtitle %s", config.subtitle) : "--all-subtitles" )
        end
      end

      cmd_opts << raw_option if raw_option

      cmd_opts.join(" ")
    end
  end

  class ImageMagick
    COMMAND = "convert %s %s %s %s "

    def self.command(input, output, pconfig, raw_option="")
      input_opt = ""
      output_opt = ""
      if pconfig.instance_of?(ImageConfig) then
        input_opt += "-quality %s" % pconfig.quality if pconfig.quality
        s = COMMAND % [input, input_opt, output, output_opt]
        s
      end
    end
  end

  MediaUtil.start(ARGV)
#+end_src
* genalbum

Personal script for encoding family pictures and movies.

#+begin_src ruby :tangle (expand-tangle-target ".local/bin/genalbum")
  #!/usr/bin/env ruby

  require 'fileutils'
  require 'time'
  require 'exifr'
  require 'streamio-ffmpeg'
  require 'pathname'
  require 'thor'

  PICTURE_FILE_EXTS = [".jpg"]
  MOVIE_FILE_EXTS = [".mp4"]
  ALBUM_DIR_NAME = "album/"
  RENAME_DIR_NAME = "rename/"
  WEB_DIR_NAME = "album_web/"
  IMG_PREFIX = "img_"

  class GenAlbum < Thor
    default_command :album
    desc "[album] -i <img_dir>", "generate album"
    option :in, aliases: "i", :type => :string, :required => true
    def album
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = ALBUM_DIR_NAME

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      Dir.glob(src_path + "/*").each do |img_file|
        basename = File::basename(img_file)
        src_file = src_path + "/" + basename
        dest_file = dest_path + "/" + basename
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          system("convert -resize \"4096x>\" -quality 92 #{src_file} #{dest_file}")
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          system("mediautil encode -i #{src_file} -o #{dest_file} -q 22.0 -Q 100.0")
        end
      end
    end

    desc "web -i <img_dir>", "generate lightweight album for web"
    option :in, aliases: "i", :type => :string, :required => true
    def web
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = WEB_DIR_NAME

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      Dir.glob(src_path + "/*").each do |img_file|
        basename = File::basename(img_file)
        src_file = src_path + "/" + basename
        dest_file = dest_path + "/" + basename
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          system("convert -resize \"1024x>\" -quality 80 #{src_file} #{dest_file}")
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          system("mediautil encode -i #{src_file} -o #{dest_file} -q 26.0 -Q 100.0")
        end
      end
    end

    desc "renmae -i <img_dir>", "rename image files in chlonological order"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    def rename
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = ((options[:out]) ? options[:out] : RENAME_DIR_NAME)

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      img_time = {}
      Dir.glob(src_path + "/*").each do |img_file|
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          pic = EXIFR::JPEG.new(img_file)
          if pic.exif? && pic.date_time_original then
            img_time[img_file] = pic.date_time_original
          else
            img_time[img_file] = Time.now
          end
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          movie = FFMPEG::Movie.new(img_file)
          time = movie.creation_time
          if time then
            img_time[img_file] = time
          else
            img_time[img_file] = Time.now
          end
        end
      end
      img_time = img_time.sort_by{ |_, v| v }

      digit = img_time.length.to_s.length
      digit = 2 if digit < 2
      img_time.each_with_index do |(img, time), i|
        ext = File.extname(img).downcase
        base = IMG_PREFIX + "%0#{digit}d" % (i + 1) + ext
        src_file = img
        dest_file = dest_path + "/" + base
        system("cp #{src_file} #{dest_file}")
      end
    end
  end

  GenAlbum.start(ARGV)
#+end_src

* nhp
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-tangle-target ".local/bin/nhp")
  #!/usr/bin/env bash

  readonly MAIL_FROM="<<email()>>"
  readonly MAIL_TO="<<email()>>"

  function usage() {
    cat <<_EOT_
  Usage:
    $(basename "$0") [options] command|exefile

  Description:
    $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

  Options:
    -l <logfile>  log file name
    -p <pidfile>  process id file name
    -h            help

  _EOT_
    exit 1
  }

  if [ "${OPTIND}" = 1 ]; then
    while getopts l:p:h OPT
    do
      case ${OPT} in
      l)
        opt_logfile=${OPTARG}
        ;;
      p)
        opt_pidfile=${OPTARG}
        ;;
      h)
        usage
        ;;
      \?)
        echo "Try to enter the h option." 1>&2
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi

  shift $((OPTIND - 1))

  function mailtome() {
    local _command=$1
    local _whole_command=$2
    local _logfile_rel=$4

    if [ "$3" -eq 0 ]; then
      _result='success'
    else
      _result='failed'
    fi
    _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

    mailfrom=${MAIL_FROM}
    mailto=${MAIL_TO}
    subject="${_result}: ${_command} @ $(uname -n)"
    msg1="command line      : ${_whole_command}"
    msg2="exit status(nohup): $3"
    msg3="execution time    : $5"
    msg4="pwd               : $(pwd)"
    msg5="Log data (stdout/stderr) is stored in following file:"
    msg6="${_logfile}"

    {
      echo "${msg1}"
      echo "${msg2}"
      echo "${msg3}"
      echo "${msg4}"
      echo "${msg5}"
      echo "${msg6}"
    } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
  }
  export -f mailtome

  if [ $# -eq 1 ] && [ -x "$1" ]; then
    utility="$1"
  elif [ $# -gt 0 ] && type "$1" >/dev/null; then
    utility="$*"
  else
    exit 1
  fi

  LOG_DIR=${HOME}/var/log/$(basename "$0")
  fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

  if [ ! -d "${LOG_DIR}" ]; then
    mkdir -p "${LOG_DIR}"
  fi

  if [ -v "opt_logfile" ]; then
    logfile=${opt_logfile}
  else
    logfile="${LOG_DIR}/${fname_default}.log"
  fi

  if [ -v "opt_pidfile" ]; then
    pidfile=${opt_pidfile}
  else
    pidfile="${LOG_DIR}/${fname_default}.pid"
  fi

  (
    start_time=$(date +%s)
    nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
    PID=$!
    echo $PID >"${pidfile}"
    wait $PID
    EXIT_STATUS=$?
    end_time=$(date +%s)
    exec_time=$((end_time-start_time))
    ((h=exec_time/3600))
    ((m=(exec_time%3600)/60))
    ((s=exec_time%60))
    exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
    mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
  )
  echo "$1 has finished successfully"

  exit 0
#+end_src

* sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-tangle-target ".local/bin/sendmail.py")
  #!/usr/bin/env python3

  import sys
  import argparse
  import subprocess
  import smtplib
  import ssl
  from email.mime.text import MIMEText
  from email.utils import formatdate

  def sendmail(mail_to, mail_from, subject, message):
      smtp_host = 'smtp.daisychain.jp'
      smtp_port = '465'
      smtp_user = '<<email()>>'.split(sep='@')[0]
      smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

      mime_msg = MIMEText(message)
      mime_msg['Subject'] = subject
      mime_msg['From'] = mail_from
      mime_msg['To'] = mail_to
      mime_msg["Date"] = formatdate(None, True)

      if smtp_port == '465':
          context = ssl.create_default_context()
          smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

      if smtp is not None:
          smtp.login(smtp_user, smtp_pass)
          smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
          smtp.quit()


  DESC = 'sendmail.py sends mail'
  parser = argparse.ArgumentParser(description=DESC)
  parser.add_argument('-s', '--subject')
  parser.add_argument('-f', '--mailfrom')
  parser.add_argument('to')
  args = parser.parse_args()

  message = sys.stdin.read()
  sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

* pwsudo
#+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/pwsudo")
  #!/usr/bin/env bash

  _userid=$(whoami)
  _hostname=$(hostname)

  if pass show "${_hostname}/${_userid}" >/dev/null 2>&1; then
    pass show "${_hostname}/${_userid}" | head -1 | sudo -S $*
  else
    sudo $*
  fi
#+end_src

* gitsync

- gitsync-local
  #+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/gitsync-local")
    #!/usr/bin/env bash

    function usage() {
      cat <<_EOT_
    Usage:
      $0 <prj_root>

    Description:
      $0 adds file changes in git projects under root_dir to the repository

    Options:
      prj_root:  a root directory that has git projects as children

    _EOT_
      exit 1
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo} || continue

          # skip if this is not git repo
          git rev-parse || continue

          echo "repository: ${repo}"

          cd `git rev-parse --show-toplevel`
          sync_mode=`git config sync.mode`
          case "${sync_mode}" in
          "auto" )
            # Remove deleted files
            git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
            # Add new files
            git add . >/dev/null 2>&1
            git commit -m "$(date)";;
          "manual" )
            git add -u >/dev/null 2>&1
            git commit -m "$(date)";;
          "none" )
          ;;
          esac
        done
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi
  #+end_src

- gitsync-remote
  #+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/gitsync-remote")
    #!/usr/bin/env bash

    # Local bare repository name
    syncrepo=origin

    # Display repository name only once
    log_repo() {
      [ "x$lastrepo" == "x$repo" ] || {
        printf "\nREPO: ${repo}\n"
        lastrepo="$repo"
      }
    }

    # Log a message for a repository
    log_msg() {
      log_repo
      printf "  $1\n"
    }

    # fast-forward reference $1 to $syncrepo/$1
    fast_forward_ref() {
      log_msg "fast-forwarding ref $1"
      current_ref=$(cat .git/HEAD)
      if [ "x$current_ref" = "xref: refs/heads/$1" ]
      then
        # Check for dirty index
        files=$(git diff-index --name-only HEAD --)
        git merge refs/remotes/$syncrepo/$1
      else
        git branch -f $1 refs/remotes/$syncrepo/$1
      fi
    }

    # Push reference $1 to $syncrepo
    push_ref() {
      log_msg "Pushing ref $1"
      if ! git push --tags --quiet $syncrepo $1
      then
        exit 1
      fi
    }

    # Check if a ref can be moved
    #   - fast-forwards if behind the sync repo and is fast-forwardable
    #   - Does nothing if ref is up to date
    #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
    #   - Fails if ref and $syncrop/ref have diverged
    check_ref() {
      revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
      revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
      if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
      then
        # Ref $1 is up to date.
        :
      elif [ "x$revlist1" = "x" ]
      then
        # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
        fast_forward_ref $1 || exit 1
      elif [ "x$revlist2" = "x" ]
      then
        # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
        push_ref $1 || exit 1
      else
        log_msg "Ref $1 and $syncrepo/$1 have diverged."
        exit 1
      fi
    }

    # Check all local refs with matching refs in the $syncrepo
    check_refs () {
      git for-each-ref refs/heads/* | while read sha1 commit ref
      do
        ref=${ref/refs\/heads\//}
        git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
        do
          if [ "x$sha1" != "x" -a "x$sha2" != "x" ]
          then
            check_ref $ref || exit 1
          fi
        done
      done
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    # For all repositories under $reporoot
    #   Check all refs matching $syncrepo and fast-forward, or push as necessary
    #   to synchronize the ref with $syncrepo
    #   Bail out if ref is not fastforwardable so user can fix and rerun
    retval=0
    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo}

          # continue if this is not git repo
          git rev-parse 2> /dev/null || continue

          upd=$(git remote update $syncrepo 2>&1 || retval=1)
          [ "x$upd" = "xFetching $syncrepo" ] || {
            log_repo
            printf "$upd\n"
          }
          check_refs || retval=1
        done
        exit $retval
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi

    exit $retval
#+end_src
