#+SETUPFILE: ./export.setup

#+TITLE: Utility Programs (.bin)
#+PROPERTY: header-args       :tangle-mode (identity #o755)
#+PROPERTY: header-args+      :mkdirp yes
#+PROPERTY: tangle-target-dir .files

* Declutters

These scripts (declutter_xxx) keep things decluttered.

- trash
  #+begin_src python :tangle (expand-tangle-target ".local/bin/declutter_trash")
    #!/usr/bin/env python3

    import os
    import time
    import datetime
    import shutil
    import glob
    from send2trash import send2trash

    TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
    TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                       list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                       + glob.glob(os.path.join(os.environ['HOME'], 'var/tmp/*')))

    MAX_STAY_DAYS_IN_TRASH = 7
    MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    def humansize(nbytes):
        i = 0
        while nbytes >= 1024 and i < len(suffixes)-1:
            nbytes /= 1024.
            i += 1
        f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
        return '%s %s' % (f, suffixes[i])

    def get_size(start_path = '.'):
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(start_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                # skip if it is symbolic link
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)

        return total_size

    print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                       datetime.datetime.now()))

    NOW = time.time()

    print('--{0} starts to move files neglected more than {1} days to trash box.\n'
          .format(os.path.basename(__file__),
                  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

    tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
    for a_file in [item for sublist in tidyup_lists for item in sublist]:
        atime = os.lstat(a_file).st_atime
        delta_atime = datetime.timedelta(seconds=(NOW - atime))
        if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
            send2trash(a_file)
            print('moveed to trash: {}'.format(a_file))

    print('--{0} starts to remove files staying more than {1} days in trash box.'
          .format(os.path.basename(__file__),
                  MAX_STAY_DAYS_IN_TRASH))

    rbytes_total = 0
    for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
        lstat = os.lstat(trash_file)
        delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
        if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
            method = 'removed'
            fname = os.path.basename(trash_file)
            if os.path.islink(trash_file):
                method = 'unlinked'
                fsize = 'N/A'
                os.unlink(trash_file)
            elif os.path.isfile(trash_file):
                rbytes = os.path.getsize(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                os.remove(trash_file)
            elif os.path.isdir(trash_file):
                rbytes = get_size(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                fname += '/'
                shutil.rmtree(trash_file)
            print('{}: [{:>9}] {}'.format(method, fsize, fname))

    print('--{0} removes [{1}] in total.\n'
          .format(os.path.basename(__file__),
                  humansize(rbytes_total)))

    print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))
#+end_src
- home directory (ruby implementation)
  #+begin_src ruby :tangle (expand-tangle-target ".local/bin/declutter_home")
    #!/usr/bin/env ruby
    # coding: utf-8

    TRASHES = ["*~", "#*#", ".#*#", "._*", ".DS_Store"]

    class Sweep
      def self.sweep(base_dir)
        puts base_dir
        TRASHES.each do |trash|
          tfiles = File.join("%s/**" % base_dir, trash)
          Dir.glob(tfiles).each do |f|
            if File.delete(f) > 0
              puts "Removed: " + f
            else
              puts "CANNOT Removed: " + f
            end
          end
        end
      end
    end

    ARGV.each do |arg|
      if Dir.exist?(arg) then
        Sweep.sweep(arg)
      end
    end
  #+end_src
- home directory (python implementation)
  #+begin_src python :tangle (expand-tangle-target ".local/bin/declutter_home_py")
    #!/usr/bin/env python3

    import sys
    import os
    import glob
    import argparse

    TRASH_REGEXPS = ["*~", "#*", ".#*", "._*", ".DS_Store", "*.dvi", "*.aux", "*.bbl"]

    class Sweepy:
        @classmethod
        def sweep_with_regexp(self, base_dir, recursive=False):
            for trash_regexp in TRASH_REGEXPS:
                files = glob.glob("%s/**/" % base_dir + trash_regexp, recursive=recursive)
                for file in files:
                    if os.path.isfile(file):
                        os.remove(file)
                        print("Removed: " + file)
        @classmethod
        def sweep_broken_symlink(self, base_dir, recursive=False):
            files = glob.glob("%s/*" % base_dir, recursive=recursive)
            dotfiles = glob.glob("%s/.*" % base_dir, recursive=recursive)
            for file in (files + dotfiles):
                if os.path.islink(file):
                    if not os.path.exists(os.readlink(file)):
                        os.unlink(file)
                        print("Unlinked: " + file)

    parser = argparse.ArgumentParser(description='Removes all desired files')
    parser.add_argument('dir', metavar='dir', nargs='?', action='store',
                        help='base directory to search')
    parser.add_argument('-r', dest='recursive', action="store_true", default=False)
    args = parser.parse_args()
    if args.recursive:
        Sweepy.sweep_with_regexp(args.dir, recursive=True)
        Sweepy.sweep_broken_symlink(args.dir, recursive=True)
    else:
        Sweepy.sweep_with_regexp(args.dir, recursive=False)
        Sweepy.sweep_broken_symlink(args.dir, recursive=False)
  #+end_src
* Database back-up scripts
- PostgreSQL
  #+begin_src bash :tangle (expand-tangle-target ".local/bin/postgres_backup")
    #!/usr/bin/env bash

    # Usage: $ postgres_backup <db_name> <backup_dir>

    POSTGRES_DBNAME=$1
    BACKUP_DIR=$2
    DATE="$(date +%Y%m%d_%H%M)"

    pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

    exit 0
  #+end_src

- MySQL
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/mysql_backup")
    #!/usr/bin/env bash

    BACKUP_DIR=~/var/backups/mysql
    RAW_SQL="$(date +%Y%m%d_%H%M)_backup.sql"
    TAR_SQL="${RAW_SQL}.txz"

    (
      cd "${BACKUP_DIR}" || exit 1
      mysqldump --opt --all-databases --events --default-character-set=binary -u root > "${RAW_SQL}"
      tar cfJ "${TAR_SQL}" "${RAW_SQL}"
      rm -f "${RAW_SQL}"
    ) || exit 1

    exit 0
  #+end_src

* Snapshots taking
- snapshot.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/snapshot.sh")
    #!/usr/bin/env bash

    DATETIME=`date "+%Y%m%d-%H%M"`
    BTRFS_MNT="/mnt/ssd01"

    # take a snapshot in btrfs
    if mountpoint ${BTRFS_MNT} >/dev/null 2>&1; then
      btrfs subvolume snapshot "${BTRFS_MNT}/doc" "${BTRFS_MNT}/snapshots/doc-${DATETIME}"
    fi
  #+end_src
* backup scripts
- back_btrfs.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_btrfs.sh")
    #!/usr/bin/env bash

    src_dev=/mnt/ssd01
    src_snap_dir="${src_dev}"/snapshots
    src_back_dir="${src_dev}"/backups
    dst_dev=/mnt/hdd01
    dst_back_dir="${dst_dev}"/backups

    parent=$(ls -d "${src_back_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)
    snap_earliest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | head -1 | xargs basename)
    snap_latest=$(ls -d "${src_snap_dir}"/doc-* 2>/dev/null | sort | tail -1 | xargs basename)

    # backup root snapshot if nothing exists
    if [ -z "${parent}" ] && [ -n "${snap_earliest}" ]; then
      btrfs subvolume snapshot -r "${src_snap_dir}/${snap_earliest}" "${src_back_dir}/${snap_earliest}"
      pwsudo btrfs send "${src_back_dir}/${snap_earliest}" | sudo btrfs receive "${dst_back_dir}"
      parent="${snap_earliest}"
    fi

    # backup latest snapshot by sending differential data
    if [ -n "${parent}" ] && [[ "${parent}" < "${snap_latest}" ]]; then
      btrfs subvolume snapshot  -r "${src_snap_dir}/${snap_latest}" "${src_back_dir}/${snap_latest}"
      pwsudo btrfs send -p "${src_back_dir}/${parent}" "${src_back_dir}/${snap_latest}" | sudo btrfs receive "${dst_back_dir}"
    fi
  #+end_src
- back_rsync.sh
  #+begin_src shell :tangle (expand-tangle-target ".local/bin/back_rsync.sh")
    #!/usr/bin/env bash

    OPT="-aPh"
    LINK="--link-dest=../last/"
    DEST="ns01:~/share/backups"
    DATETIME=`date "+%Y%m%d-%H%M"`

    ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

    # take a snapshot for pc01
    if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
      rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
    else
      rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
      ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
    fi

    # take a snapshot for sv04
    if mountpoint /mnt/sv04 >/dev/null 2>&1; then
      if ssh ns01 "[ -h ~/share/backups/sv04/last ]"; then
        rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
      else
        rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
        ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
      fi
    fi
 #+end_src
  + rsync exclude file for pc01
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
      + var
      + var/log
      + var/log/**
      - var/lib/dash
      + var/lib
      + var/lib/**
      + work
      + work/**
      + git
      + git/**
      - *
    #+end_src
  + rsync exclude file for sv04
    #+begin_src conf :tangle (expand-tangle-target ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
      + var
      + var/backup
      + var/backup/**
      - *
    #+end_src
* filetype

This program determine type of the file.

#+begin_src ruby  :tangle (expand-tangle-target ".local/bin/filetype.rb")
  #!/usr/bin/env ruby

  require 'pathname'
  require 'uri'
  require 'shellwords'

  class FileType
    ZIP_PREFIXES = ['Zip archive data']

    def self.type(filename, file_cmd_opt = "")
      if  File.exists?(filename)
        local_opt = ""
        if File.symlink?(filename)
          local_opt += "--dereference"
        end
        `file --brief #{file_cmd_opt} #{local_opt} #{Shellwords.shellescape(filename)}`.strip
      elsif filename =~ /https?:\/\/www\.youtube\.com.*/
        `youtube-dl -f worst -q #{Shellwords.shellescape(filename)} -o - 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      elsif filename =~ URI::DEFAULT_PARSER.make_regexp
        `curl --location --range 0-9999 #{Shellwords.shellescape(filename)} 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      else
        ''
      end
    end

    def self.mime_type(filename)
      type(filename, "--mime-type")
    end

    def self.block_device?(file)
      type(file).start_with?('block special') &&
        mime_type(file) == 'inode/blockdevice'
    end

    def self.iso9660?(file)
      mime_type(file) == 'application/x-iso9660-image'
    end

    def self.video_dvd_image?(file)
      iso9660?(file) && type(file).start_with?('UDF filesystem data')
    end

    def self.html?(file)
      type(file).start_with?("HTML document")
    end

    def self.pdf?(file)
      type(file).start_with?("PDF document")
    end

    def self.epub?(file)
      type(file) == "EPUB document"
    end

    def self.mobi?(file)
      type(file).start_with?("Mobipocket E-book")
    end

    def self.pgp?(file)
      type(file).start_with?("PGP")
    end

    def self.tarpgp?(file)
      pgp?(file) && file.end_with?('.tar.gpg')
    end

    def self.zip?(file)
      type(file).start_with?(*ZIP_PREFIXES)
    end

    def self.video?(file)
      mime_type(file).start_with?("video/")
    end

    def self.audio?(file)
      mime_type(file).start_with?('audio/')
    end

    def self.image?(file)
      mime_type(file).start_with?("image/")
    end

    def self.playable?(file)
      if File.directory?(file)
        Dir.foreach(file) do |fname|
          next if [".", ".."].include?(fname)
          return false unless playable?("#{file}/#{fname}")
        end
        true
      elsif file =~ /https?:\/\/www\.youtube\.com.*/
        true
      else
        type(file).start_with?("ISO Media", "Audio file") ||
          mime_type(file).start_with?("video", "audio", "image")
      end
    end

    def self.dvd_dir?(file)
      false unless mime_type(file) == 'inode/directory'
      File.exist?(Pathname.new(file).join("VIDEO_TS")) ||
        File.exist?(Pathname.new(file).join("video_ts"))
    end
  end
#+end_src

* nhp
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-tangle-target ".local/bin/nhp")
  #!/usr/bin/env bash

  readonly MAIL_FROM="<<email()>>"
  readonly MAIL_TO="<<email()>>"

  function usage() {
    cat <<_EOT_
  Usage:
    $(basename "$0") [options] command|exefile

  Description:
    $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

  Options:
    -l <logfile>  log file name
    -p <pidfile>  process id file name
    -h            help

  _EOT_
    exit 1
  }

  if [ "${OPTIND}" = 1 ]; then
    while getopts l:p:h OPT
    do
      case ${OPT} in
      l)
        opt_logfile=${OPTARG}
        ;;
      p)
        opt_pidfile=${OPTARG}
        ;;
      h)
        usage
        ;;
      \?)
        echo "Try to enter the h option." 1>&2
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi

  shift $((OPTIND - 1))

  function mailtome() {
    local _command=$1
    local _whole_command=$2
    local _logfile_rel=$4

    if [ "$3" -eq 0 ]; then
      _result='success'
    else
      _result='failed'
    fi
    _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

    mailfrom=${MAIL_FROM}
    mailto=${MAIL_TO}
    subject="${_result}: ${_command} @ $(uname -n)"
    msg1="command line      : ${_whole_command}"
    msg2="exit status(nohup): $3"
    msg3="execution time    : $5"
    msg4="pwd               : $(pwd)"
    msg5="Log data (stdout/stderr) is stored in following file:"
    msg6="${_logfile}"

    {
      echo "${msg1}"
      echo "${msg2}"
      echo "${msg3}"
      echo "${msg4}"
      echo "${msg5}"
      echo "${msg6}"
    } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
  }
  export -f mailtome

  if [ $# -eq 1 ] && [ -x "$1" ]; then
    utility="$1"
  elif [ $# -gt 0 ] && type "$1" >/dev/null; then
    utility="$*"
  else
    exit 1
  fi

  LOG_DIR=${HOME}/var/log/$(basename "$0")
  fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

  if [ ! -d "${LOG_DIR}" ]; then
    mkdir -p "${LOG_DIR}"
  fi

  if [ -v "opt_logfile" ]; then
    logfile=${opt_logfile}
  else
    logfile="${LOG_DIR}/${fname_default}.log"
  fi

  if [ -v "opt_pidfile" ]; then
    pidfile=${opt_pidfile}
  else
    pidfile="${LOG_DIR}/${fname_default}.pid"
  fi

  (
    start_time=$(date +%s)
    nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
    PID=$!
    echo $PID >"${pidfile}"
    wait $PID
    EXIT_STATUS=$?
    end_time=$(date +%s)
    exec_time=$((end_time-start_time))
    ((h=exec_time/3600))
    ((m=(exec_time%3600)/60))
    ((s=exec_time%60))
    exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
    mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
  )
  echo "$1 has finished successfully"

  exit 0
#+end_src

* sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-tangle-target ".local/bin/sendmail.py")
  #!/usr/bin/env python3

  import sys
  import argparse
  import subprocess
  import smtplib
  import ssl
  from email.mime.text import MIMEText
  from email.utils import formatdate

  def sendmail(mail_to, mail_from, subject, message):
      smtp_host = 'smtp.daisychain.jp'
      smtp_port = '465'
      smtp_user = '<<email()>>'.split(sep='@')[0]
      smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

      mime_msg = MIMEText(message)
      mime_msg['Subject'] = subject
      mime_msg['From'] = mail_from
      mime_msg['To'] = mail_to
      mime_msg["Date"] = formatdate(None, True)

      if smtp_port == '465':
          context = ssl.create_default_context()
          smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

      if smtp is not None:
          smtp.login(smtp_user, smtp_pass)
          smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
          smtp.quit()


  DESC = 'sendmail.py sends mail'
  parser = argparse.ArgumentParser(description=DESC)
  parser.add_argument('-s', '--subject')
  parser.add_argument('-f', '--mailfrom')
  parser.add_argument('to')
  args = parser.parse_args()

  message = sys.stdin.read()
  sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

* pwsudo
#+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/pwsudo")
  #!/usr/bin/env bash

  _userid=$(whoami)
  _hostname=$(hostname)

  if pass show "${_hostname}/${_userid}" >/dev/null 2>&1; then
    pass show "${_hostname}/${_userid}" | head -1 | sudo -S $*
  else
    sudo $*
  fi
#+end_src

* gitsync

- gitsync-local
  #+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/gitsync-local")
    #!/usr/bin/env bash

    function usage() {
      cat <<_EOT_
    Usage:
      $0 <prj_root>

    Description:
      $0 adds file changes in git projects under root_dir to the repository

    Options:
      prj_root:  a root directory that has git projects as children

    _EOT_
      exit 1
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo} || continue

          # skip if this is not git repo
          git rev-parse || continue

          echo "repository: ${repo}"

          cd `git rev-parse --show-toplevel`
          sync_mode=`git config sync.mode`
          case "${sync_mode}" in
          "auto" )
            # Remove deleted files
            git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
            # Add new files
            git add . >/dev/null 2>&1
            git commit -m "$(date)";;
          "manual" )
            git add -u >/dev/null 2>&1
            git commit -m "$(date)";;
          "none" )
          ;;
          esac
        done
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi
  #+end_src

- gitsync-remote
  #+begin_src shell :noweb tangle :tangle (expand-tangle-target ".local/bin/gitsync-remote")
    #!/usr/bin/env bash

    # Local bare repository name
    syncrepo=origin

    # Display repository name only once
    log_repo() {
      [ "x$lastrepo" == "x$repo" ] || {
        printf "\nREPO: ${repo}\n"
        lastrepo="$repo"
      }
    }

    # Log a message for a repository
    log_msg() {
      log_repo
      printf "  $1\n"
    }

    # fast-forward reference $1 to $syncrepo/$1
    fast_forward_ref() {
      log_msg "fast-forwarding ref $1"
      current_ref=$(cat .git/HEAD)
      if [ "x$current_ref" = "xref: refs/heads/$1" ]
      then
        # Check for dirty index
        files=$(git diff-index --name-only HEAD --)
        git merge refs/remotes/$syncrepo/$1
      else
        git branch -f $1 refs/remotes/$syncrepo/$1
      fi
    }

    # Push reference $1 to $syncrepo
    push_ref() {
      log_msg "Pushing ref $1"
      if ! git push --tags --quiet $syncrepo $1
      then
        exit 1
      fi
    }

    # Check if a ref can be moved
    #   - fast-forwards if behind the sync repo and is fast-forwardable
    #   - Does nothing if ref is up to date
    #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
    #   - Fails if ref and $syncrop/ref have diverged
    check_ref() {
      revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
      revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
      if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
      then
        # Ref $1 is up to date.
        :
      elif [ "x$revlist1" = "x" ]
      then
        # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
        fast_forward_ref $1 || exit 1
      elif [ "x$revlist2" = "x" ]
      then
        # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
        push_ref $1 || exit 1
      else
        log_msg "Ref $1 and $syncrepo/$1 have diverged."
        exit 1
      fi
    }

    # Check all local refs with matching refs in the $syncrepo
    check_refs () {
      git for-each-ref refs/heads/* | while read sha1 commit ref
      do
        ref=${ref/refs\/heads\//}
        git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
        do
          if [ "x$sha1" != "x" -a "x$sha2" != "x" ]
          then
            check_ref $ref || exit 1
          fi
        done
      done
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    # For all repositories under $reporoot
    #   Check all refs matching $syncrepo and fast-forward, or push as necessary
    #   to synchronize the ref with $syncrepo
    #   Bail out if ref is not fastforwardable so user can fix and rerun
    retval=0
    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo}

          # continue if this is not git repo
          git rev-parse 2> /dev/null || continue

          upd=$(git remote update $syncrepo 2>&1 || retval=1)
          [ "x$upd" = "xFetching $syncrepo" ] || {
            log_repo
            printf "$upd\n"
          }
          check_refs || retval=1
        done
        exit $retval
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi

    exit $retval
#+end_src
