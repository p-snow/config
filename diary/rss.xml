<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title><![CDATA[ティンカラー日記]]></title>
<description><![CDATA[ティンカラー日記]]></description>
<link>https://www.p-snow.org/config/diary</link>
<lastBuildDate>Fri, 08 Nov 2024 14:43:50 +0000</lastBuildDate>
<item>
  <title><![CDATA[現在 Org エントリへのバックリンクをミニバッファに表示する]]></title>
  <description><![CDATA[
<p>
<preview>
Scrapbox (現Cosense) や Obsidian を見るとノートの被リンク情報、つまりバックリンクをサイドバーや下部にスマートに表示していて少しうらやましくなります。私は org-mode+denote ユーザなのでこの枠組みの中で似たような機能をつくりたいところです。
</preview>
</p>

<p>
もちろん denote にはバックリンクを表示する機能 M-x denote-backlinks があるのですが、私にとってはふたつ問題があります。ひとつは、バックリンクがノート単位でしかサポートされていないこと。もうひとつは、明示的にこのコマンドを打たないとバックリンクバッファが表示されないことです。この二つの点を解決するコードを書いてみましょう。
</p>

<p>
特に二つ目の点を解消するために今回、目をつけたのは Eldoc Mode です。Emacs Lisp を書いているあいだミニバッファにちょこちょこ出てくるヤツくらいとしか認識していなかったこの子ですが、調べてみると Elisp 以外にも対応するやればできる子であることが判明しました。というか任意のタイミングで現在ポイントにある変数などの補助情報をミニバッファに表示できるのです。今回の目的にあてはめるなら、現在ポイントしている Org エントリに対しリンクを張っているエントリの heading を表示するという機能を実装できそうです。それでは書いてみましょう。
</p>

<p>
<details><summary>Elisp Code to display org backlinks in minibuffer</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/org-backlink-eldoc</span> ()
  <span style="font-style: italic;">"Start displaying backlinks in minibuffer."</span>
  (<span style="font-weight: bold;">when</span> (boundp 'eldoc-documentation-functions)
    (add-hook 'eldoc-documentation-functions
              #'my/org-backlinks nil t)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/org-backlinks</span> ()
  <span style="font-style: italic;">"Return heading of backlinks that points the entry at point."</span>
  (string-join
   (mapcar (<span style="font-weight: bold;">lambda</span> (elem)
             (org-entry-get elem <span style="font-style: italic;">"ITEM"</span>))
           (<span style="font-weight: bold;">when-let</span> ((id (org-entry-get nil <span style="font-style: italic;">"ID"</span>)))
             (org-ql-select (org-agenda-files)
               `(link <span style="font-weight: bold;">:target</span> ,id))))
   <span style="font-style: italic;">" "</span>))
</pre>
</div>
<p>
</p></details>
</p>

<p>
my/org-backlinks は org-ql を使って現在エントリのIDを使ったリンクをもつすべてのエントリの見出し文字列を返します。org-ql マ便利。そして my/org-backlink-eldoc でeldocモードをオンにしつつ、先ほどの関数を、ミニバッファ表示内容を請け負う役割に指定します。このくらいの行数で今回の目的が成せるなんて幸せ！
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-emacs.html">emacs</a> <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> <a href="https://www.p-snow.org/config/diary/tag-link.html">link</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org]]></category>
  <category><![CDATA[link]]></category>
  <link>https://www.p-snow.org/config/diary/20241108-2302.html</link>
  <guid>https://www.p-snow.org/config/diary/20241108-2302.html</guid>
  <pubDate>Fri, 08 Nov 2024 23:02:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[Org のプロパティ値をサクッとコピーする]]></title>
  <description><![CDATA[
<p>
<preview>
Org エントリのプロパティ値をサクッとコピーしたいときってありますよね (あるはず！)。org-entry-get が interactive ならな〜とかブツブツ呟きながら、現在エントリの指定してプロパティ値を kill-ring にコピーするコマンドを<a href="https://p-snow.org/config/dotfiles.html#emacs-org-copy-property">つくりました</a>。
</preview>
</p>

<p>
<details><summary>Elisp code to copy puroperty value at point</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/org-copy-property-as-kill</span> (property)
  <span style="font-style: italic;">"Copy the value of PROPERTY to `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">kill-ring</span><span style="font-style: italic;">'.</span>

<span style="font-style: italic;">If the value matches $(...) format, ... will be treated as a</span>
<span style="font-style: italic;">shell command, and the output of the command will be copied to</span>
<span style="font-style: italic;">the `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">kill-ring</span><span style="font-style: italic;">' instead."</span>
  (<span style="font-weight: bold;">interactive</span> (<span style="font-weight: bold;">progn</span> (<span style="font-weight: bold;">setq</span> properties (org-entry-properties))
                      (list (completing-read <span style="font-style: italic;">"Property: "</span> properties))))
  (<span style="font-weight: bold;">pcase</span> (<span style="font-weight: bold;">setq</span> value (alist-get property properties nil nil #'equal))
    ((<span style="font-weight: bold;">rx</span> (seq <span style="font-style: italic;">"$("</span> (group (+ print)) <span style="font-style: italic;">")"</span>))
     (<span style="font-weight: bold;">setq</span> value (shell-command-to-string (match-string 1 value)))))
  (<span style="font-weight: bold;">when</span> (stringp value)
    (kill-new value)
    (message <span style="font-style: italic;">"Copied: %s"</span> value)))

(<span style="font-weight: bold;">with-eval-after-load</span> 'org
  (keymap-set org-mode-map <span style="font-style: italic;">"C-c K"</span>
              #'my/org-copy-property-as-kill)
  (<span style="font-weight: bold;">setf</span> (alist-get <span style="font-style: italic;">"K"</span> org-speed-commands nil nil #'equal)
        #'my/org-copy-property-as-kill))
</pre>
</div>
<p>
</p></details>
</p>

<p>
ちょうどプロパティにシェルコマンドを埋め込みたいという特殊なニーズがあったので、それに対応するコードも入ってます。今日は短めで、失礼します。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-emacs.html">emacs</a> <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> <a href="https://www.p-snow.org/config/diary/tag-property.html">property</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org]]></category>
  <category><![CDATA[property]]></category>
  <link>https://www.p-snow.org/config/diary/20241101-1932.html</link>
  <guid>https://www.p-snow.org/config/diary/20241101-1932.html</guid>
  <pubDate>Fri, 01 Nov 2024 19:32:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[transient でいろんなコマンドをつくってみた]]></title>
  <description><![CDATA[
<p>
<preview>
Charles Choi 氏の <a href="https://github.com/kickingvegas/casual-suite">casual-suite</a> が静かなブームを巻き起こしている。casual-suite とは、メニューシステム <a href="https://github.com/magit/transient">transient</a> を使って Emacs のさまざまな機能をアクセシブルにするパッケージだ。Emacs における機能の充実ぶりは、手練のユーザには心地良いものである一方で、そもそもどんな機能があるのかを知らない初学者などには混乱を招く元ともなってきた。その問題を解決するために各機能分野ごとにどういうコマンドが存在しどういうパラメタが設定可能かを可視化してくれる。
</preview>
</p>

<p>
現在は <a href="http://yummymelon.com/devnull/announcing-casual-redux-and-reorganization.html">ELPA への登録を目指している</a> ようであり、ゆくゆくは Emacs のコアへの導入もあるかもしれない。個人的にもこの活動は好意をもって注視している。
</p>

<p>
ところで casual-suite が使っているインプットメソッドの transient。Magit のインタフェイスとしてユーザにはおなじみのアレだが、Emacs 28.1 でコアに導入されて以来、ここ一年くらいで活用事例を多く見るようになった印象がある。私もエンドユーザとしてはいつもお世話になっているものの、ライブラリ利用はしたことがなかったので興味がわいていくつかのコマンドを実装してみた。
</p>

<p>
そのひとつが yt-dlp をパラメタ調整しながら構築できるようにした<a href="https://p-snow.org/config/dotfiles.html#emacs-yt-dlp-command">こちら</a>。ダウンロードファイルのサイズやフォーマット、ファイル名などをアドホックに指定することができる。実装してみると意外とこれが大変だった。Elispのオブジェクト指向ライブラリ EIEIO などの知識が不足していたこともあり、<a href="https://github.com/positron-solutions/transient-showcase">transient-showcase</a> などを参考にしながら何とか動くものができた。
</p>

<p>
しかし一度実装経験を積むと、あとは型にはめていくだけなので他にもコマンドをつくりたくなる。<a href="https://p-snow.org/config/dotfiles.html#emacs-vp9-command">ffmpeg</a> や <a href="https://p-snow.org/config/dotfiles.html#emacs-pandoc-command">pandoc</a> をパラメタ調整しながら実施できる便利なコマンドたちができた。Choi 氏が連続していろいろな casual-xxx パッケージをつくった気持ちがよくわかった。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-emacs.html">emacs</a> <a href="https://www.p-snow.org/config/diary/tag-transient.html">transient</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[transient]]></category>
  <link>https://www.p-snow.org/config/diary/20241029-1554.html</link>
  <guid>https://www.p-snow.org/config/diary/20241029-1554.html</guid>
  <pubDate>Tue, 29 Oct 2024 15:54:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[org-mode で現在エントリのアウトラインパスを表示する]]></title>
  <description><![CDATA[
<p>
<preview>
ジャングルのように生い茂ったOrgツリーの中で目的とする場所にジャンプすることは、Emacsのさまざまな機能を駆使すれば難しいことではありません。Isearchを使ってもいいし、consult-lineを使って攻めの検索をするのもいい。
</preview>
</p>

<p>
バッファを対象にしてorg-qlすれば、細かい検索パラメタで 網羅性の高い検索ができるし、consult-outlineを使えばヘッドラインを快適に絞り込みながら見つけることができます。
</p>

<p>
しかし、一度目的の場所を見つけ作業をしたあと、はて自分は今この樹海の中のどこにいるのだろうかと迷子になったことはありませんか。私はあります！そういうときは M-x org-shifttab を連続押しするなどして Org ツリーの全体像を俯瞰するという手もありますが、これだと今度は作業に戻ろうとしたときに肝心の目的エントリが隠れてしまったりして手間を要することがあります。
</p>

<p>
そんなときのためにつくったのが、現在いるOrgエントリのパスを表示する以下のコマンド。(<a href="https://p-snow.org/config/dotfiles.html#emacs-org-tweak-outline-path">設定ファイルの該当箇所</a>)
</p>

<p>
<details><summary>Elisp Code for Showing Outline Path</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/org-show-outline-path</span> (pom)
  <span style="font-style: italic;">"Display a sparse tree that shows an outline path for the entry at POM."</span>
  (<span style="font-weight: bold;">interactive</span> (list (point)))
  (<span style="font-weight: bold;">save-excursion</span>
    (<span style="font-weight: bold;">cl-labels</span> ((lookup-parent ()
                  (<span style="font-weight: bold;">let*</span> ((heading-raw (substring-no-properties
                                       (org-get-heading t t t t)))
                         (heading (<span style="font-weight: bold;">if</span> (string-match org-link-bracket-re heading-raw)
                                      (match-string 2 heading-raw)
                                    heading-raw))
                         (h-li (list heading)))
                    (<span style="font-weight: bold;">if</span> (org-up-heading-safe)
                        (append (lookup-parent) h-li)
                      h-li))))
      (org-ql-sparse-tree (format <span style="font-style: italic;">"(olps %s)"</span>
                                  (mapconcat (<span style="font-weight: bold;">lambda</span> (str) (format <span style="font-style: italic;">"\"%s\""</span> str))
                                             (lookup-parent)
                                             <span style="font-style: italic;">" "</span>))))))

(<span style="font-weight: bold;">with-eval-after-load</span> 'org-ql
  (keymap-set org-mode-map <span style="font-style: italic;">"C-c M-/"</span>
              #'my/org-show-outline-path))
</pre>
</div>
<p>
</p></details>
</p>

<p>
これだとパンくずリストみたいに現在いるエントリへつながるパスのみを表示させることができます。スパースツリーを表示してるみたいですね。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-emacs.html">emacs</a> <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org]]></category>
  <link>https://www.p-snow.org/config/diary/20241024-1858.html</link>
  <guid>https://www.p-snow.org/config/diary/20241024-1858.html</guid>
  <pubDate>Thu, 24 Oct 2024 18:58:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[動作は速く設定はスマート、Linux用キーリマッパkeyd]]></title>
  <description><![CDATA[
<p>
<preview>
個人的に Linux のキーリマップまわりの問題は <a href="https://github.com/xremap/xremap">xremap</a> でほぼ解決し、このまま(少なくとも数年は)添い遂げるだろうと思っていました。でも、でも、どうしても抗えない浮気相手がでてきてしまったのです。それが <a href="https://github.com/rvaiya/keyd">keyd</a> でした。
</preview>
</p>

<p>
まず、keyd は早い。レスポンス速度が体感でわかるほど xremap に比べて快適です。そして設定ファイルのフォーマットが秀逸で、きわめて簡潔にリマップ規則を書くことができます。
</p>

<p>
Emacser にはおなじみの capslock を control とする設定は、
</p>

<div class="org-src-container">
<pre class="src src-conf"><span style="font-weight: bold; font-style: italic;">capslock</span> = oneshot(control)
</pre>
</div>

<p>
と書けます。はい、シンプルです。
</p>

<p>
次に、特にSKKユーザに支持されているSandS、spaceを修飾キーとしてはshiftとして、単独ではspaceとして機能させるには、
</p>

<div class="org-src-container">
<pre class="src src-conf"><span style="font-weight: bold; font-style: italic;">space</span> = overload(shift, space)
</pre>
</div>

<p>
と書きます。ナイス。
</p>

<p>
それでは capslock を control に割り当てたので、左コントロールは capslock にします。ついでに、修飾キーとして右手ホームポジションまわりを数字キーとして使えるようにしましょう。
</p>

<p>
<details><summary>left control configuration</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-conf"><span style="font-weight: bold; font-style: italic;">leftcontrol</span> = overload(numpad_layer, capslock)

[<span style="font-weight: bold; text-decoration: underline;">numpad_layer</span>]

<span style="font-weight: bold; font-style: italic;">m</span> = 1
<span style="font-weight: bold; font-style: italic;">,</span> = 2
<span style="font-weight: bold; font-style: italic;">.</span> = 3
<span style="font-weight: bold; font-style: italic;">j</span> = 4
<span style="font-weight: bold; font-style: italic;">k</span> = 5
<span style="font-weight: bold; font-style: italic;">l</span> = 6
<span style="font-weight: bold; font-style: italic;">u</span> = 7
<span style="font-weight: bold; font-style: italic;">i</span> = 8
<span style="font-weight: bold; font-style: italic;">o</span> = 9
<span style="font-weight: bold; font-style: italic;">space</span> = 0
</pre>
</div>
<p>
</p></details>
</p>

<p>
これは何をやっているかと言うと、左コントロール押下時に機能する numpad<sub>layer</sub> という独自レイヤを定義し、つまり左コントロールを押しているときには、例えば mキー を押すと 1 が入力される設定を施しているのです。
</p>

<p>
それでは最後に最近の私のお気に入り、Emacs で 'キー(アポストロフィ) をSuperキーとして利用する設定をご紹介します。英字配列キーボードが前提ですが、左手小指をcontrolとして使うので右手小指も修飾キーとして使えばキーバインディングが枯渇せず、かつ打ちやすいのではないかという発想のもとに考えた方法です。
</p>

<div class="org-src-container">
<pre class="src src-conf"><span style="font-style: italic;">' = overload(apostrophe_layer, '</span>)

[<span style="font-weight: bold; text-decoration: underline;">apostrophe_layer:M</span>]
</pre>
</div>

<p>
このたった二行で実現できます。レイヤには対応する修飾キーを定義することができて、それが :M の箇所になります。ちなみに M はMetaもしくはSuperの役割を意味します。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-linux.html">linux</a> <a href="https://www.p-snow.org/config/diary/tag-keyboard.html">keyboard</a> </div>]]></description>
  <category><![CDATA[linux]]></category>
  <category><![CDATA[keyboard]]></category>
  <link>https://www.p-snow.org/config/diary/20241023-1340.html</link>
  <guid>https://www.p-snow.org/config/diary/20241023-1340.html</guid>
  <pubDate>Wed, 23 Oct 2024 13:40:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[よく利用する場所に素早くジャンプする]]></title>
  <description><![CDATA[
<p>
<preview>
よく使うものをどれだけ素早く取り出せるか。これは大事な話です、たぶん。物理的な世界では「整頓」がカギを握るわけですが、コンピュータ内では少し事情が違ってきます。今回は私がEmacs内でよく利用する場所に移動するためにどんな方法を使っているかを見ていきたいとおもいます。
</preview>
</p>

<p>
よく利用する場所。個人的には、設定ファイルを集約したOrgファイルであるdotfiles.orgや、直近で開発を進めているプロジェクトのルートディレクトリがそれにあたるでしょうか。
</p>

<p>
これらに素早く移動するEmacsの機能としてまず思い浮かぶのは<a href="https://p-snow.org/config/dotfiles.html#emacs-register">Register</a>でしょう。でも私はこれ、うまく使えません。理由はいくつか思いつきます。まずRegisterでジャンプするためのコマンド、jump-to-registerのデフォルトキーバインドがイマイチすぎる。それならもちろんリバインドするわけですが、それでもまだまだ不満は残ります。Emacsの再起動後に登録したRegisterが使えない。これも以下のコードで一応は解決ができるのですが、不意に消えてたりもするのでなかなかしんどいです。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'savehist-additional-variables
             'register-alist)
</pre>
</div>

<p>
すいません。Registerをディスりすぎましたが、それだけ真剣に使おうとしたことは付言しておきます。
</p>

<p>
じゃあ、<a href="https://p-snow.org/config/dotfiles.html#emacs-bookmark">Bookmark</a>だ。そうだ。僕らにはBookmarkがある！でも  bookmark-jump にしても consult-bookmark にしても、Bookmark名を入力しなきゃいけない。違うんだ。もっと短いタイプ数じゃなきゃダメなんだ。
</p>

<p>
そこで私が行きついたのが、Bookmark名を入力するキーボードマクロをつくりこれを実行するという方法。これを好みの(短めの)キーにバインドすればめでたく目的達成です。私はH-kとそれに続くキーで目的の場所ごとのショートカットをつくれるようにしました。ジャンプするためのキーボードマクロを登録したあと、これを保存するコードを<a href="https://p-snow.org/config/dotfiles.html#emacs-function-insert-last-kbd-macro">自動生成するコマンド</a>もつくりました。
</p>

<p>
<details><summary>Elisp Code for Inserting Last KBD Macro for my/kmacro-map</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/insert-last-kbd-macro</span> (macroname keys)
  <span style="font-style: italic;">"Customized `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">insert-kbd-macro</span><span style="font-style: italic;">' to bind last recorded kbd macro to `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">my/kmacro-map</span><span style="font-style: italic;">'.."</span>
  (<span style="font-weight: bold;">interactive</span> (list (read-string <span style="font-style: italic;">"Macro name: "</span>)
                     (read-string <span style="font-style: italic;">"Keys (following H-k): "</span>)))
  (kmacro-name-last-macro (intern macroname))
  (insert-kbd-macro (intern macroname))
  (insert <span style="font-style: italic;">"(keymap-set my/kmacro-map"</span>)
  (insert (format <span style="font-style: italic;">" \"%s\""</span> keys))
  (insert (format <span style="font-style: italic;">" #'%s)"</span> macroname)))
</pre>
</div>
<p>
</p></details>
</p>

<p>
これで今のところ快適に2キータイプで移動できています。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-emacs.html">emacs</a> <a href="https://www.p-snow.org/config/diary/tag-register.html">register</a> <a href="https://www.p-snow.org/config/diary/tag-bookmark.html">bookmark</a> <a href="https://www.p-snow.org/config/diary/tag-kmacro.html">kmacro</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[register]]></category>
  <category><![CDATA[bookmark]]></category>
  <category><![CDATA[kmacro]]></category>
  <link>https://www.p-snow.org/config/diary/20241021-2230.html</link>
  <guid>https://www.p-snow.org/config/diary/20241021-2230.html</guid>
  <pubDate>Mon, 21 Oct 2024 22:30:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[バッファ内のテキストをAIに喋らせる]]></title>
  <description><![CDATA[
<p>
<preview>
Emacs内のテキストをマシンに喋らせるということは、これまでもけっこう拘ってやってきました。いくつか理由はあります。自分が弱視なのでスクリーンリーダー代わりに使いたいという欲求もありましたし、他のことに目を使っている間に耳で情報を摂取したいというズボラな動機もありました。
</preview>
</p>

<p>
最近では、難しい英単語のより正確な発音を知りたいというのもあります。まあ、ブラウザ内で検索すればGoogle先生が即座にその願いを叶えてくれますが、バッファ内で完結するのがEmacserの矜持というものです。はい。
</p>

<p>
AIブーム前夜まではローカルに用意したエンジンに喋ってもらっていました。<a href="https://p-snow.org/config/dotfiles.html#emacs-tts-old">日本語なら OpenJTalk に、英語なら Festival に。</a>
</p>

<p>
しかし今や、音声合成の技術の発達とともに、AIの力で行われる圧倒的な構文解釈能力をベースにして驚くほどに人間に近い発話が可能になりました。なので、API経由でリージョン内のテキストをChatGPTに喋らせる<a href="https://p-snow.org/config/dotfiles.html#emacs-package-tts">コードを書きました</a>。
</p>

<p>
<details><summary>Elisp Code for Text to Speech</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">tts-openai-request</span> (api-key input action)
  <span style="font-style: italic;">"Return audio file content from OpenAI API and save it to OUTPUT-FILE or play it.</span>
<span style="font-style: italic;">INPUT is the text string sent to the API.</span>
<span style="font-style: italic;">RESPONSE-FORMAT is the format of the audio file, defaults to '</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">mp3</span><span style="font-style: italic;">'.</span>
<span style="font-style: italic;">ACTION is either 'save or 'play, determining what to do with the response."</span>
  (<span style="font-weight: bold;">let*</span> ((auth-value (format <span style="font-style: italic;">"Bearer %s"</span> api-key))
         (model <span style="font-style: italic;">"tts-1"</span>)
         (voice <span style="font-style: italic;">"nova"</span>)
         (speed nil)
         (response-format <span style="font-style: italic;">"opus"</span>)
         (url <span style="font-style: italic;">"https://api.openai.com/v1/audio/speech"</span>)
         (data (json-encode `((<span style="font-style: italic;">"model"</span> . ,model)
                              (<span style="font-style: italic;">"input"</span> . ,input)
                              (<span style="font-style: italic;">"voice"</span> . ,voice)
                              ,@(<span style="font-weight: bold;">when</span> response-format `((<span style="font-style: italic;">"response_format"</span> . ,response-format)))
                              ,@(<span style="font-weight: bold;">when</span> speed `((<span style="font-style: italic;">"speed"</span> . ,speed)))))))
    (request
      url
      <span style="font-weight: bold;">:type</span> <span style="font-style: italic;">"POST"</span>
      <span style="font-weight: bold;">:data</span> data
      <span style="font-weight: bold;">:headers</span> `((<span style="font-style: italic;">"Authorization"</span> . ,auth-value) (<span style="font-style: italic;">"Content-Type"</span> . <span style="font-style: italic;">"application/json"</span>))
      <span style="font-weight: bold;">:parser</span> 'buffer-string
      <span style="font-weight: bold;">:success</span> (<span style="font-weight: bold;">cl-function</span>
                (<span style="font-weight: bold;">lambda</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;key</span> data <span style="font-weight: bold; text-decoration: underline;">&amp;allow-other-keys</span>)
                  (<span style="font-weight: bold;">let</span> ((coding-system-for-write 'binary)
                        (speech-file (make-temp-file <span style="font-style: italic;">"tts-"</span> nil <span style="font-style: italic;">".opus"</span>)))
                    (<span style="font-weight: bold;">with-temp-file</span> speech-file
                      (insert data))
                    (<span style="font-weight: bold;">when</span> action (funcall action speech-file)))))
      <span style="font-weight: bold;">:error</span> (<span style="font-weight: bold;">cl-function</span>
              (<span style="font-weight: bold;">lambda</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;key</span> error-thrown <span style="font-weight: bold; text-decoration: underline;">&amp;allow-other-keys</span>)
                (message <span style="font-style: italic;">"Error: %S"</span> error-thrown))))))
</pre>
</div>
<p>
</p></details>
</p>

<p>
はい。書き方を見ればおわかりのとおり、ちゃっかりパッケージ化を目論んだ書き方になってますね。もしご所望の方がおられましたらご一報ください。がんばってみます。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-ai.html">ai</a> <a href="https://www.p-snow.org/config/diary/tag-speech.html">speech</a> </div>]]></description>
  <category><![CDATA[ai]]></category>
  <category><![CDATA[speech]]></category>
  <link>https://www.p-snow.org/config/diary/20241020-1518.html</link>
  <guid>https://www.p-snow.org/config/diary/20241020-1518.html</guid>
  <pubDate>Sun, 20 Oct 2024 15:18:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[ミニバッファのフォントサイズを小さくする]]></title>
  <description><![CDATA[
<p>
<preview>
Prot こと Protesilaos Stavrou 氏(相変わらず発音できない…)が彼のEmacsパッケージ fontaine のユーザからの質問「ミニバッファのフォントサイズを変えるにはどうしたらいいか」への答えを載せていた。
</p>

<p>
<a href="https://protesilaos.com/codelog/2024-10-17-emacs-remap-minibuffer-face/">Emacs: remap font size in the minibuffer | Protesilaos Stavrou</a>
</preview>
</p>

<p>
なるほど、と思いながら読み進めるうちに、そう言えば自分も昔、同じような設定をしたなと調べてみたら<a href="https://p-snow.org/config/dotfiles.html#emacs-minibuffer">あった</a>。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq-local</span> face-remapping-alist '((default <span style="font-weight: bold;">:height</span> 0.9)))
</pre>
</div>

<p>
Protは face-remap の関数 face-remap-add-relative を使っていたのに対し、自分はCの変数 face-remapping-alist を直接 setq-local で弄っていた。コードを追っていくと何のことはない face-remap-add-relative 内で face-remapping-alist を設定していた。こりゃ Prot のコードの方が行儀がよいですな。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> <a href="https://www.p-snow.org/config/diary/tag-minibuffer.html">minibuffer</a> </div>]]></description>
  <category><![CDATA[org]]></category>
  <category><![CDATA[minibuffer]]></category>
  <link>https://www.p-snow.org/config/diary/20241018-1753.html</link>
  <guid>https://www.p-snow.org/config/diary/20241018-1753.html</guid>
  <pubDate>Fri, 18 Oct 2024 17:53:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[実は奥深い「締切り」の世界]]></title>
  <description><![CDATA[
<p>
<preview>
「хххというタスク管理アプリでは締切りの管理が難しい」という声をたまたま耳にしました。個人的に締切りの遵守にあまり自信がある方ではありませんが、Org Modeではタスクの期限をどうあつかえるのかをいい機会なのでまとめてみようと思います。
</preview>
</p>

<p>
Org Modeでは、締切りはタスク項目とセットで機能します。TODO ステートのついたOrgエントリの上でM-x org-deadlineを実行して締切日を指定すれば、以下のような期限(DEADLINE)をもつタスクができあがります。
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="font-weight: bold;">* </span><span style="font-weight: bold;">TODO</span><span style="font-weight: bold;"> &#20837;&#37329;</span>
<span style="font-weight: bold;">DEADLINE:</span> <span style="text-decoration: underline;">&lt;2024-10-31 Thu&gt;</span>
</pre>
</div>

<p>
では、Org Modeはどうやってこのタスクをリマインドしてくれるのでしょうか。それは、org-agendaを実行したきに次のような一行を表示することで教えてくれます。
</p>

<div class="org-src-container">
<pre class="src src-text">In   15 d.:  &#20837;&#37329;
</pre>
</div>

<p>
毎日org-agendaを実行していれば「14 d.」「13 d.」となり、心の準備をすることができ、もし期日前までにやっておかなければならないことがあれば実行するというステップが踏めるわけです。
</p>

<p>
期限の数日前に無事、入金が完了しました。でもそのままではその後も毎日、期限までリマインドは繰り返されます。この表示を止めるには以下の設定をして「入金」項目のTODOステートをDONEにします。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-agenda-skip-deadline-if-done t)
</pre>
</div>

<p>
ちなみに、org-agendaで締切りの何日前からリマインド表示するかは以下の設定で調整できます。この場合は２週間前から表示してくれます。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-deadline-warning-days 14)
</pre>
</div>

<p>
この設定はすべてのタスクに共通して適用されるのですが、タスクによっては別の値を設定したいこともありますよね。例えば、「原稿の提出」など、期限までに２週間では終わらない作業を終わらせなければならない場合は以下のように個別にリマインド開始日を指定することができます。これで２ヶ月前からお知らせしてくれます。
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="font-weight: bold;">* </span><span style="font-weight: bold;">TODO</span><span style="font-weight: bold;"> &#21407;&#31295;&#12398;&#25552;&#20986;</span>
<span style="font-weight: bold;">DEADLINE:</span> <span style="text-decoration: underline;">&lt;2024-10-31 Thu -2m&gt;</span>
</pre>
</div>

<p>
ところで、原稿の執筆に集中して取り組みはじめた後は、今度はリマインドが邪魔という事態が起こったりします。そんなときはタスクにSCHEDULED属性に執筆開始日を入れて以下の設定をします。
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="font-weight: bold;">* </span><span style="font-weight: bold;">TODO</span><span style="font-weight: bold;"> &#21407;&#31295;&#12398;&#25552;&#20986;</span>
<span style="font-weight: bold;">SCHEDULED:</span> <span style="text-decoration: underline;">&lt;2024-10-01 Tue&gt;</span> <span style="font-weight: bold;">DEADLINE:</span> <span style="text-decoration: underline;">&lt;2024-10-31 Thu&gt;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
</pre>
</div>

<p>
これでシステムには、このタスクに着手したことを伝えて事前のリマインド表示は中止させるのです。
</p>

<p>
このように締切りと一口に言ってもいろいろな背景を考え合わせる必要があり、それをコンピュータ上で管理しようとするとけっこう難しい課題につきあたることがわかります。万人に有効な解決策をタスク管理アプリが提供することはけっこうな高難度なのでしょう。結果的に冒頭で紹介したようなユーザの声が聞こえてくるのも、ある意味では無理からぬことなのかなと個人的には感じています。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> <a href="https://www.p-snow.org/config/diary/tag-agenda.html">agenda</a> </div>]]></description>
  <category><![CDATA[org]]></category>
  <category><![CDATA[agenda]]></category>
  <link>https://www.p-snow.org/config/diary/20241015-1415.html</link>
  <guid>https://www.p-snow.org/config/diary/20241015-1415.html</guid>
  <pubDate>Tue, 15 Oct 2024 14:15:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[新たなスペルチェッカー Jinx]]></title>
  <description><![CDATA[
<p>
この記事は <a href="https://qiita.com/advent-calendar/2023/emacs">Emacs Advent Calendar 2023</a> の13日目の記事です。
</p>

<p>
<preview>
みなさんEmacsで英文、書いてますか？
</p>

<p>
最近、個人的に英語での情報発信欲が高まっていて、このサイトでもいくつか英文記事を書きました。海外からいろいろレスポンスをもらえるのは楽しいです。
英文執筆ではChatGPTの存在が頼もしく、私の稚拙な英語表現もおおむね正しく直してくれるので、間違いを恐れずガンガン書き進めていけるのがよいです。
ChatGPT利用には主に <a href="https://github.com/xenodium/chatgpt-shell">chatgpt-shell</a> パッケージを使っています。M-x chatgpt-shell-proofread-region すれば校閲結果を返してくれます。
</preview>
</p>

<p>
今日は私の英文執筆時のもうひとつのミカタ、英単語スペルチェッカー Jinx を紹介してみたいとおもいます。
</p>

<p>
Emacs でスペルチェッカーと言うとビルトインの ispell/flyspell がありますが、個人的にはうまく使えずにいました。M-$ (ispell-word) を押しても自分が使っている completion framework (vertico) が使えなかったり、などなど。
Jinxは動作が機敏で単語修正候補に好みの補完フレームワークが使えるので個人的に満足しています。
</p>

<p>
Jinxはバックエンドとして<a href="https://abiword.github.io/enchant/">Enchant</a>を使います。Enchantは統一的なスペルチェック用APIを提供するライブラリです。その裏ではHunspellやAspellなどのスペルチェックプログラムをユーザが指定する順序で呼び出しています。
なのでJinxを動作させるには、Jinx自身をインストール・設定することに加えて、Enchantとスペルチェッカーもインストールする必要があります。
</p>

<p>
以下、関連パッケージのインストール例
</p>
<ul class="org-ul">
<li>Jinxインストール時にlibenchantを使ってモジュールをコンパイルするのでpkgconf/pkg-configが必要</li>
<li>スペルチェッカーはEnchantでデフォルトチェッカーになっている Hunspell だけあれば事足りる印象</li>
<li>macOSでは<a href="https://github.com/minad/jinx/issues/48">フリーズするケースがある</a>そうなのでご注意を</li>
</ul>

<p>
Ubuntu/Debian
</p>
<div class="org-src-container">
<pre class="src src-shell">apt install libenchant-2-dev pkgconf enchant-2 hunspell hunspell-en-us
</pre>
</div>

<p>
Guix
</p>
<div class="org-src-container">
<pre class="src src-shell">guix install emacs-jinx enchant hunspell hunspell-dict-en hunspell-dict-en-us
</pre>
</div>

<p>
Enchantは、ユーザコンフィグディレクトリ(~/.config/enchant など)にユーザ辞書(en<sub>US.dic</sub>)などを置いて checker agnostic に設定することができます。
</p>

<p>
Jinxは GNU ELPA/melpa にあるので問題なくインストールできます。M-$ を ispell-word に代わって jinx-correct に割り当てています。
</p>

<p>
<details><summary>Elisp Code</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">use-package</span> jinx
  <span style="font-weight: bold;">:ensure</span> t
  <span style="font-weight: bold;">:bind</span> ((<span style="font-style: italic;">"M-$"</span> . jinx-correct)
         (<span style="font-style: italic;">"C-M-$"</span> . jinx-languages))
  <span style="font-weight: bold;">:hook</span> ((prog-mode conf-mode) . jinx-mode)
  <span style="font-weight: bold;">:config</span>
  (<span style="font-weight: bold;">bind-keys</span> <span style="font-weight: bold;">:map</span> jinx-mode-map
             (<span style="font-style: italic;">"M-n"</span> . jinx-next)
             (<span style="font-style: italic;">"M-p"</span> . jinx-previous)))
</pre>
</div>
<p>
</p></details>
</p>

<p>
これで M-$ を押せばJinxがスペルミスした単語を見つけだし修正候補を提示してくれます。スペルミスした単語にポイントを置き M-n/M-p で次/前の候補に移動してどんどん修正できます。超快適！
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-spellcheck.html">spellcheck</a> </div>]]></description>
  <category><![CDATA[spellcheck]]></category>
  <link>https://www.p-snow.org/config/diary/20231212-1850.html</link>
  <guid>https://www.p-snow.org/config/diary/20231212-1850.html</guid>
  <pubDate>Tue, 12 Dec 2023 18:50:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[Org内でタスク名のヒストリを残す]]></title>
  <description><![CDATA[
<p>
<preview>
タスクとは、生まれて実施されて終えられて捨てられる。そんな存在。たとえ賞味の実施期間は短くとも、タスクのライフサイクル全体を見れば、管理する当人も驚くくらいに長くなっていたなんてことはザラにあるのではないでしょうか。長い時間というものはいろいろなものを変え得る可能性を秘めています。ビジネスの風向きが変わることもあれば、生活環境が変わることもあるでしょう。そんな変化を経てもタスクだけは絶対に不変であるなんてことはもちろんありません。もしかしたらタスクの中身、つまりやることは不変だったとしても、タスク管理者のタスクに対するまなざしが変わっていたなんてこともあるでしょう。そんなときにおもうのです。「このタスク名、何か変じゃね」と。
</preview>
</p>

<p>
タスク名を変える。行為としてはこんな簡単なことはありません。でも私はこれが苦手でした。なぜでしょうか。ひとつには、改名するにあたり経年したタスクと真剣に向き合い直す必要があり、メンタル負荷的にこれを避けたいという心理がはたらいていたのかもしれません。もう一つは、改名することで前のタスク名が完全に消されてしまい、タスクの時間的な変遷が隠れてしまうことを惜しんでいたフシがあるような気がします。タスクを作成した当初はこういう意図や動機があってこう名付けたが、事情や事態が変わってああいうタスク名になった、というような情報は個人的には軽視できないメタ情報だとおもいます。タスク内にメモすればいいわけですが、改名のワークフローとフォーマットは統一されていた方が自分好みなので下のようなコードを書きました。新しいタスク名を入力するとタスクが改名されると同時に一つ前のタスク名は日付情報とともにヒストリとして保存されます。
</p>

<p>
<details><summary>Elisp Code</summary><p>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-log-into-drawer t)

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my/org-change-heading</span> ()
  <span style="font-style: italic;">"CHange the heading of the entry at `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">point</span><span style="font-style: italic;">'.</span>

<span style="font-style: italic;">The previous name will be stored along with the execution date."</span>
  (<span style="font-weight: bold;">interactive</span>)
  (<span style="font-weight: bold;">let*</span> ((old-heading (org-get-heading t t t t))
         (new-heading (read-string <span style="font-style: italic;">"Heading: "</span> old-heading)))
    (<span style="font-weight: bold;">save-excursion</span>
      (org-back-to-heading t)
      (replace-string old-heading new-heading nil
                      (line-beginning-position) (line-end-position))
      (org-align-tags))
    (org-add-log-setup 'state new-heading old-heading 'state)))
</pre>
</div>
<p>
</p></details>
</p>

<p>
この機能を使うようになってからタスクの作成と改名が軽快におこなえるようになった気がします。「会議で提案されたアレをやっておく」のようなタスクが作成できるようになって、後で修正すせばいいからとタスク作成の心理的な負荷が軽減される一方で、修正後に残されたヒストリを見て「発生時にはアレと呼ばなければならないくらい、このタスクはあの時点では自分にとって新規性の高いものだったんだな」などと振り返ることができるのです。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> </div>]]></description>
  <category><![CDATA[org]]></category>
  <link>https://www.p-snow.org/config/diary/20231121-1858.html</link>
  <guid>https://www.p-snow.org/config/diary/20231121-1858.html</guid>
  <pubDate>Tue, 21 Nov 2023 18:58:00 +0000</pubDate>
</item>
<item>
  <title><![CDATA[Org-modeは九龍城砦]]></title>
  <description><![CDATA[
<p>
<preview>
以下の記事を興味深く読みました。
</p>

<p>
<a href="https://rashita.net/blog/?org-mode%E3%81%A8%E3%81%84%E3%81%86%E4%BC%9D%E7%B5%B1">https://rashita.net/blog/?org-mode%E3%81%A8%E3%81%84%E3%81%86%E4%BC%9D%E7%B5%B1</a>
</p>

<p>
Logseq や Obsidian に org-mode が提供する機能(のいくつか)が取り入れられて、多くのユーザに支持されているようで、個人的には喜ばしいことだなと思っています。(すいません、どちらも使ったことはありません。)この現象をみていると私は、org-modeで提供されているある機能と、それを参考にして実装された他アプリの機能は同じなのか、ということをよく考えます。いや、機能としては確かにほぼ同等だろうとは思います。もちろん優劣の話でもありません。以下に展開してみましょう。
</preview>
</p>

<p>
org-modeは、確かに出来ることを列挙していくと「重厚な思想に基づいてつくられた巨大なシステム」のように見えますが、その実体は細かいピースの集合体です。そのピースとは何か。それは、ユーザが自由に弄ることのできる設定項目と、設定を反映しながら少し気の利いたことをしてくれるコマンドもしくは関数です。
</p>


<p>
これらのピースは、長い年月をかけてユーザの「こういうのあったらいいよね」を具現化して積み上げられてきました。自由闊達に。昔、誰かがブログでorg-modeを評して、「欲しい機能を好き勝手に入れ込んで積み上げられた九龍城砦のような違法建築」と言っていて、言い得て妙だなと思いました。この表現が適切かは分かりませんが、一定程度は的を射ているとおもいます。
</p>

<p>
<a href="https://www.youtube.com/watch?v=No_vQ8FiQiw">Kowloon walled city 九龍城砦 - YouTube</a>
</p>

<p>
一方でorg-mode全体として整合性をとる必要はもちろんあるので、現メンテナのBastien Guerryの苦労は推して知るべし、かなと思っています。結果としてorg-modeは、細かいところまで設定できる柔軟性をもつ反面、ユーザに一定以上のリテラシを要求するものに仕上がったのだとおもいます。さらに言えば、この複雑な仕様ゆえにMarkdownのように標準化が進まず、結果として他のプラットフォームへの進出が芳しくない状態になっているのではないかと推察します。
</p>

<p>
つまり私がおもうのは、org-modeは、Big Pictureから精緻にデザインされたのではなく、ユーザのニーズに応え続けた「結果」であるということです。我々がorg-modeに抱く「思想」や「システム性」は後付けでしかないのではないか、と。(もちろんEmacsから受け継ぐ、特にテキスト編集における、ある種の「思想」はあります)
</p>

<p>
さて、最初の話に戻りましょう。org-modeの機能の一部を他のアプリが実装することだけを考えれば、それはそれほどむずかしいことではないかもしれません。しかし、org-modeにおける機能と機能の複雑な連携を考慮に入れようとすると、とたんに難易度が爆上がりする気がします。
</p>

<p>
加えて、機能と(キーボードメインの)ユーザ操作が独特のつながりをもつEmacsというプラットフォーム上での「体験」という点を考えれば、やはり両者はベツモノと考えた方がいいのではないか。現時点での私は、今のノートアプリ界隈の流れを見てそんなことを考えています。
</p>
<div class="taglist"><a href="https://www.p-snow.org/config/diary/tags.html">Tags</a>: <a href="https://www.p-snow.org/config/diary/tag-org.html">org</a> </div>]]></description>
  <category><![CDATA[org]]></category>
  <link>https://www.p-snow.org/config/diary/20230713-1703.html</link>
  <guid>https://www.p-snow.org/config/diary/20230713-1703.html</guid>
  <pubDate>Thu, 13 Jul 2023 17:03:00 +0000</pubDate>
</item>
</channel>
</rss>
