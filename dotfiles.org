#+TITLE: My Configuration Collection
#+STARTUP: overview

* Personal Information
** Local Directories
*** home directory

#+name: home-dir
#+begin_src shell :eval no-export
echo "${HOME}"
#+end_src

*** document directory
:PROPERTIES:
:CREATED:  [2023-12-06 Wed 12:43]
:END:

#+name: doc-dir
#+begin_src emacs-lisp :eval no-export :noweb yes
(let* ((sep "-")
       (node (split-string "<<laptop-node()>>" sep)))
  (expand-file-name
   (file-name-concat "~/"
                     (string-join (list (concat (car node) "doc") (cadr node))
                                  sep)
                     "doc/")))
#+end_src

*** share directory

My share directory is where my variable data stay.

#+name: share-dir
#+begin_src shell :eval no-export
realpath "${HOME}/data/share"
#+end_src

*** media directory

#+name: media-dir
#+begin_src shell :noweb yes :eval no-export
realpath "<<home-dir()>>/data/media"
#+end_src

*** trash directory
:PROPERTIES:
:CREATED:  [2023-04-10 Mon 21:57]
:END:

#+name: trash-dir
#+begin_src shell :eval no-export
echo "${XDG_DATA_HOME}/Trash"
#+end_src

delete file which lives longer than 1 week in trash directory.

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<trash-dir()>>/files 0700 - - 1w
#+end_src

#+begin_src shell :noweb yes :noweb-ref updatedb-opt
-e "<<trash-dir()>>" \
#+end_src

*** log file directory
:PROPERTIES:
:CREATED:  [2023-11-03 Fri 08:56]
:END:

#+name: log-dir
#+begin_src shell :eval no-export
echo "${XDG_STATE_HOME}/log"
#+end_src

** Email Settings
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:57]
:END:

*** Smtp Server Host (supposed to define 'smtp-host') :crypt:
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 12:01]
:END:

-----BEGIN PGP MESSAGE-----

hQEMA9uWvE5LJ2ejAQgAgdgJUS0v+ASUy6B5/RsqDdm/3ll8VK3bq+GlNPdPUIca
hO2qmuJfgiwXWmNZtr4wSFLYOEU6l9PjM8lCS+U1dcv18XcX0v3cjIZKb/0EiABl
PLnxdI0Nnkk3RBrWICP1+DLE48rCuJQvdHLzZ8wsVw1Wh4/BizIvY+t7+TxSDKLy
4UissNE9C+lftBL7caIaSUOyeppoQCKUaM4TaRiJU/Yv0QpCZvp6x03dSoTkr10h
l73EhhlkhbwvAUAg8Sb2hX7bAFwR8qp6BC8XkbtZM5u2uqrYUAmXGIYmHWOYSvQZ
hsxj9jzPkt8Y+xIZ//+oXxhN0UFigwGHn5IbIlB2TNJ+AYMlUGxMiv13YoI19N09
aGTmms93QHI7c86kfJNi4bI20kDLOwZThFK3gXEpzVFFT0rD1LOVga3Dqw1VsO0N
EEcaZWs9POlc4rdeF3kn3ZSB0P3J77vidiaIFOh5lNpU/9k7nEmT9QE0K++fpTxs
obm9ZjahsnwNP10Vn2pQ
=rUbc
-----END PGP MESSAGE-----

*** My Email Address (supposed to define 'email') :crypt:
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 19:41]
:END:

-----BEGIN PGP MESSAGE-----

hQEMA9uWvE5LJ2ejAQgAtC7Jd2eChH/yaCKEx5ecJFRpmv0JJlymqJU7Jf2ShbgF
FQeDPbqQaBAyp/vV9RVxeiYV5EsOofTJYhlLvvdiv4zq4NiaaEDjrUblOGWxaEHp
KBMdKLqqLADM9RfvPv2vrofI7FtxAG7PF+wRFeW1vXyKakjhnPA/ydJpDdOIgjzh
HCPmcZnYObSz9pwKPM05Rhfd7eLtOtaWBCxmTLGHhVd9xU0dXJ3eQwO0OeqYns7l
QWq4lQ9Q825aZ7h+hKkamleVuKy8kjrBxnfdsyHGMaPUQlQcTTnNmS50+EmiHh4Z
0I9N+vIhAM6yuz5Y/C4pndMgggFjKYCpmVAnIJLLjdKBASx2bGgpUfmRqdHeOwY5
/3zipNj2QRjif9iZuSNdgthn2Yz0wtZuzwzc+CGib/fqtY+N5Nt36mhydgbac36v
y3bLp9UlGFAAUsqmvw1EP0nmtONIX+9SZDL3B08OV6OdtmmINKNAR/8rkDZN8o0d
5F/lEfK8uU00O1Cwjl6O8YK/
=qchL
-----END PGP MESSAGE-----

*** My Login Name

#+name: login-name
#+begin_src emacs-lisp :eval no-export
user-login-name
#+end_src

*** My Domain Name

#+name: my-domain
#+begin_src shell :eval no-export
echo -n "${EMAIL}" | cut -d'@' -f2
#+end_src

** Machines
:PROPERTIES:
:CREATED:  [2023-12-06 Wed 12:39]
:END:

*** Primary Laptop
:PROPERTIES:
:CREATED:  [2023-12-06 Wed 12:39]
:END:

#+name: laptop-node
#+begin_src shell :eval no-export
uname -n
#+end_src

* Linux Distributions
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 14:59]
:END:
** Ubuntu
:PROPERTIES:
:CREATED:  [2022-10-06 Thu 15:32]
:END:

initialization script for a ubuntu account

#+begin_src bash :noweb tangle :noweb-sep "\n\n" :tangle (expand-file-name "initialize-ubuntu-desktop" tangle/local-bin-dir)
apt-install
npm-install
start-systemd-services

<<ubuntu-setup>>
#+end_src

*** Apt Package Manager
:PROPERTIES:
:CREATED:  [2023-11-01 Wed 12:11]
:END:

- apt-managed packages
  #+begin_src shell :noweb tangle :tangle (expand-file-name "apt-install" tangle/local-bin-dir)
  sudo apt-get install -y \
       <<apt-pkg>>
  #+end_src
- update apt packages every midnight
  #+begin_src shell :eval no :tangle no :noweb-ref system-batch
  apt update && apt upgrade --yes
  #+end_src

** Linux Mint (Cinnamon DE)
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 15:00]
:ID:       f3cd9a3b-9ff5-4cc8-807e-846f3f04c97a
:END:

initialization script for a linuxmint account

#+begin_src shell :noweb tangle :tangle (expand-file-name "initialize-linuxmint-desktop" tangle/local-bin-dir)
initialize-ubuntu-desktop

<<linuxmint-setup>>
#+end_src

- Back-up Cinnamon Desktop Configuration
  #+begin_src shell :eval no :tangle no :noweb-ref midnight-batch
  dconf dump /org/cinnamon/ > ~/.config/linuxmint/cinnamon.conf
  #+end_src

  To thaw backed up config
  #+begin_src conf :noweb yes :noweb-ref linuxmint-setup
  dconf load /org/cinnamon/ < <<home-dir()>>/.config/linuxmint/cinnamon.conf
  #+end_src

** GNU Guix

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/SystemCrafters/guix-installer/releases.atom" soft_update)
#+end_src

#+begin_src shell :noweb-ref bashrc
export GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

# fill in a variable below like a comment line
# if you'd like to acticate specific profiles under GUIX_EXTRA_PROFILES
ACTIVE_PROFILE_NAMES=()
# ACTIVE_PROFILE_NAMES=(base emacs)

profiles=()
if [ ${#ACTIVE_PROFILE_NAMES[@]} -eq 0 ]; then
  profiles="${GUIX_EXTRA_PROFILES}/*"
else
  for name in ${ACTIVE_PROFILE_NAMES[@]}; do
    profiles+=("${GUIX_EXTRA_PROFILES}/${name}")
  done
fi

for profile in ${profiles[@]}; do
  GUIX_PROFILE="${profile}/$(basename ${profile})"
  if [ -f ${GUIX_PROFILE}/etc/profile ]; then
    . "${GUIX_PROFILE}"/etc/profile
  fi
done

export GUIX_PROFILE="$HOME/.guix-profile"
. "$GUIX_PROFILE/etc/profile"

export GUIX_PROFILE="$HOME/.config/guix/current"
. "$GUIX_PROFILE/etc/profile"

export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"


if [ -v GUIX_ENVIRONMENT ]; then
  if [[ $PS1 =~ (.*)"\\$" ]]; then
    PS1="${BASH_REMATCH[1]} [env]\\\$ "
  fi
fi
#+end_src

*** Channel definitions

#+begin_src scheme :tangle (expand-file-name ".config/guix/base-channels.scm")
(list (channel
       (name 'nonguix)
       (url "https://gitlab.com/nonguix/nonguix"))
      (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git"))
      (channel
       (name 'guix-jp)
       (url "https://gitlab.com/guix-jp/channel")
       (branch "main"))
      (channel
       (name 'p-snow)
       (url "https://github.com/p-snow/guix-channel")
       (introduction
        (make-channel-introduction
         "3a10227fbc2d5e9744aced43f820a0d3bf64add5"
         (openpgp-fingerprint
          "CF56 FC53 3AD6 6A67 6FDC  1D73 0D2B AF0E 8AEF 0306")))))
#+end_src

*** Manifests
**** guix base profile

#+begin_src shell :noweb yes :noweb-ref bashrc
export XDG_DATA_DIRS=${GUIX_EXTRA_PROFILES}/base/base/share:${XDG_DATA_DIRS}
export MANPATH=${MANPATH}:${GUIX_EXTRA_PROFILES}/base/base/share/man
#+end_src

#+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/base.scm")
(specifications->manifest
 '("coreutils"
   "diffutils"
   "parallel"
   "gawk"
   "sed"
   "tar"
   "zip"
   "unzip"
   "zstd"
   "p7zip"
   "shadow"
   "sshfs"
   "grep"
   "ripgrep"
   "less"
   "pwgen"
   "file"
   "nkf"
   "lsof"
   "tree"
   "poppler"
   "pass-git-helper"
   "stow"
   "pandoc"
   "nss-certs"
   "openssl"
   "glibc"
   "procps"
   "time"
   "htop"
   "net-tools"
   "curl"
   "wget"
   "httrack"
   "ghc-tldr"
   "network-manager"
   "wakelan"
   "speedtest-cli"
   "parted"
   "fdisk"
   "gptfdisk"
   "cryptsetup"
   "smartmontools"
   "ddrescue"
   "sqlite"
   "libarchive"
   "imagemagick"
   "pngquant"
   "ffmpeg"
   "dav1d"
   "jq"
   "pup"
   "htmlq"
   "util-linux"
   "binutils"
   "make"
   "llvm"
   "cmake"
   "libtool"
   "pkgconf"
   "texinfo"
   "shellcheck"
   "global"
   "perl"
   "linux-libre-documentation"
   "pfetch"
   "neofetch"
   <<guix-base>>))
#+end_src

**** guix desktop profile

#+begin_src shell :noweb yes :noweb-ref bashrc
export XDG_DATA_DIRS=${GUIX_EXTRA_PROFILES}/desktop/desktop/share:${XDG_DATA_DIRS}
export MANPATH=${MANPATH}:${GUIX_EXTRA_PROFILES}/desktop/desktop/share/man
#+end_src

#+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/desktop.scm")
(specifications->manifest
 '("font-adobe-source-han-sans"
   "pulseaudio"
   "gparted"
   "vlc"
   "gcompris-qt"
   "gnome-disk-utility"
   "wine64"
   "winetricks"
   "kdeconnect"
   "dia"
   "inkscape"
   "krita"
   <<guix-desktop>>))
#+end_src

**** guix creative profile                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-10-14 Sat 13:39]
:END:

#+begin_src shell :noweb yes
export XDG_DATA_DIRS=${GUIX_EXTRA_PROFILES}/creative/creative/share:${XDG_DATA_DIRS}
#+end_src

#+begin_src scheme :noweb yes :tangle no
(specifications->manifest
 '(<<guix-creative>>))
#+end_src

**** guix emacs profile

#+begin_src shell :noweb yes :noweb-ref bashrc
export XDG_DATA_DIRS=${GUIX_EXTRA_PROFILES}/emacs/emacs/share:${XDG_DATA_DIRS}
export MANPATH=${MANPATH}:${GUIX_EXTRA_PROFILES}/emacs/emacs/share/man
#+end_src

#+begin_src scheme :noweb yes :noweb-prefix no :tangle (expand-file-name ".config/guix/manifests/emacs.scm")
(specifications->manifest
 '(<<guix-emacs>>
   "sicp"
   "isync"
   "stunnel"
   "wordnet"
   "emacs-transient"
   "emacs-compat"))
#+end_src

*** Activating Profiles

This script accepts a space-separated list of manifest file names (without extension) under the =~/.config/guix/manifests= folder and then installs those profiles for the first time.  For example:

: activate-profiles base emacs

#+begin_src shell :tangle (expand-file-name "activate-profiles" tangle/local-bin-dir)
GREEN='\033[1;32m'
RED='\033[1;30m'
NC='\033[0m'
GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

profiles=$*
if [ $# -eq 0 ]; then
  profiles="$HOME/.config/guix/manifests/*.scm";
fi

for profile in $profiles; do
  # Remove the path and file extension, if any
  profileName=$(basename $profile)
  profileName="${profileName%.*}"
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  manifestPath=$HOME/.config/guix/manifests/$profileName.scm

  if [ -f $manifestPath ]; then
    echo
    echo -e "${GREEN}Activating profile:" $manifestPath "${NC}"
    echo

    mkdir -p $profilePath
    guix package --manifest=$manifestPath --profile="$profilePath/$profileName"

    # Source the new profile
    GUIX_PROFILE="$profilePath/$profileName"
    if [ -f $GUIX_PROFILE/etc/profile ]; then
      . "$GUIX_PROFILE"/etc/profile
    else
      echo -e "${RED}Couldn't find profile:" $GUIX_PROFILE/etc/profile "${NC}"
    fi
  else
    echo "No profile found at path" $profilePath
  fi
done
#+end_src

#+name: template-activate-profiles
#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-template
(activate-profiles "activate-profiles "
                   (completing-read "profiles: "
                                    (mapcar (lambda (elt)
                                              (string-join elt " "))
                                            (my/combinations
                                             '("base" "desktop" "emacs")))))
#+end_src

- Automating Script
  Update packages in base profile every midnight
  #+begin_src shell :eval no :tangle no :noweb-ref midnight-batch
  update-channels && activate-profiles base && guix gc -d 2m -F 20G
  #+end_src
  #+begin_src shell :eval no :tangle no :noweb-ref system-batch
  sudo -i guix pull && systemctl restart guix-daemon.service
  #+end_src
  Update packages in desktop and emacs profile every weekend
  #+begin_src shell :eval no :tangle no :noweb-ref weekend-batch
  activate-profiles desktop emacs && guix gc -d 2m -F 20G
  #+end_src

*** Updating Channels

This script makes it easy to update all channels to the latest commit based on an original channel file.

: update-channels

You can use ~/.config/guix/channels.scm to replicate exact packages on another machine with

: guix pull -C ~/.config/guix/channels.scm

#+begin_src shell :tangle (expand-file-name "update-channels" tangle/local-bin-dir)
guix pull --channels=$HOME/.config/guix/base-channels.scm \
  && guix describe --format=channels > ~/.config/guix/channels.scm
#+end_src

* System Constituents
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:14]
:END:
** Font
:PROPERTIES:
:CREATED:  [2022-09-07 Wed 19:08]
:END:

#+begin_src scheme :noweb-ref guix-base
"font-ipa"
"font-ipa-ex"
"font-google-noto"
"font-inconsolata"
"font-iosevka"
#+end_src

*** Fontconfig

#+begin_src scheme :noweb-ref guix-base
"fontconfig"
#+end_src

# #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
#   fonts-ipafont-mincho fonts-ipafont-gothic
# #+end_src

#+begin_src xml :noweb tangle :tangle (expand-file-name ".config/fontconfig/fonts.conf")
<?xml version='1.0'?>
<!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
<fontconfig>
  <dir><<home-dir()>>/.guix-extra-profiles/base/base/share/fonts</dir>
</fontconfig>
#+end_src

install available fonts by rescanning font directories
#+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
fc-cache -rvf
#+end_src

*** Font Viewer
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:24]
:END:

#+begin_src scheme
"gnome-font-viewer"
#+end_src

** Bash

#+begin_src scheme :noweb-ref guix-base
"bash"
#+end_src

- bash profile
  #+BEGIN_SRC shell :tangle (expand-file-name ".bash_profile") :comments no
  #!/usr/bin/env bash

  if [ -f ~/.bashrc ]; then
    source ~/.bashrc
  fi
  #+END_SRC
- bashrc
  #+BEGIN_SRC bash :noweb yes :tangle (expand-file-name ".bashrc") :comments no :shebang ""
  if [ -f ~/.bashrc.secret ]; then
    source ~/.bashrc.secret
  fi

  export EMAIL=<<email>>
  export VIEWER=less

  USER_PATHS=(
    "${HOME}/usr/bin"
    "${HOME}/.local/bin"
  )
  for path in "${USER_PATHS[@]}"; do
    if [ -d "${path}" ]; then
      export PATH="${path}:$PATH"
    fi
  done

  if [ -e $HOME/.bash_aliases ]; then
    source $HOME/.bash_aliases
  fi
  if [ -e $HOME/.bash_functions ]; then
    source $HOME/.bash_functions
  fi

  # prompt
  MACHINE=$(echo $(uname -n) | awk -F . '{print $1}')
  PS1="[\u@${MACHINE}:\\W]\n\$ "

  # function/variable used in libvterm/emacs
  vterm_printf(){
    if [ -n "$TMUX" ]; then
      # Tell tmux to pass the escape sequences through
      # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
      printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
      # GNU screen (screen, screen-256color, screen-256color-bce)
      printf "\eP\e]%s\007\e\\" "$1"
    else
      printf "\e]%s\e\\" "$1"
    fi
  }

  vterm_prompt_end(){
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
  }

  PROMPT_COMMAND='echo -ne "\033]0;${HOSTNAME}:${PWD}\007"'

  case ${TERM} in
  dumb)
    ;;
  xterm-256color)
    export LANG=en_US.UTF-8
    PS1=$PS1'\[$(vterm_prompt_end)\]'
    ;;
  ,*)
    export LANG=ja_JP.UTF-8
    ;;
  esac

  export WINEARCH=win64
  export WINEPREFIX=~/.wine

  <<bashrc>>
  #+END_SRC
- aliases
  #+begin_src shell :tangle (expand-file-name ".bash_aliases")
  alias ..="cd ../"
  alias l="ls -F"
  alias ll="l -lh"
  alias la="l -a"
  alias lal="l -alh"
  alias lld="l -ld"
  alias cp="cp -i"
  alias mv="mv -i"
  alias rm="rm -i"
  alias rmf="rm -rf"
  alias mkdir="mkdir -pv"
  alias rmdir="rmdir -v"
  alias ff='find . -type f -iname'

  alias cputemp='cat /sys/class/thermal/thermal_zone0/temp'
  alias ipaddr="hostname -I | cut -f1 -d' '"
  #+end_src
- functions
  #+begin_src shell :tangle (expand-file-name ".bash_functions")
  function cl() {
    DIR="$*";
    # if no DIR given, go home
    if [ $# -lt 1 ]; then
      DIR=$HOME;
    fi;

    builtin cd "${DIR}" && \
      # use your preferred ls command
      ls -F --color=auto
  }

  function cpuinfo {
    cores=$(nproc)
    frequency=$(grep MHz /proc/cpuinfo | head -1 | awk -F ' ' '{print $4" MHz"}')
    model=$(grep "model name" /proc/cpuinfo | head -1 | sed -r 's/^.{13}//')
    echo "CPU Model: $model"
    echo "CPU Cores: $cores"
    echo "Frequency: $frequency"
  }

  function dual() {
    if [ $# -eq 0 ]; then
      du_arg="./* ./.[^.]*"
    else
      du_arg=""
      for v in "$@"
      do
        if [ -f ${v} ]; then
          du_arg="${du_arg} ${v}"
        elif [ -d ${v} ]; then
          du_arg="${du_arg} ${v}/* ${v}/.[^.]*"
        fi
      done
    fi

    ionice -c2 -n7 nice -n19 du -scD ${du_arg} 2>/dev/null
  }
  export -f dual

  function mkcdir() {
    mkdir -p -- "$1" && cd -P -- "$1"
  }

  function rms() {
    read -p 'shred all files - are you sure (y/n) ? ' ans
    test x$ans == xy && (
      for file in "$@"; do
        if [ -f "${file}" ]; then
          shred -uzv "${file}"
        elif [ -d "${file}" ]; then
          find "${file}" -type f -exec shred -uzv {} \;
          rm -rf "${file}"
        fi
      done
    )
  }

  # A simple script to check on system resources
  function chksys() {
    clear

    echo "Memory Usage:"
    /usr/bin/free -h

    echo $'\n'$"Disk Usage:"
    /bin/df -h /dev/sd[a-z][1-9] 2>/dev/null

    echo $'\n'$"Uptime:"
    /usr/bin/uptime
  }
  #+end_src
- profile
  #+BEGIN_SRC shell :tangle (expand-file-name ".profile")
  # ~/.profile: executed by the command interpreter for login shells.
  # This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
  # exists.
  # see /usr/share/doc/bash/examples/startup-files for examples.
  # the files are located in the bash-doc package.

  # the default umask is set in /etc/profile; for setting the umask
  # for ssh logins, install and configure the libpam-umask package.
  #umask 022

  # if running bash
  if [ -n "$BASH_VERSION" ]; then
    # include .bash_profile if it exists
    if [ -f "$HOME/.bash_profile" ]; then
      . "$HOME/.bash_profile"
    fi
  fi

  # set PATH so it includes user's private bin if it exists
  if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
  fi

  # set PATH so it includes user's private bin if it exists
  if [ -d "$HOME/.local/bin" ] ; then
    PATH="$HOME/.local/bin:$PATH"
  fi
  #+END_SRC
** Systemd

#+begin_src shell :noweb tangle :tangle (expand-file-name "start-systemd-services" tangle/local-bin-dir)
cd ~/.config/systemd/system/ && \
  for sys_service in $(ls ./*); do
    sudo cp -f ${sys_service} /etc/systemd/system
  done

<<systemd-service>>
#+end_src

*** systemd-tmpfiles

[[https://www.freedesktop.org/software/systemd/man/systemd-tmpfiles-setup.service.html][systemd-tmpfiles]] manages file creation and deletion. In this section, all settings focus on user level file cleanup and deletion under /home directory.

You may need to enable systemd-tmpfiles service for user
: $ cd /usr/lib/systemd/user
: $ cp systemd-tmpfiles-* ~/.config/systemd/user/
#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer
#+end_src

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name ".config/user-tmpfiles.d/cleanup.conf")
d <<home-dir()>>/tmp 0755 - - 5d
d <<home-dir()>>/Downloads 0755 - - 4w
<<tmpfiles-cleanup>>
#+end_src

** Vixie Cron

A script to reinitialize a set of cron jobs
#+begin_src bash :eval no :comments no :noweb tangle :tangle (expand-file-name "cron-reinit.sh" tangle/local-bin-dir)
crontab <<home-dir()>>/.config/crontab/<<login-name()>>
#+end_src

#+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
cron-reinit.sh
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name user-login-name ".config/crontab") :tangle-mode o444
MAILTO="<<email>>"

BIN_DIR="<<home-dir()>>/bin"
LOG_DIR="<<log-dir()>>"

<<cronjob-user>>
#+end_src

** Btrfs

Btrfs is a CoW (Copy on Write) file system supports snapshot and send/recv mechanism.

#+begin_src scheme :noweb-ref guix-base
"btrfs-progs"
#+end_src

*** btrbk

[[https://digint.ch/btrbk/doc/btrbk.1.html][Btrbk]] supports for taking snapshots and backups

#+begin_src scheme :noweb-ref guix-base
"btrbk"
#+end_src

**** btrbk.conf

[[https://digint.ch/btrbk/doc/btrbk.conf.5.html][btrbk.conf documentation]]

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/btrbk/btrbk.conf")
timestamp_format long
incremental yes

snapshot_preserve_min 6h
snapshot_preserve 36h 3d 2w

# Create snapshots only if the backup disk is attached
#snapshot_create ondemand

target_preserve_min latest
target_preserve 8w 6m *y

snapshot_dir snapshots
volume /mnt/home
target /mnt/exbak/<<laptop-node()>>
subvolume home
#+end_src

**** snapshot/backup script

#+begin_src shell :noweb tangle :tangle (expand-file-name "btrbkhome" tangle/local-bin-dir)
BTRBK_CONF=<<home-dir()>>/.config/btrbk/btrbk.conf

<<which(filename="btrbk")>> --config "${BTRBK_CONF}" run
#+end_src

#+begin_src conf :noweb yes :noweb-ref cronjob-user
,*/15 * * * * <<which(filename="pwsudo")>> <<which(filename="btrbkhome")>>
#+end_src

*** snapshots management                      :ARCHIVE:

A structure described below is expected under all devices.

/mountpoint/
├── backups
├── incumbents
└── snapshots

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_snap") :tangle-mode (identity #o755)
#!/usr/bin/env bash
set -euo pipefail

DATETIME=`date "+%Y%m%d-%H%M"`
BTRFS_MNTS=("/mnt/ssd01"
            "/mnt/nvme01")

# back up server data beforehand
ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit" \
  && rsync -arhv sv04:~/var/backup ~/share/sv04

# take snapshots for all btrfs subvolumes
for btrfs_mnt in ${BTRFS_MNTS[@]}; do
  if mountpoint ${btrfs_mnt} >/dev/null 2>&1; then
    for subv in ${btrfs_mnt}/incumbents/*; do
      subv_base=$(basename ${subv})
      if [ ! -d "${btrfs_mnt}/snapshots/${subv_base}" ]; then
        mkdir -p "${btrfs_mnt}/snapshots/${subv_base}"
      fi
      btrfs subvolume snapshot "${subv}" "${btrfs_mnt}/snapshots/${subv_base}/${DATETIME}"
    done
  fi
done
#+end_src

*** backup to another device                  :ARCHIVE:

: $ btrfs_back

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_back") :tangle-mode (identity #o755)
#!/usr/bin/env bash
set -euo pipefail

MNT_SSD=/mnt/ssd01
MNT_HDD=/mnt/hdd01

function backup_subvol() {
  local _src_snap_dir=$1
  local _src_back_dir=$2
  local _dst_back_dir=$3

  echo "Name: $(basename ${_src_back_dir})"

  mkdir -pv "${_src_back_dir}"
  mkdir -pv "${_dst_back_dir}"

  src_back_last=$((ls -d "${_src_back_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename) || echo -n "")
  snap_last=$(ls -d "${_src_snap_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename || echo -n "")

  # create readonly clone of last snapshot
  if [[ "${src_back_last}" < "${snap_last}" ]]; then
    echo btrfs subv snap -r "${_src_snap_dir}/${snap_last}" "${_src_back_dir}/${src_back_last}"
  fi

  exit;

  # determine parent btrfs subvolume
  parent=
  dst_backs=$(ls -d "${_dst_back_dir}"/* 2>/dev/null | sort || echo -n "")
  if [ ${#dst_backs} -ne 0 ]; then
    for dst_back in "${dst_backs[@]}"; do
      test=$(basename ${dst_back})
      if [ -d "${_src_back_dir}/${test}" ]; then
        parent=${test}
      fi
    done
  fi

  # determine subvolume to send in source device
  subvol=
  if [ ${#src_back_last} -ne 0 ]; then
    if [[ "${parent}" < "${src_back_last}" ]] && [ ! -d "${_dst_back_dir}/${src_back_last}" ]; then
      subvol=${src_back_last}
    fi
  fi

  echo "Parent: ${parent}"
  echo "Subvol: ${subvol}"

  if [ -n "${parent}" ] && [ -n "${subvol}" ]; then
    echo "Invoke incremental backup"
    sudo btrfs send -p "${_src_back_dir}/${parent}" "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
  elif [ -z "${parent}" ] && [ -n "${subvol}" ]; then
    echo "Invoke full backup"
    sudo btrfs send "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
  fi

  echo "--------"
}

backup_subvol "${MNT_SSD}"/snapshots/doc "${MNT_SSD}"/backups/doc "${MNT_HDD}"/backups/doc
# backup_subvol "${MNT_SSD}"/snapshots/share "${MNT_SSD}"/backups/share "${MNT_HDD}"/backups/share
#+end_src
** XDG

#+begin_src scheme :noweb-ref guix-base
"xdg-utils"
#+end_src

#+name: conf-dir
#+begin_src shell :eval no-export
echo "${XDG_CONFIG_HOME}"
#+end_src

*** xdg-mime
- ask default application for text/plain
  : $ xdg-mime query default text/plain

#+begin_src conf :tangle (expand-file-name ".config/mimeapps.list") :tangle-mode (identity #o644)
[Added Associations]
inode/directory=io.github.celluloid_player.Celluloid.desktop;nemo.desktop;

[Default Applications]
inode/directory=nemo.desktop
#+end_src

** GnuPG (gpg)
[[https://wiki.archlinux.org/title/GnuPG][
GnuPG - ArchWiki]]

I've chosen to use gpg/gpg-agent and pass on Ubuntu system since pass (password-store) spouts a warning saying there's gpg version mismatch persistently.
#+begin_src scheme :noweb-ref guix-base
;; "gnupg"
#+end_src

- gpg config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg.conf")
  with-keygrip
  #+end_src
- gpg-agent config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg-agent.conf")
  # pinentry-program /usr/bin/pinentry-curses
  pinentry-program /usr/bin/pinentry
  allow-emacs-pinentry
  allow-loopback-pinentry
  enable-ssh-support
  max-cache-ttl <<hours-in-sec(h=700)>>
  default-cache-ttl <<hours-in-sec(h=700)>>
  default-cache-ttl-ssh <<hours-in-sec(h=48)>>
  #+end_src
- mandatory config to use pinentry-curses for gpg-agent

  #+begin_src shell :noweb-ref bashrc
  export GPG_TTY=$(tty)

  # Refresh gpg-agent tty in case user switches into an X session
  gpg-connect-agent updatestartuptty /bye >/dev/null
  #+end_src

  #+begin_src conf :tangle (expand-file-name ".ssh/config")
  Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
  #+end_src
- utility
  #+name: hours-in-sec
  #+begin_src emacs-lisp :var h=1
  (* h 60 60)
  #+end_src

** Key Remappers
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:44]
:END:

*** Xremap
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:45]
:END:

[[https://github.com/k0kubun/xremap][Xremap]] is a key remapper for Wayland/X11. It's astoundingly fast, customizable and easy-to-use.

#+begin_src scheme :noweb-ref guix-base
"xremap-x11"
#+end_src

- config file
  #+begin_src yaml :tangle (expand-file-name ".config/xremap/config.yml") :comments no
  modmap:
  - name: CapsCtrlSwap
  remap:
  CapsLock: Ctrl_L
  Ctrl_L: CapsLock
  Ctrl_R: Super_R
  - name: Enter/Quote as Hyper
  remap:
  KEY_ENTER:
  held: Super_L
  alone: KEY_ENTER
  alone_timeout_millis: 500
  KEY_APOSTROPHE:
  held: Super_L
  alone: KEY_APOSTROPHE
  - name: SandS
  remap:
  Space:
  held: Shift_L
  alone: Space
  alone_timeout_millis: 500
  - name: Left/Right Shift to Equal/Minus
  remap:
  Shift_L:
  held: Shift_L
  alone: KEY_EQUAL
  alone_timeout_millis: 300
  Shift_R:
  held: Shift_R
  alone: KEY_MINUS
  alone_timeout_millis: 300
  keymap:
  - name: M-u/H-u to C-u
  exact_match: true
  remap:
  M-KEY_U: Ctrl-KEY_U
  Super-KEY_U: Ctrl-KEY_U
  - name: asdf1234
  exact_match: true
  remap:
  C-Super-a: KEY_1
  C-Super-s: KEY_2
  C-Super-d: KEY_3
  C-Super-f: KEY_4
  C-Super-g: KEY_5
  C-Super-h: KEY_6
  C-Super-j: KEY_7
  C-Super-k: KEY_8
  C-Super-l: KEY_9
  C-Super-semicolon: KEY_0
  #+end_src

**** xremap systemd service
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:49]
:END:

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
sudo systemctl enable xremap
sudo systemctl start xremap
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/system/xremap.service")
[Unit]
Description=xremap daemon

[Service]
ExecStart=<<which(filename="xremap")>> --watch=device,config <<conf-dir()>>/xremap/config.yml
Restart=always
Type=simple

[Install]
WantedBy=multi-user.target
#+end_src

*** XKB                                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-19 Sun 15:32]
:END:

#+begin_src scheme :noweb-ref guix-base
"xkeyboard-config"
"setxkbmap"
"xkbcomp"
#+end_src

- 通常の'setxkbmap -print'の出力からシンボルctrl(swapcaps)を加えたもの (CtrlとCapsLockの入替)
  #+begin_src conf :tangle (expand-file-name ".config/xkb/keymap/keymap.xkb")
  xkb_keymap {
  xkb_keycodes  { include "evdev+aliases(qwerty)"	};
  xkb_types     { include "complete"	};
  xkb_compat    { include "complete"	};
  xkb_symbols   { include "pc+us+inet(evdev)+group(win_space_toggle)+ctrl(swapcaps)+terminate(ctrl_alt_bksp)"	};
  xkb_geometry  { include "pc(pc105)"	};
  };
  #+end_src

**** xkb user systemd service
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 18:45]
:END:

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/start-xkb") :shebang #!/bin/bash :tangle-mode (identity #o755)
<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY 2>/dev/null
#+end_src

# #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
#+begin_src conf :tangle no
systemctl --user enable xkb
systemctl --user start xkb
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/user/xkb.service")
[Unit]
Description=xkb
# Wants=systemd-udev-settle.service
# After=systemd-udev-settle.service

[Service]
ExecStart=<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY

[Install]
# WantedBy=default.target
WantedBy=basic.target
# WantedBy=graphical-session.target

# [Unit]
# Description=Custom xkb layout service

# [Service]
# # ExecStart=/usr/bin/setxkbmap -layout us -variant altgr-intl -option grp:ctrl_shift_toggle
# ExecStart=<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY
# Restart=always

# [Install]
# WantedBy=multi-user.target
#+end_src

*** Interception Tools                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:02]
:END:

[[https://gitlab.com/interception/linux/tools][Interception Tools]] offers a set of programs to change key event by intervening evdev which is low layer key event managing program.

#+begin_src scheme :noweb-ref guix-base
"interception-dual-function-keys"
"interception-tools"
#+end_src

**** udevmon
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:10]
:END:

#+begin_src yaml :noweb tangle :tangle (expand-file-name ".config/interception/udevmon.yaml")
- JOB: "<<which(filename="intercept")>> -g $DEVNODE | <<which(filename="dual-function-keys")>> -c <<home-dir()>>/.config/interception/dual-function-keys.yaml | <<which(filename="uinput")>> -d $DEVNODE"
DEVICE:
EVENTS:
EV_KEY: [KEY_ENTER]
LINK: .*_Realforce_103-event-kbd
#+end_src

***** udevmon systemd service

# #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
#   sudo systemctl enable udevmon
#   sudo systemctl start udevmon
# #+end_src

# #+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/system/udevmon.service")
#+begin_src conf :noweb tangle :tangle no
[Unit]
Description=udevmon
Wants=systemd-udev-settle.service
After=systemd-udev-settle.service

[Service]
ExecStart=<<which(filename="pwsudo")>> <<which(filename="nice")>> -n -20 <<which(filename="udevmon")>> -c <<home-dir()>>/.config/interception/udevmon.yaml

[Install]
WantedBy=multi-user.target
#+end_src

**** dual function keys
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:09]
:END:

[[https://man.archlinux.org/man/community/interception-dual-function-keys/dual-function-keys.1.en][dual-function-keys]] is constituent of Interception Tools. It allows users to add a function to the key resulting to impart two capability for one key exerted at tapped and held.

#+begin_src yaml :tangle (expand-file-name ".config/interception/dual-function-keys.yaml")
TIMING:
TAP_MILLISEC: 400
DOUBLE_TAP_MILLISEC: 150

MAPPINGS:
- KEY: KEY_ENTER
TAP: KEY_ENTER
HOLD: KEY_RIGHTCTRL
# space for shift on hold
- KEY: KEY_SPACE
TAP: KEY_SPACE
HOLD: KEY_LEFTSHIFT
- KEY: KEY_LEFTSHIFT
TAP: KEY_MINUS
HOLD: KEY_LEFTSHIFT
- KEY: KEY_RIGHTSHIFT
TAP: KEY_EQUAL
HOLD: KEY_RIGHTSHIFT
#+end_src

* Application Configurations

#+name: user-bin-dir
#+begin_src emacs-lisp :noweb yes
(expand-file-name "~/.local/bin")
#+end_src

** GNU Emacs
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:22]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs"
;; "emacs-next"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
export EDITOR="emacsclient -c -a emacs"
#+end_src

#+name: emacs-dir
#+begin_src emacs-lisp :noweb yes
(expand-file-name "~/.emacs.d")
#+end_src

*** general configuration
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/elisp/config/my-config.el")
:CREATED:  [2023-01-20 Fri 10:22]
:END:

**** early-init.el
:PROPERTIES:
:header-args+: :tangle (expand-file-name "early-init.el" user-emacs-directory-default)
:END:

Early init file defines fundamental variables used from both normal Emacs session and batch mode.

***** global variable definitions

#+begin_src emacs-lisp :noweb tangle
(setf user-emacs-directory
      (file-name-as-directory (expand-file-name "emacs" "<<share-dir()>>")))
(setf user-emacs-directory-default
      (file-name-as-directory (expand-file-name (file-name-as-directory "~/.emacs.d"))))

(defvar my/user-dot-emacs-dir
  (expand-file-name "<<emacs-dir()>>")
  "Original .emacs.d directory.")
(defvar my/user-lisp-dir
  (expand-file-name "elisp" "<<emacs-dir()>>")
  "Directory beneath which user Emacs config files are placed.")
(defvar my/user-config-dir
  (expand-file-name "config" my/user-lisp-dir)
  "Directory beneath which user Emacs init files are placed.")
(defvar my/user-package-dir
  (expand-file-name "site-elisp" "<<emacs-dir()>>")
  "Directory beneath which Emacs packages including mime are placed.")

(defvar my/user-bin-dir
  (expand-file-name "<<user-bin-dir()>>")
  "Directory beneath which local binary files are placed.")
(defvar my/user-share-directory "<<share-dir()>>")

(push my/user-lisp-dir load-path)
(push my/user-package-dir load-path)
#+end_src

***** package.el

#+begin_src emacs-lisp
(require 'package)

(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/")
             t)
(setopt package-enable-at-startup t)
(setopt package-user-dir
        (expand-file-name "elpa" user-emacs-directory-default))

(require 'package-vc)
#+end_src

***** load cl-lib

Use 'cl-lib' rather than 'cl' package since it is [[https://www.gnu.org/savannah-checkouts/gnu/emacs/news/NEWS.27.1][officially deprecated]].

#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src

***** use-package

[[https://jwiegley.github.io/use-package/][Official manual]] is handy especially when you look up [[https://jwiegley.github.io/use-package/keywords/][Keywords]].

#+begin_src emacs-lisp
(require 'use-package)
(require 'use-package-ensure)

(customize-set-variable 'use-package-compute-statistics t)
(customize-set-variable 'use-package-verbose nil)
(with-eval-after-load 'my-launch-app
  (keymap-set my/invoke-list-command-map (kbd "u")
              #'use-package-report))
#+end_src

use-package depends on following packages internally

****** diminish

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-diminish"
#+end_src

****** delight

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-delight"
#+end_src

***** straight.el                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 20:17]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/raxod502/straight.el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(customize-set-variable 'straight-recipes-gnu-elpa-use-mirror t)
(customize-set-variable 'straight-base-dir user-emacs-directory-default)
(customize-set-variable 'straight-vc-git-default-clone-depth 1)

(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory-default))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(with-eval-after-load 'hydra
  (defhydra hydra-straight (global-map "C-x -"
                                       :color blue)
    "Straight"
    ("c" straight-check-package)
    ("C" straight-check-all)
    ("r" straight-rebuild-package)
    ("R" straight-rebuild-all)
    ("f" straight-fetch-package)
    ("F" straight-fetch-all)
    ("p" straight-pull-package-and-deps)
    ("P" straight-pull-all)
    ("m" straight-merge-package)
    ("M" straight-merge-all)
    ("n" straight-normalize-package)
    ("N" straight-normalize-all)
    ("u" straight-push-package)
    ("U" straight-push-all)
    ("v" straight-freeze-versions)
    ("V" straight-thaw-versions)
    ("w" straight-watcher-start)
    ("W" straight-watcher-quit)
    ("g" straight-get-recipe)
    ("e" straight-prune-build)
    ("q" nil)))
#+end_src

***** safe local eval forms
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 10:19]
:END:

Following hook statements are likely written in .dir-locals.el at the top level of git repositories.

#+begin_src emacs-lisp
(add-to-list 'safe-local-eval-forms
             '(add-hook 'find-file-hook
                        (lambda () (setq-local buffer-save-without-query t))))

(add-to-list 'safe-local-eval-forms
             '(remove-hook 'find-file-hook
                           (lambda () (setq-local buffer-save-without-query t))))
#+end_src

**** loading sequence

***** custom file
:PROPERTIES:
:CREATED:  [2023-01-10 Tue 18:48]
:END:

#+begin_src emacs-lisp
(customize-set-variable 'custom-file
                        (expand-file-name "custom.el" user-emacs-directory-default))

(when (file-readable-p custom-file)
  (load custom-file))
#+end_src

***** init.el
:PROPERTIES:
:CREATED:  [2022-12-24 Sat 14:56]
:END:

init.el devote itself to call for remaining config files.

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/init.el")
(require 'user-init)
#+end_src

***** load user config files
:PROPERTIES:
:CREATED:  [2023-01-10 Tue 18:46]
:END:

#+begin_src emacs-lisp  :tangle (expand-file-name ".emacs.d/elisp/user-init.el")
(let ((load-match "\\.el$"))
  (mapc #'load-file
        (append (directory-files my/user-config-dir t load-match)
                (directory-files (file-name-concat my/user-config-dir "tangled") t load-match))))

(provide 'user-init)

;;; user-init ends here
#+end_src

**** Themes

The theme of my choice at present

#+begin_src emacs-lisp
(with-eval-after-load 'ef-themes
  (load-theme 'ef-bio :no-confirm))
#+end_src

***** modus-themes

I love modus-theme which [[https://protesilaos.com/codelog/2019-08-07-emacs-modus-themes/][conforms to WCAG AAA]]. [[https://protesilaos.com/codelog/2022-04-21-modus-themes-colour-theory/][This blog post]] explains how this package determines colors theoretically and perceptually.

Following configuration is for version 4 of modus-themes which takes breaking change from previous major version.

#+begin_src emacs-lisp
(use-package modus-themes
  :disabled t
  :custom
  (modus-themes-to-toggle '(modus-vivendi
                            modus-vivendi-tinted
                            modus-vivendi-deuteranopia))
  (modus-themes-org-blocks 'tinted-background)
  (modus-themes-bold-constructs t)
  :config
  (customize-set-variable 'modus-themes-common-palette-overrides
                          modus-themes-preset-overrides-faint)
  (bind-keys ("<f6>" . modus-themes-toggle)))
#+end_src

***** ef-themes
:PROPERTIES:
:CREATED:  [2023-05-15 Mon 15:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ef-themes"
#+end_src

#+begin_src emacs-lisp
(use-package ef-themes
  :init
  (setq ef-bio-palette-overrides
        '((cursor "#ffffff")))
  :custom
  (ef-themes-to-toggle ef-themes-dark-themes)
  :config
  (bind-keys ("<f9>" . ef-themes-toggle)))
#+end_src

**** Basic Preferences

Settings in this section are influenced a great deal by my personal preference. Please be meticulous when you borrow.

***** Modifier Keys

#+begin_src emacs-lisp
(cond
 ((string= window-system "x")
  (setf x-meta-keysym 'meta
        x-alt-keysym 'meta
        x-super-keysym 'hyper))
 ((string= window-system "ns")
  ;; IME inline patch
  (setf mac-use-input-method-on-system nil)
  (setf mac-control-modifier       'control
        mac-command-modifier       'meta
        mac-option-modifier        'super
        mac-right-option-modifier  'alt
        mac-right-control-modifier 'super
        mac-function-modifier      'hyper)))
#+end_src

***** Basic Key Bindings

#+begin_src emacs-lisp
(global-set-key (kbd "M-F") #'forward-to-word)
(global-set-key (kbd "M-B") #'backward-to-word)
(global-set-key (kbd "C-c d") #'duplicate-dwim)
(global-set-key (kbd "C-c M-d") #'copy-from-above-command)
(global-set-key (kbd "M-z") #'zap-up-to-char)

(global-set-key (kbd "C-c k") #'kill-this-buffer)
(global-set-key (kbd "C-x M-r") #'rename-visited-file)
(global-set-key (kbd "C-M-<delete>") #'restart-emacs)
(global-set-key (kbd "C-M-S-<delete>") #'save-buffers-kill-emacs)

(substitute-key-definition 'upcase-region
                           'upcase-dwim
                           global-map)
(substitute-key-definition 'downcase-region
                           'downcase-dwim
                           global-map)
(global-set-key (kbd "C-x C-c") #'capitalize-dwim)
#+end_src

- Bind for C-x C-b, use [[help:ibuffer][ibuffer]] which has more features than [[help:list-buffers][list-buffers]] based on [[https://irreal.org/blog/?p=10329][this advice]].
  #+begin_src emacs-lisp
  (substitute-key-definition 'list-buffers
                             'ibuffer
                             global-map)
  #+end_src

- bind handy find functions like 'find-library to C-x L
  #+begin_src emacs-lisp
  (find-function-setup-keys)
  #+end_src

***** Unleash Disabled Commands
:PROPERTIES:
:CREATED:  [2023-07-01 Sat 13:59]
:END:

#+begin_src emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'set-goal-column 'disabled nil)
(put 'buffer-save-without-query 'disabled nil)
(put 'scroll-left 'disabled nil)
(put 'scroll-right 'disabled nil)
#+end_src

***** Language

[[info:emacs#Language Environments][emacs#Language Environments]]

#+begin_src emacs-lisp
;; language and locale
(set-language-environment "Japanese")
(setq system-time-locale "C")

;; coding system
(set-default-coding-systems 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
(set-selection-coding-system 'utf-8-unix)

;; prefer-coding-system take effect equally to follows
(set-buffer-file-coding-system 'utf-8-unix)
(set-file-name-coding-system 'utf-8-unix)
(set-terminal-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8-unix)
(setq locale-coding-system 'utf-8-unix)
#+end_src
***** Fontsets

#+begin_src emacs-lisp
(create-fontset-from-ascii-font "IPAGothic" nil "default")

(create-fontset-from-ascii-font "IPAexMincho" nil "exmincho")
(set-fontset-font "fontset-exmincho" 'japanese-jisx0208 "IPAexMincho")

(create-fontset-from-ascii-font "IPAexGothic" nil "exgothic")
(set-fontset-font "fontset-exgothic" 'japanese-jisx0208 "IPAexGothic")

(create-fontset-from-ascii-font "IPAMincho" nil "mincho")
(set-fontset-font "fontset-mincho" 'japanese-jisx0208 "IPAMincho")
(set-fontset-font "fontset-mincho" 'symbol "IPAMincho")

(create-fontset-from-ascii-font "Iosevka" nil "code")
(set-fontset-font "fontset-code" 'latin (font-spec :family "Iosevka" :weight 'Light :width 'Normal))

;; foreign fonts for all fontsets
(set-fontset-font t 'emoji "Noto Color Emoji")
(set-fontset-font t 'symbol "Noto Sans CJK JP" nil 'append)
(set-fontset-font t 'symbol "Noto Sans Symbols" nil 'append)
(set-fontset-font t 'symbol "Noto Sans Symbols2" nil 'append)
#+end_src

***** Faces
:PROPERTIES:
:CREATED:  [2022-09-11 Sun 16:55]
:END:

Caveat: There are some face definitions which use an extra large font since I am [[https://en.wikipedia.org/wiki/Visual_impairment][visually impaired]].

#+begin_src emacs-lisp
(defvar my/default-pixel-width 2560 "Default display width in pixel.")
(defmacro my/normalized-font-size (original-size)
  "This macro culculates normalized font size for display resolution at runtime.
It tries to proportionate ORIGINAL-SIZE in `my/default-pixel-width' in the display at runtime."
  `(truncate (* ,original-size (/ (float (x-display-pixel-width))
                                  ,my/default-pixel-width))))

(set-face-attribute 'default
                    nil
                    :font "fontset-default"
                    :height (my/normalized-font-size 630))
(set-face-attribute 'fixed-pitch
                    nil
                    :font "fontset-default")
(set-face-attribute 'variable-pitch
                    nil
                    :font "fontset-exmincho")

(use-package face
  :no-require t
  :hook
  ((eww-mode mastodon-mode nov-mode mu4e-view-mode elfeed-show-mode)
   . (lambda ()
       (buffer-face-set
        (or (ignore-errors (check-face 'my/reading-face))
            (defface my/reading-face `((t . (:font "fontset-exgothic"
                                                   :height ,(my/normalized-font-size 850))))
              "My customized face offers great legibility for reading articles.")))))
  ((Info-mode help-mode helpful-mode woman-mode)
   . (lambda ()
       (buffer-face-set
        (or (ignore-errors (check-face 'my/document-face))
            (defface my/document-face `((t . (:font "fontset-default"
                                                    :height ,(my/normalized-font-size 720))))
              "My customized face offers large fixed fonts for documentations.")))))
  ((org-mode text-mode mu4e-compose-mode)
   . (lambda ()
       (buffer-face-set
        (or (ignore-errors (check-face 'my/writing-face))
            (defface my/writing-face `((t . (:font "fontset-default"
                                                   :height ,(my/normalized-font-size 655))))
              "My customized face offers relatively small fixed fonts for writing.")))))
  ((prog-mode shell-mode term-mode vterm-mode eshell-mode calendar-mode)
   . (lambda ()
       (buffer-face-set
        (or (ignore-errors (check-face 'my/code-face))
            (defface my/code-face `((t . (:font "fontset-code"
                                                :height ,(my/normalized-font-size 580))))
              "My customized face offers condensed fonts for programming code.")))))
  ((dired-mode mu4e-headers-mode elfeed-search-update)
   . (lambda ()
       (buffer-face-set
        (or (ignore-errors (check-face 'my/list-face))
            (defface my/list-face `((t . (:font "fontset-mincho"
                                                :height ,(my/normalized-font-size 670))))
              "My customized face offers variable pitch fonts for displaying lists."))))))
#+end_src

***** Performance Tuning
:PROPERTIES:
:CREATED:  [2022-09-16 Fri 12:08]
:END:

#+begin_src emacs-lisp
(setq auto-window-vscroll nil)
(setq-default bidi-display-reordering nil)
(setq bidi-inhibit-bpa t)
#+end_src

**** Custom Variables
:PROPERTIES:
:ID:       587bc395-6321-4f59-97e6-6f0b62518b20
:END:

Entries in this section represnets [[info:emacs#Customization Groups][Customization Groups]] hierarchy.

***** Files
:PROPERTIES:
:ID:       1a73e0cf-f851-4f48-9a22-1ec37fdcf960
:END:

#+begin_src emacs-lisp
(customize-set-variable 'create-lockfiles nil)
(customize-set-variable 'remote-file-name-inhibit-locks t)
#+end_src

****** Auto Revert

[[info:emacs#Auto Revert][Auto Revert]]: Keeping buffers automatically up-to-date.

#+begin_src emacs-lisp
(use-package autorevert
  :diminish (global-auto-revert-mode auto-revert-mode)
  :custom
  (auto-revert-verbose nil)
  (global-auto-revert-non-file-buffers t)
  (auto-revert-interval 3)
  (auto-revert-check-vc-info t)
  (global-auto-revert-mode t))
#+end_src

****** Auto Save

[[info:emacs#Auto Save][Auto Save mode]] saves the file you are editing periodically, whereas [[help:auto-save-visited-mode][auto-save-visited-mode]] saves all  open buffers in Emacs session.

#+name: emacs-auto-save-dir
#+begin_src elisp :noweb yes :eval no-export
(let ((auto-save-dir (file-name-as-directory (expand-file-name "emacs/auto-save" "<<share-dir()>>"))))
  (unless (file-directory-p auto-save-dir)
    (make-directory auto-save-dir))
  auto-save-dir)
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<emacs-auto-save-dir()>> 0775 - - 2w
#+end_src

#+begin_src emacs-lisp :noweb tangle
(setopt auto-save-default t)
(setopt auto-save-interval 200)
(setopt auto-save-timeout 25)
(setopt auto-save-file-name-transforms
        '((".*" "<<emacs-auto-save-dir()>>" t)))
(setopt delete-auto-save-files t)
(setopt kill-buffer-delete-auto-save-files t)

(setopt auto-save-visited-mode t)
(setopt auto-save-visited-interval 10)
(put 'auto-save-visited-mode 'disabled nil)

(setopt delete-by-moving-to-trash t)
(setopt save-some-buffers-default-predicate 'save-some-buffers-root)
#+end_src

****** Uniquify

[[info:emacs#Uniquify][Uniquify]] shows buffer name easy to distinguish.

#+begin_src emacs-lisp
(use-package uniquify
  :custom
  (uniquify-buffer-name-style 'post-forward))
#+end_src

****** Recentf

[[info:emacs#File Conveniences][emacs#File Conveniences]]

#+begin_src emacs-lisp
(use-package recentf
  :defer 5
  :custom
  (recentf-exclude '(".gz" ".xz" ".zip" ".gpg"))
  (recentf-max-saved-items 200)
  (recentf-max-menu-items 15)
  (recentf-auto-cleanup "1:23am")
  :config
  (recentf-mode 1))
#+end_src

****** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer t
  :custom
  (tramp-default-method "ssh")
  :config
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  (add-to-list 'tramp-remote-path "~/bin"))
#+end_src

****** Find File

#+begin_src emacs-lisp
(setopt large-file-warning-threshold 30000000)
(setopt revert-buffer-quick-short-answers t)
#+end_src

****** Backup
:PROPERTIES:
:CREATED:  [2023-10-13 Fri 09:53]
:END:

I no longer use backup functionality. Even if I reinstate it, backing up by copying must be rational.

#+begin_src emacs-lisp
(setopt make-backup-files nil)
(setopt backup-by-copying t)
#+end_src

***** Environment

****** Initialization
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:24]
:END:

#+begin_src emacs-lisp
(setopt initial-scratch-message "")
(setopt inhibit-startup-screen t)
#+end_src

****** Frames

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

******* Fringe
:PROPERTIES:
:CREATED:  [2023-09-15 Fri 08:53]
:END:

#+begin_src emacs-lisp
(set-fringe-mode 15)
(setq-default indicate-buffer-boundaries 'left)
#+end_src

******* Two Column
:PROPERTIES:
:CREATED:  [2023-09-07 Thu 10:45]
:END:

#+begin_src emacs-lisp
(use-package two-column
  :commands (2C-two-columns 2C-split 2C-associate-buffer)
  :custom
  (2C-window-width 25))
#+end_src

******* Desktop
:PROPERTIES:
:CREATED:  [2022-12-20 Tue 16:06]
:END:

[[info:emacs#Saving Emacs Sessions][Info manual for Saving Emacs Sessions]] describes how to set up desktop-save-mode.
'--no-desktop' option for emacs command will disable forcibly desktop-save-mode .

#+begin_src emacs-lisp
(use-package desktop
  :commands (desktop-save)
  :custom
  (desktop-restore-frames t)
  (desktop-restore-eager 1)
  (desktop-lazy-idle-delay 5)
  :config
  (desktop-change-dir (expand-file-name "desktop" user-emacs-directory))
  (desktop-save-mode 1))
#+end_src

******* Cursor

#+begin_src emacs-lisp
(customize-set-variable 'blink-cursor-blinks 15)
(customize-set-variable 'blink-cursor-delay 0.7)
(customize-set-variable 'blink-cursor-interval 0.35)
(customize-set-variable 'blink-cursor-mode t)
#+end_src

******* Scrolling
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 00:14]
:END:

#+begin_src emacs-lisp
(customize-set-variable 'fast-but-imprecise-scrolling t)
#+end_src

****** Display

#+begin_src emacs-lisp
;; do not use visual bell
(setopt visible-bell nil)

(customize-set-variable 'text-scale-mode-step 1.0625)
(customize-set-variable 'highlight-nonselected-windows t)
(customize-set-variable 'truncate-lines t)
(customize-set-variable 'x-underline-at-descent-line nil)
;; avoid to break at whitespace in Japanese
(customize-set-variable 'word-wrap-by-category t)
;; suppress curved quotes in docstring (for emacs25)
(customize-set-variable 'text-quoting-style 'straight)
;; resize frame size responding to font size
(setopt global-text-scale-adjust-resizes-frames t)
#+end_src

****** Windows

[[https://www.masteringemacs.org/article/demystifying-emacs-window-manager?utm_source=newsletter&utm_medium=email&utm_campaign=rss][This blog post]] is must-read when you tweak display-buffer facilities or something related to display settings.

#+begin_src emacs-lisp
(customize-set-variable 'scroll-step 1)
(customize-set-variable 'scroll-conservatively 101)
(customize-set-variable 'next-screen-context-lines 2)
(customize-set-variable 'scroll-preserve-screen-position t)
;; display buffer
(customize-set-variable 'display-buffer-base-action
                        '((display-buffer-same-window
                           display-buffer-reuse-window
                           display-buffer-reuse-mode-window
                           display-buffer-in-previous-window)))

(bind-keys :map other-window-repeat-map
           ("0" . delete-window)
           ("1" . delete-other-windows))
#+end_src

******* Winner

Triple Escape (M-ESC ESC) has got to reset window layout by tweaking buffer-quit-function.

#+begin_src emacs-lisp
(use-package winner
  :bind (("C-z" . winner-undo)
         ("C-M-z" . winner-redo))
  :custom
  (winner-mode t)
  :config
  (setq buffer-quit-function 'winner-undo))
#+end_src

******* Windmove

You can now switch windows with your shift key by pressing S-<left>, S-<right>, S-<up>, S-<down>.

#+begin_src emacs-lisp
(use-package windmove
  :custom
  (windmove-mode t)
  (windmove-wrap-around t)
  :config
  (windmove-default-keybindings '(control shift)))
#+end_src

****** Minibuffer

#+begin_src emacs-lisp
(define-key minibuffer-mode-map
            (kbd "C-h") #'delete-backward-char)
(define-key minibuffer-mode-map
            (kbd "M-h") #'backward-kill-word)
(keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete)

(customize-set-variable 'history-length 300)
(customize-set-variable 'history-delete-duplicates t)
(customize-set-variable 'enable-recursive-minibuffers t)
(customize-set-variable 'minibuffer-depth-indicate-mode t)
(customize-set-variable 'read-file-name-completion-ignore-case t)
(customize-set-variable 'read-minibuffer-restore-windows t)
(customize-set-variable 'minibuffer-default-prompt-format " [%s]")
(customize-set-variable 'completion-cycle-threshold 1)
(customize-set-variable 'completions-detailed t)

(add-hook 'minibuffer-setup-hook 'my/minibuffer-setup-function)
(defun my/minibuffer-setup-function ()
  ;; disable input method in mini buffer
  (when current-input-method
    (deactivate-input-method))
  ;; decrease font size to 90% in minibuffer
  (setq-local face-remapping-alist '((default :height 0.9))))
#+end_src

******* Savehist

[[help:savehist-mode][savehist-mode]] saves minibuffer history and additionals.

#+begin_src emacs-lisp
(use-package savehist
  :defer 1
  :custom
  (savehist-save-minibuffer-history t)
  (savehist-additional-variables '((kill-ring . 1000)
                                   (register-alist . 200)))
  (savehist-autosave-interval 90)
  :config
  (savehist-mode 1))
#+end_src

****** Menu

[[https://christiantietze.de/posts/2022/12/use-file-open-dialog-for-file-actions/][This blog post]] demonstrates for emacsers who have disabled file pickers and dialog boxes to adversely use them temporalily.

#+begin_src emacs-lisp
(setopt use-short-answers t)
(setopt use-file-dialog nil)
#+end_src

****** Mode Line

#+begin_src emacs-lisp
(defvar my/mode-line-buffer-name-length-max 15
  "Fixed length for displaying buffer name in mode line.")

(customize-set-variable 'line-number-mode nil)
(customize-set-variable 'column-number-mode nil)
(customize-set-variable 'mode-line-compact t)
(customize-set-variable
 'mode-line-format
 '("%e"
   mode-line-front-space
   (:eval
    (let ((mode-line-buffer-name
           (replace-regexp-in-string " %\\([[:ascii:]]\\)" " %%\\1"
                                     (truncate-string-to-width
                                      (buffer-name) my/mode-line-buffer-name-length-max nil ? t))))
      (cond
       (buffer-read-only
        (propertize mode-line-buffer-name 'face 'underline))
       ((buffer-modified-p)
        (propertize mode-line-buffer-name 'face 'warning))
       (mode-line-buffer-name))))
   (:eval
    (cond
     ((and line-number-mode
           column-number-mode)
      mode-line-position-column-line-format)
     (line-number-mode mode-line-position-line-format)
     (column-number-mode mode-line-position-column-format)))
   " "
   global-mode-string))
#+end_src

******* Display Time

#+begin_src emacs-lisp
(customize-set-variable
 'display-time-string-forms
 '((propertize (format-time-string "%H:%M" now) 'face 'mode-line-highlight)))
(customize-set-variable 'display-time-mode t)
#+end_src

****** Mouse

Mouse needs to be unobtrusive in my Emacs experience.

#+begin_src emacs-lisp
(use-package mouse
  :custom
  (mouse-1-click-follows-link nil)
  (mouse-highlight nil)
  (mouse-wheel-mode nil))

(use-package pixel-scroll
  :custom
  (pixel-scroll-precision-mode t))
#+end_src

******* Tool Tips
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:14]
:END:

#+begin_src emacs-lisp
(tooltip-mode -1)
(setq x-gtk-use-system-tooltips nil)
#+end_src

****** Hardware
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:00]
:END:

******* Battery
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:01]
:END:

#+begin_src emacs-lisp
(use-package battery
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("b" . battery)))
#+end_src

***** Convenience

subword-mode enables to recognize 'RSS' and 'Feed' are separate words in 'RSSFeed'

#+begin_src emacs-lisp
(repeat-mode 1)
(global-subword-mode 1)
#+end_src

****** Abbreviations

#+begin_src emacs-lisp
(use-package abbrev
  :diminish abbrev-mode
  :custom
  (save-abbrevs t)
  :config
  (setq-default abbrev-mode t)
  (setf abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory))
  (quietly-read-abbrev-file))
#+end_src

****** Hippie Expand

[[https://www.masteringemacs.org/article/text-expansion-hippie-expand][As this blog post mentions]], Hippie Expansion is superior to dabbrev, skeleton and company in the field of auto typing.

#+begin_src emacs-lisp
(use-package hippie-exp
  :bind ([remap dabbrev-expand] . hippie-expand))
#+end_src

****** Hl Line

#+begin_src emacs-lisp
(use-package hl-line
  :hook (vterm-mode . (lambda () (hl-line-mode -1)))
  :config
  (hl-line-mode 1))
#+end_src

****** Visual Line

#+begin_src emacs-lisp
(use-package visual-line
  :no-require t
  :after adaptive-wrap
  :hook
  ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode mu4e-view-mode nov-mode twittering-mode)
   . visual-line-mode)
  ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode mu4e-view-mode nov-mode twittering-mode)
   . adaptive-wrap-prefix-mode)
  :custom
  (global-visual-line-mode nil))
#+end_src

****** Whitespace

[[info:emacs#Useless Whitespace][emacs#Useless Whitespace]]

#+begin_src emacs-lisp
(use-package whitespace
  :diminish ((global-whitespace-mode . "Ws")
             (whitespace-mode . "ws"))
  :hook
  ((org-mode prog-mode dired-mode) . whitespace-mode)
  (eww-mode . whitespace-turn-off)
  (before-save . delete-trailing-whitespace)
  :custom
  (whitespace-style
   '(face trailing tabs tab-mark spaces space-mark empty missing-newline-at-eof))
  (whitespace-action '(cleanup auto-cleanup))
  (whitespace-space-regexp "\\(\x3000+\\)")
  (whitespace-trailing-regexp "\\([ \t\u00A0]+\\)$")
  (whitespace-display-mappings
   '((space-mark ?\x3000 [?\u2423])
     (tab-mark   ?\t   [?\u00BB ?\t])))
  (global-whitespace-mode nil))
#+end_src

****** So Long
:PROPERTIES:
:ID:       9b051905-c21b-492b-ba0b-4468f53cb975
:END:

#+begin_src emacs-lisp
(customize-set-variable 'global-so-long-mode t)
#+end_src

****** Tab Bar

#+begin_src emacs-lisp
(use-package tab-bar
  :disabled t
  :bind (:map ctl-x-map
              ("t" . tab-prefix-map)
              :map tab-bar-map
              ("M-[" . tab-bar-history-back)
              ("M-]" . tab-bar-history-forward))
  :custom
  (tab-bar-mode t)
  (tab-bar-show 2)
  (tab-bar-history-mode t)
  (tab-bar-tab-hints t))
#+end_src

****** Ffap

#+begin_src emacs-lisp
(require 'ffap)

(ffap-bindings)
#+end_src

****** Kmacro

The power of keyboard macro is more than repeating editing commands. [[https://masteringemacs.org/article/keyboard-macros-are-misunderstood][This post explains fluently]].

#+begin_src emacs-lisp
(require 'kmacro)

(defalias 'kmacro-insert-macro 'insert-kbd-macro)
(define-key kmacro-keymap (kbd "I") #'kmacro-insert-macro)
#+end_src

***** Editing

#+begin_src emacs-lisp
;; the point will be at the beginning of duplicated lines
(setopt duplicate-line-final-position 1)
#+end_src

****** Indent

See also [[id:4a58219c-74dd-4135-b56d-876b0db2cd83][aggressive-indent-mode]]

#+begin_src emacs-lisp
(customize-set-variable 'tab-always-indent 'complete)
(customize-set-variable 'indent-tabs-mode nil)
(customize-set-variable 'tab-first-completion 'word-or-paren-or-punct)
#+end_src

****** Electricity

#+begin_src emacs-lisp
(setopt electric-indent-mode nil)
#+end_src

****** Fill

#+begin_src emacs-lisp
(customize-set-variable 'fill-column 80)
(customize-set-variable 'sentence-end-double-space nil)
#+end_src

****** Killing

#+begin_src emacs-lisp
(setopt yank-pop-change-selection t)
(setopt delete-active-region 'kill)
(setopt kill-do-not-save-duplicates nil)
(setopt kill-whole-line nil)
#+end_src

****** Undo

The older undo step which exceeds [[help:undo-limit][undo-limit]] in byte is eliminated at garbage collection.
The oldest undo step, if undo info exceeds [[help:undo-strong-limit][undo-strong-limit]] in total, is removed instantaneously.
No more new undo step than [[help:undo-outer-limit][undo-outer-limit]] could not be registered.

#+begin_src emacs-lisp
(customize-set-variable 'undo-limit 320000)
(customize-set-variable 'undo-strong-limit 480000)
(customize-set-variable 'undo-outer-limit 48000000)
(customize-set-variable 'undo-no-redo t)
#+end_src

****** Matching
******* Isearch

#+begin_src emacs-lisp
(use-package isearch
  :custom
  (isearch-allow-motion t)
  (isearch-lazy-count t)
  (isearch-lax-whitespace t)
  (isearch-regexp-lax-whitespace t)
  (search-whitespace-regexp ".*")
  :config
  (bind-keys :map isearch-mode-map
             ("C-j" . isearch-exit)))
#+end_src

******* Bookmark

#+begin_src emacs-lisp
(use-package bookmark
  :bind ("C-x 5 B" . bookmark-jump-other-frame)
  :custom
  (bookmark-save-flag 1)
  (bookmark-menu-confirm-deletion t)
  (bookmark-watch-bookmark-file 'silent))
#+end_src

****** Paragraph
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 00:23]
:END:

#+begin_src emacs-lisp
(customize-set-variable 'bidi-paragraph-direction 'left-to-right)
#+end_src

***** Multimedia

****** Image

[[https://xenodium.com/emacs-viewing-webp-images/][This post]] teaches me how to enable converting external formats (i.e. webp) to internal ones.

#+begin_src emacs-lisp
(use-package image
  :custom
  (image-use-external-converter t))
#+end_src

***** Programming
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

****** Tools
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

******* Xref
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

#+begin_src emacs-lisp
(use-package xref
  :custom
  (xref-show-definitions-function 'xref-show-definitions-completing-read))
#+end_src

******* Ediff
:PROPERTIES:
:CREATED:  [2023-11-19 Sun 06:17]
:END:

******** Ediff Window
:PROPERTIES:
:CREATED:  [2023-11-19 Sun 06:17]
:END:

#+begin_src emacs-lisp
(use-package ediff
  :commands ediff-files
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally))
#+end_src

***** Development

****** Internal
******* Storage Allocation

#+begin_src emacs-lisp
(customize-set-variable 'gc-cons-threshold (* 10 gc-cons-threshold))
#+end_src

****** Lisp
******* Shortdoc

#+begin_src emacs-lisp
(use-package shortdoc
  :bind ("<help> D" . shortdoc-display-group))
#+end_src

******* Re Builder

#+begin_src emacs-lisp
(use-package re-builder
  :custom
  (reb-re-syntax 'string))
#+end_src

******* Comp

For [[info:elisp#Native Compilation][native compilation feature]] introduced at Emacs 28.1.

#+begin_src emacs-lisp
(use-package comp
  :custom
  (native-comp-async-report-warnings-errors 'silent)
  (native-comp-async-query-on-exit t)
  (native-comp-verbose 1))
#+end_src

******* Eldoc

#+begin_src emacs-lisp
(use-package eldoc
  :preface
  (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
  :custom
  (eldoc-echo-area-prefer-doc-buffer 'maybe)
  :config
  (eldoc-add-command-completions "paredit-"))
#+end_src

****** Debug

#+begin_src emacs-lisp
(customize-set-variable 'message-log-max 10000)
#+end_src

***** Help
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 23:04]
:END:

#+begin_src emacs-lisp
(setopt help-enable-variable-value-editing t)
#+end_src

***** Data

****** Save Place

File-related tweaks including [[info:emacs#Customize Save][Customizing Saving of Files]].

#+begin_src emacs-lisp
(require 'saveplace)

(customize-set-variable 'save-place-abbreviate-file-names t)
(customize-set-variable 'save-place-version-control t)
(customize-set-variable 'save-place-mode t)
#+end_src

****** Compression

- Jka Compr (auto compression mode)
  #+begin_src emacs-lisp
  (customize-set-variable 'auto-compression-mode t)
  #+end_src

****** Tar

#+begin_src emacs-lisp
(require 'tar-mode)
#+end_src

****** Archive

#+begin_src emacs-lisp
(require 'archive-mode)
#+end_src

***** Editing Basics

#+begin_src emacs-lisp
(customize-set-variable 'set-mark-command-repeat-pop t)
(customize-set-variable 'mark-ring-max 32)
(customize-set-variable 'next-line-add-newlines nil)
(customize-set-variable 'cycle-spacing-actions
                        '(delete-all-space just-one-space restore))
;; delsel
;;; delete rather than insert the text in region if hit single char
(customize-set-variable 'delete-selection-mode t)
;; files
(customize-set-variable 'mode-require-final-newline 'visit-save)
(customize-set-variable 'delete-auto-save-files t)
(customize-set-variable 'enable-remote-dir-locals t)
#+end_src

***** External

****** EasyPG

#+begin_src emacs-lisp
(use-package epg
  :defer t
  :custom
  (epg-pinentry-mode 'loopback))
#+end_src

******* Epa (EasyPG Assistant)
:PROPERTIES:
:CREATED:  [2023-01-01 Sun 15:03]
:END:

[[info:epa#Top][EasyPG Assistant (epa)]] enables users to manage their GnuPG keys and exert encryption/sign with them.

#+begin_src emacs-lisp :noweb tangle
(use-package epa
  :bind (("C-x : l" . epa-list-keys)
         ("C-x : L" . epa-list-secret-keys)
         :map dired-mode-map
         (": E" . my/epa-dired-do-encrypt-armor))
  :preface
  (defun my/epa-dired-do-encrypt-armor ()
    "Encrypt mark files in ASCII armored format."
    (interactive)
    (let ((epa-armor t))
      (epa-dired-do-encrypt)))
  :config
  (setq epa-file-encrypt-to "<<email>>"))
#+end_src

****** Server

#+begin_src emacs-lisp
(use-package server
  :preface
  (defun my/server-start ()
    "Start Emacs server only if not running."
    (unless (server-running-p)
      (server-start)))
  :hook (after-init . my/server-start)
  :custom
  (server-client-instructions t))
#+end_src

****** Processes
******* Proced

[[https://www.masteringemacs.org/article/displaying-interacting-processes-proced][This blog post]] explains how to use proced, process monitoring package for emacs.

#+begin_src emacs-lisp
(use-package proced
  :commands proced
  :custom
  (proced-auto-update-flag t)
  (proced-auto-update-interval 3)
  (proced-show-remote-processes t)
  (proced-show-remote-processes t))
#+end_src

****** Browse Url

#+begin_src emacs-lisp
(use-package browse-url
  :init
  (global-set-key (kbd "C-c C-o") #'browse-url-at-point)
  :custom
  (browse-url-new-window-flag t)
  (browse-url-secondary-browser-function 'browse-url-firefox))
#+end_src

******* Webjump
:PROPERTIES:
:CREATED:  [2023-10-10 Tue 19:01]
:END:

#+begin_src emacs-lisp
(use-package webjump
  :commands webjump
  :custom
  (webjump-use-internal-browser t))
#+end_src

****** locate

#+begin_src emacs-lisp :noweb yes
(use-package locate
  :commands locate
  :custom
  (locate-command "plocate")
  (locate-make-command-line #'my/plocate-make-command-line)
  (locate-fcodes-file "<<plocate-db()>>")
  (locate-update-path (expand-file-name "~/")))

(defun my/plocate-make-command-line (search-string)
  (list locate-command "-d" "<<plocate-db()>>" "--ignore-case" "--existing" "--regexp" search-string))
#+end_src

***** Applications

****** Mail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:54]
:END:

******* Smtpmail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:54]
:END:

#+begin_src emacs-lisp :noweb tangle
(use-package smtpmail
  :after mu4e
  :init
  (setq smtpmail-default-smtp-server "<<smtp-host>>")
  :custom
  (smtpmail-smtp-service 465)
  (smtpmail-smtp-user user-mail-address)
  (smtpmail-stream-type 'ssl)
  (smtpmail-mail-address user-mail-address))
#+end_src

******* Message
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:23]
:END:

******** Message Mail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:24]
:END:

#+begin_src emacs-lisp
(use-package message
  :after (dired mu4e)
  :custom
  (message-send-mail-function 'smtpmail-send-it))
#+end_src

******* Mime Security
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:50]
:END:

#+begin_src emacs-lisp
(use-package mm-encode
  :after mu4e
  :custom
  (mm-sign-option nil))

(use-package mml-sec
  :after (mu4e dired)
  :custom
  (mml-secure-openpgp-sign-with-sender t)
  (mml-default-sign-method 'pgpmime))
#+end_src

****** Ispell/FlySpell
:PROPERTIES:
:CREATED:  [2023-10-07 Sat 10:40]
:END:

#+begin_src emacs-lisp
(use-package ispell
  :if (executable-find "aspell")
  :custom
  (ispell-program-name "aspell")
  :config
  ;; avoid checking for Japanese characters
  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
  (setq-default ispell-extra-args '("--sug-mode=ultra"
                                    "--lang=en_US"))
  (let ((arg "--camel-case"))
    (and (string-match-p arg
                         (shell-command-to-string (concat ispell-program-name " --help")))
         (push arg ispell-extra-args))))

(use-package flyspell
  :after ispell
  :hook ((text-mode . (lambda ()
                        (unless (derived-mode-p 'org-mode)
                          (flyspell-mode 1))))
         (prog-mode . flyspell-prog-mode))
  :preface (setq flyspell-mode-map nil)
  :bind (:map flyspell-mode-map
              :prefix "C-$"
              :prefix-map my/flyspell-mode-map
              :prefix-docstring "Keymap for Flyspell"
              ("n" . flyspell-goto-next-error)
              ("C-$" . flyspell-auto-correct-word)
              ("C-" . flyspell-auto-correct-previous-word)
              ("$" . flyspell-correct-word-before-point))
  :custom
  (flyspell-issue-message-flag nil))
#+end_src

****** News

******* Gnus

******** Auth Source

#+begin_src emacs-lisp
(use-package auth-source
  :custom
  (auth-source-gpg-encrypt-to `(,user-mail-address))
  :config
  (add-to-list 'auth-sources "~/.netrc.gpg"))

(use-package auth-source-pass
  :config
  (auth-source-pass-enable))
#+end_src

****** Calc (The GNU Emacs Calculator)

#+begin_src emacs-lisp
(use-package calc
  :bind ("<f7>" . calc)
  :config
  (setf calc-display-trail nil))
#+end_src
****** Calendar
[[https://github.com/emacs-jp/japanese-holidays/releases.atom][japanese-holidays]]

#+begin_src emacs-lisp
(use-package calendar
  :commands calendar
  :ensure japanese-holidays
  :hook
  ((calendar-today-visible calendar-today-invisible) . japanese-holiday-mark-weekend)
  (calendar-today-visible . calendar-mark-today)
  (calendar-move . my/japanese-holiday-show)
  :custom
  (calendar-left-margin 0)
  (calendar-right-margin 0)
  (calendar-intermonth-spacing 1)
  (calendar-mark-holidays-flag t)
  (japanese-holiday-weekend '(0 6))
  (japanese-holiday-weekend-marker
   '(holiday nil nil nil nil nil japanese-holiday-saturday))
  :config
  (require 'japanese-holidays)
  ;; add 'holiday-general-holidays to calendar-holidays
  ;; if you want holidays in the U.S. to be counted as your holidays.
  (setf calendar-holidays
        (append japanese-holidays holiday-local-holidays holiday-other-holidays))
  (bind-keys :map calendar-mode-map
             ("v" . my/calendar-show-items)))

(defun my/japanese-holiday-show (&rest _args)
  "Show holiday information in mini buffer if date on which the cursor is any holidays."
  (let* ((date (calendar-cursor-to-date t))
         (calendar-date-display-form '((format "%s年 %s月 %s日（%s）" year month day dayname)))
         (date-string (calendar-date-string date))
         (holiday-list (calendar-check-holidays date)))
    (when holiday-list
      (message "%s: %s" date-string (mapconcat #'identity holiday-list "; ")))))
#+end_src

******* Midnight
:PROPERTIES:
:CREATED:  [2023-06-08 Thu 18:20]
:END:

#+begin_src emacs-lisp :noweb tangle
(use-package midnight
  :defer t
  :custom
  (midnight-mode t)
  (midnight-delay "<<midnight-hour>>:00"))
#+end_src

****** Package

#+begin_src emacs-lisp
(use-package package
  :custom
  (package-native-compile t)
  (package-install-upgrade-built-in t)
  (package-quickstart t)
  (package-quickstart-file
   (expand-file-name "package-quickstart.el"
                     user-emacs-directory-default))
  :config
  (with-eval-after-load 'my-launch-app
    (keymap-set my/invoke-list-command-map (kbd "p")
                #'list-packages)))
#+end_src

****** Eglot
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:32]
:END:

[[https://github.com/joaotavora/eglot][Eglot]]

#+begin_src emacs-lisp
(use-package eglot
  :hook ((sh-mode ruby-mode python-mode graphviz-dot-mode) . eglot-ensure)
  :custom
  (eglot-extend-to-xref t))
#+end_src

***** Text

****** View

#+begin_src emacs-lisp
(use-package view
  :diminish view-mode "vw")
#+end_src

***** Hypermedia
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 16:59]
:END:
****** Dictionary
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 17:01]
:END:

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
dictd dict \
      dict-gcide dict-wn \
      dict-jargon dict-foldoc dict-vera \
      dict-freedict-eng-jpn dict-freedict-jpn-eng
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
sudo systemctl start dictd
#+end_src

#+begin_src emacs-lisp
(customize-set-variable 'dictionary-use-single-buffer t)
(customize-set-variable 'dictionary-server nil)

(with-eval-after-load 'dictionary
  (setq switch-to-buffer-obey-display-actions t)
  (add-to-list 'display-buffer-alist
               '("^\\*Dictionary\\*"
                 display-buffer-in-tab))
  (add-hook 'dictionary-mode-hook
            #'my/lazy-view-enter))
#+end_src

***** Communication
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 12:58]
:END:

****** Net Utils
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 12:58]
:END:

#+begin_src emacs-lisp
(use-package net-utils
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("n d" . run-dig)
              ("n i" . ifconfig)
              ("n w" . iwconfig)
              ("n p" . ping)))
#+end_src

**** Input Methods

***** ddskk

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ddskk"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/skk-dev/ddskk/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(defvar skk-dir (expand-file-name "skk" my/user-share-directory))
(defvar skk-dotemacs-dir (expand-file-name "ddskk" user-emacs-directory-default))

(use-package skk
  :defer t
  :init
  (customize-set-variable 'default-input-method "japanese-skk")
  (defface skk-candidate `((t . (:font "fontset-default"
                                       :height ,(my/normalized-font-size 860))))
    "Default face for ddskk candidates."
    :group 'skk-dcomp)
  (setq skk-get-jisyo-directory "<<skk-jisyo-path()>>")
  :custom
  (skk-user-directory (expand-file-name "ddskk" user-emacs-directory))
  (skk-init-file (expand-file-name "skk-init.el" skk-dotemacs-dir))
  (skk-byte-compile-init-file t)
  ;; cursor color
  (skk-use-color-cursor t)
  (skk-cursor-hiragana-color "orange")
  (skk-cursor-katakana-color "OrangeRed3")
  (skk-cursor-latin-color "DodgerBlue3")
  (skk-cursor-jisx0201-color "purple3")
  ;; mode line string
  (skk-latin-mode-string "A")
  (skk-hiragana-mode-string "あ")
  (skk-katakana-mode-string "ア")
  (skk-jisx0201-mode-string "ｱ")
  (skk-jisx0208-latin-mode-string "Ａ")
  ;; AZIK
  (skk-use-azik t)
  (skk-azik-keyboard-type 'us101)
  ;; conversion
  (skk-egg-like-newline t)
  (skk-henkan-strict-okuri-precedence t)
  (skk-check-okurigana-on-touroku t)
  ;; annotation
  (skk-show-annotation t)
  (skk-annotation-delay 0.3)
  ;; how candidates behave
  (skk-show-candidates-always-pop-to-buffer t)
  (skk-henkan-number-to-display-candidates 10)
  (skk-show-candidates-nth-henkan-char 3)
  (skk-henkan-show-candidates-keys
   '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0))
  ;; set face for candidates list
  (skk-treat-candidate-appearance-function
   (lambda (candidate listing-p)
     (cond
      ((string-match ";" candidate)
       (put-text-property 0 (match-beginning 0)
                          'face 'skk-candidate
                          candidate)
       (put-text-property (match-beginning 0)
                          (length candidate) 'face 'shadow candidate))
      (t
       (put-text-property 0 (length candidate)
                          'face 'skk-candidate
                          candidate)))
     candidate))
  ;; bind C-q for hankaku-kana input mode
  (skk-use-jisx0201-input-method t)
  ;; dynamic conversion
  (skk-dcomp-activate nil)
  (skk-dcomp-multiple-activate nil)
  ;; config file
  (skk-record-file (expand-file-name "record" skk-dir))
  (skk-emacs-id-file (expand-file-name "emacs-id" skk-dir))
  ;; jisyo
  (skk-share-private-jisyo t)
  (skk-compare-jisyo-size-when-saving t)
  (skk-save-jisyo-instantly t)
  ;; jisyo file/directory
  (skk-jisyo `(,(expand-file-name "jisyo" skk-dotemacs-dir) . utf-8))
  (skk-backup-jisyo (expand-file-name "jisyo.bak" skk-dir))
  (skk-large-jisyo (expand-file-name "SKK-JISYO.L" skk-get-jisyo-directory))
  (skk-itaiji-jisyo (expand-file-name "SKK-JISYO.itaiji" skk-get-jisyo-directory))
  (skk-extra-jisyo-file-list
   (seq-remove (lambda (dic)
                 (seq-some (lambda (suffix)
                             (string-suffix-p (symbol-name suffix) dic))
                           '(L itaiji tar)))
               (append (file-expand-wildcards (expand-file-name "SKK-JISYO.*" skk-get-jisyo-directory))
                       (file-expand-wildcards (expand-file-name "open-jisyo/SKK-JISYO.*" skk-dir)))))
  ;; jisyo server
  ;; (skk-server-host "localhost")
  ;; (skk-server-portnum 1178)
  ;; (skk-server-inhibit-startup-server t)
  ;; study
  (skk-study-file (expand-file-name "study" skk-dir))
  (skk-study-backup-file (expand-file-name "study.bak" skk-dir))
  :config
  ;; ward off activating skk-auto-fill-mode inadvertently
  (bind-keys ("C-x j" . skk-mode)))
#+end_src

***** skk init file

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/ddskk/skk-init.el")
;; -*- mode:emacs-lisp; -*-
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("!" nil skk-purge-from-jisyo)
                ("xka" nil ("ヵ" . "ヵ"))
                ("xke" nil ("ヶ" . "ヶ"))
                ("n" nil nil)
                ("nn" nil ("ナノ" . "なの"))
                ("nm" nil ("ノミ" . "のみ"))
                ("ks" nil ("コソ" . "こそ"))
                ("kna" nil ("カナ" . "かな"))
                ("kno" nil ("コノ" . "この"))
                ("ym" nil ("ヤマ" . "やま"))
                ("yk" nil ("ユキ" . "ゆき"))
                ("tga" nil ("タガ" . "たが"))
                ("vj" nil ("ヴン" . "ぶん"))
                ("hm" nil ("ハマ" . "はま"))
                ;; followings are for preventing from changing to zenkaku eisu mode by pressing 'L'
                ("bL" nil ("ボン" . "ぼん"))
                ("byL" nil ("ビョン" . "びょん"))
                ("cL" nil ("チョン" . "ちょん"))
                ("dL" nil ("ドン" . "どん"))
                ("fL" nil ("フォン" . "ふぉん"))
                ("gL" nil ("ゴン" . "ごん"))
                ("gyL" nil ("ギョン" . "ぎょん"))
                ("hL" nil ("ホン" . "ほん"))
                ("hgL" nil ("ヒョン" . "ひょん"))
                ("hyL" nil ("ヒョン" . "ひょん"))
                ("jL" nil ("ジョン" . "じょん"))
                ("kL" nil ("コン" . "こん"))
                ("kgL" nil ("キョン" . "きょん"))
                ("kyL" nil ("キョン" . "きょん"))
                ("mL" nil ("モン" . "もん"))
                ("mgL" nil ("ミョン" . "みょん"))
                ("myL" nil ("ミョン" . "みょん"))
                ("nL" nil ("ノン" . "のん"))
                ("ngL" nil ("ニョン" . "にょん"))
                ("nyL" nil ("ニョン" . "にょん"))
                ("pL" nil ("ポン" . "ぽん"))
                ("pgL" nil ("ピョン" . "ぴょん"))
                ("pyL" nil ("ピョン" . "ぴょん"))
                ("rL" nil ("ロン" . "ろん"))
                ("ryL" nil ("リョン" . "りょん"))
                ("sL" nil ("ソン" . "そん"))
                ("syL" nil ("ション" . "しょん"))
                ("tL" nil ("トン" . "とん"))
                ("tyL" nil ("チョン" . "ちょん"))
                ("vL" nil ("ヴォン" . "う゛ぉん"))
                ("wL" nil ("ウォン" . "うぉん"))
                ("xL" nil ("ション" . "しょん"))
                ("xxL" nil ("→" . "→"))
                ("yL" nil ("ヨン" . "よん"))
                ("zL" nil ("ゾン" . "ぞん"))
                ("zyL" nil ("ジョン" . "じょん")))))

(add-hook 'skk-azik-load-hook
          (lambda ()
            (dolist (key '("kA" "kE" "tU" "wA"))
              (setq skk-rom-kana-rule-list
                    (skk-del-alist key skk-rom-kana-rule-list)))))
#+end_src

**** Dired

#+begin_src emacs-lisp
(use-package dired
  :bind (:map dired-mode-map
              ("C-j" . dired-find-file)
              ("^" . dired-up-directory)
              ("(" . dired-hide-details-mode)
              (")" . dired-hide-details-mode)
              ("E" . dired-create-empty-file)
              ("Y" . dired-do-relsymlink)
              ("e" . wdired-change-to-wdired-mode)
              ("RET" . dired-open-file)
              ("C-c C-o" . dired-open-file)
              ("C-c C-s" . my/dired-share))
  :hook (dired-mode . dired-hide-details-mode)
  :custom
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-do-revert-buffer t)
  (dired-auto-revert-buffer t)
  (dired-copy-dereference t)
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'top)
  (dired-listing-switches "-ahgG --time-style=long-iso --group-directories-first")
  (dired-dwim-target 'dired-dwim-target-next)
  (dired-hide-details-hide-information-lines nil)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-compress-file-default-suffix ".zst")
  (dired-compress-directory-default-suffix ".7z")
  (dired-isearch-filenames t)
  (dired-open-use-nohup t)
  (dired-open-query-before-exit nil)
  (completion-ignored-extensions nil)
  :config
  (with-eval-after-load 'open-file
    (setq dired-guess-shell-alist-user
          `((,(regexp-opt (append my/open-file-media-extensions
                                  my/open-file-compressed-media-extensions)
                          "\\.\\(")
             "mpv")
            (,(regexp-quote ".kdenlive") "kdenlive")
            (,(regexp-quote ".xcf") "gimp"))))
  (advice-add #'dired-do-delete :around #'my/advice-dired-control-deletion)
  (advice-add #'dired-do-flagged-delete :around #'my/advice-dired-control-deletion)
  (put 'dired-find-alternate-file 'disabled nil))

(use-package dired-x
  :after dired
  :custom
  ;; hide ., .. and all dotfiles starting with .
  (dired-omit-files (rx (seq string-start
                             (or "." ".."
                                 (seq "." (+? graph)))
                             string-end)))
  :config
  (bind-keys :map dired-mode-map
             ("." . dired-omit-mode)))

(use-package dired-aux
  :after dired
  :config
  (setq dired-compress-files-alist
        (append dired-compress-files-alist
                '(("\\.tar\\.7z\\'" . "tar cf - %i | 7z a -si %o")
                  ("\\.7z\\'" . "7z a %o %i"))))
  (add-to-list 'dired-compress-file-suffixes
               '("\\.tar\\.7z\\'" "" "7z x -so %i | tar xf -")))

(defun my/advice-dired-control-deletion (oldfun &rest r)
  "Enable file deleting functions to control deleting procedure
whether files are going to be in trash box."
  (let ((delete-by-moving-to-trash
         (if (equal current-prefix-arg '(4))
             nil t)))
    (apply oldfun (cdr r))))

(defun my/dired-share ()
  "Share file with remote device via KDE Connect."
  (interactive)
  (let ((files (dired-get-marked-files nil nil)))
    (mapc (lambda (file)
            (shell-command
             (mapconcat 'identity
                        (list "kdeconnect-cli" "-d" "a30587ededf4c2d2"
                              "--share" (shell-quote-argument
                                         file)) " ")))
          files)))
#+end_src
***** dired-rsync

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dired-rsync"
#+end_src

#+begin_src emacs-lisp
(use-package dired-rsync
  :after dired
  :bind (:map dired-mode-map
              ("C-c C-r" . dired-rsync))
  :custom
  (dired-rsync-options "-auz --info=progress2"))
#+end_src

***** dired-single                          :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/crocket/dired-single/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package dired-single
  :disabled t
  :after dired
  :bind (:map dired-mode-map
              ("C-j" . dired-single-buffer)
              ("^" . dired-single-up-directory)))
#+end_src

***** dired-hacks

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dired-hacks"
#+end_src

#+begin_src emacs-lisp
(require 'dired-open)

(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("TAB" . dired-subtree-cycle)))

(use-package dired-narrow
  :after dired
  :bind
  (:map dired-mode-map
        ("z" . dired-narrow))
  (:map dired-narrow-map
        ("C-j" . exit-minibuffer)))
#+end_src

***** dired-hide-dotfiles                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-05-24 Wed 21:44]
:END:

dired-omit-mode took over [[https://github.com/mattiasb/dired-hide-dotfiles#start-of-content][dired-hide-dotfiles]].

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/mattiasb/dired-hide-dotfiles/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("," . dired-clean-directory)
              ("." . dired-hide-dotfiles-mode))
  :config
  (dired-hide-dotfiles-mode -1))
#+end_src

***** find-dired

#+begin_src emacs-lisp
(use-package find-dired
  :bind (:prefix "M-s d"
                 :prefix-map my/find-dired-map
                 :prefix-docstring "Keymap for FInd Dired"
                 ("f" . find-dired)
                 ("F" . find-lisp-find-dired)
                 ("g" . find-grep-dired)
                 ("n" . find-name-dired)
                 ("d" . find-lisp-find-dired-subdirectories)
                 ("!" . find-dired-with-command))
  :custom
  (find-grep-options "-n -H --no-heading -q")
  (find-ls-option '("-print0 | xargs -0 ls -ldN" . "-ldN")))
#+end_src

**** EWW

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<share-dir()>>/emacs/eww-view-in-org 0755 - - 3d
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'shr
  (setopt shr-width 10000)
  (setopt shr-use-fonts nil)
  (setopt shr-image-animate t)
  (setopt shr-use-colors nil)
  (setopt shr-max-image-proportion 0.4)
  ;; never use cookies
  (setopt shr-cookie-policy nil))

(use-package eww
  :commands eww
  :after my-launch-app
  :bind (:map my/invoke-list-command-map
              ("B" . eww-list-bookmarks)
              :map my/launch-app-map
              ("W" . eww-switch-to-buffer))
  :custom
  ;; set enough large column number to prevent from inserting line break
  (eww-header-line-format nil)
  (eww-browse-url-new-window-is-tab nil)
  (eww-auto-rename-buffer 'title)
  (eww-buffer-name-length 20)
  (eww-bookmarks-directory (expand-file-name "eww"
                                             user-emacs-directory-default))
  :config
  (bind-keys :map eww-mode-map
             ("C" . eww-set-character-encoding)
             ("C-j" . eww-follow-link)
             ("T" . eww-goto-title-heading)
             ("L" . my/eww-goto-heading)
             ("O" . my/eww-view-in-org)
             :map eww-bookmark-mode-map
             ("C-j" . eww-bookmark-browse)))

(defun my/eww-view-in-org ()
  "Convert current html page into one org file and show it.

This is handy if you would like to check a page index comfortably."
  (interactive)
  (let ((source (plist-get eww-data :source))
        (src-html (make-temp-file "source-"))
        (dst-org (file-name-concat user-emacs-directory
                                   "eww-view-in-org"
                                   (format "%s.org" (org-id-uuid))))
        (coding-system-for-write 'utf-8-unix)
        (org-startup-folded t))
    (with-temp-buffer
      (insert source)
      (make-directory
       (file-name-directory (directory-file-name dst-org)) t)
      (write-region (point-min) (point-max) src-html nil)
      (call-process-shell-command (format "pandoc %s -f html -t org -o %s"
                                          (shell-quote-argument src-html)
                                          (shell-quote-argument dst-org)))
      (delete-file src-html))
    (find-file dst-org t)
    (goto-char (point-min))
    (org-ctrl-c-tab)))

(defun eww-headings-dom ()
  "Return heading list as a dom from xml."
  (let ((source (plist-get eww-data :source))
        (dom nil))
    (with-temp-buffer
      (let ((source-file (make-temp-file "source-"))
            (coding-system-for-write 'utf-8-unix))
        (insert source)
        (write-region (point-min) (point-max) source-file nil)
        (erase-buffer)
        (call-process "extract_headings" source-file t)
        (delete-file source-file)
        (libxml-parse-xml-region (point-min) (point-max))))))

(defun eww-goto-title-heading ()
  "Set point to a line which contaings the possible heading."
  (interactive)
  (when-let* ((headings-dom (eww-headings-dom))
              (possible-heading (cl-reduce (lambda (node-a node-b)
                                             (if (not (bound-and-true-p node-a))
                                                 (if (not (bound-and-true-p node-b))
                                                     nil
                                                   node-b)
                                               (if (>= (string-to-number (dom-attr node-a 'proximity))
                                                       (string-to-number (dom-attr node-b 'proximity)))
                                                   node-a node-b)))
                                           (dom-children headings-dom)
                                           :initial-value nil))
              (possible-text (dom-text possible-heading))
              (match-pos (or (re-search-forward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1)
                             (re-search-backward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1))))
    (beginning-of-line)
    (recenter-top-bottom 0)))

(defun my/eww-goto-heading ()
  "Go to selected heading line."
  (interactive)
  (setq lexical-binding t)
  (when-let* ((headings-root (eww-headings-dom))
              (cur-buf (current-buffer))
              (heading (completing-read
                        "Heading : "
                        (mapcar (lambda (heading-node)
                                  (when-let* ((heading (dom-text heading-node))
                                              (tag (symbol-name (dom-tag heading-node)))
                                              (match-pos (string-match "h\\([1-6]\\{1\\}\\)" tag))
                                              (indent (- (string-to-number (match-string 1 tag)) 1)))
                                    (format "%s%s"
                                            (apply 'concat (make-list indent "  "))
                                            heading)))
                                (dom-children headings-root))))
              (match (string-match "\\(?:  \\)*\\(.*\\)" heading))
              (heading (match-string 1 heading))
              (match-pos (or (re-search-forward (build-regex heading) nil t 1)
                             (re-search-backward (build-regex heading) nil t 1))))
    (with-current-buffer cur-buf
      (switch-to-buffer cur-buf)
      (beginning-of-line)
      (recenter-top-bottom 0))))

(defmacro build-regex (str)
  "Return a regexp representation for `STR'."
  `(format "^[[:blank:]SVG Image]*%s[[:blank:]]*$"
           ,str))
#+end_src

***** extract_headings

#+begin_src python :tangle (expand-file-name "extract_headings" tangle/local-bin-dir)
# This script extract most probable page heading.

import sys
import lxml.html as html
from lxml import etree
import difflib

if len(sys.argv) == 1:
    INPUT_STR = sys.stdin.read()
    ROOT = html.fromstring(INPUT_STR).getroottree()
else:
    sys.exit(1)

OUT_ROOT = etree.Element("headings")

# extract title text
title = ''
title_text_arr = ROOT.xpath('//title[1]//text()')
if len(title_text_arr):
    title = title_text_arr[0]
    OUT_ROOT.set("title", title.strip())

htag_text_arr = ROOT.xpath('//*[self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6]')
for i in range(len(htag_text_arr)):
    text = ''
    texts = htag_text_arr[i].xpath('.//text()')
    if len(texts) == 1:
        text = texts[0].strip()
    elif len(texts) > 1:
        text = ''.join(map(str.strip, texts))
    else:
        continue
    proximity = difflib.SequenceMatcher(None, title, text).ratio()
    heading = etree.Element(htag_text_arr[i].tag)
    heading.text = text
    heading.set('proximity', str(proximity))
    OUT_ROOT.append(heading)

out_root_str = etree.tostring(OUT_ROOT, encoding='utf-8', method='xml', pretty_print=True)
if type(out_root_str) is bytes:
    out_root_str = out_root_str.decode()
    print(out_root_str)
#+end_src
**** Info

#+begin_src emacs-lisp
(with-eval-after-load 'info
  (require 'info-look)
  (autoload 'info-lookup-add-help "info-look")
  (customize-set-variable 'Info-use-header-line nil)
  (customize-set-variable
   'Info-additional-directory-list
   `(,(expand-file-name "~/.local/share/info")
     ,@(let ((guix-custom-dir "~/.guix-extra-profiles")
             custom-info-path)
         (remq nil (mapcar (lambda (prof)
                             (setq custom-info-path (file-name-concat guix-custom-dir prof prof "share/info"))
                             (when (file-directory-p custom-info-path)
                               custom-info-path))
                           (directory-files guix-custom-dir))))))
  (define-key Info-mode-map (kbd "C-j") #'Info-follow-nearest-node)
  (define-key Info-mode-map (kbd "a") #'info-apropos))
#+end_src

**** Magit

[[https://github.com/magit/magit][Magit]] is git front end for emacs which is outstandingly powerful.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-magit"
#+end_src

#+begin_src emacs-lisp
(use-package magit
  :commands (magit magit-status)
  :bind ("C-x M" . magit-status)
  :config
  (bind-keys :map magit-status-mode-map
             ("/" . magit-file-checkout)
             (";" . magit-list-repositories)))
#+end_src

***** Magit Essentials
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:07]
:END:

#+begin_src emacs-lisp
(use-package magit-repos
  :after magit
  :custom
  (magit-repository-directories '(("~/git" . 1))))
#+end_src

***** Magit Revision
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:13]
:END:

#+begin_src emacs-lisp
(use-package magit-diff
  :after magit
  :custom
  ;; %GG denotes signature key info botained by --show-signature option in git log command
  (magit-revision-headers-format
   (mapconcat #'identity
              (list "Author:     %aN <%aE>"
                    "AuthorDate: %ad"
                    "Commit:     %cN <%cE>"
                    "CommitDate: %cd"
                    "%GG")
              "\n")))
#+end_src

***** Magit Log
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:15]
:END:

#+begin_src emacs-lisp
(use-package magit-log
  :after magit
  :custom
  (magit-log-show-refname-after-summary t))
#+end_src

***** Magit Wip
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 13:59]
:END:

The following excerpt is important when trying finer control for git-wip-*-mode.
- [[help:magit-wip-mode][magit-wip-mode]]
  #+begin_quote
  For historic reasons this mode is implemented on top of four
  other 'magit-wip-*' modes, which can also be used individually,
  if you want finer control over when the wip refs are updated;
  but that is discouraged.
  #+end_quote

#+begin_src emacs-lisp
(use-package magit-wip
  :after magit
  :custom
  (magit-wip-merge-branch t)
  :config
  (magit-wip-after-save-mode 1))
#+end_src

**** Mu4e

You need to [[https://www.djcbsoftware.nl/code/mu/mu4e/Initializing-the-message-store.html][issue 'mu init' command]] before using mu4e.
Command in practice presumably looks like:
: mu init --maildir=~/data/share/mail --muhome=~/data/share/mu --my-address=jim@example.com --my-address=bob@example.com

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"mu"
#+end_src

#+begin_src emacs-lisp
(use-package mu4e
  :defer t
  :hook (after-init . (lambda ()
                        (mu4e t)
                        (mu4e-update-mail-and-index t)))
  :delight
  (mu4e-main-mode    " MU")
  (mu4e-headers-mode " MU")
  (mu4e-view-mode    " MU")
  (mu4e-compose-mode " MU")
  :custom
  (mail-user-agent 'mu4e-user-agent)
  (mu4e-hide-index-messages t)
  (mu4e-context-policy 'pick-first)
  (mu4e-compose-context-policy 'ask)
  (mu4e-update-interval 300)
  (mu4e-split-view 'single-window)
  (mu4e-headers-date-format "%y%m%d")
  (mu4e-headers-time-format " %R")
  (mu4e-headers-fields
   '((:human-date . 6)
     (:flags      . 3)
     (:from       . 16)
     (:subject)))
  (mu4e-search-results-limit 2000)
  (mu4e-headers-advance-after-mark t)
  (mu4e-change-filenames-when-moving t)
  (mu4e-view-show-images t)
  (mu4e-html2text-command (lambda (msg)
                            (plist-put msg :body-html
                                       (with-temp-buffer
                                         (insert (or (mu4e-message-field msg :body-html) ""))
                                         (shell-command-on-region (point-min) (point-max) "nkf -w -Lu" (current-buffer) t)
                                         (or (buffer-string) "")))
                            (mu4e-shr2text msg)))
  :config
  (bind-keys :map mu4e-headers-mode-map
             ("C-j" . mu4e-headers-view-message)
             :map mu4e-view-mode-map
             ("C-j" . push-button)
             ("C-c C-a" . mu4e-view-attachment-action)
             :map mu4e-compose-mode-map
             ("C-x C-o" . org-mu4e-compose-org-mode))
  (add-to-list 'mu4e-view-actions
               '("external browser" . mu4e-action-view-in-browser) t)
  (add-to-list 'mu4e-view-actions
               '("XWidget View" . mu4e-action-view-with-xwidget) t)
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types)))
#+end_src

***** mu4e-alert                            :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-04-28 Fri 11:42]
:END:

#+begin_src scheme :tangle no
"emacs-mu4e-alert"
#+end_src

#+begin_src emacs-lisp
(use-package mu4e-alert
  :commands mu4e-alert-view-unread-mails
  :defer 5
  :custom
  (mu4e-alert-modeline-formatter
   (lambda (count)
     (if (> count 0)
         (format " M:%d" count)
       "")))
  :config
  (mu4e-alert-set-default-style 'fringe)
  (mu4e-alert-enable-notifications)
  (mu4e-alert-enable-mode-line-display))
#+end_src

***** additional tweaks

- file attachment in dired ([[https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html][source]])
  : gnus-dired-attach (C-c RET C-a)

  #+begin_src emacs-lisp
  (use-package gnus-dired
    :after mu4e-compose
    :hook
    (dired-mode . turn-on-gnus-dired-mode)
    :custom
    (gnus-dired-mail-mode 'mu4e-user-agent))
  #+end_src

- use contact info from org-contacts

  #+begin_src emacs-lisp
  (with-eval-after-load 'mu4e
    (add-to-list 'mu4e-headers-actions
                 '("Contact to add" . mu4e-action-add-org-contact) t)
    (add-to-list 'mu4e-view-actions
                 '("Contact to add" . mu4e-action-add-org-contact) t)
    (with-eval-after-load 'org-contacts
      (setq mu4e-org-contacts-file (car org-contacts-files))))
  #+end_src

**** Elfeed

[[https://github.com/skeeto/elfeed][Elfeed]] is a powerful RSS feed reader with tag capability that is one of core software in my input workflow.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/skeeto/elfeed/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package elfeed
  :delight
  (elfeed-show-mode   " EF")
  (elfeed-search-mode " EF")
  :commands elfeed
  :init
  (defface elfeed-search-unchecked-title-face
    nil
    "Face used in search mode for unchecked entry titles."
    :group 'elfeed)
  (defface elfeed-search-checked-title-face
    nil
    "Face used in search mode for checked entry titles."
    :group 'elfeed)
  :custom-face
  (elfeed-search-title-face ((t (:foreground "#4D4D4D"))))
  (elfeed-search-unchecked-title-face ((t (:foreground "cornflowerblue"))))
  (elfeed-search-checked-title-face ((t (:foreground "darkblue"))))
  :custom
  (elfeed-use-curl t)
  (elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory))
  (elfeed-search-date-format '("%Y%m%d" 8 :left))
  (elfeed-search-title-min-width 100)
  (elfeed-search-title-max-width 120)
  (elfeed-search-trailing-width 160)
  (elfeed-sort-order 'ascending)
  (elfeed-enclosure-default-dir "~/Downloads/")
  (elfeed-save-multiple-enclosures-without-asking t)
  :config
  (defalias 'elfeed-search-tag-all-unchecked
    (elfeed-expose #'elfeed-search-tag-all 'unchecked)
    "Add the `unchecked' tag to all selected entries.")
  (defalias 'elfeed-search-untag-all-unchecked
    (elfeed-expose #'elfeed-search-untag-all 'unchecked)
    "Remove the `unchecked' tag from all selected entries.")
  (defalias 'elfeed-search-tag-all-checked
    (elfeed-expose #'elfeed-search-tag-all 'checked)
    "Add the `checked' tag to all selected entries.")
  (defalias 'elfeed-search-untag-all-checked
    (elfeed-expose #'elfeed-search-untag-all 'checked)
    "Remove the `checked' tag from all selected entries.")
  (bind-keys :map elfeed-search-mode-map
             ("C-j" . elfeed-search-show-entry)
             ("M-RET" . elfeed-search-open-url)
             ("C-c C-o" . elfeed-search-open-url)
             ("f" . scroll-up-line)
             ("e" . scroll-down-line)
             ("q" . elfeed-kill-buffer)
             ("Q" . quit-window)
             ("x" . elfeed-search-update--force)
             ("c" . (lambda () (interactive)
                      (elfeed-search-untag-all-unread)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all-unchecked)))
             ("C" . elfeed-search-untag-all-unchecked)
             ("r" . (lambda () (interactive)
                      (elfeed-search-untag-all-unread)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-untag-all-unchecked)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all-checked)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))))
             ("R" . elfeed-search-untag-all-checked)
             ("d" . elfeed-search-untag-all-unread)
             ("D" . elfeed-search-download-media)
             ("_" . elfeed-search-show-media-duration))
  (add-to-list 'elfeed-search-face-alist '(unchecked elfeed-search-unchecked-title-face))
  (add-to-list 'elfeed-search-face-alist '(checked elfeed-search-checked-title-face)))

(defun elfeed-search-open-url ()
  "Visit the current entry in your browser using 'eww-browse-url'."
  (interactive)
  (elfeed-search-untag-all-unchecked)
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-tag-all-checked)
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-browse-url))

(defun elfeed-search-download-media ()
  "Downlaod video file."
  (interactive)
  (let ((entries (elfeed-search-selected)))
    (cl-loop for entry in entries
             when (or (caar (elfeed-entry-enclosures entry))
                      (elfeed-entry-link entry))
             do (let ((title (elfeed-entry-title entry)))
                  (detached-shell-command
                   (my/command-download-media it :filename title))))
    (mapc #'elfeed-search-update-entry entries)
    (unless (or elfeed-search-remain-on-entry (use-region-p))
      (forward-line))))

(defun elfeed-search-show-media-duration ()
  "Show duration of media attached to current entry."
  (interactive)
  (let* ((entry (elfeed-search-selected :single))
         (url (or (caar (elfeed-entry-enclosures entry))
                  (elfeed-entry-link entry))))
    (princ
     (string-trim
      (shell-command-to-string
       (my/command-download-media url :duration t))))))
#+end_src

***** elfeed-score
:PROPERTIES:
:CREATED:  [2023-07-20 Thu 09:26]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed-score"
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-score
  :after elfeed
  :custom
  (elfeed-score-serde-score-file
   (expand-file-name "elfeed.score" user-emacs-directory-default))
  (elfeed-score-rule-stats-file
   (expand-file-name "elfeed.stats" user-emacs-directory))
  (elfeed-score-score-format '("%d " 3 :right))
  :config
  (elfeed-score-enable)
  (setq elfeed-search-sort-function #'my/elfeed-score-sort-descending)
  (setq elfeed-search-print-entry-function #'my/elfeed-score-search-print-entry)
  (define-key elfeed-search-mode-map "=" elfeed-score-map)
  (bind-keys :map elfeed-search-mode-map
             ("C-c =" . my/elfeed-score-apply))
  :preface
  (defun my/elfeed-score-apply ()
    "Apply score rule from user managed score file."
    (interactive)
    (when (featurep 'elfeed-score)
      (elfeed-score-load-score-file (expand-file-name "elfeed.score.el" user-emacs-directory-default))
      (when (eq major-mode 'elfeed-search-mode)
        (elfeed-score-score-search))
      (elfeed-score-serde-write-score-file elfeed-score-serde-score-file)))
  (defun my/elfeed-score-sort-descending (a b)
    "Return non-nil if A should sort after B."
    (let ((a-score (elfeed-score-scoring-get-score-from-entry a))
          (b-score (elfeed-score-scoring-get-score-from-entry b)))
      (if (< a-score b-score)
          t
        (let ((a-date (elfeed-entry-date a))
              (b-date (elfeed-entry-date b)))
          (and (eq a-score b-score) (< a-date b-date))))))
  (defun my/elfeed-score-search-print-entry (entry)
    "Print ENTRY to the buffer with my style."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (mapconcat
                      (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                      tags ","))
           (title-width (- (window-width) 10 elfeed-search-trailing-width))
           (title-column (elfeed-format-column
                          title (elfeed-clamp
                                 elfeed-search-title-min-width
                                 title-width
                                 elfeed-search-title-max-width)
                          :left))
           (score
            (elfeed-score-format-score
             (elfeed-score-scoring-get-score-from-entry entry))))
      (insert score)
      (when feed-title
        (insert (propertize (elfeed-format-column feed-title 6 :left)
                            'face 'elfeed-search-feed-face) " "))
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (when tags
        (insert "(" tags-str ")")))))
#+end_src

***** elfeed-org

[[https://github.com/remyhonig/elfeed-org][elfeed-org]] allow me to express feeds for elfeed in org file.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed-org"
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-org
  :after (elfeed org denote)
  :custom
  (rmh-elfeed-org-ignore-tag "ARCHIVE")
  (rmh-elfeed-org-auto-ignore-invalid-feeds nil)
  :config
  (with-eval-after-load 'denote
    (setq rmh-elfeed-org-files
          (list (denote-get-path-by-id "20230605T173315")))
    (elfeed-org)))
#+end_src

Packages managed by other than guix (i.e. straight.el or apt) are encouraged to register feed since updating information channel is desirable to exist.

#+begin_src emacs-lisp :noweb yes
(advice-add #'rmh-elfeed-org-process
            :after #'my/elfeed-org-add-feeds)

(defun my/elfeed-org-add-feeds (rmh-elfeed-org-files rmh-elfeed-org-tree-id)
  "Add feeds in addition to feeds in `rmh-elfeed-org-files'.

This function needs to be invoked after `rmh-elfeed-org-process' which clear all feeds."
  (setf elfeed-feeds
        (append elfeed-feeds
                '(;; s-exps for feeds will be inserted here
                  <<elfeed-feeds>>))))
#+end_src

**** Terminal Emulators

#+begin_src emacs-lisp
(setf shell-command-switch "-c")
(customize-set-variable 'shell-command-prompt-show-cwd t)

(shell-command-with-editor-mode 1)
#+end_src

***** shell

#+begin_src emacs-lisp
(use-package shell
  :delight " SM"
  :commands (shell)
  :custom
  (shell-has-auto-cd t)
  :config
  (bind-keys :map shell-mode-map
             ("C-j" . comint-send-input)))
#+end_src

***** term

#+begin_src emacs-lisp
(use-package term
  :disabled t
  :delight
  (term-mode " TR")
  :config
  (bind-keys :map term-mode-map
             ("C-j" . term-send-input)))
#+end_src

***** vterm

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-vterm"
"emacs-multi-vterm"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/akermu/emacs-libvterm/releases.atom" soft_update)
("https://github.com/suonlight/multi-vterm/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :commands (vterm multi-vterm multi-vterm-next)
  :bind (:map vterm-mode-map
              ("C-c M-n" . multi-vterm-next)
              ("C-c M-p" . multi-vterm-prev))
  :delight " VT"
  :diminish ((vterm-copy-mode . "vc"))
  :custom
  (vterm-min-window-width 55)
  (vterm-buffer-name-string "vterm %s")
  :config
  (require 'multi-vterm)
  (bind-keys :map vterm-mode-map
             ("C-h" . vterm-send-backspace)
             ("M-h" . vterm-send-meta-backspace)
             ("C-y" . vterm-yank)
             ("M-y" . vterm-yank-pop)
             ("M-l" . nil)
             :map vterm-copy-mode-map
             ("C-j" . vterm-copy-mode-done))
  (advice-add 'consult-yank-from-kill-ring :around #'advice/vterm-yank-pop))

(defun my/multi-vterm (&optional arg)
  "Switch between existing vterm buffers.

Spawn a new vterm buffer if there's no available vterm buffer.
If command prefix ARG is simgle `C-u', spawn a vterm buffer forcibly regardless of condition."
  (interactive "P")
  (if (equal arg '(4))
      (multi-vterm)
    (multi-vterm-next)))

(defun advice/vterm-yank-pop (orig-fun &rest args)
  (if (eq major-mode 'vterm-mode)
      (let ((inhibit-read-only t)
            (yank-undo-function (lambda (_start _end) (vterm-undo))))
        (cl-letf (((symbol-function 'insert-for-yank)
                   (lambda (str) (vterm-send-string str t))))
          (apply orig-fun args)))
    (apply orig-fun args)))
#+end_src

***** eshell

#+begin_src emacs-lisp
(use-package eshell
  :delight " ES"
  :hook
  (eshell-kill . eshell-command-alert)
  :custom
  (eshell-prompt-function
   #'(lambda ()
       (format "[%s]\n%s"
               (eshell/basename (eshell/pwd))
               (if (= (user-uid) 0) "# " "$ "))))
  (eshell-prompt-regexp "[#$] ")
  (eshell-visual-subcommands '(("git" "log" "diff" "show")))
  (eshell-scroll-to-bottom-on-input 'this)
  :config
  (setq eshell-path-env (getenv "PATH")))

(defun eshell-command-alert (process status)
  "Send `alert' with severity based on STATUS when PROCESS finished."
  (let* ((cmd (process-command process))
         (buffer (process-buffer process))
         (msg (format "%s: %s" (mapconcat 'identity cmd " ")  status)))
    (if (string-prefix-p "finished" status)
        (alert msg :buffer buffer :severity  'normal)
      (alert msg :buffer buffer :severity 'urgent))))
#+end_src

**** Org Mode
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:02]
:header-args+: :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org"
"tree-sitter-org"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://updates.orgmode.org/feed/releases" soft_update)
#+end_src

Basic settings for built-in Org features. Similar to [[id:587bc395-6321-4f59-97e6-6f0b62518b20][this section]], all entries obey customize group hierarchy for Org mode.

#+begin_src emacs-lisp
(use-package org
  :mode ("\\.org$" . org-mode)
  :init
  (defvar my/org-initialized nil
    "Indicator showing whether any org file had opened.")
  (defvar my/org-mode-init-hook nil
    "One-off hook run when first org file open.")
  (setq org-directory "~/org")
  :hook
  (org-mode . (lambda ()
                (unless my/org-initialized
                  (setq my/org-initialized t)
                  (run-hooks 'my/org-mode-init-hook)
                  (provide 'my/org-mode-init))))
  :config
  (bind-keys :map org-mode-map
             ("C-c F" . org-next-block)
             ("C-c B" . org-previous-block)))

(defvar my/org-todo-keyword--urgent "UG"
  "TODO keyword acronym standing for 'UrGent'")
(put 'my/org-todo-keyword--urgent 'char ?u)
(defvar my/org-todo-keyword--todo "TD"
  "TODO keyword acronym standing for 'ToDo'")
(put 'my/org-todo-keyword--todo 'char ?t)
(defvar my/org-todo-keyword--next "NX"
  "TODO keyword acronym standing for 'NeXt")
(put 'my/org-todo-keyword--next 'char ?n)
(defvar my/org-todo-keyword--in-action "IA"
  "TODO keyword acronym standing for 'In Action")
(put 'my/org-todo-keyword--in-action 'char ?i)
(defvar my/org-todo-keyword--someday "OH"
  "TODO keyword acronym standing for 'On Hold'")
(put 'my/org-todo-keyword--someday 'char ?h)
(defvar my/org-done-keyword--done "DN"
  "DONE keyword acronym standing for 'DoNe'")
(put 'my/org-done-keyword--done 'char ?d)
(defvar my/org-done-keyword--cancel "CX"
  "DONE keyword acronym standing for 'Cancel'")
(put 'my/org-done-keyword--cancel 'char ?x)
(defvar my/org-done-keyword--pending "LG"
  "DONE keyword acronym standing for 'Let Go'")
(put 'my/org-done-keyword--pending 'char ?l)

(defvar my/org-project-tag "project" "A tag for projects")
#+end_src

***** org mode keymap

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (let ((map org-mode-map))
    (define-key map (kbd "C-j") #'org-return)
    (define-key map (kbd "C-M-j") #'org-return-indent)
    (define-key map (kbd "M-j") #'org-meta-return)
    (define-key map (kbd "C-S-p") #'org-previous-item)
    (define-key map (kbd "C-S-n") #'org-next-item)
    (define-key map (kbd "C-S-u") #'org-up-element)
    (define-key map (kbd "C-M-d") #'org-down-element)
    (define-key map (kbd "C-<") #'org-previous-link)
    (define-key map (kbd "C->") #'org-next-link)
    (define-key map (kbd "C-c @") #'org-mark-element)
    (define-key map (kbd "C-c C-SPC") #'org-mark-subtree)
    (define-key map (kbd "C-c C-a") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "M-h") nil)))
#+end_src

***** org core feature setup
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:14]
:END:
****** Org Agenda

#+begin_src emacs-lisp
(use-package org
  :no-require t
  :defer t
  :init
  (setq org-agenda-files
        (list (file-name-as-directory
               (expand-file-name
                (file-name-concat org-directory "agenda")))))
  :custom
  (org-agenda-inhibit-startup t))

(use-package org-agenda
  :commands org-agenda
  :init
  (with-eval-after-load 'my-org-global-map
    (keymap-set my/org-global-map "a"
                'org-agenda))
  :hook
  (org-agenda-mode . (lambda ()
                       ;; TODO: this can be rewritten with `display-buffer'
                       (delete-other-windows)
                       (org-agenda-to-appt t '((category "appt")))))
  :custom
  (org-agenda-use-tag-inheritance nil)
  :config
  (bind-keys :map org-agenda-mode-map
             ("C-j" . org-agenda-switch-to)
             ("M" . org-agenda-month-view)))

(defun org-agenda-cmp-latest-clock-log (a b)
  "Compare two org entry A and B in terms of clock log.

This function can be used as `org-agenda-cmp-user-defined' in `org-agenda-sorting-strategy'."
  (let* ((marker-a (get-text-property 1 'org-marker a))
         (time-a (org-get-latest-clock-log-time marker-a))
         (marker-b (get-text-property 1 'org-marker b))
         (time-b (org-get-latest-clock-log-time marker-b)))
    (if (time-less-p time-a time-b) -1 +1)))

(defun org-clock-sum-all ()
  "Sum the times for all agenda files."
  (interactive)
  (save-excursion
    (mapc (lambda (file)
            (with-current-buffer (or (org-find-base-buffer-visiting file)
                                     (find-file-noselect file))
              (org-clock-sum)
              (org-clock-sum-today)))
          (org-agenda-files))))

(defun org-get-latest-clock-log-time (pom)
  "Get the latest clock log time stamp in org entry at POM as a time object.

If entry at POM has no clock log time stamp, this function returns 0."
  (org-with-point-at pom
    (save-excursion
      (setq end-of-subtree (org-end-of-subtree))
      (setq latest-time 0)
      (org-back-to-heading t)
      (org-show-all)
      (while (re-search-forward org-drawer-regexp end-of-subtree t)
        (when (string= (match-string 1) (org-clock-drawer-name))
          (while (progn
                   (forward-line 1)
                   (when (org-match-line (concat "^[ \t]*" org-clock-string "[ \t]*" org-tsr-regexp-both))
                     (setq match-ts
                           (if (match-string 3)
                               (match-string 3) (match-string 1)))
                     (when (time-less-p latest-time
                                        (apply 'encode-time (parse-time-string match-ts)))
                       (setq latest-time (apply 'encode-time (parse-time-string match-ts)))))
                   (not (org-match-line org-clock-drawer-end-re))))))))
  latest-time)
#+end_src

******* Org Agenda Custom Commands
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 11:05]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setopt org-stuck-projects `(,(concat "+" my/org-project-tag)
                               (,my/org-todo-keyword--todo ,my/org-todo-keyword--next ,my/org-todo-keyword--in-action)
                               nil ""))
  (setq org-agenda-custom-commands
        `(("a" "Week-agenda"
           agenda ""
           ((org-agenda-skip-function #'my/org-agenda-skip-on-hold-task)))
          ("l" "Log entries in a week"
           agenda ""
           ((org-agenda-span (if (equal current-prefix-arg '(4))
                                 'day 'week))
            (org-agenda-start-with-log-mode t)
            (org-agenda-start-with-clockreport-mode t)
            (org-agenda-include-inactive-timestamps nil)
            (org-agenda-include-diary t)
            (org-agenda-sorting-strategy
             '(time-up
               deadline-up
               todo-state-up
               priority-down))))
          ("L" "Log entry timeline on today with default org-agenda-prefix-format"
           agenda ""
           ((org-agenda-prefix-format (eval (car (get 'org-agenda-prefix-format 'standard-value))))
            (org-agenda-span (if (equal current-prefix-arg '(4))
                                 'day 'week))
            (org-agenda-start-with-clockreport-mode t)
            (org-agenda-start-with-log-mode t)
            (org-agenda-include-inactive-timestamps nil)
            (org-agenda-include-diary t)
            (org-agenda-sorting-strategy
             '(time-up
               deadline-up
               todo-state-up
               priority-down))))
          ;; KEEP IN MIND
          ;; invoking `org-clock-sum-all' is required before showing effort table
          ("e" . "Effort table")
          ("ei" "today"
           ((org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action)
                                      (and (clocked :on today)
                                           (or (todo) (done))
                                           (not (habit))
                                           (not (tags "web"))))
                                 ((org-ql-block-header "Today's task"))))
           ((org-agenda-overriding-header "Today's Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("eg" "this week"
           ((org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--next)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "This Week's task"))))
           ((org-agenda-overriding-header "This Week's Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("ed" "done task"
           ((org-ql-search-block `(or (todo ,my/org-done-keyword--done)
                                      (todo ,my/org-done-keyword--cancel)
                                      (todo ,my/org-done-keyword--pending))
                                 ((org-ql-block-header "Done task"))))
           ((org-agenda-overriding-header "Done Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM(Total){:}")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("i" "Today's agenda"
           ((todo "Today's agenda"
                  ((org-agenda-sorting-strategy '(priority-up))))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "Today's task")))
            (org-ql-search-block `(and (planning :on today)
                                       (not (todo ,my/org-todo-keyword--in-action
                                                  ,my/org-done-keyword--done
                                                  ,my/org-done-keyword--cancel
                                                  ,my/org-done-keyword--pending))
                                       (not (tags "web"))
                                       (not (habit))
                                       (not (todo ,my/org-todo-keyword--someday)))
                                 ((org-ql-block-header "Scheduled/Deadlined on today")))
            (org-ql-search-block `(and (habit)
                                       (or (todo ,my/org-todo-keyword--todo)
                                           (todo ,my/org-todo-keyword--next))
                                       (scheduled :to today)
                                       (not (tags "bad_habit"))
                                       (not (tags-inherited "ARCHIVE")))
                                 ((org-ql-block-header "Habits to take")))
            (org-ql-search-block `(and (ts-active :on today)
                                       (not (or (todo ,my/org-todo-keyword--in-action)
                                                (habit) (done)))
                                       (not (todo ,my/org-todo-keyword--someday)))
                                 ((org-ql-block-header "Today's common event")))
            (org-ql-search-block '(and (done)
                                       (closed :on today))
                                 ((org-ql-block-header "Completed tasks on today")))
            (org-ql-search-block '(and (habit)
                                       (last-repeat 0))
                                 ((org-ql-block-header "Completed habits on today"))))
           ((org-agenda-sorting-strategy
             '(todo-state-up priority-down deadline-up))))
          ("n" "This Week's agenda"
           ((org-ql-search-block `(heading ,(format-time-string "%G-W%V"))
                                 ((org-agenda-files `(,(file-name-concat org-directory "archive" (format-time-string "archive_%Y.org"))))
                                  (org-ql-block-header "This week in datetree archive")))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--next))
                                 ((org-ql-block-header "This week's tasks")))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "Today's tasks")))
            (org-ql-search-block `(and (planning :from 0 :to 6)
                                       (not (todo ,my/org-todo-keyword--in-action
                                                  ,my/org-done-keyword--done
                                                  ,my/org-done-keyword--cancel
                                                  ,my/org-done-keyword--pending))
                                       (not (tags "web"))
                                       (not (todo ,my/org-todo-keyword--someday))
                                       (not (habit)))
                                 ((org-ql-block-header "Scheduled/Deadlined this week")))
            (org-ql-search-block `(and (and (ts-active :from 0 :to 6)
                                            (not (deadline))
                                            (not (scheduled))
                                            (not (closed)))
                                       (not (or (todo ,my/org-todo-keyword--next
                                                      ,my/org-todo-keyword--in-action)
                                                (done))))
                                 ((org-ql-block-header "This week's common event"))))
           ((org-agenda-sorting-strategy
             '(todo-state-up priority-down deadline-up))))
          ("t" "All tasks"
           ((org-ql-search-block `(todo ,my/org-todo-keyword--urgent)
                                 ((org-ql-block-header "Urgent task")))
            (org-ql-search-block `(todo ,my/org-todo-keyword--in-action)
                                 ((org-ql-block-header "Today's task")))
            (org-ql-search-block `(todo ,my/org-todo-keyword--next)
                                 ((org-ql-block-header "This week's task")))
            (org-ql-search-block `(and (todo ,my/org-todo-keyword--todo)
                                       (not (habit)))
                                 ((org-ql-block-header "Remaining task")))))
          ("d" "Done tasks"
           ((org-ql-search-block `(and (or (done)
                                           (and (todo ,my/org-todo-keyword--someday)
                                                (not (path ,(expand-file-name "agenda/on-holds.org" org-directory)))))
                                       (not (tags "project")))
                                 ((org-ql-block-header "Done/Canceled/Pending task")))))
          ("p" "Projects" tags ,(concat "+" my/org-project-tag))
          ("h" "Habits in consistency graph"
           agenda ""
           ((org-agenda-span 'day)
            (org-agenda-use-time-grid nil)
            (org-agenda-prefix-format '((agenda . "")))
            (org-habit-show-all-today t)
            (org-agenda-sorting-strategy '(scheduled-up))
            ;; display habits only
            (org-agenda-skip-function
             (lambda ()
               (and (save-excursion
                      (not (org-is-habit-p)))
                    (progn (outline-next-heading) (point)))))))
          ("H" "show all habits"
           ((org-ql-search-block '(habit)
                                 ((org-ql-block-header "All Habits"))))
           ((org-agenda-sorting-strategy '(scheduled-up)))))))
#+end_src

******* Org Agenda Daily/Weekly
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 14:08]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setopt org-agenda-start-on-weekday 1)
  (setopt org-agenda-skip-deadline-if-done t)
  (setopt org-agenda-include-diary t)
  (setopt org-agenda-dim-blocked-tasks nil))
#+end_src

******* Org Agenda Line Format
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 14:21]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setq org-agenda-prefix-format '((agenda   . "%?-12t% s")
                                   (timeline . "  %s")
                                   (todo     . " ")
                                   (tags     . " ")
                                   (search   . " "))))
#+end_src

****** Org Capture

#+begin_src emacs-lisp
(use-package org-capture
  :after (org my-org-global-map)
  :bind (:map my/org-global-map
              ("c" . org-capture))
  :hook
  (org-capture-mode . delete-other-windows)
  :custom
  (org-reverse-note-order nil)
  (org-capture-bookmark nil)
  (org-capture-templates
   `(("e" "Entry"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      ,(concat "* %a\n"
               "%(and (length> \"%i\" 0)
(format \"#+begin_\%1$s\n\%2$s#+end_%1$s\n\"
\"text\"
(replace-regexp-in-string \"^*\" \",*\" \"%i\")))"))
     ("t" "Task"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      ,(format "* %s %%?\n"
               my/org-todo-keyword--todo))
     ("p" "Project"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      "* %? [/] :project:\n#+CALL: project-tasks(id=\"\")"
      :jump-to-captured t)
     ("M" "Append memo to clocking task"
      item (clock)
      "- %i%?"))))
#+end_src

****** Org Startup

#+begin_src emacs-lisp
(setopt org-startup-folded t)
(setopt org-startup-truncated t)
(setopt org-startup-with-inline-images t)
(setopt org-cycle-hide-drawer-startup t)

;; allow _{}/^{} format for sub/super script
(setopt org-use-sub-superscripts '{})
#+end_src

****** Org TODO

#+begin_src emacs-lisp
(customize-set-variable 'org-enforce-todo-dependencies t)
(customize-set-variable
 'org-todo-keywords
 `((sequence ,(format "%s(%c)" my/org-todo-keyword--todo
                      (get 'my/org-todo-keyword--todo 'char))
             ,(format "%s(%c)" my/org-todo-keyword--urgent
                      (get 'my/org-todo-keyword--urgent 'char))
             ,(format "%s(%c)" my/org-todo-keyword--next
                      (get 'my/org-todo-keyword--next 'char))
             ,(format "%s(%c)" my/org-todo-keyword--in-action
                      (get 'my/org-todo-keyword--in-action 'char))
             ,(format "%s(%c!/!)" my/org-todo-keyword--someday
                      (get 'my/org-todo-keyword--someday 'char))
             "|"
             ,(format "%s(%c!/@)" my/org-done-keyword--done
                      (get 'my/org-done-keyword--done 'char))
             ,(format "%s(%c!/@)" my/org-done-keyword--cancel
                      (get 'my/org-done-keyword--cancel 'char))
             ,(format "%s(%c!/@)" my/org-done-keyword--pending
                      (get 'my/org-done-keyword--pending 'char)))))
(customize-set-variable
 'org-todo-keyword-faces
 `((,my/org-todo-keyword--urgent    . "red1")
   (,my/org-todo-keyword--todo      . "DeepPink1")
   (,my/org-todo-keyword--next      . "green1")
   (,my/org-todo-keyword--in-action . "DodgerBlue1")
   (,my/org-todo-keyword--someday   . "SpringGreen")
   (,my/org-done-keyword--done      . "gray30")
   (,my/org-done-keyword--cancel    . "dark gray")
   (,my/org-done-keyword--pending   . "sea green")))
(customize-set-variable 'org-log-into-drawer t)
(customize-set-variable 'org-log-states-order-reversed t)
(customize-set-variable 'org-log-note-clock-out nil)
(customize-set-variable 'org-log-done 'time)
(customize-set-variable 'org-log-refile 'time)
(customize-set-variable 'org-log-reschedule nil)
(customize-set-variable 'org-log-redeadline 'time)
(customize-set-variable 'org-closed-keep-when-no-todo nil)
#+end_src

****** Org Structure

#+begin_src emacs-lisp
(customize-set-variable 'org-startup-indented t)
(customize-set-variable 'org-bookmark-names-plist nil)
(customize-set-variable 'org-M-RET-may-split-line '((default . nil)))

(use-package org-indent
  :after org
  :bind (:map org-mode-map
              ("C-c C-M-i" . org-indent-mode))
  :hook (org-mode . org-indent-mode))

;; org speed command settings
(customize-set-variable 'org-use-speed-commands
                        (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))

(with-eval-after-load 'org-keys
  (add-to-list 'org-speed-commands
               '("Additional")
               t)
  (cl-labels ((os-set (key command)
                (assoc-delete-all key org-speed-commands)
                (add-to-list 'org-speed-commands
                             (cons key command)
                             t)))
    (os-set "j" #'org-insert-heading)
    (os-set "P" #'org-set-property)
    (os-set "C" #'org-clone-subtree-with-time-shift)
    (os-set "s" #'org-schedule)
    (os-set "d" #'org-deadline)
    (os-set "N" #'org-toggle-narrow-to-subtree)
    (os-set "$" #'org-archive-subtree)
    (os-set "'" #'ignore)))
#+end_src

******* Org Edit Structure

#+begin_src emacs-lisp
(use-package org-src
  :after org
  :hook (org-src-mode . (lambda ()
                          (setq-local auto-save-visited-mode nil)
                          (setq-local buffer-save-without-query t)
                          (when (eq major-mode 'text-mode)
                            (visual-line-mode 1))))
  :custom
  (org-special-ctrl-a/e t)
  (org-src-window-setup 'current-window)
  (org-edit-src-content-indentation 0)
  (org-edit-src-turn-on-auto-save nil)
  (org-edit-src-auto-save-idle-delay 30)
  (org-edit-src-persistent-message nil)
  (org-src-ask-before-returning-to-edit-buffer nil)
  (org-special-ctrl-k t)
  (org-ctrl-k-protect-subtree t)
  :config
  (mapc (lambda (temp-cons)
          (if-let ((place (assoc (car temp-cons) org-structure-template-alist)))
              (setf (cdr (assoc (car temp-cons) org-structure-template-alist)) (cdr temp-cons))
            (add-to-list 'org-structure-template-alist temp-cons t)))
        '(("sh" . "src shell")
          ("tx" . "src text")
          ("el" . "src emacs-lisp")
          ("py" . "src python")))
  (setq org-src-lang-modes
        (append org-src-lang-modes
                '(("json" . json-ts)
                  ("dot"  . graphviz-dot)
                  ("yaml" . yaml-ts))))
  (advice-add #'org-edit-src-save
              :before
              (lambda (&rest _)
                (delete-trailing-whitespace))))
#+end_src

******* Org Plain lists

#+begin_src emacs-lisp
(customize-set-variable 'org-list-demote-modify-bullet
                        '(("-" . "+") ("+" . "-") ("*" . "-")
                          ("1." . "1)") ("1)" . "1.") ("*" . "1.")))
(customize-set-variable 'org-cycle-include-plain-lists 'integrate)
(customize-set-variable 'org-list-use-circular-motion t)
(customize-set-variable 'org-list-allow-alphabetical t)
#+end_src

******* Org Archive

#+begin_src emacs-lisp
(use-package org-archive
  :defer t
  :custom
  (org-archive-default-command 'org-toggle-archive-tag))

(setopt org-cycle-open-archived-trees t)
#+end_src

******* Org Inline Tasks

#+begin_src emacs-lisp
(use-package org-inlinetask
  :commands (org-inlinetask-insert-task
             org-inlinetask-promote
             org-inlinetask-demote)
  :custom
  (org-inlinetask-default-state my/org-todo-keyword--todo)
  (org-inlinetask-min-level 10))
#+end_src

****** Org Tags

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (customize-set-variable 'org-use-tag-inheritance
                          org-archive-tag)
  (customize-set-variable 'org-tags-column -57)
  (customize-set-variable 'org-tags-sort-function #'org-string-collate-greaterp))
#+end_src

****** Org Properties

#+begin_src emacs-lisp
(customize-set-variable 'org-use-property-inheritance "TIMELIMIT.*")
(customize-set-variable 'org-highest-priority ?A)
(customize-set-variable 'org-lowest-priority ?Z)
(customize-set-variable 'org-default-priority ?E)
(customize-set-variable 'org-global-properties
                        '(("Effort_ALL". "0 0:10 0:20 0:30 1:00 1:30 2:00 3:00 4:00 6:00 8:00")))
#+end_src

****** Org Refile

#+begin_src emacs-lisp
(use-package org-refile
  :after (org denote)
  :commands (org-refile)
  :custom
  (org-refile-targets
   `((org-agenda-files :tag . ,my/org-project-tag)
     (,(org-agenda-files) :tag . "refile"))))
#+end_src

****** Org Time

#+begin_src emacs-lisp
(customize-set-variable 'org-time-stamp-custom-formats
                        '("<%m-%d %a>" . "<%H:%M>"))
#+end_src

******* Org Progress

******** Org Habit
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 12:58]
:END:

#+begin_src emacs-lisp
(use-package org-habit
  :after my/org-mode-init
  :custom
  (org-habit-graph-column 32)
  (org-habit-preceding-days 14)
  (org-habit-following-days 21)
  (org-habit-show-habits-only-for-today t))
#+end_src

******** Org Clock

#+begin_src emacs-lisp
(use-package org-clock
  :after (org my-org-global-map)
  :custom
  (org-clock-into-drawer "CLOCK")
  (org-clock-out-when-done t)
  (org-clock-persist t)
  (org-clock-persist-file (file-name-concat user-emacs-directory "org-clock-save.el"))
  (org-clock-persist-query-resume nil)
  (org-clock-string-limit 20)
  (org-clock-continuously t)
  (org-clock-ask-before-exiting nil)
  :config
  (org-clock-persistence-insinuate)
  (bind-keys :map my/org-global-map
             ("j" . org-clock-goto)
             ("I" . org-clock-in)
             ("O" . org-clock-out)
             ("X" . org-clock-cancel))
  (with-eval-after-load 'org-keys
    (dolist (elt '(("Clock Commands")
                   ("I" . org-clock-in)
                   ("O" . org-clock-out)
                   ("x" . nil)
                   ("X" . org-clock-cancel)))
      (add-to-list 'org-speed-commands elt t))))
#+end_src

****** Org Appearance

#+begin_src emacs-lisp
(customize-set-variable 'org-hide-leading-stars t)
(customize-set-variable 'org-hide-emphasis-markers t)
(customize-set-variable 'org-pretty-entities t)
(customize-set-variable 'org-image-actual-width 100)
(customize-set-variable 'org-display-remote-inline-images 'cache)
#+end_src

****** Babel

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"plantuml"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package ob-core
  :after org
  :hook (org-babel-after-execute . org-display-inline-images)
  :init
  (cond
   ((string= system-type "gnu/linux")
    (setq org-plantuml-jar-path (expand-file-name "plantuml.jar" "~/.guix-profile/share/java")))
   ((string= system-type "darwin")
    (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/8041/plantuml.8041.jar")))
  :custom
  (org-babel-load-languages '((emacs-lisp . t)
                              (lisp       . t)
                              (C          . t)
                              (java       . t)
                              (R          . t)
                              (shell      . t)
                              (ruby       . t)
                              (python     . t)
                              (scheme     . t)
                              (lua        . t)
                              (ledger     . t)
                              (gnuplot    . t)
                              (dot        . t)
                              (plantuml   . t)
                              (lilypond   . t))))

<<babel-conf>>
#+end_src

******* Org Babel Tangle
:PROPERTIES:
:CREATED:  [2023-10-29 Sun 11:23]
:END:

org-babel-tangle-default-file-mode does not seems to be in effect. I set org-babel-default-header-args:<lang> instead as a wordaround.

#+begin_src emacs-lisp
(use-package ob-tangle
  :after ob-core
  :custom
  (org-babel-tangle-default-file-mode (identity #o444)))
#+end_src

****** Org ID

#+begin_src emacs-lisp
(use-package org-id
  :after org
  :bind (:map org-mode-map
              ("C-c i" . org-id-copy))
  :custom
  (org-id-track-globally t)
  (org-id-link-to-org-use-id 'create-if-interactive)
  (org-id-locations-file
   (expand-file-name ".org-id-locations" org-directory)))
#+end_src

****** Org Crypt

#+begin_src emacs-lisp
(use-package org-crypt
  :after my/org-mode-init
  :custom
  (org-crypt-key user-mail-address)
  :config
  (bind-keys :map org-mode-map
             ("C-c M-: e" . org-encrypt-entry)
             ("C-c M-: E" . org-encrypt-entries)
             ("C-c M-: d" . org-decrypt-entry)
             ("C-c M-: D" . org-decrypt-entries))
  (org-crypt-use-before-save-magic)
  (add-to-list 'org-tags-exclude-from-inheritance
               org-crypt-tag-matcher))
#+end_src

****** Org Attach

#+begin_src emacs-lisp
(customize-set-variable 'org-attach-preferred-new-method nil)
#+end_src

****** Org Link

#+begin_src emacs-lisp
(use-package ol
  :after my-org-global-map
  :bind (:map my/org-global-map
              ("s" . org-store-link))
  :config
  (org-link-set-parameters "src" :follow #'org-babel-ref-resolve))
#+end_src

******* Org Follow Link

#+begin_src emacs-lisp
(customize-set-variable 'org-link-elisp-confirm-function nil)
(customize-set-variable 'org-return-follows-link t)
(with-eval-after-load 'ol
  (setf (alist-get 'file org-link-frame-setup) 'find-file))
#+end_src

****** Org Export

******* Org Export General

#+begin_src emacs-lisp
(use-package ox
  :commands org-export-dispatch
  :custom
  (org-export-with-smart-quotes t)
  (org-export-with-emphasize t)
  (org-export-with-special-strings t)
  (org-export-with-fixed-width t)
  (org-export-with-timestamps t)
  (org-export-preserve-breaks nil)
  (org-export-with-sub-superscripts nil)
  (org-export-with-archived-trees 'headline)
  (org-export-with-author nil)
  (org-export-with-broken-links 'mark)
  (org-export-with-clocks nil)
  (org-export-with-creator nil)
  (org-export-with-drawers '(not "LOGBOOK"))
  (org-export-with-date nil)
  (org-export-with-entities t)
  (org-export-with-email nil)
  (org-export-with-footnotes t)
  (org-export-headline-levels 5)
  (org-export-with-inlinetasks t)
  (org-export-with-section-numbers nil)
  (org-export-with-planning nil)
  (org-export-with-priority nil)
  (org-export-with-properties nil)
  (org-export-with-statistics-cookies t)
  (org-export-with-tags nil)
  (org-export-with-tasks t)
  (org-export-with-latex t)
  (org-export-time-stamp-file nil)
  (org-export-with-title t)
  (org-export-with-toc nil)
  (org-export-with-todo-keywords nil)
  (org-export-with-tables t)
  (org-export-default-language "ja")
  (org-export-dispatch-use-expert-ui nil))
#+end_src

******* Org Export HTML

#+begin_src emacs-lisp
(use-package ox-html
  :commands (org-html-export-as-html
             org-html-export-to-html)
  :custom
  (org-html-preamble t)
  (org-html-postamble 'auto)
  (org-html-with-latex t)
  (org-html-container-element "div")
  (org-html-doctype "xhtml-strict"))
#+end_src

******* Org Export LaTeX

#+begin_src emacs-lisp
(use-package ox-latex
  :commands (org-latex-export-as-latex
             org-latex-export-to-latex
             org-latex-export-to-pdf)
  :custom
  (org-latex-pdf-process '("platex %f"
                           "platex %f"
                           "bibtex %b"
                           "platex %f"
                           "platex %f"
                           "dvipdfmx %b.dvi"))
  (org-latex-default-class "jsarticle")
  :config
  (add-to-list 'org-latex-classes
               '("jsarticle"
                 "\\documentclass[dvipdfmx,12pt]{jsarticle}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               `("beamer"
                 "\\documentclass[presentation,dvipdfmx,18pt]{beamer}\n"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

****** Org Plot                            :ARCHIVE:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"gnuplot"
"emacs-gnuplot"
"emacs-mkmcc-gnuplot-mode"
#+end_src

***** org 3rd-party packages
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:07]
:END:
****** org-ai                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-23 Fri 17:40]
:END:

#+begin_src emacs-lisp :noweb no
(use-package org-ai
  :disabled t
  :after org
  :hook (org-mode #'org-ai-mode)
  :custom
  (org-ai-chat-models '("gpt-3.5-turbo"))
  (org-ai-default-chat-model "gpt-3.5-turbo")
  (org-ai-default-max-tokens 150)
  (org-ai-image-directory (expand-file-name "org-ai-images"
                                            user-emacs-directory))
  (org-ai-openai-api-token "<<openai-api-key()>>"))
#+end_src

****** org-modern                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 22:03]
:END:

#+begin_src scheme :tangle no
"emacs-org-modern"
#+end_src

****** org-transclusion
:PROPERTIES:
:CREATED:  [2023-03-02 Thu 14:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-transclusion"
#+end_src

#+begin_src emacs-lisp
(use-package org-transclusion
  :after org
  :bind (:map my/org-global-map
              ("t a" . org-transclusion-add)
              ("t A" . org-transclusion-add-all)
              ("t n" . org-transclusion-make-from-link)
              ("t t" . org-transclusion-activate)))
#+end_src

****** org-edna
:PROPERTIES:
:CREATED:  [2022-10-24 Mon 15:28]
:END:

[[https://www.nongnu.org/org-edna-el/][Org Edna]] allows to org entries to be blockers and action triggers, which is very intresting feature especially for managing successive set of tasks or any correlated tasks.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-edna"
#+end_src

#+begin_src emacs-lisp
(use-package org-edna
  :after org
  :custom
  (org-edna-mode t))
#+end_src

****** org-drill

[[https://gitlab.com/phillord/org-drill][org-drill]] helps me to learn english words and phrases. [[https://youtu.be/SGzdFtN_NqE][This video]] introduces how I use org-drill.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-drill"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://gitlab.com/phillord/org-drill/-/tags?format=atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package org-drill
  :after org
  :commands (org-drill org-drill-tree)
  :init
  (bind-keys :map org-mode-map
             ("C-c D" . org-drill-tree))
  :custom
  (org-drill-spaced-repetition-algorithm 'sm5))
#+end_src

****** org-ql

[[https://github.com/alphapapa/org-ql][Org QL]] enables me to issue queries to search org entries with either SQL-like format or plain search strings.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-ql"
#+end_src

#+begin_src emacs-lisp
(use-package org-ql
  :after (org my-org-global-map)
  :bind (:map my/org-global-map
              ("q q" . org-ql-search)
              ("q v" . org-ql-view)
              ("q f f" . org-ql-find)
              ("q f F" . org-ql-find-in-org-directory)
              ("q f a" . org-ql-find-in-agenda)
              ("q f n" . my/org-ql-find-in-notes)
              ("q /" . org-ql-sparse-tree))
  :preface
  (with-eval-after-load 'denote
    (defun my/org-ql-find-in-notes ()
      "Call 'org-ql-find' on 'denote-all-files'."
      (interactive)
      (org-ql-find (denote-all-files))))
  :custom
  (org-ql-search-directories-files-regexp "\\.org\\(?:\\.gpg\\)?$")
  (org-ql-search-directories-files-recursive t)
  :preface
  (defconst org-last-repeat-time-regexp
    "\\(?::LAST_REPEAT: *\\[\\([^]]+\\)]\\)"
    "Matches the LAST_REPEAT property together with a time stamp.")
  :config
  (require 'org-ql-search)
  (org-ql-defpred last-repeat (&key from to _on)
    "Return non-nil if current entry was repeated in given period.
Without arguments, return non-nil if entry has LAST_REPEAT property."
    :normalizers ((`(,predicate-names ,(and num-days (pred numberp)))
                   (let* ((from-day (* -1 num-days))
                          (rest (list :from from-day)))
                     (org-ql--normalize-from-to-on
                       `(last-repeat :from ,from))))
                  (`(,predicate-names . ,rest)
                   (org-ql--normalize-from-to-on
                     `(last-repeat :from ,from :to ,to))))
    :preambles ((`(,predicate-names . ,_)
                 ;;  Predicate still needs testing.
                 (list :regexp org-last-repeat-time-regexp :query query)))
    :body
    (org-ql--predicate-ts :from from :to to :regexp org-last-repeat-time-regexp :match-group 1))
  (org-ql-defpred (tags-expanded expanded-tags tags-x xtags) (&rest tags)
    "Return non-nil if current heading has one or more of TAGS.
If TAGS contains a group tag, all tags in the group is used to match.
Both inherited and local tags is tested."
    :normalizers ((`(,predicate-names . ,tags)
                   `(tags-expanded ,@tags)))
    :body (apply #'org-ql--predicate-tags
                 (seq-uniq (--mapcat (org-tags-expand it t)
                                     tags))))
  (org-ql-defpred (category-inherited) (&rest categories)
    "Return non-nil if current heading has CATEGORY.
Ancestors are looked up If current heading has no CATEGORY."
    :body (when-let ((category (or (org-get-category (point))
                                   (org-entry-get (point) "CATEGORY" t))))
            (cl-typecase categories
              (null t)
              (otherwise (member category categories)))))
  (with-eval-after-load 'org-expiry
    (org-ql-defpred expired ()
      "Return non-nil if the entry is expired."
      :body (org-expiry-expired-p))))

(use-package org-ql-view
  :after (org-ql org-agenda)
  :config
  (push `("Tasks on Web/Book"
          :buffers-files org-agenda-files
          :query (and (or (tags "web")
                          (tags "book"))
                      (not (or (done) (todo ,my/org-todo-keyword--someday))))
          :super-groups ((:auto-tags))
          :sort (priority date))
        org-ql-views)
  (push `("Habits"
          :buffers-files org-agenda-files
          :query (habit)
          :sort (todo scheduled))
        org-ql-views))
#+end_src

****** org-contacts

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-contacts"
#+end_src

#+begin_src emacs-lisp
(use-package org-contacts
  :after (org denote)
  :commands (org-contacts-anniversaries)
  :init
  (setq org-contacts-files
        (list (denote-get-path-by-id "20230605T173003"))))
#+end_src

****** org-ml                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 20:02]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/ndwarshuis/org-ml/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-ml
  :after org)
#+end_src

****** org-roam                            :ARCHIVE:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-org-roam"
#   "emacs-emacsql-sqlite3"
# #+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/org-roam/org-roam/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-roam
  :disabled t
  :after org
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n S" . org-roam-db-sync))
  :custom
  (org-roam-directory org-directory)
  (org-roam-db-location (file-name-concat user-emacs-directory "org-roam.db"))
  (org-roam-database-connector 'sqlite3)
  (org-roam-db-update-on-save nil)
  (org-roam-db-extra-links-exclude-keys
   '((node-property "ROAM_REFS")
     (node-property "PARENT")
     (keyword "transclude")))
  :config
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-section
              #'org-roam-reflinks-section
              #'org-roam-unlinked-references-section)))
#+end_src
****** org-mime

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-mime"
#+end_src

#+begin_src emacs-lisp
(use-package org-mime
  :after org
  :commands (org-mime-org-subtree-htmlize)
  :bind (:map org-mode-map
              ("C-c M-M" . org-mime-org-subtree-htmlize))
  :custom
  (org-mime-use-property-inheritance t)
  (org-mime-export-ascii t))
#+end_src

****** org-web-tools

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-web-tools"
#+end_src

#+begin_src emacs-lisp
(use-package org-web-tools
  :bind (("C-c C-;" . org-web-tools-insert-link-for-url)))
#+end_src

****** org-volume                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 21:59]
:END:

[[https://github.com/akirak/org-volume][org-volume]] can be used to insert book information in dynamic block.

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/akirak/org-volume/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-volume
  :straight (org-volume
             :host github
             :repo "akirak/org-volume"
             :branch "master"))
#+end_src

****** org-clock-convenience

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/dfeich/org-clock-convenience/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package org-clock-convenience
  :ensure t
  :after org-agenda
  :bind
  (:map org-agenda-mode-map
        ("@"   . org-clock-convenience-fill-gap)
        ("C-@" . org-clock-convenience-fill-gap-both)))
#+end_src

****** org-reveal

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-reveal"
#+end_src

****** org-expiry

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-contrib"
#+end_src

#+begin_src emacs-lisp
(use-package org-expiry
  :after my/org-mode-init
  :custom
  (org-expiry-inactive-timestamps t)
  (org-expiry-handler-function 'org-expiry-archive-subtree)
  :config
  (with-eval-after-load 'org-capture
    (add-hook 'org-capture-prepare-finalize-hook
              #'org-expiry-insert-created))
  (org-expiry-insinuate))
#+end_src

****** ob-async                            :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:31]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ob-async"
#+end_src

#+begin_src emacs-lisp
(use-package ob-async
  :after ob-core)
#+end_src

****** ob-lilypond                         :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:31]
:END:

#+begin_src emacs-lisp
(use-package ob-lilypond
  :after ob-core
  :custom
  ;; (org-babel-lilypond-commands '("lilypond" "firefox" "fluidsynth -a alsa -m alsa_seq -l"))
  (org-babel-lilypond-commands '("lilypond" "firefox" "xdg-open"))
  (org-babel-lilypond-arrange-mode t))
#+end_src

****** ox-hugo
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:33]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ox-hugo"
#+end_src

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox)
#+end_src

****** org-web-track
:PROPERTIES:
:CREATED:  [2023-01-06 Fri 13:43]
:END:

[[help:my/org-web-track-update-all-and-notify][org-web-track-update-all-and-notify]] seems not to suit midnight-hook.

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-web-track.el" tangle/emacs-config-dir)
(use-package org-web-track
  :after my/org-mode-init
  :load-path ("~/data/ghq/github.com/p-snow/org-web-track")
  :config
  (with-eval-after-load 'my-org-global-map
    (bind-keys :map my/org-global-map
               ("T q" . my/org-web-track-ql-view)
               ("T a" . org-web-track-agenda-view)
               ("T n" . org-web-track-setup)
               ("T u" . org-web-track-update)
               ("T U" . org-web-track-update-all)
               ("T i" . org-web-track-insert-value-change-table)))
  (setq org-web-track-selector-alist
        `((,(rx "www.amazon.co.jp"
                (+ anychar)
                "-ebook")
           "pup 'span[id=\"priceblock_ourprice\"],span[id=\"kindle-price\"],span[class=\"a-text-price\"],span[class=\"a-offscreen\"] json{}' \| jq -re '.[0].text'")
          (,(regexp-quote "www.amazon.co.jp/product-reviews")
           [.a-size-base.a-color-secondary] ; num of stars
           [.a-size-medium.a-color-base]) ; rating
          (,(regexp-quote "www.amazon.co.jp")
           [.a-price .a-offscreen]
           [div:availability span]) ; availability
          (,(regexp-quote "www.yodobashi.com/product")
           [:js_scl_unitPrice])
          (,(regexp-quote "kakaku.com/item")
           [.priceTxt])
          (,(regexp-quote "store.steampowered.com")
           "htmlq --text 'div.game_purchase_action:nth-child(4) > div:nth-child(1) > div:nth-child(1)'")
          ("www.googleapis.com/youtube/v3/channels"
           (lambda (json)
             (assoc-default 'subscriberCount
                            (assoc-default 'statistics (aref (cdr (assoc 'items json))
                                                             0)))))
          ("openexchangerates.org/api/latest"
           (lambda (json)
             (number-to-string
              (assoc-default 'JPY
                             (assoc-default 'rates json)))))
          ("map.kaldi.co.jp/kaldi"
           "pup 'div[class=\"shop_bnr news\"] ul li text{}' | xargs echo -n")))
  :preface
  (defun my/org-web-track-ql-view ()
    "Open Org Agenda view with tracking items which hold TRACK_URL property."
    (interactive)
    (with-current-buffer (get-buffer-create "Org Web Track")
      (org-agenda-mode)
      (setq-local org-overriding-columns-format org-web-track-columns-format
                  org-agenda-view-columns-initially t)
      (setq org-columns-modify-value-for-display-function
            'org-web-track-display-values)
      (when (require 'org-ql nil t)
        (org-ql-search org-web-track-files
          `(property ,org-web-track-url-property)
          :super-groups '((:tag "book") (:tag "food")
                          (:tag "tool") (:tag "supply"))
          :buffer (current-buffer)))))
  (defun my/org-web-track-update-all-and-notify ()
    "Update all web tracking items in `org-web-track-files'
 and send an email if any of them has changed its value."
    (when-let* ((changes (org-web-track-update-all))
                (mail-msg (mapconcat
                           (lambda (chg)
                             (org-with-point-at (car chg)
                               (let ((org-trust-scanner-tags t)
                                     (track-value
                                      (org-entry-get-multivalued-property (point)
                                                                          org-web-track-prev-property)))
                                 (format "%s\n\t%s\n"
                                         (substring-no-properties
                                          (org-get-heading t t t t))
                                         (org-web-track-changes (cdr chg)
                                                                track-value)))))
                           changes)))
      ;; you need to set SMTP info to smtpmail-xxx variables
      (let ((message-kill-buffer-on-exit t))
        (message-mail user-mail-address "Web Tracking Notification")
        (message-goto-body)
        (insert mail-msg)
        (message-send-and-exit))))
  :custom
  (org-agenda-bulk-custom-functions
   '((?W org-agenda-web-track-update)))
  (org-web-track-item-column-width 16)
  (org-web-track-update-column-width 30)
  (org-web-track-files
   (mapcan (lambda (dir)
             (directory-files dir t "^.+\\.org\\(?:\\.gpg\\)?$"))
           '("~/org/agenda/" "~/org/notes/"))))
#+end_src

******* batch tracking
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 21:05]
:END:

#+begin_src shell :eval no :tangle no :noweb-ref midnight-batch
export DISPLAY=:0 && \
  emacs -Q \
        -l ~/.emacs.d/early-init.el \
        -l ~/.emacs.d/elisp/config/my-org-web-track.el \
        -l ~/.emacs.d/elisp/config/batch/org-web-track-mail.el \
        -f my/org-web-track-mail
#+end_src

#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name "batch/org-web-track-mail.el" tangle/emacs-config-dir)
(provide 'my/org-mode-init)

(custom-set-variables
 '(message-send-mail-function 'smtpmail-send-it)
 '(smtpmail-smtp-server "<<smtp-host>>")
 '(smtpmail-smtp-service 465)
 '(smtpmail-smtp-user user-mail-address)
 '(smtpmail-stream-type 'ssl)
 '(smtpmail-mail-address user-mail-address)
 '(message-send-mail-function 'smtpmail-send-it))

(defun my/org-web-track-mail ()
  "Update `org-web-track' items along with sending email and immediate exit."
  (my/org-web-track-update-all-and-notify)
  (org-save-all-org-buffers)
  (save-buffers-kill-emacs t))
#+end_src

**** Completion

***** vertico

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-vertico"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/minad/vertico/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package vertico
  :bind (:map vertico-map
              ("C-j" . exit-minibuffer)
              ("RET" . vertico-directory-enter)
              ("C-h" . vertico-directory-delete-char)
              ("M-h" . vertico-directory-delete-word)
              ("M-q" . vertico-quick-insert)
              ("C-q" . vertico-quick-exit))
  :hook
  ((minibuffer-setup . vertico-repeat-save)
   ;; enable to write "~/" or "/" whatever path being input in minibuffer
   (rfn-eshadow-update-overlay . vertico-directory-tidy))
  :custom
  (vertico-cycle t)
  (vertico-scroll-margin 0)
  (vertico-count 11)
  (vertico-resize 'grow-only)
  :config
  (bind-keys ("M-R" . vertico-repeat))
  (vertico-mode 1))

(use-package vertico-multiform
  :after vertico
  :bind (:map vertico-map
              ("M-G" . vertico-multiform-grid))
  :config
  (vertico-multiform-mode 1))
#+end_src

***** consult

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-consult"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/minad/consult/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package consult
  :after my-org-global-map
  :bind (("C-;" . consult-buffer)
         ("C-c m" . consult-mode-command)
         ("C-c r" . consult-recent-file)
         ("C-c h" . consult-outline)
         ("C-x M-:" . consult-complex-command)
         ("M-y" . consult-yank-pop)
         ("C-M-y" . consult-yank-from-kill-ring)
         ("M-g M-g" . consult-goto-line)
         ("M-g m" . consult-mark)
         ("M-g M" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("C-x r j" . consult-register)
         ("M-s e" . consult-isearch-history)
         ("M-s \\" . consult-locate)
         ("M-s f" . consult-find)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("H-s" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ("M-s i" . consult-info)
         ("C-x M-#" . consult-theme)
         :map my/org-global-map
         ("h" . consult-org-agenda)
         :map isearch-mode-map
         ("C-M-n" . consult-isearch-history)
         ("M-l" . consult-line)
         ("M-L" . consult-line-multi)
         :map minibuffer-local-map
         ("C-M-n" . consult-history)
         :map text-mode-map
         ("C-M-i" . completion-at-point)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :custom
  (consult-narrow-key "<")
  (consult-widen-key ">")
  (consult-line-start-from-top t)
  (consult-project-root-function #'project-root-function)
  (consult-locate-args "plocate -d <<plocate-db()>> --ignore-case --existing --regexp")
  :init
  ;; use consult for completion unless Corfu is active
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))
  :config
  (with-eval-after-load 'org
    (bind-keys :map org-mode-map
               ("C-c H" . consult-org-heading))))

(defun project-root-function ()
  (when-let (project (project-current))
    (car (project-roots project))))
#+end_src

****** consult-dir
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 17:01]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-consult-dir"
#+end_src

#+begin_src emacs-lisp
(use-package consult-dir
  :after consult
  :bind ("H-d" . consult-dir))
#+end_src

****** affe
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 14:02]
:END:

#+begin_src emacs-lisp
(use-package affe
  :ensure t
  :bind (("M-s a f" . affe-find)
         ("M-s a g" . affe-grep)))
#+end_src

****** consult-ghq
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 15:56]
:END:

#+begin_src emacs-lisp
(use-package consult-ghq
  :ensure t
  :defer t
  :after consult
  :bind (("C-x g f" . consult-ghq-find)
         ("C-x g g" . consult-ghq-grep)))
#+end_src

***** embark

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-embark"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/oantolin/embark/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-." . embark-act)
         ("M-." . embark-dwim)
         ("<help> B" . embark-bindings)
         :map embark-file-map
         ("b" . browse-url))
  :init
  (setq prefix-help-command #'embark-prefix-help-command) ;
  :custom
  (embark-mixed-indicator-delay 3)
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  :config
  (require 'embark-consult)
  (require 'embark-org)
  (require 'avy-embark-collect)
  (push 'embark--allow-edit
        (alist-get 'shell-command-on-region embark-target-injection-hooks)))
#+end_src

***** marginalia
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 12:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-marginalia"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/minad/marginalia/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :after vertico
  :config
  (marginalia-mode 1))
#+end_src

***** orderless
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 12:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-orderless"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/oantolin/orderless/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package orderless
  :custom (completion-styles '(orderless)))
#+end_src

****** support for migemo in orderless

#+begin_src emacs-lisp
(defun orderless-migemo (component)
  (let ((pattern (migemo-get-pattern component)))
    (condition-case nil
        (progn (string-match-p pattern "") pattern)
      (invalid-regexp nil))))

(orderless-define-completion-style orderless-default-style
  (orderless-matching-styles '(orderless-literal
                               orderless-regexp)))

(orderless-define-completion-style orderless-migemo-style
  (orderless-matching-styles '(orderless-literal
                               orderless-regexp
                               orderless-migemo)))

;; uncomment below if you wish to apply migemo globally
;; (setq orderless-matching-styles '(orderless-literal orderless-regexp orderless-migemo))

(setq completion-category-overrides
      '((command (styles orderless-default-style))
        (file (styles orderless-migemo-style))
        (project-file (styles orderless-migemo-style))
        (buffer (styles orderless-migemo-style))
        (symbol (styles orderless-default-style))
        (multi-category (styles orderless-migemo-style))
        (consult-org-heading (styles orderless-migemo-style))
        (consult-location (styles orderless-migemo-style))
        (org-roam-node (styles orderless-migemo-style))
        (unicode-name (styles orderless-migemo-style))
        (variable (styles orderless-default-style))))
#+end_src

***** corfu
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:12]
:END:

Though I prefer vertico more for completion interface, [[https://github.com/minad/consult][consult manual]] says Vertico can't be used with Eglot or lsp-mode. So I decided to use Corfu only in prog-mode.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-corfu"
#+end_src

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode shell-mode eshell-mode) . corfu-mode)
  :custom
  (corfu-cycle t)
  (corfu-auto t)
  (corfu-preselect-first t))
#+end_src

***** cape
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:45]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-cape"
#+end_src

#+begin_src emacs-lisp
(use-package cape
  :bind (:map ctl-x-map
              :prefix "C-M-i"
              :prefix-map my/cape-map
              :prefix-docstring "Keymap for cape commands."
              ("C-M-i" . completion-at-point)
              ("d" . cape-dabbrev)
              ("h" . cape-history)
              ("f" . cape-file)
              ("k" . cape-keyword)
              ("s" . cape-symbol)
              ("a" . cape-abbrev)
              ("l" . cape-line)
              ("w" . cape-dict)
              ("\\" . cape-tex)
              ("_" . cape-tex)
              ("^" . cape-tex)
              ("&" . cape-sgml)
              ("r" . cape-rfc1345))
  :hook
  (text-mode . (lambda ()
                 (setq-local completion-at-point-functions
                             (append completion-at-point-functions
                                     '(cape-dabbrev
                                       cape-file
                                       cape-symbol
                                       cape-dict)))))
  (prog-mode . (lambda ()
                 (setq-local completion-at-point-functions
                             (append completion-at-point-functions
                                     '(cape-dabbrev
                                       cape-file
                                       cape-symbol
                                       cape-keyword
                                       cape-history))))))
#+end_src

**** text-mode and its derivatives

***** nxml-mode

#+begin_src emacs-lisp
(use-package nxml-mode
  :delight (nxml-mode " XM")
  :mode (("\.xml$"   . nxml-mode)
         ("\.xsl$"   . nxml-mode)
         ("\.xhtml$" . nxml-mode)
         ("\.page$"  . nxml-mode)
         ("\.plist$" . nxml-mode))
  :hook (nxml-mode . my/prog-mode-hook-function)
  :custom
  (nxml-child-indent 2)
  (nxml-attribute-indent 2)
  (nxml-slash-auto-complete-flag t)
  :config
  (setq-local tab-width 2)
  ;; pattern in hideshow mode for nxml mode
  (add-to-list 'hs-special-modes-alist
               (list 'nxml-mode
                     "<!--\\|<[^/>]*[^/]>"
                     "-->\\|</[^/>]*[^/]>"
                     "<!--"
                     'nxml-forward-element
                     nil)))
#+end_src

***** toml-mode
:PROPERTIES:
:CREATED:  [2023-06-01 Thu 18:01]
:END:

language grammar for toml

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(toml "https://github.com/tree-sitter/tree-sitter-toml")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(toml-mode . toml-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package toml
  :mode "\\.toml$")
#+end_src

***** yaml-mode

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(yaml "https://github.com/ikatyang/tree-sitter-yaml")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(yaml-mode . yaml-ts-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref combobulate-hook
(yaml-ts-mode . combobulate-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package yaml
  :mode "\\.ya?ml$")
#+end_src

***** json-mode
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 15:07]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-json"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(json-mode . json-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package json
  :mode "\\.json$")
#+end_src

***** markdown-mode
:PROPERTIES:
:CREATED:  [2023-06-02 Fri 18:02]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"markdown"
"tree-sitter-markdown"
"emacs-markdown-mode"
#+end_src

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode "\\.md$")
#+end_src

***** tex-mode

#+begin_src emacs-lisp
(use-package tex-mode
  :mode ("\\.tex$" . latex-mode)
  :hook ((tex-mode . (lambda () (setq ispell-parser 'tex))))
  :config
  (my/add-dash-docsets-hook 'latex-mode-hook '("LaTeX")))
#+end_src

**** prog-mode and its derivatives

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook
          #'my/prog-mode-hook-function)

(defun my/prog-mode-hook-function ()
  (hl-line-mode -1)
  (hs-minor-mode -1)
  (display-fill-column-indicator-mode 1)
  (prettify-symbols-mode 1))
#+end_src

***** sh-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-bash"
#+end_src

#+begin_src emacs-lisp
(use-package sh-script
  :delight " SH"
  :commands sh-mode
  :mode ("\\.sh$" . sh-mode)
  :custom
  (sh-basic-offset 2)
  (sh-indent-after-if '+)
  (sh-indent-for-case-label 0)
  (sh-indent-for-case-alt '+)
  :config
  (my/add-dash-docsets-hook 'sh-mode-hook '("Bash")))
#+end_src

***** emacs-lisp-mode

I'm in the trial of pp-eval-last-sexp instead of eval-last-sexp adviced from [[https://karthinks.com/software/an-elisp-editing-tip/][this blog post]]

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(elisp "https://github.com/Wilfred/tree-sitter-elisp")
#+end_src

#+begin_src emacs-lisp
(use-package elisp-mode
  :mode ("\\.eld?$" . emacs-lisp-mode)
  :commands emacs-lisp-mode
  :hook (emacs-lisp-mode . (lambda ()
                             (push '("lambda" . ?λ) prettify-symbols-alist)
                             (setq-local tab-width 8)
                             (eldoc-mode 1)))
  :config
  (require 'eldoc)
  (substitute-key-definition 'eval-last-sexp
                             'pp-eval-last-sexp
                             global-map)
  (my/add-dash-docsets-hook 'emacs-lisp-mode-hook
                            '("Emacs Lisp")))

(defun my/elisp-mode-eval-buffer ()
  (interactive)
  (message "Evaluated buffer")
  (eval-buffer))

(define-key emacs-lisp-mode-map (kbd "C-c C-c") #'my/elisp-mode-eval-buffer)
(define-key lisp-interaction-mode-map (kbd "C-c C-c") #'my/elisp-mode-eval-buffer)
#+end_src

***** lisp-mode
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 16:53]
:END:

#+begin_src emacs-lisp
(use-package lisp-mode
  :mode "\\.lisp$"
  :config
  (my/add-dash-docsets-hook 'lisp-mode-hook
                            '("Common Lisp")))
#+end_src

****** sly
:PROPERTIES:
:CREATED:  [2023-12-18 Mon 14:53]
:END:

[[https://github.com/joaotavora/sly#start-of-content][Sly]], a fork of [[https://slime.common-lisp.dev/][Slime]].

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-sly"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package sly
  :custom
  (inferior-lisp-program "<<which(filename="sbcl")>>")
  (sly-auto-start 'ask)
  :config
  (with-eval-after-load 'ob-lisp
    (setopt org-babel-lisp-eval-fn 'sly-eval)))
#+end_src

***** scheme-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-scheme"
#+end_src

#+begin_src emacs-lisp
(use-package scheme
  :mode (("\\.guix-channel" . scheme-mode)
         ("\\.guix-authorizations" . scheme-mode)))
#+end_src

***** c-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-c"
#+end_src

#+begin_src emacs-lisp
(use-package cc-mode
  :defer 10
  :custom
  (c-tab-always-indent t)
  (c-auto-align-backslashes nil)
  (c-echo-syntactic-information-p t)
  (c-default-style "my/c-style")
  :config
  (my/add-dash-docsets-hook 'c-mode-common-hook
                            '("C"))
  (c-toggle-auto-newline 1)
  (c-add-style "my/c-style"
               '((c-basic-offset . 4)
                 (c-comment-only-line-offset . 0)
                 (c-hanging-braces-alist
                  . ((brace-if-brace before after)
                     (substatement-open before after)))
                 (c-hanging-colons-alist
                  . ((case-label after)))
                 (c-cleanup-list
                  . (brace-else-brace
                     brace-elseif-brace
                     empty-defun-braces
                     defun-close-semi
                     list-close-comma
                     scope-operator))
                 (c-offsets-alist
                  . ((arglist-intro . +)
                     (arglist-cont-nonempty . c-lineup-arglist)))))
  (c-add-style "my/objc-style"
               '((c-basic-offset . 2)
                 (c-comment-only-line-offset . 0)
                 (c-hanging-braces-alist
                  . ((brace-if-brace before after)
                     (substatement-open before after)))
                 (c-hanging-colons-alist
                  . ((case-label after)))
                 (c-cleanup-list
                  . (brace-else-brace
                     brace-elseif-brace
                     empty-defun-braces
                     defun-close-semi
                     list-close-comma
                     scope-operator))
                 (c-offsets-alist
                  . ((arglist-intro . +)
                     (arglist-cont-nonempty . c-lineup-arglist))))))
#+end_src

***** rustic
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 17:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-rustic"
#+end_src

#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :custom
  (rustic-lsp-client "eglot")
  :config
  (my/add-dash-docsets-hook 'rustic-mode-hook
                            '("Rust")))
#+end_src

***** python-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-python"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(python-mode . python-ts-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref combobulate-hook
(python-ts-mode . combobulate-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package python
  :mode "\\.py\\'"
  :interpreter "python"
  :hook
  ((python-mode inferior-python-mode) .
   (lambda ()
     (setq-local flycheck-checker 'python-pylint)))
  :config
  (my/add-dash-docsets-hook 'python-mode-hook
                            '("Python 3"))
  (my/add-dash-docsets-hook 'inferior-python-mode-hook
                            '("Python 3")))

(defvar python-mode-initialized nil)

(defun my-python-mode-hook ()
  (setq-local flycheck-checker 'python-pylint)
  (jedi:setup)
  (jedi-mode 1)
  (unless python-mode-initialized
    (setq python-mode-initialized t)
    (info-lookup-add-help
     :mode 'python-mode
     :regexp "[a-zA-Z_0-9.]+"
     :doc-spec
     '(("(python)Python Module Index" )
       ("(python)Index"
        (lambda
          (item)
          (cond
           ((string-match
             "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
            (format "%s.%s" (match-string 2 item)
                    (match-string 1 item))))))))))
#+end_src

****** emacs-project

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-company-jedi"
#+end_src

#+begin_src emacs-lisp
(use-package company-jedi
  :after python
  :hook (python-mode . my/python-mode-hook)
  :custom
  (jedi:tooltip-method nil)
  :config
  (defun my/python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi)))
#+end_src

***** ruby-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-ruby"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(ruby-mode . ruby-ts-mode)
#+end_src

#+begin_src emacs-lisp
(use-package ruby
  :mode (("\\.rb$"   . ruby-mode)
         ("Capfile$" . ruby-mode)
         ("Gemfile$" . ruby-mode))
  :interpreter (("ruby"    . ruby-mode)
                ("rbx"     . ruby-mode)
                ("jruby"   . ruby-mode))
  :config
  (setq ruby-indent-level 2)
  (setq ruby-insert-encoding-magic-comment nil)
  (add-hook 'ruby-mode-hook
            '(lambda ()
               (setq-local flycheck-checker 'ruby-rubocop)))
  (add-to-list 'hs-special-modes-alist
               `(ruby-mode
                 ,(rx (or "def" "class" "module" "do" "if" "{" "[")) ; Block start
                 ,(rx (or "}" "]" "end"))                       ; Block end
                 ,(rx (or "#" "=begin"))                        ; Comment start
                 ruby-forward-sexp nil))
  (my/add-dash-docsets-hook 'ruby-mode-hook '("Ruby")))
#+end_src

****** inf-ruby

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-inf-ruby"
#+end_src

#+begin_src emacs-lisp
(use-package inf-ruby
  :after ruby
  :config
  (setq inf-ruby-default-implementation "pry")
  (add-to-list 'inf-ruby-implementations '("pry" . "pry"))
  (setq inf-ruby-eval-binding "Pry.toplevel_binding")
  (setq inf-ruby-first-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)> *")
  (setq inf-ruby-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)[>*\"'] *"))
#+end_src

***** lua-mode

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-lua-mode"
# #+end_src

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-mode))
#+end_src

***** perl-mode

#+begin_src emacs-lisp
(use-package perl-mode
  :delight " PL")
#+end_src

***** web-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-web-mode"
"tree-sitter-html"
"tree-sitter-css"
#+end_src

#+begin_src emacs-lisp
(use-package web-mode
  :delight " WB"
  :mode (("\\.phtml$"     . web-mode)
         ("\\.tpl\\.php$" . web-mode)
         ("\\.jsp$"       . web-mode)
         ("\\.as[cp]x$"   . web-mode)
         ("\\.erb$"       . web-mode)
         ("\\.html?$"     . web-mode))
  :custom
  (web-mode-attr-indent-offset        2)
  (web-mode-attr-value-indent-offset  2)
  (web-mode-code-indent-offset        2)
  (web-mode-css-offset                2)
  (web-mode-markup-indent-offset      2)
  (web-mode-sql-indent-offset         2)
  (web-mode-block-padding             2)
  (web-mode-script-padding            2)
  :config
  (my/add-dash-docsets-hook 'web-mode-hook '("HTML")))
#+end_src

***** css-mode

#+begin_src emacs-lisp
(with-eval-after-load 'css-mode
  (customize-set-variable 'css-indent-offset 2)
  (my/add-dash-docsets-hook 'css-mode-hook '("CSS")))
#+end_src

***** js2-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-js2-mode"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(js2-mode . js-ts-mode)
(css-mode . css-ts-mode)
#+end_src

#+begin_src emacs-lisp
(use-package js2-mode
  :delight " J2"
  :mode (("\\.js\\(on\\)?\\'" . js2-mode)
         ("\\.eslintrc\\'"    . js2-mode))
  :hook (js2-mode . (lambda ()
                      (setq-local flycheck-checker 'javascript-eslint)
                      (setq-local flycheck-disabled-checkers '(javascript-jshint javascript-jscs))))
  :custom
  (flycheck-javascript-eslint-executable "eslint")
  (my/add-dash-docsets-hook 'js2-mode-hook '("JavaScript")))

(use-package js
  :defer 10
  :delight " JS"
  :custom
  (js-indent-level 2))
#+end_src

***** make
:PROPERTIES:
:CREATED:  [2023-06-02 Fri 19:18]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(cmake "https://github.com/uyha/tree-sitter-cmake")
(make "https://github.com/alemuller/tree-sitter-make")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(cmake-mode . cmake-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package cmake
  :mode (("\\.mk$" . cmake-mode)
         ("^Makefile$" . cmake-mode)))
#+end_src

***** sql-mode

#+begin_src emacs-lisp
(use-package sql
  :delight " SQ"
  :commands (sql-mode)
  :mode (("\\.sql$" . sql-mode))
  :bind (:map sql-interactive-mode-map
              ("C-j" . comint-send-input))
  :hook (sql-mode . (lambda ()
                      (setq-local flycheck-checker 'sql-sqlint))))
#+end_src

***** plantuml-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-plantuml-mode"
#+end_src

#+begin_src emacs-lisp
(use-package plantuml
  :mode "\\.plu$"
  :custom
  (plantuml-jar-path "~/.guix-extra-profiles/emacs/emacs/share/java/plantuml.jar")
  (plantuml-exec-mode 'jar)
  :config
  (my/add-dash-docsets-hook 'plantuml-mode-hook '("PlantUML")))
#+end_src

***** conf

#+begin_src emacs-lisp
(use-package conf-mode
  :delight " CF")
#+end_src

***** generic-x

#+begin_src emacs-lisp
(use-package generic-x
  :mode (("\\.conf$"     . apache-conf-generic-mode)
         ("\\.htaccess$" . apache-conf-generic-mode)))
#+end_src

**** special-mode derivatives
:PROPERTIES:
:CREATED:  [2022-08-23 Tue 18:51]
:END:

***** special mode

#+begin_src emacs-lisp
(define-key special-mode-map (kbd "C-j") #'push-button)
#+end_src

***** help
:PROPERTIES:
:ID:       a55da7a2-6525-4788-ba56-085eb61928d4
:END:

#+begin_src emacs-lisp
(customize-set-variable 'help-enable-symbol-autoload t)
(customize-set-variable 'describe-bindings-outline t)

(with-eval-after-load 'help
  (define-key help-map (kbd "C-?") #'help-for-help)
  (define-key help-map (kbd "c") #'describe-face)
  (define-key help-map (kbd "K") #'describe-keymap)
  (define-key help-map (kbd "C-l") #'find-library))
#+end_src

***** woman

#+begin_src emacs-lisp
(autoload #'woman "woman" nil t)
#+end_src

**** Programming

***** sMerge
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 19:57]
:END:

sMerge can be used to solve merging problems. The code below kicks off sMerge if there is a collision sign.

#+begin_src emacs-lisp
(autoload 'smerge-mode "smerge-mode" nil t)

(defun my/try-smerge ()
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^<<<<<<< " nil t)
      (smerge-mode 1))))
(add-hook 'find-file-hook 'my/try-smerge t)
#+end_src

***** Next Error

#+begin_src emacs-lisp
(customize-set-variable 'next-error-message-highlight t)
#+end_src

***** Hideshow

#+begin_src emacs-lisp
(use-package hideshow
  :diminish "hs"
  :bind (("C-c TAB" . hs-toggle-hiding)))
#+end_src

***** imenu

#+begin_src emacs-lisp
(use-package imenu
  :custom
  (imenu-auto-rescan t))
#+end_src
***** compile

#+begin_src emacs-lisp
(use-package compile
  :bind (:map compilation-mode-map
              ("C-j" . compile-goto-error)))
#+end_src

***** grep

#+begin_src emacs-lisp
(use-package grep
  :custom
  (grep-program "rg")
  :config
  (bind-keys :map grep-mode-map
             ("C-j" . compile-goto-error)))

(defun my/grep-ripgrep-all ()
  "Grep many kind of files like pdf, epub and more."
  (interactive)
  (let ((grep-find-command '("rga --with-filename --no-heading --line-number --color never -e '' ./* ./**/*" . 66)))
    (call-interactively 'grep-find)))

(global-set-key (kbd "M-s R") 'my/grep-ripgrep-all)
#+end_src

***** executable

[[https://emacsredux.com/blog/2021/09/29/make-script-files-executable-automatically/][The post]] says it is useful to set executable bit if the saved file seems to be script.

#+begin_src emacs-lisp
(with-eval-after-load 'executable
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p))
#+end_src

***** Paren Showing

#+begin_src emacs-lisp
(use-package paren
  :hook (prog-mode . show-paren-local-mode)
  :custom
  (show-paren-style 'mixed)
  (show-paren-delay 0.2)
  (show-paren-mode nil)
  (show-paren-context-when-offscreen t))
#+end_src

***** project

#+begin_src emacs-lisp
(use-package project
  :custom
  (project-kill-buffers-display-buffer-list t)
  :config
  (add-to-list 'project-switch-commands
               '(project-dired "Dired root"))
  (with-eval-after-load 'magit
    (bind-keys :map project-prefix-map
               ("M" . magit-project-status))
    (add-to-list 'project-switch-commands
                 '(magit-project-status "Magit"))))
#+end_src

***** log-view

#+begin_src emacs-lisp
(use-package log-view
  :delight
  (log-view-mode " LV")
  :mode ("\\.log$" . log-view-mode)
  :hook ((log-view-mode . my/prog-mode-hook-function )
         (log-view-mode . auto-revert-tail-mode)))
#+end_src

***** vc (version control)
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:
***** vc-hooks

#+begin_src emacs-lisp
(use-package vc-hooks
  :custom
  (vc-follow-symlinks t))
#+end_src
**** Tree Sitter
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:00]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter"
#+end_src

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(use-package treesit
  :preface
  (defun my/setup-install-grammars ()
    "Install Tree-sitter grammars if they are absent."
    (interactive)
    (dolist (grammar
             '(<<treesit-language-source>>))
      (add-to-list 'treesit-language-source-alist grammar)
      (unless (treesit-language-available-p (car grammar))
        (treesit-install-language-grammar (car grammar)))))
  :config
  (my/setup-install-grammars))
#+end_src

***** combobulate
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:08]
:END:

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(use-package combobulate
  :after treesit
  :preface
  (setq combobulate-key-prefix "C-c o")
  :hook (<<combobulate-hook>>)
  :load-path ("~/.emacs.d/site-elisp/combobulate/"))
#+end_src

***** major mode remapping
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:12]
:END:

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(setq major-mode-remap-alist
      '(<<major-mode-remap-rule>>))
#+end_src

**** Elisp Package Development
:PROPERTIES:
:CREATED:  [2023-06-08 Thu 13:58]
:END:

***** Eldev
:PROPERTIES:
:CREATED:  [2023-06-08 Thu 14:02]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-eldev"
#+end_src

**** sundry 3rd-party packages

Packages below are out of categories above. Packages which have ARCHIVE tag is no longer in use. Keywords which package gives in its description are set to tag.

***** git-modes

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-modes"
#+end_src

#+begin_src emacs-lisp
(use-package git-modes)
#+end_src

***** git-annex

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-annex"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/jwiegley/git-annex-el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package git-annex
  :after dired
  :custom-face
  (git-annex-dired-annexed-available ((t (:foreground "green yellow"))))
  (git-annex-dired-annexed-unavailable ((t (:foreground "red3")))))
#+end_src

***** magit-annex                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-24 Sat 15:47]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-magit-annex"
# #+end_src

#+begin_src emacs-lisp :tangle no
(use-package magit-annex)
#+end_src

***** orgit

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-orgit"
#+end_src

#+begin_src emacs-lisp
(use-package orgit
  :after org
  :custom
  (orgit-remote "github"))
#+end_src

***** suggest
:PROPERTIES:
:CREATED:  [2023-10-11 Wed 11:12]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-suggest"
#+end_src

#+begin_src emacs-lisp
(use-package suggest
  :commands suggest
  :custom
  (suggest-insert-example-on-start nil))
#+end_src

***** mastodon
:PROPERTIES:
:CREATED:  [2023-09-24 Sun 02:23]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-mastodon"
#+end_src

#+begin_src emacs-lisp
(use-package mastodon
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("@" . mastodon))
  :hook (mastodon-mode . visual-line-mode)
  :custom
  (mastodon-active-user "p_snow")
  (mastodon-instance-url "https://emacs.ch")
  :config
  (require 'mastodon-views))
#+end_src

***** bookmark+
:PROPERTIES:
:CREATED:  [2023-09-17 Sun 14:58]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-bookmark-plus"
#+end_src

#+begin_src emacs-lisp
(use-package bookmark+
  :defer 2
  :after bookmark)
#+end_src

***** chatgpt-shell
:PROPERTIES:
:CREATED:  [2023-09-12 Tue 17:42]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-chatgpt-shell"
#+end_src

#+begin_src emacs-lisp
(use-package chatgpt-shell
  :after engine-mode
  :defer 7
  :preface
  (defun my/chatgpt-shell-dwim ()
    "docstring"
    (interactive)
    (if (use-region-p)
        (chatgpt-shell-prompt-compose)
      (chatgpt-shell)))
  (defun my/openai-key ()
    "Return my openai key."
    (or (cdr (assoc "API key" (auth-source-pass-parse-entry "openai.com")))
        (let ((sec (plist-get (car (auth-source-search :host "openai.com")) :secret)))
          (if (functionp sec)
              (funcall sec) sec))))
  :bind (:map engine-mode-prefixed-map
              ("c c" . my/chatgpt-shell-dwim)
              ("c C" . chatgpt-shell-prompt)
              ("c e" . chatgpt-shell-explain-code)
              ("c d" . chatgpt-shell-describe-code)
              ("c p" . chatgpt-shell-proofread-region)
              ("c g" . chatgpt-shell-write-git-commit)
              ("c u" . chatgpt-shell-generate-unit-test)
              :map chatgpt-shell-mode-map
              ("C-M-g" . chatgpt-shell-clear-buffer))
  :custom
  (chatgpt-shell-openai-key 'my/openai-key)
  (chatgpt-shell-system-prompt 3)
  (chatgpt-shell-model-temperature 0.6))

(use-package ob-chatgpt-shell
  :after (chatgpt-shell ob-core)
  :config
  (ob-chatgpt-shell-setup)
  (add-to-list 'org-structure-template-alist
               '("ch" . "src chatgpt-shell")
               t))

(use-package dall-e-shell
  :commands dall-e-shell
  :custom
  (dall-e-shell-openai-key 'my/openai-key))
#+end_src

***** async
:PROPERTIES:
:CREATED:  [2023-07-15 Sat 08:18]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-async"
#+end_src

#+begin_src emacs-lisp
(use-package dired-async
  :after dired
  :config
  (dired-async-mode 1))
#+end_src

***** visible-mark              :marking:faces:color:
:PROPERTIES:
:CREATED:  [2023-07-01 Sat 13:40]
:END:

#+begin_src emacs-lisp
(use-package visible-mark
  :ensure t
  :config
  (global-visible-mark-mode 1))
#+end_src

***** ement                                    :comm:
:PROPERTIES:
:CREATED:  [2023-06-27 Tue 10:45]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ement"
#+end_src

***** ligature                      :extensions:data:
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 17:21]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ligature"
#+end_src

#+begin_src emacs-lisp
(use-package ligature
  :hook (prog-mode . ligature-mode)
  :config
  ;; ligatures below are supported by `Iosevka' font
  (ligature-set-ligatures 'prog-mode
                          '("-<<" "-<" "-<-" "<--" "<---" "<<-" "<-" "->" "->>" "-->" "--->" "->-" ">-" ">>-"
                            "=<<" "=<" "=<=" "<==" "<===" "<<=" "<=" "=>" "=>>" "==>" "===>" "=>=" ">=" ">>="
                            "<->" "<-->" "<--->" "<---->" "<=>" "<==>" "<===>" "<====>" "::" ":::" "__"
                            "<~~" "</" "</>" "/>" "~~>" "==" "!=" "/=" "~=" "<>" "===" "!==" "!===" "=/=" "=!="
                            "<:" ":=" "*=" "*+" "<*" "<*>" "*>" "<|" "<|>" "|>" "<." "<.>" ".>" "+*" "=*" "=:" ":>"
                            "(*" "*)" "/*" "*/" "[|" "|]" "{|" "|}" "++" "+++" "\\/" "/\\" "|-" "-|" "<!--" "<!---")))
#+end_src

***** meow        :modal_editing:convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 12:36]
:END:

[[https://github.com/meow-edit/meow][meow]] offers modal editing functionality and more. I tried it on [2023-05-31 Wed], but overwhelmed a bit. Following configuration for meow will be save for future use.

#+begin_src emacs-lisp
(use-package meow
  :disabled t
  :preface
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))
  :config
  (meow-setup)
  (meow-global-mode 1))
#+end_src

***** enlive                     :selector:query:css:
:PROPERTIES:
:CREATED:  [2023-04-28 Fri 15:49]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-enlive"
#+end_src

***** gptel                             :convenience:
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:53]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-gptel"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package gptel
  :after engine-mode
  :bind (:map engine-mode-prefixed-map
              ("C" . gptel))
  :custom
  (gptel-api-key "<<openai-api-key()>>")
  (gptel-max-tokens 500)
  (gptel-model "gpt-3.5-turbo")
  (gptel-default-mode 'org-mode))
#+end_src

#+name: openai-api-key
#+begin_src emacs-lisp
(auth-source-pass-get "API key" "openai.com")
#+end_src

***** engine-mode
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 16:27]
:ID:       db630173-d371-45de-a78e-bcc57cb9d50c
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-engine-mode"
#+end_src

#+begin_src emacs-lisp
(use-package engine-mode
  :custom
  (engine/browser-function 'eww-browse-url)
  :config
  (engine/set-keymap-prefix (kbd "H-q"))
  (engine-mode 1)
  (defengine google
    "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "g")
  (defengine google-images
    "https://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
    :keybinding "i")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")
  (defengine youtube
    "https://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y")
  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "h")
  (defengine amazon
    "https://www.amazon.co.jp/gp/search/?field-keywords=%s"
    :keybinding "a")
  (defengine melpa
    "https://melpa.org/#/?q=%s"
    :keybinding "m")
  (defengine eijiro
    "https://eow.alc.co.jp/search?q=%s"
    :keybinding "e")
  (defengine weblio
    "https://www.weblio.jp/content/%s"
    :keybinding "l")
  (defengine wikipedia-ja
    "https://ja.wikipedia.org/wiki/%s"
    :keybinding "w")
  (defengine wikipedia
    "https://en.wikipedia.org/wiki/%s"
    :keybinding "W"))
#+end_src

***** tmr                         :timer:convenience:
:PROPERTIES:
:CREATED:  [2023-03-06 Mon 14:16]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-tmr"
#+end_src

#+begin_src emacs-lisp
(use-package tmr
  :after my-launch-app
  :bind (("C-x M-t t"   . tmr)
         ("C-x M-t M-t" . tmr)
         ("C-x M-t x"   . tmr-cancel)
         ("C-x M-t k"   . tmr-remove)
         ("C-x M-t s"   . tmr-reschedule)
         ("C-x M-t l"   . tmr-tabulated-view)
         :map my/launch-app-map
         ("t" . tmr)))
#+end_src

***** beframe
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 15:47]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-beframe"
#+end_src

#+begin_src emacs-lisp
(use-package beframe
  :ensure t
  :bind (("C-x B" . beframe-switch-buffer)
         ("C-x C-b" . beframe-buffer-menu))
  :custom
  (beframe-global-buffers '("*Messages*" "*Backtrace*"))
  (beframe-create-frame-scratch-buffer nil)
  :config
  (with-eval-after-load 'consult
    (defface beframe-buffer
      '((t :inherit font-lock-string-face))
      "Face for `consult' framed buffers.")
    (defvar beframe--consult-source
      `( :name     "Frame-specific buffers (current frame)"
         :narrow   ?F
         :category buffer
         :face     beframe-buffer
         :history  beframe-history
         :items    ,#'beframe--buffer-names
         :action   ,#'switch-to-buffer
         :state    ,#'consult--buffer-state))
    (add-to-list 'consult-buffer-sources 'beframe--consult-source))
  (beframe-mode 1))
#+end_src

***** free-keys                         :convenience:
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 21:51]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-free-keys"
#+end_src

#+begin_src emacs-lisp
(use-package free-keys
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("f" . free-keys))
  :config
  (setq free-keys-modifiers (append free-keys-modifiers
                                    '("H"))))
#+end_src

***** consult-recoll               :docs:convenience:
:PROPERTIES:
:CREATED:  [2023-02-11 Sat 22:31]
:END:

#+begin_src emacs-lisp
(use-package consult-recoll
  :ensure t
  :after consult
  :bind ("M-s c" . consult-recoll)
  :preface
  (defun my/consult-recoll--html (file)
    (let ((mime (mailcap-extension-to-mime (file-name-extension file))))
      (cond
       ((string= mime (regexp-quote "application/epub+zip"))
        (my/open-epub-as-html file))
       (t (eww-open-file file)))))
  :custom
  (consult-recoll-open-fns
   '(("text/html" . my/consult-recoll--html)
     ("application/pdf" . my/open-pdf-as-html))))
#+end_src

***** detached                :processes:convenience:
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 15:35]
:END:

How to use detached.el
- in vterm
  1. create a session with S-RET(detached-vterm-send-input)
  2. detach from the session with C-c C-d(detached-detach-key)
  3. attach to the session with C-RET(detached-vterm-attach)
- with shell-command
  - invoke/call detached-shell-command

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"dtach"
"emacs-detached"
#+end_src

#+begin_src emacs-lisp
(use-package detached
  :init
  (detached-init)
  :bind
  (([remap async-shell-command] . detached-shell-command)
   ([remap compile] . detached-compile)
   ([remap recompile] . detached-compile-recompile))
  :custom
  (detached-shell-command-initial-input nil)
  (detached-terminal-data-command system-type)
  (detached-terminal-data-command system-type))

(defun my/org-link--open-shell-detached (path _)
  "Open a \"shell\" type.

PATH is the command to execute with `detached-shell-command'."
  (if (or (and (org-string-nw-p org-link-shell-skip-confirm-regexp)
               (string-match-p org-link-shell-skip-confirm-regexp path))
          (not org-link-shell-confirm-function)
          (funcall org-link-shell-confirm-function
                   (format "Execute %s in shell? "
                           (org-add-props path nil 'face 'org-warning))))
      (progn
        (message "Executing %s" path)
        (detached-shell-command path))
    (user-error "Abort")))

(with-eval-after-load 'ol
  (org-link-set-parameters "shell" :follow #'my/org-link--open-shell-detached))

(use-package detached-list
  :after my-launch-app
  :bind (:map my/invoke-list-command-map
              ("d" . detached-list-sessions))
  :config
  (bind-keys :map detached-list-mode-map
             ("C-m" . detached-list-open-session)
             ("C-j" . detached-list-open-session)))
#+end_src

***** emacs-guix                              :tools:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 14:08]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-guix"
#+end_src

#+begin_src emacs-lisp
(use-package guix
  :commands guix
  :config
  (with-eval-after-load 'my-launch-app
    (bind-keys :map my/launch-app-map
               ("x" . guix))))
#+end_src

***** pcre2el
:PROPERTIES:
:CREATED:  [2022-12-06 Tue 16:50]
:END:

[[https://github.com/joddie/pcre2el][pcre2el]] is not only the converter between PCRE, emacs lisp style regexp and RX representation. It support re-builder as a conversion environment. Great!

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-pcre2el"
#+end_src

#+begin_src emacs-lisp
(use-package pcre2el)
#+end_src

***** iedit :simultaneous:region:refactoring:occurrence:
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 18:02]
:END:

[[https://github.com/victorhge/iedit][IEdit]] is not only replacement for M-%/C-M-% but it highlights symbol occurences to change. [[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][This advise]] would be useful for anyone who needs dedicated command to replace symbols in defun.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-iedit"
#+end_src

#+begin_src emacs-lisp
(customize-set-variable 'iedit-toggle-key-default (kbd "C-\""))
(customize-set-variable 'iedit-auto-narrow t)

;; require clause should sit here to supress key occupation warning
(require 'iedit)

(global-set-key (kbd "C-\"") 'iedit-mode)
#+end_src

***** ledger-mode / flycheck-ledger :tools:languages:convenience:
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 21:08]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ledger-mode"
"emacs-flycheck-ledger"
#+end_src

#+begin_src emacs-lisp
(use-package ledger-mode
  :bind (:map ledger-mode-map
              ("C-c C-y" . ledger-copy-transaction-at-point))
  :custom
  (ledger-reconcile-default-commodity "\\")
  :config
  (require 'flycheck-ledger)
  (with-eval-after-load 'ob-core
    (require 'ob-ledger)))
#+end_src

***** mentor              :processes:comm:bittorrent:
:PROPERTIES:
:CREATED:  [2022-10-04 Tue 22:09]
:END:

[[https://github.com/skangas/mentor][mentor]] is a [[id:bdc987ad-419b-4f36-922d-de75207d85c0][rTorrent]] client for emacs.

Typical file downloading workflow:
1. start mentor: M-x mentor
2. add magnet link (URL or torrent file path): M-x mentor-download-load-magnet-link-or-url (l)
3. view downloaded file in dired: M-x mentor-dired-jump (v)
4. shutdown mentor: M-x mentor-shutdown (Q)

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-mentor"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package mentor
  :commands mentor
  :custom
  (mentor-rtorrent-download-directory "<<torrent-dir()>>")
  (mentor-rtorrent-keep-session t)
  (mentor-rtorrent-external-rpc "<<rtorrent-sock()>>"))
#+end_src

***** geiser                :scheme:languages:geiser:
:PROPERTIES:
:CREATED:  [2022-09-06 Tue 15:26]
:END:

[[info:guix#The Perfect Setup][guix#The Perfect Setup]]

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"guile"
"emacs-geiser"
"emacs-geiser-guile"
#+end_src

#+begin_src emacs-lisp :noweb yes
(use-package geiser-guile
  :commands (scheme-mode)
  :config
  (add-to-list 'geiser-guile-load-path
               (file-name-concat "<<ghq-root()>>" "git.savannah.gnu.org/git/guix"))
  (with-eval-after-load 'yasnippet
    (add-to-list 'yas-snippet-dirs
                 (file-name-concat "<<ghq-root()>>" "git.savannah.gnu.org/git/guix/etc/snippets/yas")
                 t))
  (load-file (file-name-concat "<<ghq-root()>>" "git.savannah.gnu.org/git/guix/etc/copyright.el")))
#+end_src

***** consult-dash                :docs:dash:consult:
:PROPERTIES:
:CREATED:  [2022-08-05 Fri 16:56]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dash-docs"
#+end_src

#+begin_src emacs-lisp
(use-package dash-docs
  :custom
  (dash-docs-docsets-path
   (file-name-concat my/user-share-directory "dash/docsets")))

(add-to-list 'load-path
             (expand-file-name "elpa/consult-dash-20220621.226" user-emacs-directory-default))

(use-package consult-dash
  :after dash-docs
  :bind ("M-s M-d" . consult-dash))
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "00-my-early-config.el" tangle/emacs-config-dir)
(defmacro my/add-dash-docsets-hook (hook docsets)
  `(add-hook ,hook
             (lambda ()
               (when (functionp 'consult-dash)
                 (setq-local consult-dash-docsets ,docsets)))))
#+end_src

***** denote
:PROPERTIES:
:CREATED:  [2022-08-02 Tue 20:08]
:ID:       d5bd559a-2cab-4495-993b-f7a21637f0ea
:END:

[[https://protesilaos.com/emacs/denote][Denote]] leverages note taking in org mode by providing file naming scheme and backlink capability.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-denote"
#+end_src

#+begin_src emacs-lisp
(use-package denote
  :after my/org-mode-init
  :custom
  (denote-directory (expand-file-name "~/org/notes"))
  :config
  (require 'denote-org-dblock)
  (with-eval-after-load 'org-capture
    (setq denote-org-capture-specifiers "%l\n%i\n%?")
    (add-to-list 'org-capture-templates
                 '("n" "New note (with denote.el)" plain
                   (file denote-last-path)
                   #'denote-org-capture
                   :no-save t
                   :immediate-finish nil
                   :kill-buffer t
                   :jump-to-captured t))))
#+end_src

***** tree-sitter                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 10:14]
:END:

Tree-sitter module for Elisp had been incorporated into Emacs core since Emacs 29.

#+begin_src emacs-lisp
(use-package tree-sitter-langs
  :ensure t
  :defer t)

(use-package tree-sitter
  :ensure t
  :after tree-sitter-langs
  :hook ((tree-sitter-after-on . tree-sitter-hl-mode))
  :config
  (global-tree-sitter-mode 1))
#+end_src

***** xr                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-07-30 Sat 16:12]
:END:

[[https://elpa.gnu.org/packages/xr.html][XR]] converts Emacs regular expressions to the structured rx form, thus being an inverse of rx.

#+begin_src scheme :tangle no
"emacs-xr"
#+end_src

***** Whole Line Or Region           :wp:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/purcell/whole-line-or-region/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package whole-line-or-region
  :ensure t
  :config
  (whole-line-or-region-global-mode 1))
#+end_src

***** projectile                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
(use-package projectile
  :hook
  (find-file . projectile-mode-switch-dwim)
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :custom
  (projectile-project-search-path (expand-file-name "~/git"))
  (projectile-switch-project-action 'projectile-dired)
  (projectile-track-known-projects-automatically nil)
  (projectile-mode-line-prefix " P")
  (projectile-mode-line-function 'projectile-short-mode-line)
  :config
  (projectile-load-known-projects)
  (bind-keys :map projectile-command-map
             ("C-s" . projectile-save-project-buffers)))

(defun projectile-mode-switch-dwim ()
  "Intelligently switch on/off projectile mode."
  (when-let* ((bfn (buffer-file-name))
              (vc-registered (buffer-file-name)))
    (setq-local projectile-mode t)))

(defun projectile-short-mode-line ()
  "Report project name and type in the modeline."
  (let ((project-name (projectile-project-name)))
    (format "%s:%s"
            projectile-mode-line-prefix
            (or project-name "-"))))
#+end_src

***** counsel-projectile             :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
(use-package counsel-projectile
  :after projectile
  :config
  (bind-keys :map projectile-command-map
             ("p" . counsel-projectile-switch-project)
             ("sG" . counsel-projectile-grep)
             ("sS" . counsel-projectile-ag)
             ("sR" . counsel-projectile-rg)
             ("si" . counsel-projectile-git-grep)))
#+end_src
***** ag.el                          :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
;; (use-package ag :straight t)
#+end_src

***** ripgrep.el                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
;; (use-package ripgrep :straight t)
#+end_src

***** wgrep                    :grep:extensions:edit:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-wgrep"
#+end_src

#+begin_src emacs-lisp
(use-package wgrep
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-enable-key "e"))
#+end_src

***** dumb-jump                         :programming:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is "jump to definition" package without tagging.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dumb-jump"
#+end_src

#+begin_src emacs-lisp
(use-package dumb-jump
  :hook (prog-mode . (lambda ()
                       (add-to-list 'xref-backend-functions
                                    #'dumb-jump-xref-activate
                                    t)))
  :config
  (bind-keys ("M-g o" . dumb-jump-go-other-window)
             ("M-g j" . dumb-jump-go)
             ("M-g x" . dumb-jump-go-prefer-external)
             ("M-g z" . dumb-jump-go-prefer-external-other-window)
             ("M-g /" . dumb-jump-back)
             ("M-g l" . dumb-jump-quick-look)))
#+end_src

***** visual-regexp                         :ARCHIVE:

#+begin_src scheme :tangle no
"emacs-visual-regexp"
#+end_src

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind ("C-%" . vr/query-replace))
#+end_src

****** visual-regexp-steroids

#+begin_src emacs-lisp :tangle no
("https://github.com/benma/visual-regexp-steroids.el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package visual-regexp-steroids
  :straight t
  :after (visual-regexp)
  :config
  (setq vr/engine 'python))
#+end_src

***** avy                            :point:location:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

[[https://karthinks.com/software/avy-can-do-anything/][This post]] tell me how we can concoct efficient editing workflow with avy.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-avy"
#+end_src

#+begin_src emacs-lisp
(use-package avy
  :preface
  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
  :config
  (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)
  (bind-keys ("M-g g" . avy-goto-line)
             ("H-g" . avy-goto-line)))
#+end_src

****** avy-migemo

#+begin_src emacs-lisp
(use-package avy-migemo
  :ensure t
  :after migemo
  :bind (("M-g M-a" . avy-migemo-goto-char-timer)
         ("M-g a" . avy-migemo-goto-char-timer)
         ("H-a" . avy-migemo-goto-char-timer)
         :map isearch-mode-map
         ("M-a" . avy-migemo-isearch)))
#+end_src

***** paredit                                  :lisp:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

Handy commands
- press '(' to insert '()' pair
- C-<left/right> to barf and slurp s-expressions
- call paredit-splice-sexp to strip embracing parenthes
- press M-<up> or M-r to delete upper sexp except pointing one
- DEL, C-d, C-k act like originals but care for parenthes
- press DEL to remedy unbalanced parenthes
- press C-q ( to insert ( char manually

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-paredit"
#+end_src

#+begin_src emacs-lisp
(use-package paredit
  :bind (:map paredit-mode-map
              ("<backspace>" . paredit-backward-delete)
              ("C-M-g" .  paredit-splice-sexp)
              ("M-s" . nil)
              ("C-M-;" . paredit-comment-dwim)
              ("M-;" . nil))
  :hook (((emacs-lisp-mode lisp-mode scheme-mode) . enable-paredit-mode)))
#+end_src

- workaround
  Thanks to [[https://andreyorst.gitlab.io/posts/2021-09-30-why-is-paredit-is-so-un-emacsy/][this blog post]], a couple of commands in paredit.el are fixed with transient-mark-mode

  #+begin_src emacs-lisp
  (defvar my/paredit-delete-region-functions
    '(paredit-forward-delete
      paredit-backward-delete)
    "List of `paredit-mode' functions that should support tmm region deletion.")

  (defvar my/paredit-kill-region-functions
    '(paredit-forward-kill-word
      paredit-backward-kill-word)
    "List of `paredit-mode' functions that should support tmm region killing.")

  (defun my/paredit-fix-transient-mark-mode (orig-fn &rest args)
    "Allow deleting/killing a region if expression is balanced."
    (if (and transient-mark-mode
             mark-active)
        (cond ((memq this-command my/paredit-delete-region-functions)
               (paredit-delete-region (region-beginning) (region-end)))
              ((memq this-command my/paredit-kill-region-functions)
               (paredit-kill-region (region-beginning) (region-end)))
              (t (apply orig-fn args)))
      (apply orig-fn args)))

  (dolist (fun (append my/paredit-delete-region-functions
                       my/paredit-kill-region-functions))
    (advice-add fun :around #'my/paredit-fix-transient-mark-mode))
  #+end_src

***** lsp-mode                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 22:10]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-lsp-mode"
# #+end_src

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook ((python-mode) . lsp-deferred))
#+end_src

****** lsp-ivy                      :ARCHIVE:ignore:

#+begin_src emacs-lisp
;; (use-package lsp-ivy
;;   :straight t
;;   :after lsp
;;   :hook (lsp-mode . lsp-ivy-mode))
#+end_src

***** company-mode                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:26]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-company"
# #+end_src

#+begin_src emacs-lisp :tangle no
(use-package company
  :hook (prog-mode . company-mode)
  :bind (:map company-active-map
              ("C-j" . company-complete-selection)
              ("<backspace>" . backward-delete-char-untabify)
              ("C-h" . company-show-doc-buffer)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)))
#+end_src

***** flycheck          :tools:languages:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-flycheck"
#+end_src

#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :hook (prog-mode . flycheck-mode-on-safe)
  :custom
  (global-flycheck-mode t)
  (flycheck-check-syntax-automatically
   '(save new-line idle-change))
  (flycheck-display-errors-delay 10.0)
  (flycheck-checker-error-threshold 1000)
  (flycheck-textlint-config ".textlintrc")
  :config
  (add-hook 'flycheck-mode-hook
            (lambda ()
              (if (my/ascii-string-p (buffer-string))
                  (setq flycheck-textlint-config ".textlintrc")
                (setq flycheck-textlint-config ".config/textlint/textlintrc_ja"))))
  (add-to-list 'display-buffer-alist
               `(,flycheck-error-message-buffer
                 . (display-buffer-reuse-window
                    display-buffer-in-previous-window
                    display-buffer-pop-up-window
                    . ((window-height . 5))))))
#+end_src

***** twittering-mode           :web:twitter:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

Twitter API is no longer available thanks to the tyrant.

useful tips:
- invoke twittering-toggle-show-replied-statuses on "in reply to" state to show replied messages
- invoke twittering-view-user-page (C-c C-v) on user name to jump to user profile page in default browser

Disclaimers: An unexpected incident might occur if twittering-icon-mode call lay at :config section of use-package

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/hayamiz/twittering-mode/releases.atom" soft_update)
#+end_src

#+begin_src scheme :tangle no
"emacs-twittering-mode"
#+end_src

#+begin_src emacs-lisp :noweb no
(defvar my/twittering-resource-dir
  (expand-file-name "twmode" user-emacs-directory))

(use-package twittering-mode
  :disabled t
  :delight " TW"
  :commands twit
  :hook
  (twittering-mode . twittering-icon-mode)
  :custom
  (twittering-private-info-file
   (expand-file-name "twittering-mode.gpg" my/twittering-resource-dir))
  (twittering-user-id-db-file
   (expand-file-name "user-info.gz" my/twittering-resource-dir))
  (twittering-use-master-password t)
  (twittering-use-ssl t)
  (twittering-number-of-tweets-on-retrieval 50)
  (twittering-use-icon-storage t)
  (twittering-icon-storage-file
   (expand-file-name "icons.gz" my/twittering-resource-dir))
  (twittering-icon-storage-limit 2000)
  (twittering-convert-fix-size 24)
  (twittering-initial-timeline-spec-string '(":home" ":mentions"))
  (twittering-edit-skeleton 'inherit-any)
  (twittering-display-remaining t)
  (twittering-timeline-header "")
  (twittering-timeline-footer "")
  (twittering-status-format
   (concat "%RT{%FACE[bold]{RT by %S\n}}"
           "%i %S,"
           "%FACE[font-lock-constant-face]{%FIELD-IF-NONZERO[ ↺%d]{retweet_count}}"
           "%FACE[font-lock-warning-face]{%FIELD-IF-NONZERO[ ♡%d]{favorite_count}}"
           " %@{}:\n"
           "%T %r%QT{\n+----\n%i %S, %@{}:\n%T %r%R\n+----}\n "))
  :config
  (bind-keys :map twittering-mode-map
             ("C-c C-l" . nil)
             ;; move cursor
             ("f" . scroll-up-line)
             ("e" . scroll-down-line)
             ("E" . my/twittering-previous-status-and-top)
             ("SPC" . my/twittering-next-status-and-top)
             ;; create/delete tweets(messages)
             ("u" . twittering-update-status-interactive)
             ("j" . twittering-enter)
             ("J" . twittering-reply-to-user)
             ("RET" . twittering-enter)
             ("o" . my/twittering-open)
             ("C-c C-o" . my/twittering-open)
             ("d" . twittering-direct-message)
             ("k" . twittering-delete-status)
             ("y" . twittering-push-uri-onto-kill-ring)
             ("Y" . twittering-push-tweet-onto-kill-ring)
             ;; response to tweets
             ("r" . twittering-native-retweet)
             ("R" . my/twittering-quote-retweet)
             ("b" . twittering-favorite)
             ("B" . twittering-unfavorite)
             ("l" . twittering-follow)
             ("L" . twittering-unfollow)
             ("t" . twittering-toggle-show-replied-statuses)
             ("T" . twittering-toggle-or-retrieve-replied-statuses)
             ;; switch between timelines
             ("n" . twittering-switch-to-next-timeline)
             ("p" . twittering-switch-to-previous-timeline)
             ("." . twittering-visit-timeline)
             ("@" . twittering-other-user-timeline)
             ("/" . my/twittering-search)
             ("?" . twittering-search)
             ("c1" . twittering-home-timeline)
             ("c2" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":mentions")))
             ("c3" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":retweets_of_me")))
             ("c4" . (lambda ()
                       (interactive)
                       (twittering-search "from:_p_snow")))
             ("c5" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":favorites")))
             ("c6" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":direct_message_events")))))

(defun my/twittering-next-status-and-top ()
  "docstring"
  (interactive)
  (twittering-goto-next-status)
  (recenter-top-bottom 0))

(defun my/twittering-previous-status-and-top ()
  "docstring"
  (interactive)
  (twittering-goto-previous-status)
  (recenter-top-bottom 0))

(defun my/twittering-quote-retweet ()
  "docstring"
  (interactive)
  (let ((orig-tweet-uri (twittering-push-uri-onto-kill-ring)))
    (twittering-update-status (format "\n%s" orig-tweet-uri))
    (next-line -1 t)))

(defun my/twittering-search (&optional arg)
  ""
  (interactive "P")
  (let* ((spec (get-text-property (point) 'goto-spec))
         (username (get-text-property (point) 'username))
         (word (cond
                ((use-region-p) (buffer-substring (region-beginning) (region-end)))
                ((stringp spec) spec)
                ((eq (car spec) 'user) (format "@%s" (cadr spec)))
                ((stringp username) username))))
    (twittering-search (and (not arg) word))))

(defun my/twittering-open (&optional arg)
  ""
  (interactive "P")
  (let ((uri (or (get-text-property (point) 'uri)
                 (if (get-text-property (point) 'field)
                     (let* ((id (get-text-property (point) 'id))
                            (status (twittering-find-status id)))
                       (twittering-get-status-url-from-alist status))
                   nil))))
    (browse-url uri)))
#+end_src

***** comment-dwim-2                        :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/remyferre/comment-dwim-2/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package comment-dwim-2
  :disabled t
  :defer 1
  :bind ("M-;" . comment-dwim-2)
  :config
  (setf comment-dwim-2--inline-comment-behavior 'reindent-comment
        cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

***** undo-tree :undo:tree:redo:history:files:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-undo-tree"
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<share-dir()>>/emacs/undo-tree 0755 - - 3w
#+end_src

#+name: undo-tree-hist-dir
#+begin_src emacs-lisp :tangle no :eval no-export
(expand-file-name "undo-tree" user-emacs-directory)
#+end_src

#+begin_src shell :noweb yes :noweb-ref updatedb-opt :tangle no
-e "<<undo-tree-hist-dir()>>" \
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package undo-tree
  :diminish undo-tree-mode
  :init
  (defvar undo-tree-excludes '("/gnu/store"))
  :custom
  (global-undo-tree-mode t)
  (undo-tree-auto-save-history nil)
  (undo-tree-enable-undo-in-region t)
  (undo-tree-limit 320000)
  (undo-tree-strong-limit 480000)
  (undo-tree-outer-limit 64000000)
  :config
  (bind-keys :map undo-tree-map
             ("M-_" . nil))
  (add-to-list 'undo-tree-history-directory-alist
               '("." . "<<undo-tree-hist-dir()>>"))
  (add-to-list 'display-buffer-alist
               `(,undo-tree-visualizer-buffer-name . (display-buffer-in-side-window
                                                      . ((side . right)
                                                         (window-width . 15))))))
#+end_src

***** quickrun                              :ARCHIVE:

#+begin_src emacs-lisp
;; (use-package quickrun)
#+end_src

***** expand-region

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-expand-region"
#+end_src

#+begin_src emacs-lisp
(use-package expand-region
  :bind (("C-,"   . er/expand-region)
         ("C-M-," . er/contract-region))
  :config
  (push 'er/mark-outside-pairs er/try-expand-list))
#+end_src

***** helpful                               :ARCHIVE:

helpful-mode shows more than [[id:a55da7a2-6525-4788-ba56-085eb61928d4][help-mode]].

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-helpful"
# #+end_src

#+begin_src emacs-lisp
(use-package helpful
  :bind
  (:map help-map
        ("f" . helpful-callable)
        ("v" . helpful-variable)
        ("k" . helpful-key))
  (:map helpful-mode-map
        ("w" . helpful-push-symbol-onto-kill-ring) )
  :config
  (bind-keys :map helpful-mode-map
             ("f" . scroll-up-line)
             ("e" . scroll-down-line)
             ("SPC" . my/forward-paragraph)
             ("E" . my/backward-paragraph)
             ("2" . backward-button)
             ("3" . forward-button)
             ("4" . push-button)))

(defun helpful-push-symbol-onto-kill-ring ()
  "Push symbol name to kill ring."
  (interactive)
  (let ((symbol (symbol-name helpful--sym)))
    (kill-new (symbol-name helpful--sym))
    (message "COPY: %s" symbol)))
#+end_src

***** define-word            :dictionary:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/abo-abo/define-word/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package define-word
  :ensure t
  :defer t
  :bind (:map engine-mode-prefixed-map
              ("n" . my/define-word))
  :preface
  (defun my/define-word ()
    "docstring"
    (interactive)
    (if (use-region-p)
        (call-interactively #'define-word-at-point)


      (call-interactively #'define-word)))
  :custom
  (define-word-displayfn-alist
   '((wordnik . my/define-word--display-in-buffer)
     (openthesaurus . my/define-word--display-in-buffer)
     (webster . my/define-word--display-in-buffer)))
  (define-word-default-service 'wordnik)
  :config
  (setf (cdr (assoc 'wordnik define-word-services))
        '("http://wordnik.com/words/%s" my/define-word--parse-wordnik-all))
  (push '("<b>\\(.*?\\)</b>" bold)
        define-word--tag-faces)
  ;; fix issue #31 temporally
  (defun my/define-word--fix-31 (define-word-orig &rest args)
    "Fix `define-word' backends that require a user agent (like wordnik)."
    (let ((url-request-extra-headers
           '(("User-Agent" .
              "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36"))))
      (apply define-word-orig args)))
  (advice-add #'define-word :around #'my/define-word--fix-31))

(defun my/define-word--display-in-buffer (definition)
  "docstring"
  (let* ((buf-name "*DEFINE WORD*")
         (buffer (get-buffer-create buf-name))
         (display-buffer-alist
          `((,buf-name
             (display-buffer-same-window)))))
    (with-current-buffer buffer
      (read-only-mode -1)
      (erase-buffer)
      (insert definition)
      (goto-char (point-min))
      (save-excursion (xml-parse-string))
      (read-only-mode 1))
    (display-buffer buffer)))

(defun my/define-word--parse-wordnik-example ()
  (save-excursion
    (let (beg
          results
          (define-word-limit 10))
      (re-search-forward "<h2>Examples" nil t)
      (save-excursion
        (setq beg (re-search-forward "<div class=\"relatedWords-module\">" nil t)))
      (while (re-search-forward "<p class=\"text\">\\(.*\\)</p>" beg t)
        (push "---" results)
        (push (match-string 1) results))
      (when (setq results (nreverse results))
        (define-word--convert-html-tag-to-face (define-word--join-results results))))))

(defvar my/define-word-part-map-alist '(("adjective" "adj.")
                                        ("adverb" "adv.")
                                        ("intransitive verb" "v.i.")
                                        ("transitive verb" "v.t.")))


(defun my/define-word--parse-wordnik ()
  (let ((str (define-word--parse-wordnik)))
    (with-temp-buffer
      (insert str)
      (mapc (lambda (abbrev-map)
              (goto-char (point-min))
              (while (re-search-forward (format "\\(%s\\)" (car abbrev-map)) nil t)
                (let ((match (match-string 1)))
                  (replace-match
                   (propertize (cadr abbrev-map) 'face (text-properties-at (point)))))))
            my/define-word-part-map-alist)
      (buffer-string))))

(defun my/define-word--parse-wordnik-related-word ()
  "docstring"
  (save-excursion
    (save-match-data
      (seq-reduce
       (lambda (accum group)
         (let (results
               (define-word-limit 20))
           (if (re-search-forward (format "<h3>%s" group) nil t)
               (progn (save-excursion
                        (setq beg (re-search-forward "<div class=\"related-group-header clearfix\">" nil t)))
                      (push (concat group ":") results)
                      (while (re-search-forward "<span data-definition-for=\"\\([^\"]*\\)\"" beg t)
                        (push (concat "- " (match-string 1)) results)
                        (re-search-forward "</span>"))
                      (concat (when accum (concat accum "\n\n"))
                              (when (setq results (nreverse results))
                                (define-word--convert-html-tag-to-face (define-word--join-results results)))))
             accum)))
       '("antonym" "equivalents" "hypernyms" "hyponyms" "same context")
       nil))))

(defun my/define-word--parse-wordnik-all ()
  ""
  (let* ((def (funcall #'my/define-word--parse-wordnik))
         (rel (funcall #'my/define-word--parse-wordnik-related-word))
         (exp (funcall #'my/define-word--parse-wordnik-example)))
    (concat ;; "Definitions:\n" (funcall #'define-word--parse-wordnik) "\n\n"
     (when def (format "Definitions:\n%s\n\n" def))
     (when rel (format "%s\n\n" rel))
     (when exp (format "Examples:\n%s\n" exp)))))
#+end_src

***** synosaurus

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-synosaurus"
#+end_src

#+begin_src emacs-lisp
(use-package synosaurus
  :bind (:map engine-mode-prefixed-map
              ("s" . synosaurus-lookup))
  :custom
  (synosaurus-choose-method 'default))
#+end_src

***** exec-path-from-shell         :unix:environment:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

A GNU Emacs library to ensure environment variables inside Emacs look the same as in the user's shell.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-exec-path-from-shell"
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config
  (when (memq window-system '(mac))
    (exec-path-from-shell-initialize)))
#+end_src

***** migemo.el

migemo allows me to search incrementally Japanese words using roma-ji expression.

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/emacs-jp/migemo/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package migemo
  :ensure t
  :ensure-system-package cmigemo
  :custom
  (migemo-command "cmigemo")
  (migemo-options '("-q" "--emacs"))
  (migemo-directory
   (file-name-concat "<<migemo-dict-path()>>" "utf-8"))
  (migemo-dictionary
   (file-name-concat "<<migemo-dict-path()>>" "utf-8/migemo-dict"))
  (migemo-user-dictionary nil)
  (migemo-coding-system 'utf-8-unix)
  (migemo-regex-dictionary nil)
  :config
  (migemo-init))
#+end_src

****** ivy-migemo                   :ARCHIVE:ignore:

#+begin_src emacs-lisp
(use-package ivy-migemo
  :after migemo)
#+end_src

***** jaword
:PROPERTIES:
:CREATED:  [2022-08-13 Sat 18:01]
:END:

Jaword.elはbackward-wordやforward-wordを日本語に対応させる機能を提供します。これらのコマンドはデフォルトではひらがな・カタカナ・漢字の境界を単語の区切りとするのに対し、jaword.elを使用するとより正確に日本語の単語単位での移動が可能です。

#+begin_src emacs-lisp :tangle no
("https://github.com/zk-phi/jaword/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package jaword
  :ensure t
  :custom
  (jaword-enable-subword t)
  :hook ((skk-mode
          . (lambda ()
              (jaword-mode 1)))
         (input-method-activate
          . (lambda ()
              (when (string= current-input-method "japanese-skk")
                (jaword-mode 1))))
         (input-method-deactivate
          . (lambda ()
              (when (string= current-input-method "japanese-skk")
                (jaword-mode -1))))))
#+end_src

***** hungry-delete                         :ARCHIVE:

Aggressively delete successive white spaces.

#+begin_src emacs-lisp :tangle no
("https://github.com/nflath/hungry-delete/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package hungry-delete
  :straight t
  :diminish
  :config
  (global-hungry-delete-mode 1))
#+end_src

***** aggressive-indent-mode :tools:maint:lisp:indent:
:PROPERTIES:
:ID:       4a58219c-74dd-4135-b56d-876b0db2cd83
:CREATED:  [2023-06-11 Sun 18:39]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-aggressive-indent"
#+end_src

#+begin_src emacs-lisp
(use-package aggressive-indent
  :diminish (aggressive-indent-mode . "ai")
  :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src
***** adaptive-wrap

adaptive-wrap and visual-line-mode are active in a bundle in a bunch of major modes.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-adaptive-wrap"
#+end_src

#+begin_src emacs-lisp
(use-package adaptive-wrap)
#+end_src

***** restart-emacs             :convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

Configuration for shutting down Emacs moved to [[id:1a73e0cf-f851-4f48-9a22-1ec37fdcf960][here]] since M-x [[help:restart-emacs][restart-emacs]] had been built-in at ver.29.1.

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-restart-emacs"
# #+end_src

#+begin_src emacs-lisp
(use-package restart-emacs
  :bind (("C-M-<delete>"   . restart-emacs)
         ("C-M-S-<delete>" . save-buffers-kill-emacs)))
#+end_src

***** pangu-spacing                         :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/coldnew/pangu-spacing/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package pangu-spacing
  :straight t
  :diminish pangu-spacing-mode
  :custom
  (pangu-spacing-real-insert-separtor t)
  :config
  (setq pangu-spacing-chinese-before-english-regexp
        (rx (group-n 1 (category japanese))
            (group-n 2 (in "a-zA-Z0-9"))))
  (setq pangu-spacing-chinese-after-english-regexp
        (rx (group-n 1 (in "a-zA-Z0-9"))
            (group-n 2 (category japanese)))))
#+end_src
***** which-key                             :ARCHIVE:

[[https://github.com/justbur/emacs-which-key][which-key]] guides me "which key is available" after current key stroke in the mini buffer.

#+begin_src scheme :tangle no
"emacs-which-key"
#+end_src

#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :custom
  (which-key-use-C-h-commands t)
  (which-key-max-description-length 43)
  (which-key-idle-delay 0.7)
  (which-key-separator " : ")
  (which-key-side-window-max-height 0.5)
  :config
  (which-key-mode 1)
  (which-key-setup-side-window-bottom))
#+end_src
***** hydra                                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:16]
:END:

# #+begin_src scheme :tangle no
#   "emacs-hydra"
# #+end_src

#+begin_src emacs-lisp
(use-package hydra
  :custom
  (hydra-is-helpful nil))
#+end_src

***** pass         :store:password:password:keychain:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

Major mode for manupulating password store file.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-pass"
#+end_src

#+begin_src emacs-lisp
(use-package pass
  :commands pass
  :bind (:map pass-mode-map
              ("C-j" . pass-view)))
#+end_src

***** password-store :tools:store:password:password:pass:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-password-store"
#+end_src

#+begin_src emacs-lisp
(use-package password-store
  :custom
  (password-store-time-before-clipboard-restore 25))
#+end_src

***** nov.el             :multimedia:hypermedia:epub:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-nov-el"
#+end_src

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub$" . nov-mode)
  :hook (nov-mode . nov-abbreviate-file-name)
  :custom
  (nov-variable-pitch nil)
  (nov-text-width t)
  :config
  (bind-keys :map nov-mode-map
             ("C-j" . nov-browse-url)))

(defun nov-abbreviate-file-name ()
  "Shorten `nov-file-name' using `directory-abbrev-alist'."
  (setq nov-file-name (abbreviate-file-name nov-file-name)))
#+end_src

***** yasnippet               :emulation:convenience:
:PROPERTIES:
:ID:       e91bfa7e-79be-4abc-ac0c-232aa3ccddda
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-yasnippet"
"emacs-yasnippet-snippets"
#+end_src

#+begin_src emacs-lisp
(use-package yasnippet
  :disabled t
  :bind (:prefix "C-c y"
                 :prefix-map my/yas-map
                 :prefix-docstring "Keymap for YASnippet family."
                 ("v" . yas-visit-snippet-file)
                 ("n" . yas-new-snippet)
                 ("i" . yas-insert-snippet)
                 ("TAB" . yas-insert-snippet))
  :hook
  ((prog-mode text-mode) . yas-minor-mode)
  (after-init . yas-reload-all)
  :init
  (setq yas-snippet-dirs
        (list (expand-file-name "snippets" user-emacs-directory-default)))
  :custom
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :config
  (require 'yasnippet-snippets))
#+end_src

***** auto-yasnippet
:PROPERTIES:
:CREATED:  [2023-06-26 Mon 10:52]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-auto-yasnippet"
#+end_src

#+begin_src emacs-lisp
(use-package auto-yasnippet
  :disabled t
  :after yasnippet
  :init
  (setq aya-persist-snippets-dir
        (expand-file-name "snippets" user-emacs-directory-default))
  :config
  (bind-keys :map my/yas-map
             ("a"   . aya-create)
             ("A"   . aya-expand)
             ("C-s" . aya-persist-snippet)))
#+end_src

***** yankpad            :convenience:abbrev:ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-18 Sun 16:01]
:END:

[[https://github.com/Kungsgeten/yankpad][Yankpad]] enables us to define snippets in org-mode for [[id:e91bfa7e-79be-4abc-ac0c-232aa3ccddda][yasnippet]] or [[https://www.emacswiki.org/emacs/SkeletonMode][Skeltom]].

#+begin_src emacs-lisp
(use-package yankpad
  :disabled t
  :after (org denote)
  :bind (("C-c y i" . yankpad-insert)
         ("C-c y TAB" . yankpad-expand)
         ("C-c y p" . company-yankpad)
         ("C-c y c" . yankpad-capture-snippet)
         ("C-c y l" . yankpad-reload)
         ("C-c y z" . yankpad-repeat)
         ("C-c y e" . yankpad-edit))
  :custom
  (yankpad-file (denote-get-path-by-id "20230605T175742")))
#+end_src

***** pdf-tools            :multimedia:files:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no
"emacs-pdf-tools"
#+end_src

#+begin_src emacs-lisp
(use-package pdf-tools
  :delight
  (pdf-view-mode " PV")
  :mode ("\\.pdf$" . pdf-view-mode)
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-page-to-window)
  :custom
  (pdf-view-display-size 'fit-width))
#+end_src

***** rainbow-mode                            :faces:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-rainbow-mode"
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish
  (rainbow-mode . "rb")
  :hook
  ((css-mode scss-mode php-mode html-mode) . rainbow-mode)
  :custom
  (rainbow-html-colors t)
  (rainbow-x-colors t)
  (rainbow-latex-colors t)
  (rainbow-ansi-colors t))
#+end_src
***** alert              :notification:message:emacs:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-alert"
#+end_src

#+begin_src emacs-lisp
(use-package alert
  :config
  (set-face-background 'alert-saved-fringe-face nil)
  (alert-add-rule :status '(buried)
                  :mode   'mu4e-alert
                  :style  'fringe)
  (alert-add-rule :status '(buried)
                  :mode   'dired-mode
                  :style  'fringe)
  (alert-add-rule :status '(buried)
                  :mode   'org-mode
                  :style  'libnotify))
#+end_src

***** ts                              :lisp:calendar:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ts"
#+end_src

#+begin_src emacs-lisp
(use-package ts)
#+end_src

***** app-launcher
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 21:42]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-app-launcher"
#+end_src

#+begin_src emacs-lisp
(use-package app-launcher
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("a" . app-launcher-run-app)))
#+end_src

***** tldr                               :tools:docs:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

I ran into a problem with downloading TL;DR document. I forcibly download, uncompress and locate that to `tldr-directory-path'.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-tldr"
#+end_src

#+begin_src emacs-lisp
(use-package tldr
  :commands tldr
  :custom
  (tldr-use-word-at-point t))
#+end_src

***** burly                             :convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

[[https://github.com/alphapapa/burly.el][Burly.el]] is capable of saving and opening Emacs frames and windows by describing them as URL which can be stored in bookmark. You can use Burly as a lightweight workspace tool.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-burly"
#+end_src

#+begin_src emacs-lisp
(require 'burly)
#+end_src
***** tempel              :wp:tools:languages:abbrev:
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 16:07]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-tempel"
;; "emacs-tempel-collection"
#+end_src

#+begin_src emacs-lisp
(use-package tempel
  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
         ("M-_" . tempel-insert))
  :hook
  ((conf-mode prog-mode text-mode minibuffer-mode) . tempel-setup-capf)
  :preface
  (defun tempel-setup-capf ()
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
  :custom
  (tempel-path (list (file-name-concat user-emacs-directory-default "templates/*.eld")
                     (file-name-concat user-emacs-directory-default "templates/private/*.eld")))
  :config
  (bind-keys :map tempel-map
             ("TAB" . tempel-next)
             ("M-TAB" . tempel-previous)
             ("C->" . tempel-next)
             ("C-<" . tempel-previous))
  (with-eval-after-load 'cape
    (bind-keys :map my/cape-map
               ("t" . tempel-expand))))

(use-package tempel-collection
  :ensure t
  :after tempel)
#+end_src
***** literate calc mode       :tools:languages:calc:
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 21:35]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-literate-calc-mode"
#+end_src

#+begin_src emacs-lisp
(use-package literate-calc-mode
  :bind ("C-c M-=" . literate-calc-mode))
#+end_src

***** git-link
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 21:50]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-link"
#+end_src

#+begin_src emacs-lisp
(use-package git-link)
#+end_src

***** jinx
:PROPERTIES:
:CREATED:  [2023-12-07 Thu 12:22]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-jinx"
#+end_src

#+begin_src emacs-lisp
(use-package jinx
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  :hook (org-src-mode . (lambda ()
                          (when (derived-mode-p 'text-mode)
                            (jinx-mode 1))))
  :config
  (bind-keys :map jinx-mode-map
             ("M-n" . jinx-next)
             ("M-p" . jinx-previous)))
#+end_src
***** simple-httpd
:PROPERTIES:
:CREATED:  [2023-12-23 Sat 20:36]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-simple-httpd"
#+end_src

#+begin_src emacs-lisp
(use-package simple-httpd
  :commands (httpd-start httpd-serve-directory))
#+end_src

*** further extension
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/elisp/config/my-config.el")
:CREATED:  [2023-01-20 Fri 10:22]
:END:

**** utility macros/functions
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 16:56]
:header-args+: :tangle (expand-file-name "00-my-early-config.el" tangle/emacs-config-dir)
:END:

***** lambda key
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 12:33]
:END:

[[https://www.emacswiki.org/emacs/DocumentingKeyBindingToLambda][lambda-key]] is nice idea to remedy lambda bindings with define-key.

#+begin_src emacs-lisp
(defun lambda-key (keymap key def)
  "Wrap`define-key' to provide documentation."
  (set 'sym (make-symbol (documentation def)))
  (fset sym def)
  (keymap-set keymap key sym))
#+end_src

***** computational
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 18:24]
:END:

#+begin_src emacs-lisp
(defun my/combinations (list)
  "Return all combinations for all elements in LIST."
  (if (null list)
      (list nil)
    (let ((rest-combs (my/combinations (cdr list))))
      (append (mapcar (lambda (combination) (cons (car list) combination))
                      rest-combs)
              rest-combs))))
#+end_src

***** copy line number in kill ring
:PROPERTIES:
:CREATED:  [2023-12-16 Sat 12:07]
:END:

#+begin_src emacs-lisp
(defun my/copy-line-number ()
  "Copy the line number of current point into the kill ring."
  (interactive)
  (let ((line-number (number-to-string (line-number-at-pos))))
    (message "Line number: %s" line-number)
    (kill-new line-number)))
(global-set-key (kbd "C-M-S-w") 'my/copy-line-number)
#+end_src

***** expand shorthand time string
:PROPERTIES:
:CREATED:  [2023-12-16 Sat 11:40]
:END:

#+begin_src emacs-lisp
(defun my/expand-shorthand-time (time-string)
  "Expand shorthand expressions in TIME-STRING."
  (let ((case-fold-search nil))
    (rx-let ((follow-digit (char)
                           (: (group (+ digit)) (* space) char
                              (group (or eol (not alpha))))))
      (seq-reduce (lambda (result element)
                    (replace-regexp-in-string (car element) (cadr element) result))
                  `((,(rx (follow-digit "y")) "\\1year\\2")
                    (,(rx (follow-digit "M")) "\\1month\\2")
                    (,(rx (follow-digit "w")) "\\1week\\2")
                    (,(rx (follow-digit "d")) "\\1day\\2")
                    (,(rx (follow-digit "h")) "\\1hour\\2")
                    (,(rx (follow-digit "m")) "\\1minute\\2")
                    (,(rx (follow-digit "s")) "\\1second\\2"))
                  time-string))))
#+end_src

unit test
#+begin_src emacs-lisp :tangle no
(ert-deftest test/expand-shorthand-time ()
  "Tests the output string of `my/expand-shorthand-time'."
  (should (string= (my/expand-shorthand-time "1m")
                   "1minute"))
  (should (string= (my/expand-shorthand-time "1m 20s")
                   "1minute 20second"))
  (should (string= (my/expand-shorthand-time " 2h10m ")
                   " 2hour10minute ")))
#+end_src

***** org link at point map
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:58]
:END:

#+begin_src emacs-lisp
(defun org-link-at-point-map (function)
  "Call `FUNCTION' with url and title obtained from org-link at point."
  (let* ((context (org-element-lineage
                   (org-element-context)
                   '(link)
                   t))
         (type (org-element-property :type context))
         (path (org-element-property :path context))
         (desc (when-let ((begin (org-element-property :contents-begin context))
                          (end (org-element-property :contents-end context)))
                 (buffer-substring begin end))))
    (cond
     ((string-match-p "https?" type)
      (funcall function (org-link-unescape (concat type ":" path)) desc))
     ((string-match-p "elfeed" type)
      (save-excursion
        (org-open-at-point)
        (when (eq major-mode 'elfeed-show-mode)
          (when-let ((url (or (caar (elfeed-entry-enclosures elfeed-show-entry))
                              (elfeed-entry-link elfeed-show-entry)))
                     (title (elfeed-entry-title elfeed-show-entry)))
            (funcall function url title))
          (quit-window)))))))
#+end_src

**** patches and workarounds
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 15:56]
:END:

***** disable external IME (fcitx)

As of 28.1, Emacs won't steal keyboard focus at startup which means we can use external input methods. But I'm confortable with shutting out external IM, fcitx in my case. Restarting fcitx makes my desire come true.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (call-process-shell-command "fcitx -r")))
#+end_src

***** ddskk corsor color malfunction in Emacs 28 and later
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 15:57]
:END:

[[https://github.com/skk-dev/ddskk/issues/190][Cursor colour no longer changes to match hiragana/katakana mode. · Issue #190 · skk-dev/ddskk · GitHub]]

#+begin_src emacs-lisp :tangle (expand-file-name "early-init.el" user-emacs-directory-default)
(require 'facemenu)
#+end_src

**** repeat maps
:PROPERTIES:
:CREATED:  [2022-10-14 Fri 17:43]
:END:

***** dired subdir repeat map
:PROPERTIES:
:CREATED:  [2023-09-13 Wed 11:06]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'dired
  (defvar-keymap my/dired-subdir-map
    :doc "Keymap to repeat commands on dired-subdir."
    :repeat (:enter (dired-next-subdir
                     dired-prev-subdir
                     dired-goto-subdir)
                    :exit (dired-kill-subdir
                           dired-open-subdir))
    "n" #'dired-next-subdir
    "p" #'dired-prev-subdir
    "k" #'dired-kill-subdir
    "g" #'dired-goto-subdir
    "TAB" #'dired-hide-subdir
    "RET" #'dired-open-subdir))
#+end_src

***** visual cycling repeat map
:PROPERTIES:
:CREATED:  [2023-06-20 Tue 11:31]
:END:

#+begin_src emacs-lisp
(use-package emacs
  :no-require t
  :bind-keymap
  ("H-y" . my/cycle-visual-repeat-map)
  :preface
  (defvar-keymap my/cycle-visual-repeat-map
    :doc "Keymap to repeat toggle/cycling appearance.  Used in `repeat-mode'."
    :repeat t
    "#" #'display-line-numbers-mode
    "SPC" #'cycle-spacing
    "V" #'visual-line-mode
    "F" #'toggle-frame-fullscreen
    "P" #'variable-pitch-mode
    "L" #'line-number-mode
    "C" #'column-number-mode
    "R" #'rainbow-mode
    "TAB" #'adaptive-wrap-prefix-mode
    "+" #'text-scale-adjust
    "-" #'text-scale-adjust
    "0" (lambda () "Set text scale to default level." (interactive)
          (text-scale-set 0))))
#+end_src

***** frame repeat map
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 22:24]
:END:

#+begin_src emacs-lisp
(defvar-keymap my/frame-repeat-map
  :doc "Keymap to repeat frame commands.  Used in `repeat-mode'."
  :repeat (:enter (other-frame))
  "o" #'other-frame
  "0" #'delete-frame
  "1" #'delete-other-frames
  "2" #'make-frame-command
  "5" #'other-frame-prefix
  "B" #'bookmark-jump-other-frame
  "p" #'project-other-frame-command
  "D" #'dired-other-frame
  "m" #'compose-mail-other-frame)
#+end_src

***** delete repeat map
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 22:22]
:END:

Suport successive deletion with C-h/M-h

#+begin_src emacs-lisp
(defun my/delete-char-dwim ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-delete-char 1)
    (delete-char 1)))
(defun my/delete-backward-char-dwim ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-delete-backward-char 1)
    (delete-backward-char 1)))
(defun my/kill-word-dwim ()
  (interactive)
  (if jaword-mode
      (jaword-kill 1)
    (kill-word 1)))
(defun my/backward-kill-word-dwim ()
  (interactive)
  (if jaword-mode
      (jaword-kill -1)
    (backward-kill-word 1)))

(defvar-keymap my/delete-repeat-map
  :doc "Keymap to repeat deletion commands.  Used in `repeat-mode'."
  :repeat (:enter (delete-char
                   org-delete-char
                   kill-word
                   jaword-kill
                   my/delete-char-dwim
                   my/delete-backward-char-dwim
                   my/kill-word-dwim
                   my/backward-kill-word-dwim))
  "C-d" #'my/delete-char-dwim
  "C-h" #'my/delete-backward-char-dwim
  "M-d" #'my/kill-word-dwim
  "M-h" #'my/backward-kill-word-dwim)
#+end_src

**** tailored commands/functions
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:

***** update elfeed feeds automatically
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 21:39]
:END:

elfeed-update will run at every midnight time.

#+begin_src emacs-lisp
(defun my/elfeed-update ()
  "Update Elfeed feeds."
  (interactive)
  (elfeed)
  (elfeed-db-compact)
  (elfeed-update)
  (when (eq major-mode 'elfeed-search-mode)
    (elfeed-kill-buffer)))

(with-eval-after-load 'midnight
  (add-hook 'midnight-hook #'my/elfeed-update))
#+end_src

***** frame maximization
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:29]
:END:

Every frame will be spawn in maximized and initial frame will be full screen at Emacs start-up time.

#+begin_src emacs-lisp
(use-package frame
  :if (member (window-system) '(x ns w32))
  :init
  (add-to-list 'after-make-frame-functions
               (lambda (frame) (set-frame-parameter frame 'fullscreen 'maximized)))
  :hook
  (after-init . (lambda () (set-frame-parameter nil 'fullscreen 'fullboth))))
#+end_src

***** prune old .eln files at shut down     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-10-06 Fri 23:11]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'comp
  (add-hook 'kill-emacs-hook
            #'native-compile-prune-cache))
#+end_src

***** operate the number at point
:PROPERTIES:
:CREATED:  [2023-09-06 Wed 21:53]
:END:

[[https://www.emacswiki.org/emacs/IncrementNumber][EmacsWiki: Increment Number]]

#+begin_src emacs-lisp
(defmacro my/operate-number (operation)
  `(save-excursion
     (save-restriction
       (when (use-region-p)
         (narrow-to-region (region-beginning) (region-end)))
       (skip-chars-backward "0-9")
       (skip-chars-forward "0")
       (or (looking-at "[0-9]+")
           (error "No number at point"))
       (replace-match (number-to-string
                       (apply ,operation (list (string-to-number (match-string 0)))))))))

(defun my/increment-number-at-point ()
  "Increment the number at point.

If there is a region which embrace a number, that number will be
incremented instead."
  (interactive)
  (my/operate-number #'1+))

(defun my/decrement-number-at-point ()
  "Decrement the number at point.

If there is a region which embrace a number, that number will be
decremented instead."
  (interactive)
  (my/operate-number #'1-))

(global-set-key (kbd "C-x <up>") #'my/increment-number-at-point)
(global-set-key (kbd "C-x <down>") #'my/decrement-number-at-point)
(defvar-keymap my/operate-number-repeat-map
  :doc "Keymap to repeat operating a number."
  :repeat (:enter (my/increment-number-at-point
                   my/decrement-number-at-point))
  "<up>" #'my/increment-number-at-point
  "<down>" #'my/decrement-number-at-point)
#+end_src

***** edit local file as root (sudo)
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 11:58]
:END:

my/sudo-edit-local-file is inspired by [[https://emacsredux.com/blog/2013/04/21/edit-files-as-root/][this thisblog post]].

#+begin_src emacs-lisp
(defun my/sudo-edit-local-file ()
  "Reopen the current buffer file with root privileges."
  (interactive)
  (when (file-exists-p buffer-file-name)
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))

(global-set-key (kbd "C-x C-#") #'my/sudo-edit-local-file)
#+end_src

***** power management
Shut down emacs automatically when remaining power of laptop PC lower than [[help:battery-load-low][battery-load-low]]
to avoid accidental data loss.

#+begin_src emacs-lisp
(require 'battery)

(run-with-timer 60 60 #'kill-emacs-auto)

(defun kill-emacs-auto ()
  "Kill Emacs if remaining machine power lower than `battery-load-low'."
  (when-let* ((data (and battery-status-function (funcall battery-status-function)))
              (percentage (car (read-from-string (cdr (assq ?p data)))))
              (power (cdr (assq ?L data))))
    (when (and (numberp percentage)
               (< percentage battery-load-low)
               (stringp power)
               (string= power "BAT"))
      (save-buffers-kill-emacs t))))
#+end_src

***** lazy viewing

It's confortable to read long material such as web page , epub file or email with snappy control. Lazy View offers transient keymap that allow users to move cursor and scroll page with simple key stroke.

#+begin_src emacs-lisp
(use-package emacs
  :no-require t
  :bind (("C-c z" . my/lazy-view-enter)
         ("H-z" . my/lazy-view-enter))
  :hook ((help-mode Info-mode eww-mode nov-mode mu4e-view-mode woman-mode)
         . my/lazy-view-enter)
  :preface
  (defvar-keymap my/lazy-view-map
    :doc "Keymap to repeat lazy viewing commands.  Used in `repeat-mode'."
    "C-?" (lambda () "Show this keymap list."
            (interactive)
            (describe-keymap 'my/lazy-view-map))
    "<SPC>" #'my/forward-paragraph
    "E" #'my/backward-paragraph
    "f" #'scroll-up-line
    "e" #'scroll-down-line
    "C-f" #'forward-char
    "C-b" #'backward-char
    "C-n" #'next-line
    "C-p" #'previous-line
    "C-a" #'move-beginning-of-line
    "C-e" #'move-end-of-line
    "C-v" #'scroll-up-command
    "M-v" #'scroll-down-command
    ">" '(lambda () "Scroll right one column." (interactive)
           (scroll-left 1))
    "<" '(lambda () "Scroll left one column." (interactive)
           (scroll-right 1)))
  (defun my/lazy-view-enter ()
    "Activate my/lazy-view-map in current buffer."
    (interactive)
    (set-transient-map my/lazy-view-map
                       #'my/lazy-view-keep
                       nil
                       "LAZY VIEW MODE"))
  (defun my/lazy-view-keep ()
    (member this-command
            `(beginning-of-visual-line
              end-of-visual-line
              recenter-top-bottom
              reposition-window
              quit-window
              Info-next-reference
              Info-prev-reference
              Info-up
              Info-history-back
              Info-history-forward
              Info-follow-nearest-node
              Info-forward-node
              Info-backward-node
              forward-button
              backward-button
              shr-next-link
              shr-previous-link
              eww-follow-link
              eww-back-url
              eww-forward-url
              eww-goto-title-heading
              eww-reload
              nov-browse-url
              nov-next-document
              nov-previous-document
              ,@(mapcar (lambda (key-command)
                          (let ((cmd (cdr key-command)))
                            (and (commandp cmd)
                                 cmd)))
                        (cdr my/lazy-view-map))))))

(defun my/forward-paragraph ()
  (interactive)
  (forward-paragraph 2)
  (backward-paragraph 1)
  (forward-line 1)
  (recenter-top-bottom 0))

(defun my/backward-paragraph ()
  (interactive)
  (backward-paragraph 2)
  (forward-paragraph 1)
  (backward-paragraph 1)
  (forward-line 1)
  (recenter-top-bottom 0))
#+end_src

***** lookup functions                      :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 21:30]
:END:

lookup functions yield to [[id:db630173-d371-45de-a78e-bcc57cb9d50c][engine-mode]]

#+begin_src emacs-lisp :tangle no
(defmacro define-lookup-function (fun search-prefix)
  "Create lookup function named FUN using SEARCH-PREFIX for querying.

if WORD-FIXED is given, use it as a search word."
  (declare (indent 1))
  `(defun ,fun (word &optional arg)
     "Issue search query with WORD.

Use a string in region for WORD if region is active.
If called with prefix argument, prompt the user to input WORD regardless region is active or not."
     (interactive (let ((region-str (when (use-region-p)
                                      (buffer-substring (region-beginning) (region-end)))))
                    (list (cond
                           ((and (stringp region-str)
                                 (equal current-prefix-arg nil))
                            region-str)
                           (t
                            (read-string "Enter URL or keywords: " region-str))))))
     (let ((eww-search-prefix ,search-prefix))
       (eww word 4))))

(define-lookup-function lookup-google "https://www.google.com/search?q=")
(define-lookup-function lookup-wikipedia-en "https://en.wikipedia.org/wiki/")
(define-lookup-function lookup-wikipedia-ja "https://ja.wikipedia.org/wiki/")
(define-lookup-function lookup-amazon "https://www.amazon.co.jp/gp/search/?field-keywords=")
(define-lookup-function lookup-melpa "https://melpa.org/#/?q=")
(define-lookup-function lookup-duckduckgo "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
(define-lookup-function lookup-eijiro "https://eow.alc.co.jp/search?q=")
(define-lookup-function lookup-weblio "https://www.weblio.jp/content/")
(define-lookup-function lookup-youtube "https://www.youtube.com/results?search_query=")

(with-eval-after-load 'hydra
  (defhydra hydra-lookup (global-map "C-c l"
                                     :color blue)
    "Lookup"
    ("g" lookup-google)
    ("G" lookup-duckduckgo "duckduckgo")
    ("w" lookup-wikipedia-ja)
    ("W" lookup-wikipedia-en)
    ("d" (lambda (&optional arg)
           (interactive "P")
           (if (equal arg '(4))
               (funcall-interactively #'dictionary-search nil)
             (dictionary-lookup-definition))))
    ("a" lookup-amazon "amazon.co.jp")
    ("m" lookup-melpa "melpa")
    ("l" lookup-weblio "weblio")
    ("y" lookup-youtube "youtube")
    ("e" my/define-word)
    ("j" lookup-eijiro)
    ("s" synosaurus-lookup "synosaurus-lookup")
    ("S" synosaurus-choose-and-replace "synosaurus-replace")
    ("q" nil "quit")))
#+end_src

***** tldr

#+begin_src emacs-lisp
(defun my/tldr (command)
  "Show the output of tldr for COMMAND in a dedicated buffer."
  (interactive (list (read-string "Coomand: ")))
  (let* ((buf-name "*TL;DR*")
         (buffer (get-buffer-create buf-name)))
    (with-current-buffer buffer
      (read-only-mode -1)
      (erase-buffer)
      (insert (shell-command-to-string (format "tldr %s"
                                               (shell-quote-argument command))))
      (ansi-color-apply-on-region (point-min) (point-max))
      (goto-char (point-min))
      (read-only-mode 1))
    (display-buffer buffer '((display-buffer-pop-up-window)
                             . ((window-height . 8))))
    (switch-to-buffer-other-window buffer)))
#+end_src

***** download media file                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-12 Sun 18:17]
:END:

#+begin_src emacs-lisp :noweb tangle
(defvar my/download-video-dir
  (file-name-concat "<<media-dir()>>" "downloads")
  "Directory where downloaded video locate.")

(defun my/download-video (url &optional filename playlistp)
  "Download video from `URL'.

With `C-u' prefix, open `my/download-video-dir' instead.
If optional argument `FILENAME' is passed, try to use this as filename.
If optional argument `PLAYLISTP' is passed, try to download all videos in playlist
instead of single video."
  (interactive (list (or current-prefix-arg
                         (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (if (equal url '(4))
      (find-file my/download-video-dir)
    (when (and (stringp url)
               (string-match "https?://www.youtube.com.+" url))
      (let* ((default-directory my/download-video-dir)
             (url-orig (match-string 0 url))
             (urlobj-orig (url-generic-parse-url url-orig))
             (pq-orig (url-path-and-query urlobj-orig))
             (yt-url
              (if (and (not playlistp)
                       (string= (car pq-orig) "/watch")
                       (assoc-string "list" (url-parse-query-string (cdr pq-orig))))
                  (url-recreate-url
                   (url-parse-make-urlobj (url-type urlobj-orig)
                                          (url-user urlobj-orig)
                                          (url-password urlobj-orig)
                                          (url-host urlobj-orig)
                                          (url-portspec urlobj-orig)
                                          (concat (car pq-orig) "?"
                                                  (url-build-query-string
                                                   (list (assoc "v" (url-parse-query-string (cdr pq-orig))))))
                                          (url-target urlobj-orig)
                                          (url-attributes urlobj-orig)
                                          (url-fullness urlobj-orig)))
                url)))
        (detached-shell-command
         (format "yt-dlp %1$s '%2$s'"
                 (mapconcat #'identity
                            (list (format "--format '%s'" (ytdl-format))
                                  (when playlistp "--yes-playlist --ignore-errors --download-archive downloaded.txt"))
                            " ")
                 yt-url))))))

(defvar my/download-audio-dir
  (file-name-concat "<<media-dir()>>" "downloads")
  "Directory where downloaded audio locate.")

(defun my/download-audio (url &optional filename)
  "Download audio from `URL'.

With `C-u' prefix, open `my/download-audio-dir' instead.
If optional argument `FILENAME' is given use this as a filename."
  (interactive (list (or current-prefix-arg
                         (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (let ((default-directory my/download-audio-dir))
    (if (equal url '(4))
        (find-file my/download-audio-dir)
      (detached-shell-command
       (if (string-match-p "https?://www.youtube.com.+" url)
           (format "yt-dlp --extract-audio %s" url)
         (concat (format "curl -LJ -o %s %s"
                         (or (and filename
                                  (format "%s.%s"
                                          (shell-quote-argument
                                           (my/file-name-legitimate filename))
                                          (file-name-extension url)))
                             (file-name-nondirectory
                              (car (url-path-and-query
                                    (url-generic-parse-url url)))))
                         url)))))))

(defun show-media-duration (url)
  "Return a duration value for media located at URL."
  (interactive (list (or (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (when-let ((duration (cond
                        ((string-match "https?://www.youtube.com.+" url)
                         (car (split-string (shell-command-to-string
                                             (format "yt-dlp --get-duration %s" url)))))
                        ((string-match "https?://.+" url)
                         (car (split-string (shell-command-to-string
                                             (format "ffmpeg -i \"%s\" 2>&1 | grep Duration | awk -F '[ ]+' '{print substr($3, 0, length($3)-1)}'" url))))))))
    (message "Duration: %s" (if (stringp duration)
                                duration "N/A"))))

(defun ytdl-format ()
  "Return appropriate format option value for youtube-dl command."
  (let* ((ipv4-addr (shell-command-to-string "hostname -I | cut -f1 -d' ' | tr -d '\n'"))
         (wifi-ssid (shell-command-to-string "iwgetid -r | tr -d '\n'"))
         (fmt-quality (cond
                       ;; using mobile Wi-Fi
                       ((string-prefix-p "192.168.179." ipv4-addr)
                        "b[filesize<20M] / w")
                       ;; using wired network or broad wifi
                       ((or (string-prefix-p "192.168.100." ipv4-addr)
                            (string-match-p (rx (or "saint_laurent_ap" "FREE_SPOT" "FREESPOT"))
                                            wifi-ssid))
                        "bv*[height<=720]+ba/b")
                       ;; using unknown network
                       (t
                        "wv*+wa/w"))))
    (format "%s" fmt-quality)))

(with-eval-after-load 'my-launch-app
  (keymap-set my/launch-app-map (kbd "d")
              #'my/download-video))
#+end_src

***** text to speech

#+begin_src emacs-lisp :noweb tangle
(defcustom my/say-maximum-duration 30
  "Maximum speech duration in second for `my/say'.")
(defvar my/say--timer nil "Timer used to cancel speech process.")
(defvar my/say--open-jtalk-process "Say<Open-JTalk>"
  "Fixed name for a process running Open JTalk.")

(defun my/say (string)
  "Say out `STRING'.

If an argument is given as `STRING', speech that text. Otherwise the buffer text
 is spoken unless region is active.

As of now, English and Japanese are supported for speech. Spoken language is
 determined by a string, specifically a string entirely consists of ASCII
 characters is identified as English. Otherwise the string is spoken in Japanese."
  (interactive (list (if (region-active-p)
                         (buffer-substring (region-beginning) (region-end))
                       (buffer-string))))
  (when-let ((fest (require 'festival nil t))
             (my/say-lang 'en))
    (if (string-match-p
         (format "\\`[%s]+\\'" "[:ascii:]’“”–") string)
        ;; festival-say-string is unusable if region is active
        (if (region-active-p)
            (festival-say-region (region-beginning) (region-end))
          (festival-say-string string))
      (my/say--open-jtalk string)
      (setq my/say-lang 'ja))
    (setq my/say--timer
          (cond
           ((eq my/say-lang 'en)
            (run-with-timer my/say-maximum-duration nil
                            (lambda ()
                              (festival-kill-process)
                              (setq my/say--timer nil))))
           ((eq my/say-lang 'ja)
            (run-with-timer my/say-maximum-duration nil
                            (lambda ()
                              (and (get-process my/say--open-jtalk-process)
                                   (interrupt-process my/say--open-jtalk-process))
                              (setq my/say--timer nil))))))))
(with-eval-after-load 'engine-mode
  (keymap-set engine-mode-prefixed-map (kbd "\"")
              #'my/say))

(defun my/say-cancel ()
  "Cancel speech process that has started by `my/say'."
  (interactive)
  (and (require 'festival nil t)
       my/say--timer
       (progn (cancel-timer my/say--timer)
              (setq my/say--timer nil)))
  (if (and festival-process
           (string= (process-status festival-process)
                    "run"))
      (festival-kill-process)
    (and (get-process my/say--open-jtalk-process)
         (interrupt-process my/say--open-jtalk-process))))
(global-set-key (kbd "C-x C-\"") #'my/say-cancel)
(with-eval-after-load 'embark
  (define-key embark-region-map "\"" #'my/say))

(defun my/say--open-jtalk (text)
  "Speech TEXT in Japanese using Open JTalk."
  (start-process-shell-command
   my/say--open-jtalk-process nil
   (format "echo %s | open_jtalk -x /var/lib/mecab/dic/open-jtalk/naist-jdic -m <<hts-voice-dir()>>/Voice/mei/mei_angry.htsvoice -ow /tmp/a.wav && aplay /tmp/a.wav"
           (replace-regexp-in-string "[\t\r\n\v\f]+" " " text))))
#+end_src

****** jsay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/jsay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly DIC="${HOME}/usr/share/hts/dic"
readonly VOICE="${HOME}/usr/share/hts/voice/mei_normal.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/jsay_XXXXXXXX.wav`

open_jtalk -x ${DIC} -m ${VOICE} -ow ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

****** esay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/esay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly VOICE="${HOME}/usr/share/hts/voice/cmu_us_arctic_slt.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/esay_XXXXXXXX.wav`

flite_hts_engine -m ${VOICE} -o ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

***** wrap up launch app commands in single keymap

#+begin_src emacs-lisp
(global-set-key (kbd "H-j")
                (define-keymap
                  :prefix 'my/launch-app-map
                  "e" #'eshell
                  "v" #'my/multi-vterm
                  "d" #'dired-jump
                  "w" #'eww
                  "m" #'mu4e
                  "p" #'proced
                  "P" #'list-processes
                  "?" #'woman
                  "l" (define-keymap
                        :prefix 'my/invoke-list-command-map)))

(provide 'my-launch-app)
#+end_src

***** show the day in calendar

#+begin_src emacs-lisp
(defun my/calendar-show-items ()
  "Show items on the day pointed in calendar view."
  (interactive)
  (let* ((calendar-date-display-form calendar-iso-date-display-form)
         (date (calendar-date-string (calendar-cursor-to-date)))
         (d (parse-time-string date))
         (year (decoded-time-year d))
         (files (file-expand-wildcards (file-name-concat org-directory "archive" "archive_*.org")))
         (buffer-name-prefix "==")
         (buffer-name (concat buffer-name-prefix date))
         (display-buffer-alist
          `((,buffer-name-prefix
             (display-buffer-reuse-mode-window
              display-buffer-pop-up-window)))))
    (org-ql-search files `(and (or (parent (heading ,date))
                                   (ts-a :on ,date))
                               (not (tags "web" "drill")))
      :buffer buffer-name)
    (other-window 1)))
#+end_src

***** replace regexp with re-builder and query-replace-regexp trick

Great idea using re-builder when query-replace-regexp borrowed from [[https://karthinks.com/software/bridging-islands-in-emacs-1/][this post]].

#+begin_src emacs-lisp
(defvar my/re-builder-positions nil
  "Store point and region bounds before calling re-builder")

(advice-add 're-builder
            :before
            (defun my/re-builder-save-state (&rest _)
              "Save into `my/re-builder-positions' the point and region
positions before calling `re-builder'."
              (setq my/re-builder-positions
                    (cons (point)
                          (when (region-active-p)
                            (list (region-beginning)
                                  (region-end)))))))

(defun reb-replace-regexp (&optional delimited)
  "Run `query-replace-regexp' with the contents of re-builder. With
non-nil optional argument DELIMITED, only replace matches
surrounded by word boundaries."
  (interactive "P")
  (reb-update-regexp)
  (let* ((re (reb-cook-regexp (reb-read-regexp)))
         (replacement (query-replace-read-to
                       re
                       (concat "Query replace"
                               (if current-prefix-arg
                                   (if (eq current-prefix-arg '-) " backward" " word")
                                 "")
                               " regexp"
                               (if (with-selected-window reb-target-window
                                     (region-active-p)) " in region" ""))
                       t))
         (pnt (car my/re-builder-positions))
         (beg (cadr my/re-builder-positions))
         (end (caddr my/re-builder-positions)))
    (with-selected-window reb-target-window
      (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                                        ; to control where in the buffer the replacement starts
                                        ; with re-builder
      (setq my/re-builder-positions nil)
      (reb-quit)
      (query-replace-regexp re replacement delimited beg end))))

(define-key reb-mode-map (kbd "RET") #'reb-replace-regexp)
(define-key reb-lisp-mode-map (kbd "RET") #'reb-replace-regexp)
(global-set-key (kbd "C-%") #'re-builder)
#+end_src

***** mark and open a file in one go in Dired
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 08:14]
:END:

#+begin_src emacs-lisp
(defun my/dired-mark-and-open-file ()
  "Mark file and open it in one go."
  (interactive)
  (save-excursion
    (dired-mark 1))
  (dired-open-file))

(with-eval-after-load 'dired
  (keymap-set dired-mode-map "M-RET"
              #'my/dired-mark-and-open-file))
#+end_src

***** open space
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 13:00]
:END:

Like C-o (M-x open-line), it is useful open single space ahead of point.

#+begin_src emacs-lisp
(defun my/open-space ()
  "Insert single space ahead of point."
  (interactive)
  (insert " ")
  (backward-char 1))
(keymap-global-set "M-o" 'my/open-space)
#+end_src

***** miscellaneous functions/commands

#+begin_src emacs-lisp
(defun my/insert-time-stamp (&optional arg)
  "Insert date string with format derived in deterministic way with ARG."
  (interactive "P")
  (let* ((simple-fmt "%Y%m%d")
         (concise-fmt "%Y-%m-%d")
         (verbose-fmt "%Y-%m-%d %H:%M:%S")
         (fmt-in-use (cond
                      ((equal arg '(16))
                       (read-string "time format: "
                                    "%Y-%m-%d %H:%M:%S"))
                      ((equal arg '(4))
                       verbose-fmt)
                      (t (cond
                          ((eq major-mode 'text-mode) concise-fmt)
                          ((eq major-mode 'dired-mode) simple-fmt)
                          (t simple-fmt))))))
    (if (called-interactively-p)
        (insert (format-time-string fmt-in-use))
      (format-time-string fmt-in-use))))
(global-set-key (kbd "C-c .") 'my/insert-time-stamp)

(defun my/drag-line-backward ()
  "Drag up current line for one."
  (interactive)
  (transpose-lines 1)
  (previous-line 2))
(global-set-key (kbd "M-S-<up>") 'my/drag-line-backward)

(defun my/drag-line-forward ()
  "Drag down current line for one."
  (interactive)
  (next-line 1)
  (transpose-lines 1)
  (previous-line 1))
(global-set-key (kbd "M-S-<down>") 'my/drag-line-forward)

(defun my/comment-box (b e)
  "Draw a box comment around the region but arrange for the region
  to extend to at least the fill column. Place the point after the
  comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

(defun my/ascii-string-p (string)
  "Return non-nil if `STRING' seems to be made of ASCII."
  (if (length> string 0)
      (string-match-p
       (format "\\`[%s]+\\'" "[:ascii:]’“”–")
       string)
    t))

(defun my/file-name-legitimate (filename)
  "Substitute legitimate file name for `FILENAME' so as not to have any special charactors."
  (seq-reduce (lambda (takeover replace)
                (replace-regexp-in-string
                 (car replace) (cdr replace) takeover))
              '(("/" . "／")
                ("\"" . "❞")
                ("'" . "❜"))
              filename))

(defun my/kansuji-to-number (kansuuji-string)
  "Translate Japanese Kansuuji(漢数字) KANSUUJI-STRING to number."
  (let* ((kanji-digits '(?一 ?二 ?三 ?四 ?五 ?六 ?七 ?八 ?九))
         (kanji-units '((?十 . 10) (?百 . 100) (?千 . 1000)))
         (rs (cl-reduce (lambda (kansuji val)
                          (let ((digit (cl-position kansuji kanji-digits))
                                (unit (cdr (assoc kansuji kanji-units))))
                            (if (> (cdr val) 0)
                                (cons (+ (car val) (* (cdr val)
                                                      (1+ (or digit 0))))
                                      (or unit 0))
                              (cond
                               (digit (cons (+ (1+ digit) (car val)) 0))
                               (unit (cons (car val) unit))))))
                        kansuuji-string
                        :from-end t :initial-value (cons 0 0))))
    (+ (car rs) (cdr rs))))
#+end_src

**** additional org tweaks
:PROPERTIES:
:header-args+: :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
:END:
***** keymap for global org commands
:PROPERTIES:
:CREATED:  [2023-08-08 Tue 14:42]
:END:

#+begin_src emacs-lisp
(global-set-key (kbd "H-o")
                (define-keymap
                  :prefix 'my/org-global-map
                  "o" #'org-open-at-point
                  "C-s" #'org-save-all-org-buffers
                  "J" #'org-babel-tangle-jump-to-org
                  "i" #'org-info-find-node
                  "m" #'org-mark-ring-goto
                  "@" #'org-previous-link))

(provide 'my-org-global-map)
#+end_src

***** remove empty clock log unless manually clocked out
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 10:23]
:END:

Removing zero time clock log makes sense that you can exclude undesirable line. But there is some sxception. Suppose you want to make clock log afterwards. Then you must create zero time clock log first and tune beginning and/or end of time. So I decided to retain zero time clock log only if clocked out manually (called org-clock-out interactively).

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (setq org-clock-out-remove-zero-time-clocks t)
  (advice-add #'org-clock-out :around #'my/org-clock-out-force-keep))

(defun my/org-clock-out-force-keep (oldfun &rest r)
  "Clock out with removing zero time clock log if called interactively."
  (let ((org-clock-out-remove-zero-time-clocks
         (if (called-interactively-p) nil t)))
    (apply oldfun r)))
#+end_src

***** embark keymaps for consult-org-heading and consult-location
:PROPERTIES:
:CREATED:  [2023-04-16 Sun 17:13]
:END:

#+begin_src emacs-lisp
(defmacro my/with-org-heading (candidate &rest body)
  "Execute BODY at org heading CANDIDATE.

This macro is supposed to be used in `embark-consult-org-heading-map' or
`embark-consult-outline-map'."
  (declare (indent defun))
  `(when-let* ((marker (or (get-text-property 0 'consult--candidate ,candidate)
                           (car (get-text-property 0 'consult-location ,candidate))))
               (buffer (marker-buffer marker))
               (pos (marker-position marker)))
     (save-excursion
       (org-with-remote-undo buffer
         (with-current-buffer buffer
           (goto-char pos)
           ,@body)))))

(defun my/org-clock-in-with (cand)
  "Clock in for CAND org heading.

CAND is supposed to be either consult-candidate or consult-location."
  (my/with-org-heading cand (org-clock-in)))

(defun my/org-clock-in-and-open-with (cand)
  "Clock in and open thing for CAND at once.

CAND is supposed to be either consult-candidate or consult-location."
  (my/with-org-heading cand
    (progn (org-clock-in)
           (org-open-at-point))))

(defun my/org-clock-supersede-with (cand)
  "Cancel the current clocking then clock in for CAND with filling out the canceled time.

CAND is supposed to be either consult-candidate or consult-location."
  (my/with-org-heading cand (my/org-clock-supersede)))

(defun my/org-clock-supersede-and-out-with (cand)
  "Cancel the current clocking then clock in and out for CAND with filling out the canceled time.

CAND is supposed to be either consult-candidate or consult-location."
  (my/with-org-heading cand
    (progn (my/org-clock-supersede)
           (org-clock-out))))

(defun my/org-todo-with (cand)
  "Change the todo state of an org heading CAND."
  (my/with-org-heading cand (org-todo)))

(defun my/org-open-with (cand)
  "Open org link in an org heading CAND."
  (my/with-org-heading cand (org-open-at-point)))

(with-eval-after-load 'embark
  (add-to-list 'embark-keymap-alist
               `(consult-org-heading
                 ,(defvar-keymap embark-consult-org-heading-map
                    :doc "Keymap for actions on Org headings."
                    :parent embark-general-map
                    "I"   #'my/org-clock-in-with
                    "C-I" #'my/org-clock-in-and-open-with
                    "V"   #'my/org-clock-supersede-with
                    "C-V" #'my/org-clock-supersede-and-out-with
                    "T"   #'my/org-todo-with
                    "o"   #'my/org-open-with)))
  (add-to-list 'embark-keymap-alist
               '(consult-location embark-consult-org-heading-map)))
#+end_src

***** org move repeat map
:PROPERTIES:
:CREATED:  [2023-03-05 Sun 16:15]
:END:

[[help:my/org-move-repeat-map][my/org-move-repeat-map]] allows to move around org elements and blocks with ease.

#+begin_src emacs-lisp
(defvar-keymap my/org-move-repeat-map
  :doc "Keymap to repeat moving commands in `org-mode'.  Used in `repeat-mode'."
  :repeat t
  "n" #'org-next-item
  "p" #'org-previous-item
  "u" #'org-up-element
  "d" #'org-down-element
  "f" #'org-forward-element
  "b" #'org-backward-element
  ">" #'org-next-link
  "<" #'org-previous-link
  "F" #'org-next-block
  "B" #'org-previous-block
  "M-f" #'org-next-block
  "M-b" #'org-previous-block
  "M-n" #'org-babel-next-src-block
  "M-p" #'org-babel-previous-src-block)
#+end_src

***** show org entries pointing to the current (backlink)
:PROPERTIES:
:CREATED:  [2023-03-03 Fri 11:26]
:END:

These commands show back links even in [[id:d5bd559a-2cab-4495-993b-f7a21637f0ea][denote]] files.

#+begin_src emacs-lisp
(defun my/org-backlink-entry ()
  "Show all entries that point to the entry at point."
  (interactive)
  (let ((id (org-entry-get (point) "ID"))
        (heading (org-get-heading t t t t)))
    (org-ql-search
      (directory-files-recursively org-directory "\\.org$" t
                                   (lambda (subdir)
                                     (member (file-relative-name subdir org-directory)
                                             '("agenda" "notes"))))
      `(link ,(or id heading))
      :super-groups '((:auto-parent)))))
(global-set-key (kbd "C-c b b") #'my/org-backlink-entry)

(defun my/org-backlink-by-tag ()
  "Show all entries that share tag with the entry at point."
  (interactive)
  (let* ((org-use-tag-inheritance
          (if (denote-file-is-note-p (buffer-file-name))
              t nil))
         (tags (org-get-tags)))
    (org-ql-search
      (directory-files-recursively org-directory "\\.org$" t
                                   (lambda (subdir)
                                     (member (file-relative-name subdir org-directory)
                                             '("agenda" "notes"))))
      `(tags ,@tags)
      :super-groups '((:auto-tags)))))
(global-set-key (kbd "C-c b t") #'my/org-backlink-by-tag)
#+end_src

***** set timer at clocking in

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (add-hook 'org-clock-in-prepare-hook
            #'my/org-clock-in-set-timer))

(defun my/org-clock-in-set-timer ()
  "Start count down timer for a clocked in entry.

If the entry has ATTENTION_SPAN property, use it for `org-timer-default-timer'.
Otherwise count down time is Effort property value.
In neither case, count down time is 25 min which is suggested in the Pomodoro-technique."
  (let* ((todo (org-get-todo-state))
         (attention-span (org-entry-get (point) "ATTENTION_SPAN" 'selective))
         (effort (org-entry-get (point) "Effort" 'selective))
         (countdown-time (or attention-span
                             (and todo "25")))
         (org-timer-default-timer countdown-time))
    (and countdown-time
         (org-timer-set-timer '(16)))))
#+end_src

***** stop timer at clocking out
:PROPERTIES:
:CREATED:  [2023-01-29 Sun 15:08]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (dolist (hook '(org-clock-out-hook org-clock-cancel-hook))
    (add-hook hook
              (lambda ()
                (and (bound-and-true-p  org-timer-countdown-timer)
                     (org-timer-stop))))))
#+end_src

***** supersede clocking task
:PROPERTIES:
:CREATED:  [2023-02-01 Wed 13:01]
:END:

#+begin_src emacs-lisp
(defun my/org-clock-supersede ()
  "Supersede clocking task with the task at point."
  (interactive)
  (let ((org-clock-continuously t))
    (save-excursion
      (and (bound-and-true-p org-clock-current-task)
           (org-clock-cancel)))
    (org-clock-in)))

(with-eval-after-load 'org-keys
  (with-eval-after-load 'my-org-global-map
    (bind-keys :map my/org-global-map
               ("V" . my/org-clock-supersede))
    (setf (map-elt org-speed-commands "V") #'my/org-clock-supersede)))
#+end_src

***** notify completion of timer for a task

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"mpg321"
#+end_src

#+begin_src bash :tangle (expand-file-name "volget" tangle/local-bin-dir)
pactl list sinks | grep '^[[:space:]]Volume:' | head -n $(($SINK + 1 )) | tail -n 1 | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,'
#+end_src

#+begin_src emacs-lisp :noweb tangle
(with-eval-after-load 'org-timer
  (add-hook 'org-timer-done-hook
            'my/org-task-timer-finish))

(defun my/org-task-timer-finish ()
  "Notify task timer by appropriate means."
  (when (and (org-clocking-p)
             org-clock-marker)
    (let ((alert (org-entry-get org-clock-marker
                                "ALERT")))
      (and (stringp alert)
           (string= alert "alarm")
           (alert "Timer Done!" :style 'alarm))
      (alert "Timer Done!" :style 'fringe :mode 'org-mode :buffer (org-clocking-buffer) :severity 'trivial))))

(defvar alarm-sound (file-name-concat "<<media-dir()>>" "levelup.mp3"))

(with-eval-after-load 'alert
  (alert-define-style 'alarm
                      :title "alarm"
                      :notifier
                      (lambda (info)
                        (let ((system-volume (string-trim (shell-command-to-string "volget"))))
                          (when (not (string= system-volume "0"))
                            (start-process-shell-command "system-alarm" nil
                                                         (mapconcat #'shell-quote-argument
                                                                    (list "mpg321" alarm-sound)
                                                                    " ")))))))
#+end_src

***** org-scrap (jotting down in org)
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 15:32]
:END:

Memo file (memo.org) is useful for jotting down fragmented pieces of text, code and more.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (defvar my/org-capture-scrap-file
    (file-name-concat org-directory "sandbox/scrap.org")
    "File for jotting down with `org-capture'.")
  (with-eval-after-load 'org-capture
    (add-to-list 'org-capture-templates
                 `("j" "Jot down"
                   entry (file ,my/org-capture-scrap-file)
                   "* %U\n#+begin_src %^{Lnaguage|text}\n%(my/org-capture-filter-scrap \"%i\")\n#+end_src"
                   :jump-to-captured t
                   :immediate-finish t)
                 t)))

(defun my/org-capture-filter-scrap (&optional str)
  "Replace semantic representation in `org-mode' with plain string in STR."
  (cond
   ((stringp str)
    (replace-regexp-in-string "^\\(*+ \\)" ",\\1" str))
   (t "")))
#+end_src

***** reset org element contextually
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:23]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c SPC" . my/org-reset-dwim)))

(defun my/org-reset-dwim ()
  "Exert reset procedure depending on org element at point."
  (interactive)
  (cond
   ((org-at-table-p) (org-table-blank-field))
   ((org-in-subtree-not-table-p)
    (org-save-outline-visibility t
      (org-reset-checkbox-state-subtree)))))
#+end_src

***** copy arbitrary org property to kill ring
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 13:52]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c W" . my/org-entry-kill)))

(with-eval-after-load 'org-keys
  (add-to-list 'org-speed-commands
               '("W" . my/org-entry-kill)
               t))

(defun my/org-entry-kill ()
  "Prompt user to select property to append to the kill ring.

If property's value matches $(...) format, ... is interpreted as shell command and execute it."
  (interactive)
  (let* ((properties (org-entry-properties))
         (prop-key-to-copy
          (completing-read "Property name: "
                           (mapcar #'(lambda (var) (car var)) properties))))
    (when (stringp prop-key-to-copy)
      (let* ((prop-value (cdr (assoc prop-key-to-copy properties)))
             (str-to-copy
              (cond
               ((string-match "$(\\(.+\\))" prop-value)
                (shell-command-to-string (match-string 1 prop-value)))
               (t prop-value))))
        (kill-new str-to-copy)))))
#+end_src

***** lob ingest all named source blocks
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 12:10]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map my/org-global-map
             ("b i" . my/org-babel-lob-ingest-all))

  (defvar my/org-babel-lob-ingest-files
    (seq-reduce (lambda (org-files dir)
                  (append org-files
                          (directory-files (expand-file-name dir org-directory) "\.org$")))
                '("agenda" "notes")
                nil)
    "A list of org files which is used in `my/org-babel-lob-ingest-all'.")

  (defun my/org-babel-lob-ingest-all ()
    "Add all named soruce blocks in cpecified files."
    (interactive)
    (dolist (org-file my/org-babel-lob-ingest-files)
      (org-babel-lob-ingest org-file))))
#+end_src

***** browse org subtree
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 11:11]
:END:

# #+header: :var
#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<share-dir()>>/emacs/org-subtree-view 0755 - - 3d
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c C-!" . my/org-subtree-view-in-browser))
  (add-to-list 'org-speed-commands
               '("!" . my/org-subtree-view-in-browser)
               t))

(defvar my/org-subtree-view-directory
  (expand-file-name "org-subtree-view"
                    user-emacs-directory)
  "A directory where generated html files are located in `my/org-subtree-view-in-browser'.")

(defun my/org-subtree-view-in-browser ()
  "Display org subtree at point as HTML.

If cursor points before first heading, all org sub-trees in the buffer will be
displayed instead."
  (interactive)
  (let* ((heading (org-get-heading t t t t))
         (org-export-show-temporary-export-buffer nil)
         (export-buf-name "*Org HTML Export*")
         (org-export-with-broken-links 'mark)
         (org-export-babel-evaluate t)
         (org-export-preserve-breaks t)
         (id (org-id-get))
         (uuid (downcase (if id id (org-id-uuid))))
         (html-file (format "%s/%s.html" my/org-subtree-view-directory uuid)))
    (org-html-export-as-html nil (not (org-before-first-heading-p)) nil)
    (with-current-buffer export-buf-name
      (write-file html-file))
    (browse-url-of-file html-file)))
#+end_src

***** alter org heading
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 10:55]
:END:

[[https://www.p-snow.org/posts/20231121_1858/][I wrote a blog post]] for this topic.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c C-% h" . my/org-change-heading)))

(defun my/org-change-heading ()
  "CHange the heading of the entry at `point'.

The previous name will be stored along with the execution date."
  (interactive)
  (let* ((old-heading (org-get-heading t t t t))
         (new-heading (read-string "Heading: " old-heading)))
    (save-excursion
      (org-back-to-heading t)
      (replace-string old-heading new-heading nil
                      (line-beginning-position) (line-end-position))
      (org-align-tags))
    (org-add-log-setup 'state new-heading old-heading 'state)))
#+end_src

***** download media files in org           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 10:43]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c D v" . my/org-download-video-link-at-point)
             ("C-c D a" . my/org-download-audio-link-at-point)
             ("C-c D =" . my/org-show-media-duration-at-point)))

(defun my/org-download-video-link-at-point ()
  "Download video file described in org link at point.

With `C-u' prefix find `my/download-video-dir' instead."
  (interactive)
  (cl-multiple-value-bind (url title)
      (ignore-errors
        (org-link-at-point-map
         (lambda (link desc)
           (cl-values link desc))))
    (if (and (not current-prefix-arg)
             url)
        (my/download-video url title)
      (call-interactively #'my/download-video))))

(defun my/org-download-audio-link-at-point ()
  "Download audio file described in org link at point.

With `C-u' prefix find `my/download-audio-dir' instead."
  (interactive)
  (cl-multiple-value-bind (url title)
      (ignore-errors
        (org-link-at-point-map
         (lambda (link desc)
           (cl-values link desc))))
    (if (and (not current-prefix-arg)
             url)
        (my/download-audio url title)
      (call-interactively #'my/download-audio))))

(defun my/org-show-media-duration-at-point ()
  "Show duration of media at point."
  (interactive)
  (org-link-at-point-map (lambda (url title)
                           (show-media-duration url))))
#+end_src

***** manage on-hold tasks
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 09:14]
:END:

- task lifecycle
  #+HEADER: :file ./task_lifecycle.png
  #+begin_src dot :tangle no
  digraph{
  "web browsing" [shape = hexagon];
  "web browsing" -> task [label = "read later"];
  elfeed [shape = hexagon];
  elfeed -> task [label = "watch later"];
  "web browsing" -> someday [label = "read someday"];
  task -> someday [label = "expired"];
  someday -> task [label = "drill (active)"];
  task -> pending [label = "abandoned"];
  subgraph cluster_0 {
  someday -> someday [label = "drill (inactive)"];
  pending;
  label = "somedays.org";
  }
  }
  #+end_src

****** review on-hold tasks
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 09:18]
:END:

On-hold tasks are encouraged to review and they prohibited to appear in agenda views.

#+begin_src emacs-lisp
(defun my/org-on-hold-task-review (resume-p)
  "Start or resume (if RESUME-P is non-nil) a session for reviewing tasks."
  (interactive "P")
  (progn
    (org-id-goto "58da20ee-97a9-4463-96b8-6ebb1084b9b7")
    (let ((org-drill-scope 'tree)
          (org-drill-question-tag my/org-review-tag)
          (org-drill-maximum-items-per-session 40)
          (org-drill-hide-item-headings-p nil)
          ;; drill session regulations
          (org-drill-maximum-duration 12)
          (org-drill-maximum-items-per-session 30)
          (org-drill-item-count-includes-failed-items-p t)
          ;; Spaced repetition algorithm
          (org-drill-spaced-repetition-algorithm 'sm5)
          (org-drill-sm5-initial-interval 14.0)
          ;; Random variation of repetition intervals
          (org-drill-add-random-noise-to-intervals-p t)
          ;; Adjusting item difficulty globally
          (org-drill-learn-fraction 0.37)
          (org-startup-indented nil))
      (and (require 'cl nil t)
           (org-drill nil (format "TODO=\"%s\"" my/org-todo-keyword--someday)
                      resume-p)))))
#+end_src

****** skip showing on-hold tasks in agenda view
:PROPERTIES:
:CREATED:  [2023-11-04 Sat 12:17]
:END:

#+begin_src emacs-lisp
(defvar my/org-review-tag "review"
  "Tag name set for tasks which is encourged to review.")

(defun my/org-agenda-skip-on-hold-task ()
  "Skip entries which hold schedule time and review tag in agenda view."
  (let ((tags (org-get-tags)))
    (if (and (member my/org-review-tag (org-get-tags))
             (org-get-scheduled-time (point)))
        (progn (outline-next-heading) (point))
      nil)))

(with-eval-after-load 'org-agenda
  (setopt org-agenda-skip-function-global
          'my/org-agenda-skip-on-hold-task))
#+end_src

****** show on-hold/leg-go task list
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 22:06]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-ql-view
  (push `("On-Hold tasks"
          :buffers-files ,(list (file-name-concat org-directory
                                                  "agenda/on-holds.org"))
          :query (todo ,my/org-todo-keyword--someday)
          :super-groups ((:auto-property "ARCHIVE_OLPATH"))
          :sort (priority date))
        org-ql-views)
  (push `("Review: on-hold tasks"
          :buffers-files ,(list (file-name-concat org-directory
                                                  "agenda/on-holds.org"))
          :query (todo ,my/org-todo-keyword--someday)
          :sort (scheduled))
        org-ql-views)
  (push `("Let-go tasks"
          :buffers-files ,(org-agenda-files)
          :query (todo ,my/org-done-keyword--pending)
          :super-groups ((:auto-property "ARCHIVE_OLPATH"))
          :sort (scheduled priority date))
        org-ql-views))
#+end_src

****** immediate re-refile on-hold task

#+begin_src emacs-lisp
(with-eval-after-load 'org-refile
  (add-hook 'org-after-refile-insert-hook
            #'my/org-archive-suspended-task))

(defun my/org-archive-suspended-task ()
  "Archive this entry to the file for suspended tasks if the TODO state fits the bill."
  (interactive)
  (when (member (org-entry-get nil "TODO")
                `(,my/org-todo-keyword--someday ,my/org-done-keyword--pending))
    (org-archive-subtree)))
#+end_src

***** send org subtree via email

#+begin_src emacs-lisp
(with-eval-after-load 'org-keys
  (bind-keys :map org-mode-map
             ("C-c M" . my/org-subtree-send-email))
  (add-to-list 'org-speed-commands
               '("M" . my/org-subtree-send-email)
               t))

(defun my/org-subtree-send-email ()
  "Send an email containing the contents of the subtree at the entry at point."
  (interactive)
  (org-save-outline-visibility t
    (save-excursion
      (org-fold-show-all)
      (let* ((heading (org-get-heading t t t t))
             (org-export-with-toc nil)
             (org-export-with-author nil)
             (org-export-show-temporary-export-buffer nil)
             (message-kill-buffer-on-exit t)
             (exp-buf (org-ascii-export-as-ascii nil t t t)))
        (message-mail (cdr (assoc "username" (auth-source-pass-parse-entry "www.zoho.com")))
                      heading)
        (message-goto-body)
        (insert (with-current-buffer exp-buf (buffer-string)))
        (message-send-and-exit)))))
#+end_src
***** clean up after the task has chenged to DONE
:PROPERTIES:
:CREATED:  [2023-01-30 Mon 13:45]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (add-hook 'org-after-todo-state-change-hook
            #'my/org-todo-cleanup-when-done))

(defun my/org-todo-cleanup-when-done ()
  "Exert several procedure when the state of the task has chnaged to DONE.

Including:
- Remove priority
- Reset DONE state if the task is non-repeated habit
- Close the project of the task"
  ;; when the entry has any org-done-keywords
  (when (member org-state
                `(,my/org-done-keyword--done ,my/org-done-keyword--cancel ,my/org-done-keyword--pending))
    ;; remove priority if exists
    (and ;; the entry has been set any priority
     (/= 21000 (save-excursion
                 (save-match-data
                   (beginning-of-line)
                   (and (looking-at org-heading-regexp)
                        (org-get-priority (match-string 0))))))
     (org-priority 'remove))
    ;; reset done state if the task is non-repeated habit
    (and (org-is-habit-p)
         (not (org-get-scheduled-time (point)))
         (org-todo ""))
    ;; close the project
    (save-excursion
      (org-back-to-heading t)
      (org-speed-move-safe 'outline-up-heading)
      (and (member my/org-project-tag (org-get-tags))
           (org-todo my/org-done-keyword--done)))))
#+end_src

***** flush old clock logs and state changes
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:51]
:END:
:LOGBOOK:
- State "flush old clock logs and state changes" from "purge old clock logs and state changes" [2023-11-23 Thu 15:10]
- State "purge old clock logs and state changes" from "tidy up org entry by removing old blobs" [2023-11-23 Thu 15:01]
:END:

The hook functions, which is commented out, provoke malfunction failing to create todo state change logs which is necessary for habit graph.

#+NAME: midnight-flush-blobs
#+begin_src emacs-lisp
(with-eval-after-load 'midnight
  (add-hook 'midnight-hook
            (lambda ()
              (org-map-entries (lambda () (when (org-is-habit-p)
                                            (my/org-flush-blobs)))
                               nil
                               'agenda))))
#+end_src

#+NAME: flush-blobs
#+begin_src emacs-lisp
(defvar my/org-flush-blobs-old-timestamp-in-day 90
  "Flush blobs with timestamps that are earlier than this number of days.")

(defvar my/org-flush-blobs-clock-log t
  "Whether `my/org-flush-blobs' flushes old clock logs.")

(defvar my/org-flush-blobs-state-change t
  "Whether `my/org-flush-blobs' flushes old todo state changes.")

(defun my/org-flush-blobs ()
  "Flush old blob."
  (interactive)
  (org-save-outline-visibility t
    (org-show-all)
    (save-excursion
      (let ((case-fold-search t)
            (next-heading (save-excursion
                            (org-next-visible-heading 1)
                            (point-marker))))
        (mapc (lambda (re)
                (org-back-to-heading t)
                (while-let ((ts-time (and (re-search-forward re (marker-position next-heading) t)
                                          (encode-time (parse-time-string (match-string 1))))))
                  (when (time-less-p ts-time
                                     (time-subtract (current-time) (days-to-time my/org-flush-blobs-old-timestamp-in-day)))
                    (kill-whole-line))))
              (append (and my/org-flush-blobs-clock-log
                           (list org-tr-regexp-both))
                      (and my/org-flush-blobs-state-change
                           (list (concat (rx "- State " "\"" (>= 1 upper) "\"" (+ space)
                                             "from " (opt "\"" (>= 1 upper) "\"") (+ space))
                                         org-ts-regexp-inactive)))))
        (when (featurep 'org-clock)
          (org-clock-remove-empty-clock-drawer))))))
#+end_src

****** batch blob flushing                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 21:05]
:END:

#+begin_src shell :eval no :tangle no
export DISPLAY=:0 && \
  emacs -Q \
        -l ~/.emacs.d/early-init.el \
        -l ~/.emacs.d/elisp/config/my-org-flush-blobs.el \
        -l ~/.emacs.d/elisp/config/batch/org-flush-blobs.el \
        -f my/org-flush-blobs-in-habits
#+end_src

#+begin_src emacs-lisp :noweb tangle
(require 'org-habit)
(require 'org-clock)

(setq org-agenda-files '("~/org/agenda/"))

(defun my/org-flush-blobs-in-habits ()
  "Flush old blobs for habit tasks in `org-agenda-files'."
  (org-map-entries (lambda () (when (org-is-habit-p)
                                (my/org-flush-blobs)))
                   nil
                   'agenda)
  (org-save-all-org-buffers)
  (save-buffers-kill-emacs t))
#+end_src

***** pad non clocking time
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 07:36]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (add-hook 'org-clock-out-hook #'my/org-clock-pad-time))

(defun my/org-clock-pad-time ()
  "Clock in the 'Break' task if the previous task has clocked out."
  (save-excursion
    (let ((break-entry-id "d49d97de-58ec-4e41-b58c-491a9e216e1c"))
      (when (and (not org-clock-clocking-in)
                 (not (string= (or (save-excursion
                                     (org-clock-goto)
                                     (org-id-get))
                                   "")
                               break-entry-id)))
        (org-id-goto break-entry-id)
        (org-clock-in)))))
#+end_src

***** show week number from the timestamp at point
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 15:01]
:END:

#+begin_src emacs-lisp
(defun my/org-iso-week-at-point ()
  "Display ISO 8601 week number correspoinds to time stamp at point."
  (interactive)
  (when-let ((ts-bound (org-in-regexp (org-re-timestamp 'all)))
             (ts (buffer-substring (car ts-bound) (cdr ts-bound))))
    (message "W%s" (format-time-string "%V" (org-read-date nil t ts nil)))))
#+end_src

***** show outline path for the entry at point
:PROPERTIES:
:CREATED:  [2023-11-01 Wed 14:48]
:END:

#+begin_src emacs-lisp
(defun my/org-show-outline-path ()
  "Show sparse tree for the entry at point to represent outline path."
  (interactive)
  (save-excursion
    (cl-labels ((lookup-parent ()
                  (let* ((heading-raw (substring-no-properties
                                       (org-get-heading t t t t)))
                         (heading (if (string-match org-link-bracket-re heading-raw)
                                      (match-string 2 heading-raw)
                                    heading-raw))
                         (h-li (list heading)))
                    (if (org-up-heading-safe)
                        (append (lookup-parent) h-li)
                      h-li))))
      (org-ql-sparse-tree (format "(olps %s)"
                                  (mapconcat (lambda (str) (format "\"%s\"" str))
                                             (lookup-parent)
                                             " "))))))

(with-eval-after-load 'my/org-mode-init
  (keymap-set org-mode-map "C-c M-/"
              #'my/org-show-outline-path))
#+end_src

***** use ISO week tree instead of Y/M/D tree
:PROPERTIES:
:CREATED:  [2023-11-03 Fri 15:03]
:END:

Following code is also responsible for deterministic archive location.

#+begin_src emacs-lisp
(with-eval-after-load 'org-archive
  (advice-add #'org-archive-subtree :around
              #'my/org-archive-subtree--iso-datetree))

(defun my/org-archive-subtree--iso-datetree (oldfun &rest r)
  "Move the current subtree to the archive.

If archiving location is datetree, it supposed to be iso week tree."
  (interactive)
  (when (member (org-get-todo-state)
                `(,my/org-todo-keyword--urgent ,my/org-todo-keyword--todo ,my/org-todo-keyword--next ,my/org-todo-keyword--in-action))
    (org-todo my/org-done-keyword--cancel))
  (when (string= (org-get-todo-state)
                 my/org-todo-keyword--someday)
    (org-toggle-tag my/org-review-tag 'on))
  (let* ((todo-state (org-get-todo-state))
         (closed-time (org-entry-get nil "CLOSED" t))
         (org-archive-location
          (cond
           ((member todo-state
                    `(nil ,my/org-done-keyword--done ,my/org-done-keyword--cancel))
            (format "%s::datetree/"
                    (file-name-concat org-directory "archive"
                                      (format "archive_%s.org"
                                              (if closed-time
                                                  (nth 5
                                                       (parse-time-string
                                                        (substring closed-time 1 -1)))
                                                (format-time-string "%Y"))))))
           ((string= todo-state my/org-todo-keyword--someday)
            (format "%s::* on-hold tasks"
                    (expand-file-name "agenda/on-holds.org" org-directory)))
           ((string= todo-state my/org-done-keyword--pending)
            (format "%s::* let go tasks"
                    (expand-file-name "archive/agenda/let-goes.org" org-directory))))))
    (when (stringp org-archive-location)
      (and (require 'org-relate nil t)
           (org-relate-interrelate))
      (advice-add #'org-datetree-find-date-create :override
                  #'org-datetree-find-iso-week-create)
      (apply oldfun r)
      (advice-remove #'org-datetree-find-date-create
                     #'org-datetree-find-iso-week-create))))

(with-eval-after-load 'org-agenda
  (define-key org-agenda-mode-map (kbd "C") #'my/org-archive-find--iso-datetree))

(with-eval-after-load 'calendar
  (define-key calendar-mode-map (kbd "C") #'my/org-archive-find--iso-datetree))

;;;###autoload
(defun my/org-archive-find--iso-datetree (date)
  "Find and visit the location of DATE in archivee file.

DATE must be a string representing the date to find and parsable with `format-time-string'.

If called interactively, it prompt the user to select the date to find."
  (interactive
   (cond
    ((eq major-mode 'calendar-mode)
     (list (calendar-date-string (calendar-cursor-to-date))))
    ((eq major-mode 'org-agenda-mode)
     (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                     (user-error "Don't know which date to open in calendar")))
            (date (calendar-gregorian-from-absolute day)))
       (list (calendar-date-string date))))
    (t (let ((date-select (org-read-date)))
         (list date-select)))))
  (let* ((d (parse-time-string date))
         (day (decoded-time-day d))
         (month (decoded-time-month d))
         (year (decoded-time-year d)))
    (find-file (file-name-concat org-directory "archive" (format "archive_%d.org" year)))
    (org-datetree-find-iso-week-create `(,month ,day ,year))))

(with-eval-after-load 'my-org-global-map
  (bind-keys :map my/org-global-map
             ("D" . my/org-archive-find--iso-datetree)))
#+end_src

***** search org entry under 'default-directory'
:PROPERTIES:
:CREATED:  [2023-10-20 Fri 20:14]
:END:

#+begin_src emacs-lisp
(defmacro with-org-files-under (&rest body)
  "Eval `BODY' with providing org file list from `default-directory'."
  (declare (indent defun))
  `(let ((org-files (directory-files-recursively
                     default-directory
                     "\\(?:\\.org\\(?:\\.gpg\\)?$\\)")))
     ,@body))

(defun my/consult-org-heading-under ()
  "Invoke `consult-org-heading' with all org files under `default-directory'."
  (interactive)
  (with-org-files-under
    (let ((org-agenda-files org-files))
      (consult-org-agenda))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map "H"
              (lambda (dir) (interactive "sDir: ")
                (let ((default-directory dir))
                  (my/consult-org-heading-under)))))

(with-eval-after-load 'my-org-global-map
  (keymap-set my/org-global-map "H"
              #'my/consult-org-heading-under))

(defun my/org-ql-search-under ()
  "Invoke `org-ql-search' with all org files under `default-directory'."
  (interactive)
  (with-org-files-under
    (let ((org-agenda-files org-files)
          (query (read-string "Query: ")))
      (org-ql-search (org-agenda-files) query))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map "Q"
              (lambda (dir) (interactive "sDir: ")
                (let ((default-directory dir))
                  (my/org-ql-search-under)))))

(with-eval-after-load 'my-org-global-map
  (keymap-set my/org-global-map "Q"
              #'my/org-ql-search-under))
#+end_src

***** open large org files insidiously
:PROPERTIES:
:CREATED:  [2023-11-28 Tue 07:38]
:END:

#+begin_src emacs-lisp
(use-package open-large-org-file
  :no-require t
  :after (org denote)
  :config
  (run-with-idle-timer 25 nil
                       (lambda ()
                         "Open large org files."
                         (mapc #'find-file-noselect
                               (list (denote-get-path-by-id "20230605T170959")
                                     (file-name-concat org-directory (format-time-string "archive/archive_%Y.org")))))))
#+end_src

**** my tempel templates in modes
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:02]
:header-args:emacs-lisp: :eval no
:END:
***** text-mode templates
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 14:33]
:END:

#+header: :shebang "text-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/text.eld")
(gma "update on " (my/insert-time-stamp '(4)))
#+end_src

***** org-mode templates
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:02]
:END:

#+header: :shebang "org-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/org.eld")
(call & "#+CALL: " (p "name" name) "(" (s var) "=\"" (s value) "\")")
(name & "#+NAME: " (p "name" name))
(/ "[/]" (org-update-statistics-cookies nil))
(tsm p " :: " (with-temp-buffer (org-insert-time-stamp (current-time) t t)))

<<org-template>>
#+end_src

***** minibuffer-mode templates
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:18]
:END:

#+header: :shebang "minibuffer-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/minibuffer.eld")
(guix-search "guix search " (p (my/region-string-trans-buffer)))
(version (p "command") " --version")
(curly-bracket-japanese-regexp
 (rx (parened ?｛ (+ (or " "
                         (category japanese-hiragana-two-byte))))))

 <<minibuffer-template>>
#+end_src

***** emacs-lisp-mode templates
:PROPERTIES:
:CREATED:  [2023-11-15 Wed 12:26]
:END:

#+header: :shebang "emacs-lisp-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/emacs-lisp.eld")
(require "(require '" (p "feature") ")")
(lambda "(lambda () " n>
  (p "docstring: " doc-str t)
  (when (length> doc-str 0)
    (format "\"%s\"\n" doc-str))
  > p ")")
(interactive "(interactive"
             (p "code: " code t)
             (when (length> code 0)
               (format " \"%s\"" code))
             ")")
(bind-keys "(bind-keys " (p (format ":map "))
           "(\"" p "\" . " p "))")
#+end_src

***** sh-base-mode templates
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 19:23]
:END:

#+header: :shebang "sh-base-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/sh-base.eld")
(rf "${" p "}")
(function "function " (p "name") " {" n> p n "}")
#+end_src

***** mu4e-compose-mode
:PROPERTIES:
:CREATED:  [2023-12-04 Mon 19:52]
:END:

#+header: :shebang "mu4e-compose-mode"
#+begin_src emacs-lisp :noweb yes :tangle (file-name-concat user-emacs-directory-default "templates/mu4e-compose.eld")
(よろ "よろしくお願いいたします。")
(いじょう "以上、よろしくお願いいたします。")
#+end_src

**** shell command string builders
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 21:20]
:END:
***** system sleep
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 21:25]
:END:

#+begin_src emacs-lisp :noweb tangle
(defvar my/pre-command-history nil
  "History list for pre commands that will be executed before sleep.")

(defun my/command-system-sleep (&optional wake-at delay pre-command)
  "Return a shell command string to sleep system until WAKE-AT with DELAY time."
  (interactive (list (read-string "Wake time: ")
                     (read-string "Delay before sleep: ")
                     (read-string "Pre command: " nil 'my/pre-command-history)))
  (string-trim-right
   (let ((mid-h <<midnight-hour>>)
         (ct (current-time)))
     (string-join
      (delq nil
            (list
             (and (stringp delay)
                  (length> delay 0)
                  (format "sleep %s" delay))
             (and (stringp pre-command)
                  (length> pre-command 0)
                  pre-command)
             (format "pwsudo rtcwake -v -m mem -l --date '%s';"
                     (string-trim
                      (shell-command-to-string (format "date +'%%Y-%%m-%%d %%H:%%M' -d '%s'"
                                                       (or (and (stringp wake-at) (length> wake-at 0)
                                                                (my/expand-shorthand-time wake-at))
                                                           (concat (when (>= (nth 2 (decode-time ct)) mid-h)
                                                                     "tomorrow ")
                                                                   (format "%02d:00" mid-h)))))))))
      " && "))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-template
(system-sleep (call-interactively 'my/command-system-sleep))
(weekday-job "midnight.sh;")
(weekend-job "which system.sh | xargs pwsudo; midnight.sh; weekend.sh;")
#+end_src

***** download video/audio
:PROPERTIES:
:CREATED:  [2023-11-10 Fri 20:57]
:END:

command builders
#+begin_src emacs-lisp :noweb tangle
(cl-defun my/command-download-media (url &key filename audio play duration)
  "Return a shell command string to download media file from URL using yt-dlp.

If :FILENAME offered, the name of downloaded file will be its value.
If :AUDIO offered, audio file will be extracted from downloaded video file and
 set thumbnail.
if :PLAY offered, the file will be played right after downloading.
If :DURATION offered, return media duration instead."
  (format "yt-dlp %s"
          (string-join
           (delq nil
                 (list (format "-P '%s'" (file-name-concat "<<media-dir()>>" "downloads"))
                       "--embed-chapters"
                       "--live-from-start"
                       (and filename
                            (format "-o '%s.%%\(ext\)s'"
                                    (my/file-name-legitimate filename)))
                       (and play "--exec 'mpv {}'")
                       (and audio "-x --embed-thumbnail")
                       (and duration "--get-duration")
                       (format "'%s'" url)))
           " ")))

(with-eval-after-load 'embark
  (lambda-key embark-url-map "D"
              (lambda (url)
                "Download media file at URL."
                (detached-shell-command
                 (my/command-download-media url)))))

(with-eval-after-load 'my-launch-app
  (lambda-key my/launch-app-map "D"
              (lambda (url)
                "Download media file at URL."
                (interactive (list (let ((cb-txt (substring-no-properties (x-get-clipboard))))
                                     (if (string-match-p url-handler-regexp cb-txt)
                                         cb-txt
                                       (read-string "URL: ")))))
                (detached-shell-command
                 (apply 'my/command-download-media
                        url
                        (when current-prefix-arg '(:play t)))))))
#+end_src

tempel templates in minibuffer-mode
#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-template
(download-video (p "URL: " url t)
                (my/command-download-media url))
(download-audio (p "URL: " url t)
                (my/command-download-media url :audio t))
(media-durationa (p "URL: " url t)
                 (my/command-download-media url :duration t))
#+end_src

***** opus transcoder
:PROPERTIES:
:CREATED:  [2023-11-12 Sun 22:00]
:END:

#+begin_src emacs-lisp
(defun my/command-transcode-opus (&optional file)
  "Return a shell command string to transcode FILE to opus audio file.."
  (interactive (list (if (eq minibuffer-history-variable 'dired-shell-command-history)
                         "*"
                       (read-file-name "File: "))))
  (format "parallel ffmpeg -i '{}' -c:a libopus -b:a 64k -ac 2 '{.}'.opus ::: %s"
          file))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-template
(opus (call-interactively 'my/command-transcode-opus))
#+end_src

***** regenerate another file format with pandoc
:PROPERTIES:
:CREATED:  [2023-12-17 Sun 10:09]
:END:

#+NAME: elisp-pandoc
#+begin_src emacs-lisp
(defun my/pandoc (file out-format)
  "Regenerate FILE with desired OUT-FORMAT with pandoc."
  (format "parallel pandoc -o '{.}'.%1$s '{}' %3$s::: %2$s"
          out-format file
          (if (string= out-format "pdf")
              "--pdf-engine weasyprint "
            "")))
#+end_src

#+name: template-pandoc
#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-template
(pandoc (funcall-interactively 'my/pandoc
                               (if (eq minibuffer-history-variable 'dired-shell-command-history)
                                   "*" (read-file-name "File: "))
                               (read-string "Format: " "org")))
#+end_src

#+NAME: guix-base-pandoc
#+begin_src scheme :noweb-ref guix-base
"weasyprint"
#+end_src

***** region text
:PROPERTIES:
:CREATED:  [2023-12-17 Sun 16:11]
:END:

#+NAME: elisp-region-text
#+begin_src emacs-lisp
(defun my/region-string-trans-buffer ()
  "Return region string in some buffer where region is active."
  (cl-some (lambda (buf)
             (with-current-buffer buf
               (when (region-active-p)
                 (buffer-substring-no-properties (region-beginning)
                                                 (region-end)))))
           (list (current-buffer) (other-buffer nil t))))
#+end_src

**** org contents templates
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 21:44]
:END:

***** journal entry template
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 21:45]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(journal "- diary" n>
         "#+begin_src text" n> "#+end_src" n
         "- clocktable" n>
         "#+begin: clocktable-by-tag :maxlevel 3 :wstart 1 "
         ":block " (p "year") "-" (p "month") "-" (p "day") n>
         "#+end:" n
         "- agenda" n>
         "#+begin_example" n
         (p "agenda") n>
         "#+end_example")
#+end_src

***** week subtree template
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 16:36]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(nw & "- mission [/]" n
    "- clocktable" n>
    "#+begin: clocktable-by-tag :maxlevel 3 "
    ":block " (p "year") "-W" (p "isoweek") " :wstart 1" n>
    "#+end:" n
    "- meta-projects" n>
    "#+begin: clocktable :maxlevel 3 :scope agenda "
    ":block " (p "year") "-W" (p "isoweek")
    " :wstart 1 :narrow 40! :tcolumns 3 :formula %" n>
    "#+end:")
#+end_src

***** blog post
:PROPERTIES:
:CREATED:  [2023-11-16 Thu 19:58]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(blog & (org-insert-heading-after-current)
      (p "blog title: " title t) (insert title)
      (prog1 nil (org-schedule nil (current-time)))
      (org-entry-put (point) "EXPORT_FILE_NAME" (format-time-string "%Y%m%d_%H%M")))
#+end_src

**** elisp code corresponding to external app
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:

This section mainly for elisp code associated with some other programs.

#+begin_src emacs-lisp :noweb yes
<<elisp-code>>
#+end_src

**** literate configuration (this file)
:PROPERTIES:
:CREATED:  [2023-10-27 Fri 17:44]
:END:

Configuration files are generated by tangling org source blocks whenever this file is saved defined in [[file:.dir-locals.el][.dir-locals.el]]. Following code suppresses confirmation at file saving.

#+begin_src emacs-lisp
(defun my/compile-default-command ()
  "Compile `compile-command'."
  (let ((default-directory (project-root (project-current t)))
        (compilation-buffer-name-function
         (or project-compilation-buffer-name-function
             compilation-buffer-name-function)))
    (funcall #'compile compile-command))
  (quit-window))

(add-to-list 'safe-local-eval-forms
             '(add-hook 'after-save-hook
                        #'my/compile-default-command nil t))
#+end_src

***** Common Babel Config

I'd share this babel config between literate configuration and main Emacs session.

#+begin_src emacs-lisp :comments no :tangle (expand-file-name "org-babel-config.el" current-dir) :noweb-ref babel-conf
(with-eval-after-load 'ob-core
  (setq org-babel-noweb-error-all-langs t)
  (setopt org-babel-python-command (executable-find "python3"))
  (setopt org-babel-ruby-command (executable-find "ruby"))
  (setopt org-confirm-babel-evaluate nil)
  (setopt org-babel-load-languages '((shell      . t)
                                     (emacs-lisp . t)
                                     (python     . t)))
  (setf org-babel-default-header-args
        (append org-babel-default-header-args
                '((:mkdirp . t)
                  (:comments . "both")))))

(with-eval-after-load 'ob-shell
  (add-to-list 'org-babel-default-header-args:shell
               '(:shebang . "#!/bin/sh"))
  (add-to-list 'org-babel-default-header-args:shell
               `(:tangle-mode . ,(identity #o555)))
  (add-to-list 'org-babel-default-header-args:bash
               `(:tangle-mode . ,(identity #o555)))
  (add-to-list 'org-babel-default-header-args:bash
               '(:shebang . "#!/usr/bin/env bash\nset -euo pipefail\n")))

(with-eval-after-load 'ob-emacs-lisp
  (add-to-list 'org-babel-default-header-args:emacs-lisp
               `(:tangle-mode . ,(identity #o444))))

(with-eval-after-load 'ob-python
  (setf org-babel-default-header-args:python
        (append org-babel-default-header-args:python
                `((:tangle-mode . ,(identity #o555))
                  (:shebang . "#!/usr/bin/env python3")))))

(with-eval-after-load 'ob-ruby
  (setf org-babel-default-header-args:ruby
        (append org-babel-default-header-args:ruby
                `((:tangle-mode . ,(identity #o555))
                  (:shebang . "#!/usr/bin/env ruby")))))
#+end_src

**** my RX definitions
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 11:25]
:END:

My RX function 'parened' evaluates 'parened-rx' with reb-target-buffer's syntax table since  working buffer with RX in re-builder is reb-lisp-mode which does not hold same syntax table with target-buffer.

#+begin_src emacs-lisp
(defun parened-rx (paren-open-char element)
  `(seq ,paren-open-char
        (group ,element)
        ,(matching-paren paren-open-char)))

(rx-define parened (paren-open-char element)
  (eval (with-syntax-table (cond
                            ((derived-mode-p 'reb-lisp-mode)
                             (with-current-buffer reb-target-buffer (syntax-table)))
                            ((derived-mode-p 'minibuffer-mode)
                             (with-current-buffer (other-buffer nil t) (syntax-table)))
                            (t (syntax-table)))
          (parened-rx paren-open-char 'element))))
#+end_src

**** obsolete features                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:
***** org-archive-datetree                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-08-10 Wed 14:51]
:END:

#+begin_src emacs-lisp :tangle no
(require 'org)
(require 'org-agenda)

(defcustom my/org-archive-before-archive-hook nil
  "Hook that is run right before a archive process begins."
  :group 'org-archive-datetree
  :type 'hook)

(defun my/org-archive-file (&optional year)
  "Return a path of archive file.

If optional argument `YEAR' is passed that year's file is returned instead of current year's."
  (let* ((record-year (or year (ts-year (ts-now))))
         (record-file-cand (format "%s/archive/archive_%s.org" org-directory record-year))
         (record-file
          (if (file-exists-p record-file-cand)
              record-file-cand
            (expand-file-name "archive/archive_0000.org" org-directory))))
    (if (or (file-exists-p record-file)
            (file-symlink-p record-file))
        record-file
      nil)))

(defvar my/org-archive-file (my/org-archive-file))

(defun my/org-archive-files ()
  "Return list of archive files."
  (append (directory-files (expand-file-name "archive" org-directory) t "archive_[[:digit:]]\\{4\\}\\.org" nil)
          org-agenda-files))

(defvar my/org-archive-files (my/org-archive-files))

(defun my/org-archive-find-date (date)
  "Find and visit the location of DATE in archivee file.

DATE must be a string representing the date to find and parsable with `format-time-string'.

If called interactively, it prompt the user to select the date to find."
  (interactive
   (cond
    ((eq major-mode 'calendar-mode)
     (list (calendar-date-string (calendar-cursor-to-date))))
    ((eq major-mode 'org-agenda-mode)
     (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                     (user-error "Don't know which date to open in calendar")))
            (date (calendar-gregorian-from-absolute day)))
       (list (calendar-date-string date))))
    (t (let ((date-select (org-read-date)))
         (list date-select)))))
  (let* ((d (parse-time-string date))
         (day (decoded-time-day d))
         (month (decoded-time-month d))
         (year (decoded-time-year d)))
    (find-file (my/org-archive-file year))
    (org-datetree-find-iso-week-create `(,month ,day ,year))))

(defun my/org-archive-subtree ()
  "Refile current subtree to archive file using latest timestamp."
  (interactive)
  (let* ((ts (car (sort (org-timestamps-in-entry) #'ts>)))
         (year (ts-year (or ts (ts-now))))
         (save-file (my/org-archive-file year))
         (tags (org-get-local-tags))
         (todo (org-get-todo-state)))
    (when-let* ((pos (with-current-buffer (find-file-noselect save-file)
                       (save-excursion
                         (if (and (member "web" tags)
                                  (not (member todo `(,my/org-done-keyword--done
                                                      ,my/org-done-keyword--pending))))
                             (org-find-exact-headline-in-buffer "untouched items")
                           (org-datetree-find-iso-week-create `(,(ts-month ts)
                                                                ,(ts-day ts)
                                                                ,(ts-year ts)))
                           (point))))))
      (run-hooks 'my/org-archive-before-archive-hook)
      (org-refile nil nil (list nil save-file nil pos)))
    (org-save-all-org-buffers)
    (setq this-command 'my/org-archive-subtree)))

(defun my/org-agenda-archive-subtree ()
  "Refile the entry or subtree belonging to the current agenda entry."
  (interactive)
  (org-agenda-archive-with 'my/org-archive-subtree))

(defun my/org-ql-view-archive-subtree ()
  "Refile the entry or subtree belonging to the current agenda entry."
  (interactive)
  (org-agenda-archive-with 'my/org-archive-subtree)
  (org-ql-view-refresh))

(defun my/org-archive-search (query)
  "Search org entries matched QUERY in archive files using `org-ql-search'."
  (interactive (list (read-string "Query: ")))
  (let ((files (my/org-archive-files)))
    (org-ql-search files query)))

(bind-keys :map org-agenda-mode-map
           ("$" . my/org-agenda-archive-subtree)
           ("C" . my/org-archive-find-date)
           :map org-ql-view-map
           ("$" . my/org-ql-view-archive-subtree)
           :map calendar-mode-map
           ("C" . my/org-archive-find-date))

(push '("Archive entries" . my/org-archive-search)
      org-ql-views)

;; TODO: This function can be rewritten with org-ml
;;;###autoload
(defun org-timestamps-in-entry ()
  "Return timestamp objects for all Org timestamps in entry."
  (interactive (list current-prefix-arg))
  (save-excursion
    (goto-char (org-entry-beginning-position))
    (org-show-entry)
    (org-narrow-to-element)
    (let* ((parsetree (org-element-parse-buffer))
           (ts-list nil))
      (org-element-map parsetree '(planning clock timestamp)
        (lambda (elm)
          (cl-case (org-element-type elm)
            ('planning
             (add-to-list 'ts-list (ts-parse-org-element (or (org-element-property :closed elm)
                                                             (org-element-property :scheduled elm)
                                                             (org-element-property :deadline elm)))
                          t))
            ('clock
             (add-to-list 'ts-list (ts-parse-org-element (org-element-property :value elm)) t))
            ('timestamp
             (add-to-list 'ts-list (ts-parse-org-element elm) t)))))
      (widen)
      ts-list)))

(provide 'my/org-archive-datetree)
#+end_src

***** org-capture-derived                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-08 Sun 18:03]
:END:

#+begin_src emacs-lisp :tangle no
(require 'thingatpt)
(require 'whitespace)

(with-eval-after-load 'org-capture
  (mapc (lambda (template)
          (add-to-list 'org-capture-templates
                       template))
        '(("x" "actionable entry for manual input"
           entry
           (function org-capture-derived-target-function)
           "* %(org-capture-derived-insert-todo)%? %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)")
          ("X" "Actionable entry for automated input"
           entry
           (function org-capture-derived-target-function)
           "* %(org-capture-derived-insert-todo)%a %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)"
           :immediate-finish t))))

(defvar org-capture-derived-todo nil
  "Todo state to be set to an org entry which org-capture-derived creates.

User should set this value locally, otherwise unexpected results occur.")
(defvar org-capture-derived-tags nil
  "Tags represented with colon(:) to be set to an org entry which org-capture-derived creates.

User should set this value locally, otherwise unexpected results occur.")
(defvar org-capture-derived-target nil "docstring")
(defvar org-capture-derived-deadline-in-day nil "docstring")

(defun org-capture-derived-target-function ()
  ""
  (cond
   ((listp org-capture-derived-target)
    (set-buffer (org-capture-target-buffer (nth 1 org-capture-derived-target)))
    (org-capture-put-target-region-and-position)
    (widen)
    (goto-char (nth 3 org-capture-derived-target)))
   ((and (stringp org-capture-derived-target)
         (string-match-p thing-at-point-uuid-regexp org-capture-derived-target))
    (org-id-goto org-capture-derived-target))))

(defun org-capture-derived (&optional arg)
  "C-u user is asked for all arguments
C-u C-u create manually"
  (interactive "P")
  ;; insert ID property unless existing
  (cond
   ((and (eq major-mode 'org-mode)
         (not (equal arg '(16))))
    (org-id-get nil t)))
  (let* ((todo-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TODO" t)))
         (org-capture-derived-todo
          (or todo-in-org
              org-capture-derived-todo))
         (tags-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TAGS" t)))
         (org-capture-derived-tags
          (or (when (not (equal arg '(4)))
                (or tags-in-org
                    org-capture-derived-tags))
              (read-string "Tags: " tags-in-org)))
         (target-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TARGET" t)))
         (org-capture-derived-target
          (or (when (not (equal arg '(4)))
                (or target-in-org
                    org-capture-derived-target))
              (org-refile-get-location)))
         (deadline-str-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_DEADLINE_IN_DAY" t)))
         (deadline-num-in-org
          (if (stringp deadline-str-in-org) (string-to-number deadline-str-in-org) nil))
         (org-capture-derived-deadline-in-day
          (if (equal arg '(4))
              (read-number "Deadline in day: "
                           deadline-num-in-org)
            (or deadline-num-in-org
                org-capture-derived-deadline-in-day))))
    (if (equal arg '(16))
        (org-capture nil "x")
      (org-capture nil "X"))))

(defun org-capture-derived-insert-todo ()
  ""
  (if (stringp org-capture-derived-todo)
      (if (string-match-p whitespace-trailing-regexp
                          org-capture-derived-todo)
          org-capture-derived-todo
        (format "%s " org-capture-derived-todo))
    ""))

(defun org-capture-derived-insert-deadline ()
  ""
  (if (numberp org-capture-derived-deadline-in-day)
      (let ((week-ahead (encode-time
                         (seq-map-indexed (lambda (element index)
                                            (if (= index 3)
                                                (+ element org-capture-derived-deadline-in-day)
                                              element))
                                          (decode-time (current-time))))))
        (format-time-string "DEADLINE: <%Y-%m-%d %a>" week-ahead))
    ""))
#+end_src

***** narrow-dwim                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 14:45]
:END:

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/narrow-dwim.el")
(bind-key* "C-x n" 'my/toggle-narrow-dwim)

(defun my/toggle-narrow-dwim (arg)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, org-src-block, org-subtree, or defun,
whichever applies first.
Narrowing to org-src-block actually calls `org-edit-src-code'.

With prefix ARG, don't widen, just narrow even if buffer is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not arg))
         (when (org-buffer-narrowed-p)
           (when org-startup-indented
             (org-indent-mode 1))
           (visual-line-mode -1)
           (adaptive-wrap-prefix-mode -1))
         (widen)
         (setq-local truncate-lines t))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((and (boundp 'org-src-mode) org-src-mode (not arg))
         (org-edit-src-exit))
        ((condition-case err
             (org-edit-src-code)
           (user-error nil)))
        ((derived-mode-p 'org-mode)
         (cond ((org-at-block-p)
                (org-narrow-to-block))
               ((org-at-heading-p)
                (org-narrow-to-subtree)
                (adaptive-wrap-prefix-mode))
               (t (org-narrow-to-element)))
         (org-indent-mode -1)
         (visual-line-mode 1))
        ((eq major-mode 'dired-mode)
         (dired-subtree-narrow))
        (t (narrow-to-defun))))

;; (add-hook 'post-command-hook 'highlight-narrowed-buffer)
;; (defun highlight-narrowed-buffer ()
;;   "Highlight narrowed buffer.

;; Narrowed buffer have a fringe with highlighting color.
;; Plus text size in the buffer becomes a little bit larger."
;;   (unless (or (member last-command
;;                       '(text-scale-adjust))
;;               (eq major-mode 'Info-mode)
;;               (string-match-p (rx (seq line-start "CAPTURE-" (one-or-more ascii) line-end))
;;                               (buffer-name)))
;;     (let ((hl-fringe-color "purple2")
;;           (hl-text-scale (sqrt 2)))
;;       (set-face-attribute
;;        'fringe nil :background (if (buffer-narrowed-p)
;;                                    (progn
;;                                      (text-scale-set hl-text-scale)
;;                                      hl-fringe-color)
;;                                  (progn
;;                                    (when (= text-scale-mode-amount hl-text-scale)
;;                                      (text-scale-set 0))
;;                                    nil))))))
#+end_src
***** view-file (obsolete)                  :ARCHIVE:

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/view-file.el")
(defcustom my/view-file--temp-dir "~/tmp/view-file"
  "Directory in which we will work for uncompresssing, decrypting and htmlize.")
(defvar my/view-file--open-file nil
  "Target file which we will actually open.
User should not change this value.")
(defvar my/view-file--remove-files nil
  "List of files which we will remove afterward.
User should not change this value.")

;; TODO: support line/search args to jump to the desired position
(defun my/view-file (file &optional system)
  "Open FILE in my preferable way.

if SYSTEM is non-nii open FILE using preferable application in system."
  (setq my/view-file--open-file (expand-file-name file))
  (make-directory my/view-file--temp-dir t)

  ;; decrypt file if it is encrypted
  (when-let* ((match (string-match "\\(.+\\)\.gpg$" my/view-file--open-file))
              (decrypt-file (expand-file-name (file-name-base my/view-file--open-file)
                                              (expand-file-name my/view-file--temp-dir)))
              (context (epg-make-context epa-protocol)))
    (epg-context-set-passphrase-callback context
                                         #'epa-passphrase-callback-function)
    (epg-decrypt-file context my/view-file--open-file decrypt-file)
    (setq my/view-file--open-file decrypt-file)
    (add-to-list 'my/view-file--remove-files decrypt-file))

  ;; uncompress file if it is tarball
  (let* (uncompress-file
         (uncompress-command
          (cond
           ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?gz$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "gzip -dc %s | tar -xf - -C %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument uncompress-file)))
           ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?zst$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "unzstd -c %s | tar -xf - -C %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument uncompress-file)))
           ((string-match "\\(.+\\)\\.zip$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "unzip -o -d %s %s"
                    (shell-quote-argument uncompress-file)
                    (shell-quote-argument my/view-file--open-file))))))
    (when (and (stringp uncompress-file)
               (stringp uncompress-command))
      (make-directory uncompress-file t)
      (call-process-shell-command
       uncompress-command)
      (add-to-list 'my/view-file--remove-files uncompress-file)
      (setq my/view-file--open-file uncompress-file)))

  ;; convert pdf/epub to html
  (let* ((dirname-html
          (expand-file-name (file-relative-name my/view-file--open-file "/")
                            (expand-file-name my/view-file--temp-dir)))
         (filename-html
          (concat (file-name-as-directory dirname-html)
                  "index.html"))
         (command
          (cond
           ((= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
            (format "cat %s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument filename-html)))
           ((= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0)
            (format "cat %s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%s - | strip_ruby > %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument dirname-html)
                    (shell-quote-argument filename-html))))))
    (when (and (null system)
               (stringp command))
      (unless (file-exists-p filename-html)
        (make-directory dirname-html t)
        (call-process-shell-command command)
        ;; reuse html only if pdf/epub file is not ecrypted
        (when (member my/view-file--open-file my/view-file--remove-files)
          (add-to-list 'my/view-file--remove-files dirname-html)))
      (setq my/view-file--open-file filename-html)))

  ;; open file
  (cond
   ((or system
        (string-match-p "\\.midi?$" my/view-file--open-file)
        (= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
        (= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0))
    (let ((process-connection-type nil))
      (call-process-shell-command (format "xdg-open %s" (shell-quote-argument my/view-file--open-file)))
      (sleep-for 3)
      (funcall 'my/view-file--finalize-function)))
   ((or (= (call-process-shell-command (format "filetype-cli check --type playable %s" (shell-quote-argument my/view-file--open-file))) 0)
        (seq-some (lambda (suffix)
                    (string-suffix-p suffix my/view-file--open-file t))
                  '(".m3u" ".mts" ".m2ts")))
    (when-let ((mpv-proc (start-process-shell-command
                          "mpv" nil
                          (format "nohup mpv --force-window %s >/dev/null 2>&1" (shell-quote-argument my/view-file--open-file)))))
      (set-process-sentinel
       mpv-proc
       (lambda (process desc)
         (when (eq (process-status process) 'exit)
           (funcall 'my/view-file--finalize-function))))))
   ((= (call-process-shell-command
        (format "filetype-cli check --type html %s"
                (shell-quote-argument my/view-file--open-file))) 0)
    (add-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
    (eww-open-file my/view-file--open-file))
   ((file-directory-p my/view-file--open-file)
    (dired my/view-file--open-file)
    (funcall 'my/view-file--finalize-function))
   (t
    (find-file my/view-file--open-file)
    (funcall 'my/view-file--finalize-function))))

(defun my/view-file--finalize-function ()
  "Remove files and initialize variables."
  (mapc (lambda (file)
          (when (stringp file)
            (cond
             ((file-directory-p file)
              (delete-directory file t nil))
             ((file-exists-p file)
              (let ((delete-by-moving-to-trash t))
                (delete-file file))))))
        my/view-file--remove-files)
  (setq my/view-file--open-file nil
        my/view-file--remove-files nil))

(defun my/view-file--eww-finalize-function ()
  "Finalize function for `EWW'."
  (remove-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
  (funcall 'my/view-file--finalize-function))

(defun my/view-file-filter-org-link-store-props (&rest plist-orig)
  "Filter PLIST-ORIG to original file name if value of `eww-current-url'
 is in `my/view-file--temp-dir'."
  (let ((plist-filtered (car plist-orig)))
    (if (plist-member plist-filtered :link)
        (plist-put plist-filtered
                   :link
                   (replace-regexp-in-string (format "%s\\(.*\\)/index.html"
                                                     (expand-file-name my/view-file--temp-dir))
                                             (format "%s\\1"
                                                     (expand-file-name "~"))
                                             (plist-get plist-filtered
                                                        :link))))
    (car plist-orig)))

(advice-add #'org-link-store-props :filter-args
            #'my/view-file-filter-org-link-store-props)

(provide 'my/view-file)
#+end_src

*** would-be packages
:PROPERTIES:
:CREATED:  [2023-01-12 Thu 14:14]
:END:
**** lfile (custom org link type)
:PROPERTIES:
:CREATED:  [2023-04-14 Fri 14:24]
:ID:       6c7027a8-b023-4752-967d-c6c0a8834d2c
:END:

lfile is an extended org link type for files in local machine. It is inspired by [[https://karl-voit.at/2022/02/10/lfile/][Kerl Voit's implementation]].
It is implemented using abbrev mechanism since functionality of file: link type such as inline image or exporting can be easily imparted.

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
(require 'lfile)
#+end_src

#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name "lfile.el" tangle/emacs-sitelisp-dir)
(require 'ol)
(require 'org-element)

(with-eval-after-load 'ol
  (add-to-list 'org-link-abbrev-alist
               '("lfile" . "file:%(lfile-locate)")
               t)
  (add-to-list 'org-link-abbrev-alist
               '("lfile+emacs" . "file+emacs:%(lfile-locate)")
               t)
  (add-to-list 'org-link-abbrev-alist
               '("lfile+sys" . "file+sys:%(lfile-locate)")
               t))

(defun lfile-locate (tag)
  "Return a path found using TAG with locate program."
  (let* ((match-idx (string-match "^\\([^:]*\\)\\(::?\\(.*\\)\\)?$" tag))
         (link (if match-idx (match-string 1 tag) tag)))
    (concat (string-trim
             (shell-command-to-string
              (concat (format "plocate -d <<plocate-db()>> -e \"%s\" 2>/dev/null"
                              (shell-quote-argument link))
                      " | head --lines=1")))
            (when match-idx (match-string 2 tag)))))

(defun lfile-store-link ()
  "Store a lfile link.

Prefix argument does matter in this function call.
If `C-u' prefix is given, file: link type will be used instead."
  (when (and (derived-mode-p 'dired-mode)
             (string-match-p
              (format "^%s" (expand-file-name "~"))
              (dired-current-directory nil)))
    (let ((path (dired-get-filename nil t)))
      (if (equal current-prefix-arg '(4))
          (org-link-store-props
           :type "file"
           :link (concat "file:" (abbreviate-file-name
                                  (expand-file-name path))))
        (org-link-store-props
         :type "lfile"
         :link (concat "lfile:" (file-name-nondirectory path)))))))

(defun lfile-abbrev (raw-link &optional path-conv-fn)
  "Return an abbreviated lfile link from RAW-LINK.

RAW-LINK is supposed to be a file link type with a path and the path is
converted by `file-name-nondirectory' unless PATH-CONV-FN is supplied."
  (let* ((link (with-temp-buffer
                 (let ((org-inhibit-startup nil))
                   (insert raw-link)
                   (org-mode)
                   (goto-char (point-min))
                   (org-element-link-parser))))
         (type (org-element-property :type link))
         (path (org-element-property :path link))
         (abbrev-link (cond
                       ((string= type "file")
                        (format "%s:%s"
                                "lfile"
                                (if (functionp path-conv-fn)
                                    (funcall path-conv-fn path)
                                  (file-name-nondirectory path))))
                       ((stringp type)
                        raw-link)
                       (t nil))))
    abbrev-link))

(with-eval-after-load 'org
  (org-link-set-parameters "lfile"
                           :store #'lfile-store-link))

(provide 'lfile)
#+end_src

***** lfile (legacy)                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-04-16 Sun 11:43]
:END:

#+begin_src emacs-lisp :noweb tangle :tangle no
(defcustom my/lfile-root "~/" "docstring")
(defcustom my/lfile-exclude-string ".local/share/Trash" "")

(defmacro my/expand-lfile (file body exclude-search)
  "Evaluate BODY with resolving a path from FILE.

In BODY, caller could refer a resolved file path as `file-resolved'.
If exclude-search is non-nil, search specifier after \"::\" will be removed in `file-resolved'."
  `(let* ((paths (my/lfile--locate ,file ,exclude-search))
          (file-resolved (car paths)))
     (cond
      ((= 0 (length paths))
       (message "Sorry, no results found for query: %s" file))
      ((<= 1 (length paths))
       ,body))))

(defun my/lfile-follow-link (file _)
  "Open FILE given in lfile org link type."
  (my/expand-lfile file
                   (org-link-open-as-file file-resolved current-prefix-arg)
                   nil))

(defun my/lfile-follow-link--emacs (file _)
  "Open FILE in Emacs given in lfile+emacs org link type."
  (my/expand-lfile file
                   (org-open-file file-resolved t)
                   t))

(defun my/lfile-follow-link--sys (file _)
  "Open FILE out of Emacs given in lfile+sys org link type."
  (my/expand-lfile file
                   (org-open-file file-resolved 'system)
                   t))

(defun my/lfile-store-link ()
  "Store a link to the file.

Prefix argument does matter in this function call.
If `C-u' prefix is given, file link is stored instead of lfile link."
  (when (and (derived-mode-p 'dired-mode)
             (string-match-p
              (format "^%s" (expand-file-name my/lfile-root))
              (dired-current-directory nil)))
    (let ((path (dired-get-filename nil t)))
      (if (equal current-prefix-arg '(4))
          (org-link-store-props
           :type "file"
           :link (concat "file:" (abbreviate-file-name
                                  (expand-file-name path))))
        (org-link-store-props
         :type "lfile"
         :link (concat "lfile:" (file-name-nondirectory path)))))))

(defun my/lfile-completing-read (&optional arg)
  "Create a lfile link using completion."
  (let* ((paths (my/lfile--locate nil))
         (files (mapcar #'file-name-nondirectory paths))
         (file (completing-read "Local file: " files nil 'confirm)))
    (concat "lfile:" file)))

(defun my/lfile-export (link description format)
  "Return an exported string from lfile link for format FORMAT.
A link consists of LINK and DESCRIPTION."
  (when-let* ((paths (my/lfile--locate link))
              (path (org-export-file-uri (expand-file-name (car paths))))
              (desc (or description link)))
    (when (stringp path)
      (cond
       ((eq format 'html)
        (if (string-match-p (regexp-opt '(".jpeg" ".jpg" ".png" ".gif" ".svg" ".webp"))
                            path)
            (format "<img src=\"%s\" alt=\"%s\"/>" path desc)
          (format "<a href=\"%s\">%s</a>" path desc)))
       ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
       ((eq format 'ascii) (format "%s (%s)" desc path))
       (t path)))))

(defun my/lfile-from-file-link ()
  "Replace file link type with lfile link type only if hte path in my/lfile-root."
  (interactive)
  (let* ((context (org-element-lineage
                   (org-element-context)
                   '(link desc)
                   t))
         (type (org-element-property :type context))
         (path (org-element-property :path context))
         (app (org-element-property :application context))
         (search-option (org-element-property :search-option context))
         (desc-begin (org-element-property :contents-begin context))
         (desc-end (org-element-property :contents-end context))
         (desc (and (and (integerp desc-begin) (integerp desc-begin))
                    (substring-no-properties (buffer-substring desc-begin desc-end)))))
    (when (and (string= type "file")
               (string-match-p
                (format "^%s" (expand-file-name my/lfile-root))
                (expand-file-name path)))
      (delete-region (org-element-property :begin context)
                     (org-element-property :end context))
      (insert (org-link-make-string (concat "lfile" (and app (concat "+" app)) ":"
                                            (file-name-nondirectory path)
                                            (and search-option (concat "::" search-option)))
                                    desc)))))

(defun my/lfile--locate (pattern &optional exclude-search)
  "Determine an absolute path from given FILE name using `locate' program."
  (if pattern
      (save-match-data
        (let ((match-idx (string-match "\\(.+\\)\\(::.+\\)\\'"
                                       pattern))
              (data (match-data)))
          (mapcar (lambda (resolved-path)
                    (set-match-data data)
                    (concat resolved-path
                            (when (and match-idx
                                       (not exclude-search))
                              (match-string 2 pattern))))
                  (split-string
                   (shell-command-to-string
                    (concat (format "plocate -d <<plocate-db()>> -ie \"%s\""
                                    (shell-quote-argument
                                     (or (and match-idx
                                              (match-string 1 pattern))
                                         pattern)))
                            (and (stringp my/lfile-exclude-string)
                                 (format " | grep -v %s"
                                         (shell-quote-argument  my/lfile-exclude-string)))))
                   "\n" t))))
    ""))

(with-eval-after-load 'org
  (org-link-set-parameters "lfile"
                           :follow #'my/lfile-follow-link
                           :store #'my/lfile-store-link
                           :complete #'my/lfile-completing-read
                           :export #'my/lfile-export)
  (org-link-set-parameters "lfile+emacs"
                           :follow #'my/lfile-follow-link--emacs)
  (org-link-set-parameters "lfile+sys"
                           :follow #'my/lfile-follow-link--sys))

(provide 'lfile)
#+end_src

**** open-file
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 13:58]
:END:

Open-file is a feature that allows you to specify the application to open a file based on its type.

By default, PDF and EPUB files are opened in EWW after converted into HTML. Videos and audio files are played in MPV media player.

#+name: open-file-dir
#+begin_src emacs-lisp :noweb yes :eval no-export
(file-name-concat "<<share-dir()>>" "emacs/open-file")
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<open-file-dir()>> 0755 - - 14d
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
(require 'open-file)
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "open-file.el" tangle/emacs-sitelisp-dir)
;; general functions

(defvar my/open-file-dir
  (expand-file-name "open-file"
                    user-emacs-directory)
  "Directory where html file is converted into.")

(defvar my/open-file-media-player "mpv"
  "Media player used to play media file in open-file.")

(defvar my/open-file-media-extensions
  '("mpg" "mpeg" "mp3" "mp4" "m4v" "m4a"
    "avi" "wmv" "wav" "mov" "flv" "mkv" "mka" "webm" "3gp"
    "flac" "ogv" "oga" "ogx" "ogg" "spx" "opus"
    "xbm" "pbm" "pgm" "ppm" "pnm" "png" "gif" "bmp" "tif" "jpeg" "jpg" "webp")
  "Extensions files which can play with media player must have.")

(defvar my/open-file-compressed-media-extensions
  '("tar.gz" "tgz" "tar.xz" "txz" "zip" "7z")
  "Extensions compressed files which can play with media player must have.")

(defmacro my/open-file-as-html (file convert-cmd)
  `(let* ((cap-command (if (string-match-p url-handler-regexp ,file)
                           "curl"
                         (if (string-suffix-p ".gpg" ,file)
                             "gpg -d"
                           "cat")))
          (dir-name
           (seq-reduce (lambda (str rep)
                         (string-replace (car rep) (cdr rep) str))
                       '(("/" . "!")
                         ("~" . "`"))
                       ,file))
          (dirname-html
           (expand-file-name
            dir-name
            my/open-file-dir))
          (filename-html
           (concat (file-name-as-directory dirname-html)
                   "index.html"))
          (command ,convert-cmd))
     (unless (file-exists-p filename-html)
       (make-directory dirname-html t)
       (call-process-shell-command command))
     (browse-url filename-html)))

(defun my/open-pdf-as-html (pdf)
  "Open PDF in `eww' after the process of convertion into html."
  (my/open-file-as-html
   pdf
   (format "%1$s %2$s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %3$s"
           cap-command
           (shell-quote-argument pdf)
           (shell-quote-argument filename-html))))

(defun my/open-epub-as-html (epub)
  "Open EPUB in `eww' after the process of convertion into html."
  (my/open-file-as-html
   epub
   (format "%1$s %2$s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%3$s - | strip_ruby > %4$s"
           cap-command
           (shell-quote-argument epub)
           (shell-quote-argument dirname-html)
           (shell-quote-argument filename-html))))

(defun my/open-media (media &optional start-time)
  "Open MEDIA in `my/open-file-media-player' at the point of START-TIME."
  (let ((ask-file (when (or (file-directory-p media)
                            (string-match-p (eval `(rx (or ,@my/open-file-compressed-media-extensions)))
                                            media))
                    (file-name-nondirectory media))))
    (when (or (not ask-file)
              (and ask-file
                   (y-or-n-p (format "Play %s?: " ask-file))))
      (start-process-shell-command
       my/open-file-media-player nil
       (let ((cap-cmd (and (string-suffix-p ".gpg" media)
                           (format "gpg -d %s | " media))))
         (mapconcat #'identity
                    (list (or cap-cmd "")
                          "nohup" my/open-file-media-player
                          "--force-window"
                          (or (and start-time
                                   (format "--start=%s" start-time))
                              "")
                          (if cap-cmd
                              "-"
                            (shell-quote-argument media))
                          "2>&1" ">/dev/null")
                    " "))))))

;; ==============================================
;; browse-url handling

(with-eval-after-load 'browse-url
  (let ((search-suffix "\\(?:::.*\\)?"))
    (customize-set-variable
     'browse-url-handlers
     `(((lambda (url)
          (equal current-prefix-arg '(16)))
        . my/browse-url-external)
       ((lambda (url)
          (equal current-prefix-arg '(4)))
        . my/browse-url-emacs)
       (,(format "\\.html%s\\'" search-suffix)
        . my/browse-url-html)
       (,(format "\\.pdf\\(\\.gpg\\)?%s\\'" search-suffix)
        . my/browse-url-pdf)
       (,(format "\\.epub%s\\'" search-suffix)
        . my/browse-url-epub)
       (,(eval `(concat (rx "." (or ,@my/open-file-media-extensions
                                    ,@my/open-file-compressed-media-extensions)
                            (opt ".gpg"))
                        search-suffix))
        . my/browse-url-media)
       ((lambda (url)
          (let ((ignore-pattern "search_query"))
            (if (string-match-p ignore-pattern url)
                nil
              (string-match-p (rx-to-string '(: (? (or "https://" "http://" "//"))
                                                (? "www")
                                                (or "youtube.com" "youtu.be")))
                              url))))
        . my/browse-url-media)))
    (customize-set-variable
     'browse-url-browser-function 'eww-browse-url)))

(defun my/browse-url-html (url &optional same-window)
  "A handler for `browse-url' responsible for html at URL."
  (cond
   ((file-exists-p url)
    (eww-open-file url))
   ((string-match-p url-handler-regexp url)
    (browse-web url))
   (t
    (eww url))))

(defun my/browse-url-pdf (url &optional same-window)
  "A handler for `browse-url' responsible for a pdf file at URL."
  (let* ((query-list (my/browse-url-break-down url))
         (search-str (cadr query-list)))
    (my/open-pdf-as-html (car query-list))
    (and (stringp search-str)
         (org-link-search search-str))))

(defun my/browse-url-epub (url &optional same-window)
  "A handler for `browse-url' responsible for an epub file at URL."
  (let* ((query-list (my/browse-url-break-down url))
         (search-str (cadr query-list)))
    (my/open-epub-as-html (car query-list))
    (and (stringp search-str)
         (org-link-search search-str))))

(defun my/browse-url-media (url &optional same-window)
  "A handler for `browse-url' responsible for a media file at URL."
  (let* ((query-list (my/browse-url-break-down url))
         (search-str (cadr query-list)))
    (my/open-media (car query-list) search-str)))

(defun my/browse-url-emacs (url &optional same-window)
  "A handler for `browse-url' invoked with `C-u' responsible for a file at URL."
  (browse-url-emacs (car (my/browse-url-break-down url))
                    same-window))

(defun my/browse-url-external (url &optional same-window)
  "A handler for `browse-url' invoked with `C-u C-u' responsible for a file at URL."
  (browse-url-firefox (car (my/browse-url-break-down url))
                      same-window))

(defun my/browse-url-break-down (query)
  (let* ((search-opt-regexp "::\\(.*\\)\\'")
         (matcher nil)
         (url-or-file
          (cond ((string-match-p url-handler-regexp query)
                 (setq matcher (format "\\(%s.*\\)%s"
                                       url-handler-regexp
                                       search-opt-regexp))
                 query)
                (t
                 (setq matcher (format "\\(.*\\)%s"
                                       search-opt-regexp))
                 (expand-file-name
                  (and (not (string-match-p "^file://" query))
                       (replace-regexp-in-string "^\\(?:/\\)?file:" "" query)))))))
    (if (string-match matcher url-or-file)
        `(,(match-string 1 url-or-file) ,(match-string 2 url-or-file))
      `(,url-or-file nil))))

;; ==============================================
;; org-open handling

(with-eval-after-load 'org
  (customize-set-variable
   `org-file-apps
   `(("\\.html\\'" . my/org-open-html)
     ("\\.pdf\\(\\.gpg\\)?\\'" . my/org-open-pdf)
     ("\\.epub\\'" . my/org-open-epub)
     (,(eval `(rx "." (or ,@my/open-file-media-extensions
                          ,@my/open-file-compressed-media-extensions)
                  (opt ".gpg") string-end))
      . my/org-open-media)
     (auto-mode . emacs)
     (directory . my/org-open-media)
     (system . browse-url-default-browser))))

(defun my/org-open-html (file-path link-string)
  "Open a html file at FILE-PATH via org-open command."
  (browse-url file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-pdf (file-path link-string)
  "Open a pdf file at FILE-PATH via org-open command."
  (my/open-pdf-as-html file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-epub (file-path link-string)
  "Open an epub file at FILE-PATH via org-open command."
  (my/open-epub-as-html file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-media (file-path link-string)
  "Open a media file at FILE-PATH via org-open command."
  (my/open-media file-path
                 (my/org-link-search link-string)))

(defun my/org-link-search (link-string)
  (and (stringp link-string)
       (string-match "::\\(.*\\)\\'" link-string)
       (match-string 1 link-string)))

(defun my/org-execute-file-search-line-number (s)
  "A search function responsible for line number inside of S."
  (and (string-match "^l=\\([-+[:digit:]]+\\)\\'" s)
       (goto-line (string-to-number (match-string 1 s)))))

(add-hook 'org-execute-file-search-functions
          'my/org-execute-file-search-line-number)

;; ==============================================
;; dired-open handling

(with-eval-after-load 'dired-open
  (setq dired-open-functions '(dired-open-call-function-by-extension
                               dired-open-by-extension
                               dired-open-subdir)
        dired-open-extensions-elisp `(("pdf" . my/open-pdf-as-html)
                                      ("pdf.gpg" . my/open-pdf-as-html)
                                      ("epub" . my/open-epub-as-html)
                                      ("jpg.gpg" . my/open-media)
                                      ,@(mapcar (lambda (ext)
                                                  (cons ext 'my/open-media))
                                                my/open-file-media-extensions))
        dired-open-find-file-function 'my/dired-find-file))

(defun my/dired-find-file ()
  "A function for `dired-open-find-file-function' dealing with
a `dired-open-file' call with `C-u' or `C-u C-u'."
  (let ((file-for-visit (dired-get-file-for-visit)))
    (cond
     ((equal current-prefix-arg '(16))
      (browse-url-default-browser file-for-visit))
     ((equal current-prefix-arg '(4))
      (dired--find-possibly-alternative-file file-for-visit))
     ((or (and (file-directory-p file-for-visit)
               (seq-some (lambda (file)
                           (string-match-p
                            (concat "." (regexp-opt my/open-file-media-extensions) "$")
                            file))
                         (directory-files file-for-visit)))
          (string-match-p (eval `(rx (or ,@my/open-file-compressed-media-extensions)))
                          file-for-visit))
      (my/open-media file-for-visit))
     (t (dired-find-file)))))

(provide 'open-file)
#+end_src

- get original file name from converted html file
  #+begin_src emacs-lisp
  (defun my/open-file-original-file (html)
    "Revert HTML file into original file name."
    (interactive (list (if (use-region-p)
                           (buffer-substring (use-region-beginning)
                                             (use-region-end))
                         (read-string "HTML: "))))
    (when-let* ((regex (rx (group-n 1 (opt (or "file://" "file:~")))
                           (1+ (: "/" (1+ nonl)))
                           (group-n 2 (1+ (: "!" (1+ (: nonl)))))
                           "/index.html"))
                (index (string-match regex html))
                (rep (concat (and (cl-some (lambda (cand)
                                             (string= cand (match-string 1 html)))
                                           '("file://" "file:~"))
                                  "lfile:")
                             (substring (match-string 2 html) 1))))
      (if (use-region-p)
          (replace-string-in-region html rep)
        (princ (replace-regexp-in-string regex rep html)))))
  #+end_src

**** org-password-store
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 17:48]
:END:

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
(use-package org-password-store
  :after org
  :bind (:map org-mode-map
              ("C-c p c c" . my/password-store-copy)
              ("C-c p c f" . my/password-store-copy-field)
              ("C-c p s" . my/password-store-show-field)
              ("C-c p w" . my/password-store-url)
              ("C-c p l" . my/password-store-web-login)
              ("C-c p n" . my/password-store-create)
              ("C-c p e" . my/password-store-edit)
              ("C-c p v" . my/password-store-edit)
              ("C-c p k" . my/password-store-remove)))
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "org-password-store.el" tangle/emacs-sitelisp-dir)
(require 'password-store)

(defcustom my/org-password-store-property "PASSWORD_STORE"
  "Property used in my/password-store feature to get password-store entry name attached to current org entry.")

(defmacro with-password-store-entry (entry &rest body)
  "Eval BODY that can refer password-store ENTRY."
  (declare (indent defun))
  `(let ((entry (or ,entry
                    (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                    (password-store--completing-read t))))
     ,@body))

(defmacro with-password-store-entry-field (entry field &rest body)
  "Eval BODY which can refer password-store ENTRY and FIELD..

Plus, OBDY can refer value of FIELD named field-value."
  (declare (indent defun))
  `(let* ((entry (or ,entry
                     (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                     (password-store--completing-read t)))
          (field (or ,field
                     (password-store-read-field entry)))
          (field-value (password-store-get-field entry
                                                 (or (and (string= field "secret")
                                                          'secret)
                                                     (and (stringp field)
                                                          field)))))
     ,@body))

(defun my/password-store-copy ()
  "Add the secret to system clipboard and the username to primary `x-selection'.

`password-store-copy' is responsible for managing the kill ring."
  (interactive)
  (with-password-store-entry-field nil "username"
                                   (password-store-copy entry)
                                   (gui-set-selection 'PRIMARY
                                                      (or (password-store-get-field entry "username")
                                                          (password-store-get-field entry "email")
                                                          (nth 1 (password-store-parse-entry entry))))
                                   (message "USERNAME => X-SEL, SECRET => CLIPBOARD")))

(defun my/password-store-copy-field ()
  "Add field for entry into the kill ring.

entry and field is determined by appropriate manner."
  (interactive)
  (with-password-store-entry-field nil nil
                                   (password-store-copy-field entry field)))

(defun my/password-store-url (&optional arg)
  "Browse url stored in entry by appropriate manner determined by ARG."
  (interactive "P")
  (with-password-store-entry-field nil "url"
                                   (browse-url field-value)))

(defun my/password-store-show-field ()
  "Show a field value in the minibuffer.

Password-store entry and field used to derive this value are from org property
or selected by user."
  (interactive)
  (with-password-store-entry-field nil nil
                                   (message "%s: %s" field field-value)))

(defun my/password-store-create ()
  (interactive)
  (let* ((input (read-string "Entry-name or URL: "))
         (domain (when (string-match-p browse-url-button-regexp input)
                   (string-trim-right
                    (shell-command-to-string (format "echo %s | awk -F[/:] '{print $4}'"
                                                     (shell-quote-argument input)))))))
    (with-password-store-entry (cond
                                ((> (length domain) 0) domain)
                                (input))
                               (when (derived-mode-p 'org-mode)
                                 (org-entry-put (point) my/org-password-store-property entry))
                               (password-store-edit entry))))

;;;###autoload
(defun my/password-store-edit ()
  (interactive)
  (with-password-store-entry nil
                             (password-store-edit entry)))

;; TODO: make my/password-store-insert as soon after
;;     : password-store--run-insert has been implemented

(defun my/password-store-remove ()
  (interactive)
  (with-password-store-entry nil
                             (password-store-remove entry)
                             (when (derived-mode-p 'org-mode)
                               (org-entry-delete (point) my/org-password-store-property))))

(defun my/password-store-web-login ()
  "Open url for the entry at point.

Additionally the username and the secret are saved in X selection and clipboard respectively."
  (interactive)
  (my/password-store-copy)
  (funcall-interactively #'my/password-store-url '(16)))

(advice-add #'password-store-clear :before #'my/password-store-clear)

(defun my/password-store-clear (&optional field)
  "Overwrite clipboard data so that password once saved in clipboard is deleted
 for security risk.

FIELD originally for messaging is ignored in this function."
  (interactive)
  (when password-store-kill-ring-pointer
    (kill-new "")
    (setcar kill-ring-yank-pointer "")))

(provide 'org-password-store)
#+end_src

**** text-mail                               :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-27 Mon 14:11]
:END:

#+begin_src emacs-lisp :tangle no
(require 'message)

(defun mail-send-string (mailto subject body)
  "Default function to send a mail with SUBJECT and BODY to myself."
  (save-excursion
    (let ((message-kill-buffer-on-exit t))
      (message-mail mailto subject)
      (message-goto-body)
      (insert body)
      (message-send-and-exit))))

(defun mail-send-buffer (mailto)
  "Send the current buffer contents as a email.

If region is active, send the string in the region instead."
  (let ((mail-subj (buffer-name))
        (mail-body (if (use-region-p)
                       (buffer-substring (region-beginning) (region-end))
                     (buffer-string))))
    (mail-send-string mailto mail-subj mail-body)))

(provide 'text-mail)
#+end_src

**** learning english words/phrases

My workflow for acquiring English words is:
1. Capture a word which come across in the article I'm reading with my/org-english-capture
   - Captured words will be appended to my English word list
2. Review my English word list with my/org-english-drill everyday
   - Org-drill ask questions to level up my vocabulary

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
(use-package org-drill-english
  :bind (:map my/org-global-map
              ("e e" . my/org-english-capture)
              ("e d" . my/org-english-drill)
              ("e r" . my/org-english-drill-resume)
              ("e c" . my/cloze-deletion-replace)
              ("e q" . my/org-english-search)
              :map engine-mode-prefixed-map
              ("j" . my/english-japanese-translate)
              ("p" . my/english-pronunciation))
  :config
  (with-eval-after-load 'denote
    (setq my/org-english-file (denote-get-path-by-id "20230605T170959"))))
#+end_src

#+begin_src emacs-lisp  :tangle (expand-file-name "org-drill-english.el" tangle/emacs-sitelisp-dir) :comments no
;; -*- lexical-binding: t -*-

(require 'define-word)
(require 'org)
(require 'org-drill)
(require 'cl)
(require 'request)

(defvar my/org-english-file "~/documents/english.org"
  "A file where all english words to learn locate.")

(defvar my/org-english-word nil
  "An english word to capture.")

(defvar my/org-english-match-entry nil
  "An org entry which matches search word.")

(defun my/org-english-capture (word)
  "Capture an english WORD as a `org-mode' entry suitable for org-drill.

Capture URL or file currently visiting as well as a sentence at point."
  (interactive (list (if (use-region-p)
                         (buffer-substring (region-beginning) (region-end))
                       (read-string "Phrase: "))))
  (setq org-english-word (downcase word))
  (setq my/org-english-match-entry nil)
  (let* ((sentence-end-double-space nil)
         (my/org-english-match-entry (org-ql-select
                                       `(,my/org-english-file)
                                       `(and (heading-regexp
                                              ,(eval `(rx word-start
                                                          ,org-english-word
                                                          word-end)))
                                             (tags "drill"))
                                       :action 'element-with-markers))
         (sentence (replace-regexp-in-string word
                                             (my/cloze-deletion word)
                                             (sentence-at-point))))
    (kill-new (if (stringp sentence) sentence ""))
    (cond
     (my/org-english-match-entry (org-capture nil "!1"))
     (t (org-capture nil "!0")))))

(defun my/cloze-deletion (word)
  "Build cloze deletion string from WORD."
  (seq-reduce (lambda (string chunk)
                (replace-regexp-in-string chunk (format "[%s||%c]" chunk (string-to-char chunk))
                                          string))
              (split-string word "[ -]+")
              word))

(defun my/cloze-deletion-replace (word start end)
  "Convert WORD into cloze deletion.
OWRD can be determined a string between START and END.

When called Interactively, WORD is either a word at point or a string in region."
  (interactive (cond
                ((region-active-p)
                 `(,(buffer-substring (region-beginning) (region-end))
                   ,(region-beginning)
                   ,(region-end)))
                (t
                 (let ((bounds (bounds-of-thing-at-point 'word)))
                   `(,(thing-at-point 'word)
                     ,(car bounds)
                     ,(cdr bounds))))))
  (replace-string word
                  (my/cloze-deletion word)
                  nil
                  start
                  end))

(with-eval-after-load 'org-ql-view
  (push `("English words to learn"
          :buffers-files ,(list my/org-english-file)
          :query (and (tags "drill")
                      (tags "fd_en"))
          :sort (scheduled date))
        org-ql-views))

(with-eval-after-load 'org-capture
  (add-to-list 'org-capture-templates
               '("!0" "drill entry for english word"
                 entry (id "de0983a7-9d1a-4ef8-b882-148c401e862d")
                 "* %i :drill:fd_en:
[%(my/english-japanese-translate org-english-word t) %(my/english-pronunciation org-english-word t)]
%(my/org-english-insert-english-translation)
- %a
  %c"))
  (add-to-list 'org-capture-templates
               '("!1" "drill entry for english word"
                 item (function my/org-english-goto-match)
                 "- %a
  %c")))

(defun my/org-english-goto-match ()
  "Goto function for org-capture-template designed to insert an edditional example
to existing english word entry."
  (org-goto-marker-or-bmk
   (plist-get (cadar my/org-english-match-entry) :org-marker)))

(defun my/org-english-insert-english-translation ()
  "Insert English translation into org capture entry."
  (let* ((url (format "http://wordnik.com/words/%s" (downcase org-english-word)))
         (buffer (url-retrieve-synchronously url t t))
         (vertico-sort-function nil))
    (with-temp-buffer
      (url-insert-buffer-contents buffer url)
      (completing-read "match" (split-string (funcall 'my/define-word--parse-wordnik) "\n")))))

(advice-add #'my/org-english-insert-english-translation :around #'my/define-word--fix-31)

(defun my/english-japanese-translate (word &optional sync)
  "Search Japanese translation for WORD and add it to kill ring.

SYNC handles whether network access procedure is synchronous.
Return translation result as a string If SYNC is non-nil.
If called interactively, display results and add them to kill ring."
  (interactive `(,(or (when (region-active-p)
                        (buffer-substring (region-beginning) (region-end)))
                      (read-string "Word: "))))
  (let ((intr-p (interactive-p))
        trans)
    (request
      (concat "https://ejje.weblio.jp/content/" (downcase word))
      :sync sync
      :timeout 60
      :parser
      (lambda ()
        (let ((str (buffer-string)))
          (with-temp-buffer
            (insert str)
            (shr-render-region (point-min) (point-max))
            (buffer-substring-no-properties (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (and (string-match
               (rx (seq "意味・対訳 "
                        (group-n 1 (+ (or (category base)
                                          (category combining-diacritic)
                                          (category latin)
                                          (category japanese-katakana-two-byte)
                                          (category korean)
                                          (category greek))))))
               data)
              (setq trans (string-trim (match-string 1 data)))
              (when intr-p (kill-new (princ trans)))))))
    trans))

(defun my/english-pronunciation (word &optional sync)
  "Search pronunciation information for WORD and add it to kill ring.

SYNC handles whether network access procedure is synchronous.
Return search infromation as a string If SYNC is non-nil.
Display information and add it to kill ring if called interactively."
  (interactive `(,(or (when (region-active-p)
                        (buffer-substring (region-beginning) (region-end)))
                      (read-string "Word: "))))
  (let ((intr-p (interactive-p))
        pron)
    (request
      (concat "https://eow.alc.co.jp/search?q=" (string-replace " " "+" (downcase word)))
      :sync sync
      :timeout 10
      :parser
      (lambda ()
        (let ((str (buffer-string)))
          (with-temp-buffer
            (insert str)
            (shr-render-region (point-min) (point-max))
            (buffer-substring-no-properties (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (and (string-match
               (rx (seq (opt "【レベル】" (** 1 2 digit) "、")
                        "【発音" (opt "！") "】"
                        (+ (or (category combining-diacritic)
                               (category latin)
                               (category japanese-katakana-two-byte)
                               (category korean)
                               (category greek)))
                        "、"
                        (? (or (seq "【＠】" (opt "[US]")
                                    (+ (or (category japanese-katakana-two-byte)
                                           "（" "）"))
                                    (? "、"))
                               (seq (+ any) "*")))))
               data)
              (setq pron (replace-regexp-in-string
                          "\\[\\(.\\{2\\}\\)\\]" "【\\1】"
                          (string-trim-right (match-string 0 data)
                                             "、")))
              (when intr-p (kill-new (princ pron)))))))
    pron))

(defmacro with-org-drill-english-config (&rest body)
  "Evaluate BODY with config for Org-Drill for english words review."
  `(progn
     (org-id-goto "de0983a7-9d1a-4ef8-b882-148c401e862d")
     (let (;; imperative settings
           (org-drill-scope 'tree)
           (org-drill-question-tag "drill")
           (org-drill-hide-item-headings-p t)
           ;; drill session regulations
           (org-drill-maximum-duration 25)
           (org-drill-maximum-items-per-session 50)
           ;; Definition of old and overdue items
           (org-drill-overdue-interval-factor 1.4) ; more permissive for overdue than 1.2 (default)
           (org-drill-days-before-old 15)
           ;; Spaced repetition algorithm
           (org-drill-spaced-repetition-algorithm 'sm5)
           (org-drill-sm5-initial-interval 7.0) ; initial step is 7 day
           ;; Random variation of repetition intervals
           (org-drill-add-random-noise-to-intervals-p t)
           ;; Adjustment for early or late review of items
           (org-drill-adjust-intervals-for-early-and-late-repetitions-p t)
           ;; Adjusting item difficulty globally
           (org-drill-learn-fraction 0.43) ; intend not to reschedule drastically forward in 10th+ interval
           (org-startup-indented nil))
       (org-indent-mode -1)
       (visual-line-mode 1)
       (text-scale-set -1)
       ,@body)
     (save-buffer)
     (org-indent-mode 1)
     (text-scale-set 0)
     (visual-line-mode -1)))

;;;###autoload
(defun my/org-english-drill ()
  "Invoke Org-Drill for English word review."
  (interactive)
  (with-org-drill-english-config (org-drill)))

(defun my/org-english-drill-resume ()
  "Resume Org-Drill session for english word review."
  (interactive)
  (with-org-drill-english-config (org-drill-resume)))

(defun my/org-english-list-undrilled ()
  "List english words which haven't been tested before in level ascending order."
  (interactive)
  (with-current-buffer (find-file-noselect my/org-english-file)
    (org-ql-search my/org-english-file
      '(and (tags "drill")
            (tags "fd_en")
            (not (property "DRILL_LAST_REVIEWED")))
      :sort 'my/org-ql--english-level<)))

(defun my/org-english-search (word)
  "Look up WORD in my archive files using `org-ql-search'."
  (interactive (list (if (use-region-p)
                         (buffer-substring (region-beginning) (region-end))
                       (read-string "Word: "))))
  (org-ql-search
    my/org-english-file
    `(heading-regexp ,(eval `(rx word-start
                                 ,(downcase word)
                                 word-end)))))

(defun my/org-english-level (word)
  "Return difficulty level of `WORD' in number."
  (cl-labels ((parse-level (text)
                (if (string-match
                     (rx (seq "【レベル】"
                              (group-n 1 (repeat 1 2 digit))))
                     text)
                    (match-string 1 text)
                  nil)))
    (let ((local-str (with-current-buffer (find-file-noselect my/org-english-file)
                       (let ((headline (org-ql-select
                                         `(,my/org-english-file)
                                         `(and (heading-regexp ,(eval `(rx word-start
                                                                           ,(downcase word)
                                                                           word-end)))
                                               (tags "drill"))
                                         :action 'element-with-markers)))
                         (org-with-point-at (plist-get (cadar headline) :org-marker)
                           (org-get-entry))))))
      (string-to-number (or (and local-str
                                 (parse-level local-str))
                            ;; CAVEAT: getting level from web costs a lot
                            ;; (when-let ((remote-str (my/english-pronunciation word)))
                            ;;   (parse-level remote-str))
                            "99")))))

(defun my/org-ql--english-level< (a b)
  "Return non-nil if A's difficulty level is higher than B's.
A and B are Org headline elements."
  (cl-macrolet ((level (item)
                  `(my/org-english-level
                    (org-element-property :raw-value ,item))))
    (let ((a-level (level a))
          (b-level (level b)))
      (cond ((and (numberp a-level) (numberp b-level))
             (< a-level b-level))
            (a-level t)
            (b-level nil)))))

(provide 'org-drill-english)
#+end_src

Call [[elisp:(call-interactively #'ert)][ERT]] with test-org-english-pron to test this code.

test code
#+begin_src emacs-lisp
(require 'ert)

(ert-deftest test-org-english-pron ()
  "Tests the output string of `my/org-english-insert-japanese-pronunciation'."
  (should (string= (my/org-english-insert-japanese-pronunciation "rife")
                   "【レベル】11、【発音】ráif、【＠】ライフ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "congregate")
                   "【レベル】12、【発音！】【US】《動》kɑ́ngrəgèit 《形》kɑ́ŋgrəgit ｜ 【UK】《動》kɔ́ŋgrigèit 《形》kɔ́ŋgrigit"))
  (should (string= (my/org-english-insert-japanese-pronunciation "unleash")
                   "【レベル】9、【発音】ʌ̀nlíːʃ、【＠】アンリーシュ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "homage")
                   "【レベル】11、【発音】【US】 hɑ́midʒ ｜ 【UK】 hɔ́midʒ、【＠】【US】ハミジ、【UK】ホミジ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "interstitial")
                   "【発音】ìntərstíʃəl、【＠】インタ（ー）スティシャル"))
  (should (string= (my/org-english-insert-japanese-pronunciation "veterinarian")
                   "【レベル】12、【発音】vètərənέəriən、【＠】ヴェトラネアリアン"))
  (should (string= (my/org-english-insert-japanese-pronunciation "warehouse")
                   "【レベル】8、【発音！】《動》wέərhàuz 《名》wέərhàus、【＠】ウェアハウス、ウエアハウス"))
  (should (string= (my/org-english-insert-japanese-pronunciation "lambaste")
                   ""))
  (should (string= (my/org-english-insert-japanese-pronunciation "in a nutshell")
                   ""))
  (should (string= (my/org-english-insert-japanese-pronunciation "traverse")
                   "【レベル】8、【発音！】《名・形》trǽvəːrs 《動》trəvʌ́rs、【＠】トゥラヴァース、トラバース")))
#+end_src

**** org-relate

#+begin_src emacs-lisp :tangle (expand-file-name "org-relate.el" tangle/emacs-sitelisp-dir)
(require 'thingatpt)
(require 'org-ql-search)

(defconst org-relate-property "PARENT"
  "Property name for child nodes to look up parent node.")
(defcustom org-relate-parent-tag-list
  `(,my/org-project-tag "refile")
  "A list of tags all parent nodes must have one of them.")
(defcustom org-relate-target-files
  (directory-files-recursively org-directory "\\.org$")
  "A list of target files to search relation nodes.")

(with-eval-after-load 'org
  (bind-key "C-c %" #'org-relate-search
            org-mode-map))

(with-eval-after-load 'org-keys
  (setf (map-elt org-speed-commands "%") #'org-relate-search)
  (setf (map-elt org-speed-commands "&") #'org-relate-interrelate)
  (push '("Org-Relate Operation") org-speed-commands))

(with-eval-after-load 'org-agenda
  (bind-keys :map org-agenda-mode-map
             ("&" . org-agenda-relation-interrelate)))

(defun org-relate-search ()
  "Search for entries related to the entry at point.

User who would like to search for parent and children of that, namely siblings,
 must press 'p'.
User who would like to search for children of this entry must press 'c'.
User who would like to search for friends either pointing to this entry
 or pointed from this entry must be press 'f'.
User who would like to search for all listed above must press 'a'."
  (interactive)
  (let* ((org-super-agenda-properties-inherit nil)
         (char (read-char-from-minibuffer "Target: [a]ll [p]arent [c]hild [f]riend"))
         (queries (seq-remove 'null
                              (cond
                               ((equal char ?a) (list (org-relate--search-parent-org-ql-query)
                                                      (org-relate--search-children-org-ql-query)
                                                      (org-relate--search-friends-refer-org-ql-query)
                                                      (org-relate--search-friends-referred-org-ql-query)
                                                      (org-relate--search-siblings-org-ql-query)))
                               ((equal char ?p) (list (org-relate--search-parent-org-ql-query)
                                                      (org-relate--search-siblings-org-ql-query)))
                               ((equal char ?c) (list (org-relate--search-children-org-ql-query)))
                               ((equal char ?f) (list (org-relate--search-friends-refer-org-ql-query)
                                                      (org-relate--search-friends-referred-org-ql-query)))))))
    (if queries
        (org-ql-search org-relate-target-files
          (seq-reduce (lambda (accum elem)
                        (push elem (cdr (last accum)))
                        accum)
                      (mapcar 'car queries)
                      '(or))
          :super-groups (mapcar 'cdr queries))
      (message "No query found"))))

(defun org-relate--search-children-org-ql-query ()
  (when-let* ((id (org-id-get))
              (rel-prop-link (format "[[id:%s]]" id)))
    `((or (property ,org-relate-property ,id)
          (property ,org-relate-property ,rel-prop-link)) .
          (:name "Children" :auto-property ,org-relate-property))))

(defun org-relate--search-parent-org-ql-query ()
  (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
            (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
            (parent-id (match-string 0 prop-ref)))
      `((property "ID" ,parent-id) .
        (:name "Parent" :auto-property "ID"))))

(defun org-relate--search-siblings-org-ql-query ()
  (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
            (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
            (parent-id (match-string 0 prop-ref))
            (parent-id-link (format "[[id:%s]]" parent-id)))
      `((or (property ,org-relate-property ,parent-id)
            (property ,org-relate-property ,parent-id-link)) .
            (:name "Siblings" :auto-property ,org-relate-property))))

(defun org-relate--search-friends-refer-org-ql-query ()
  (when-let* ((id (org-id-get))
              (ref-re (format "\\[\\[id:%s\\].*\\]" id)))
    `((regexp ,ref-re) .
      (:name "Friends pointing to this entry" :regexp ,ref-re))))

(defun org-relate--search-friends-referred-org-ql-query ()
  (let* ((id-link-re (format "\\[\\[id:\\(%s\\)\\].*\\]" thing-at-point-uuid-regexp))
         (end (or (save-excursion
                    (outline-next-heading))
                  (point-max))))
    (when (save-excursion
            (re-search-forward id-link-re end t))
      `((property "ID" ,(match-string 1)) .
        (:name "Friends to whom this entry is pointing" :auto-property ("ID" ,(match-string 1)))))))

(defun org-relate-interrelate ()
  "Make parent-child relationship by inserting property.

This command must be called in parent node which should have one of `org-relate-parent-tag-list'."
  (interactive)
  ;; relate the entry at point and its children if the entry has some of `org-relate-parent-tag-list'
  (save-excursion
    (org-back-to-heading)
    (when (cl-some (lambda (parent-tag)
                     (member parent-tag (org-get-tags)))
                   org-relate-parent-tag-list)
      (let* ((ref-id (org-id-get-create))
             (ent-link (format "[[id:%s]]" ref-id)))
        (and (org-goto-first-child)
             (cl-labels ((set-ref-id-to-siblings
                           (ref-link)
                           (org-set-property org-relate-property
                                             ref-link)
                           (and (org-goto-sibling)
                                (set-ref-id-to-siblings ref-link))))
               (set-ref-id-to-siblings ent-link))))))
  ;; relate the entry at point and a parent if the parent has some of `org-relate-parent-tag-list'
  (let (parent-link)
    (save-excursion
      (org-up-heading-safe)
      (when (seq-some (lambda (parent-tag)
                        (member parent-tag (org-get-tags)))
                      org-relate-parent-tag-list)
        (setq parent-link (format "[[id:%s]]" (org-id-get-create)))))
    (and parent-link
         (org-set-property org-relate-property
                           parent-link))))

(defun org-agenda-relation-interrelate ()
  "Invoke `org-relate-interrelate' in agenda view."
  (interactive)
  (org-agenda-check-no-diary)
  (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                       (org-agenda-error)))
         (buffer (marker-buffer hdmarker))
         (pos (marker-position hdmarker))
         (inhibit-read-only t)
         newhead)
    (org-with-remote-undo buffer
      (with-current-buffer buffer
        (widen)
        (goto-char pos)
        (org-show-context 'agenda)
        (call-interactively 'org-relate-interrelate)
        (end-of-line 1)
        (setq newhead (org-get-heading))))))

(provide 'org-relate)
#+end_src

**** org-clocktable-by-tag

Provide a function to Build a clock table summing up time by tag.

#+begin_src emacs-lisp :tangle (expand-file-name "my-org-config.el" tangle/emacs-config-dir)
(with-eval-after-load 'org
  (require 'org-clocktable-by-tag))
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "org-clocktable-by-tag.el" tangle/emacs-sitelisp-dir)
(require 'org-table)
(require 'org-clock)

(defun clocktable-by-tag/shift-cell (n)
  (let ((str ""))
    (dotimes (i n)
      (setq str (concat str "| ")))
    str))

(defun clocktable-by-tag/insert-tag (params)
  (let ((match (plist-get params :match)))
    (insert "|--\n")
    (insert (format "| %s | *Tag time* |\n" match))
    (let ((total 0))
      (mapcar
       (lambda (file)
         (let ((clock-data (with-current-buffer (find-file-noselect file)
                             (org-clock-get-table-data (buffer-name) params))))
           (when (> (nth 1 clock-data) 0)
             (setq total (+ total (nth 1 clock-data)))
             (insert (format "| | File *%s* | %.2f |\n"
                             (file-name-nondirectory file)
                             (/ (nth 1 clock-data) 60.0)))
             (dolist (entry (nth 2 clock-data))
               (insert (format "| | . %s%s | %s %.2f |\n"
                               (org-clocktable-indent-string (nth 0 entry))
                               (replace-regexp-in-string "|" "\\vert\{\}" (nth 1 entry) nil t)
                               (clocktable-by-tag/shift-cell (nth 0 entry))
                               (/ (nth 4 entry) 60.0)))))))
       (org-agenda-files))
      (if (= total 0)
          (save-excursion
            (re-search-backward "*Tag time*")
            (forward-line -1)
            (dotimes (i 2)
              (org-table-kill-row)))
        (save-excursion
          (re-search-backward "*Tag time*")
          (org-table-next-field)
          (org-table-blank-field)
          (insert (format "*%.2f*" (/ total 60.0))))))
    (org-table-align)))

;;;###autoload
(defun org-dblock-write:clocktable-by-tag (params)
  (funcall indent-line-function)
  (insert "| Tag | Headline | Time (h) |\n")
  (insert "|     |          | <r>  |\n")
  (let ((matches
         (org-global-tags-completion-table)))
    (mapcar (lambda (match)
              (let ((match-str (car match))
                    (case-fold-search nil))
                (when (string-match-p "^AC_" match-str)
                  (setq params (plist-put params :match match-str))
                  (clocktable-by-tag/insert-tag params))))
            matches)))

(provide 'org-clocktable-by-tag)
#+end_src

**** weather

#+begin_src emacs-lisp :tangle (expand-file-name "weather.el" tangle/emacs-sitelisp-dir)
;; 気象庁配信の天気情報を加工して表示

(require 'request)
(require 'cl-lib)

(defvar weather-areas
  '(((url . "http://www.drk7.jp/weather/xml/14.xml")
     (pref . "神奈川県")
     (area . "西部"))
    ((url . "http://www.drk7.jp/weather/xml/22.xml")
     (pref . "静岡県")
     (area . "中部"))))

(defun weather-area-show (weather-area-alist weather-buffer)
  (lexical-let ((url (assoc-default 'url weather-area-alist))
                (pref (assoc-default 'pref weather-area-alist))
                (area (assoc-default 'area weather-area-alist))
                (buffer weather-buffer))
    (request
      url
      :parser
      (lambda ()
        (let ((xml-string (string-as-multibyte (string-as-unibyte (buffer-string)))))
          (with-temp-buffer
            (erase-buffer)
            (insert xml-string)
            (libxml-parse-xml-region (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (when data
           (with-current-buffer buffer
             (insert (format "%s %s\n" pref area))
             (mapcar
              (lambda (info-node)
                (insert
                 (format "%s %s %s %s\n"
                         (dom-attr info-node 'date)
                         (apply (lambda (max-temp-node min-temp-node)
                                  (format "%2d/%2d℃"
                                          (string-to-number (dom-text min-temp-node))
                                          (string-to-number (dom-text max-temp-node))))
                                (dom-by-tag (dom-child-by-tag info-node 'temperature) 'range))
                         (apply (lambda (node-1 node-2 node-3 node-4)
                                  (format "%2d-%2d-%2d-%2d％"
                                          (string-to-number (dom-text node-1))
                                          (string-to-number (dom-text node-2))
                                          (string-to-number (dom-text node-3))
                                          (string-to-number (dom-text node-4))))
                                (dom-by-tag (dom-child-by-tag info-node 'rainfallchance) 'period))
                         (dom-text (dom-child-by-tag info-node 'weather)))))
              (dom-by-tag (dom-by-id data area) 'info))
             (insert "\n"))))))))

(defun weather ()
  (interactive)
  (let ((buffer (get-buffer-create "weather")))
    (mapcar (lambda (weather-area)
              (weather-area-show weather-area buffer))
            weather-areas)
    (switch-to-buffer buffer)))

(provide 'weather)
#+end_src

** Findutils

[[https://www.gnu.org/software/findutils/][GNU Findutils]] offers following commands
- find
- locate
- updatedb
- xargs

'locate' is GNU implementation of mlocate. I prefer '[[id:c56e19dd-d3b1-4595-be74-0ff7c6558bc8][plocate]]', which is fast than mlocate, for indexed file searching,

#+begin_src scheme :noweb-ref guix-base
"findutils"
#+end_src

** plocate
:PROPERTIES:
:CREATED:  [2022-10-11 Tue 16:52]
:ID:       c56e19dd-d3b1-4595-be74-0ff7c6558bc8
:END:

#+begin_src scheme :noweb-ref guix-base
"plocate"
#+end_src

#+name: plocate-db
#+begin_src emacs-lisp :noweb yes
(file-name-concat "<<share-dir()>>" "plocate/plocate.db")
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
export LOCATE_PATH=<<plocate-db()>>
#+end_src

#+begin_src bash :noweb tangle :tangle (expand-file-name "updatedb-home" tangle/local-bin-dir)
. ~/.bashrc

mkdir -p $(dirname <<plocate-db()>>) && \
  $GUIX_EXTRA_PROFILES/base/base/sbin/updatedb -l 0 -U <<home-dir()>> -e <<open-file-dir()>> -o <<plocate-db()>> \
                                               <<updatedb-opt>>
#+end_src

#+begin_src conf :noweb yes :noweb-ref cronjob-user
,*/20 * * * * <<which(filename="bash")>> -ci "updatedb-home"
#+end_src

** OpenSSH

[[https://www.openssh.com/][OpenSSH]] is client and server side of ssh implementation.

#+begin_src scheme :noweb-ref guix-base
"openssh"
#+end_src

#+begin_src conf  :tangle (expand-file-name ".ssh/config")
Include config.d/*

Compression yes
#+end_src

** Git

#+begin_src scheme :noweb-ref guix-base
"git"
#+end_src

*** git ignore

#+BEGIN_SRC conf :tangle (expand-file-name ".config/git/info/ignore")
#
# ~/.gitignote
#
## Compiled object files ##
,*.slo
,*.lo
,*.o
,*.obj

## Compiled Dynamic libraries ##
,*.so
,*.dylib
,*.dll

## Compiled Static libraries ##
,*.lai
,*.la
,*.a
,*.lib

## Executables ##
,*.out
,*.app

## Windows ##
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
,*.cab
,*.msm
,*.msp

## Mac ##
.DS_Store
.AppleDouble
.LSOverride
.Spotlight-V100
.Trashes
._*

## Linux ##
locate.db

## version control system ##
.git/
.hg/
.svn/

## backup,log ##
,*~
~*
,*.swp
.swp.*
,*.tmp
,*.bak
,*.old
,*.log
.cache/
,*.autosave

## Emacs ##
,*.elc

## Vim ##
,*.un~
Session.vim
.netrwhist

## GNU GLOBAL ##
GPATH
GRTAGS
GTAGS

## netbeans ##
nbproject/
## intellij idea ##
.idea/
## eclipse ##
.settings/
.project
.classpath
.buildpath
## XCode ##
,*.xcodeproj/*

## Build dir ##
build/
#+END_SRC

*** git config

[[https://magit.vc/manual/magit/How-to-show-diffs-for-gpg_002dencrypted-files_003f.html][This page]] show you how to get diffs of gpg files in Magit.

#+BEGIN_SRC gitconfig :noweb tangle :tangle (expand-file-name ".config/git/config") :comments no
[core]
	excludesfile = <<home-dir()>>/.config/git/info/ignore
	attributesfile = <<home-dir()>>/.config/git/info/attributes
	editor = emacs
	symlinks = true
	# Unicode
	precomposeunicode = true
	quotepath = true
	autocrlf = false
[push]
	# simple,matching,upstream,current
	default = simple
[color]
	ui = auto
	status = auto
	diff = auto
	branch = auto
	interactive = auto
	grep = auto
[diff]
	patience = true
[diff "gpg"]
	textconv = gpg --no-tty --decrypt
[diff "common-lisp"]
	xfuncname="^\\((def\\S+\\s+\\S+)"
[diff "elisp"]
	xfuncname="^\\((((def\\S+)|use-package)\\s+\\S+)"
[diff "org"]
	xfuncname="^\\*+ +(.*)$"
[help]
	autocorrect = 0
[alias]
	co = checkout
	ca = commit -a -v
	ce = commit -v --amend
	st = status --branch --short
	si = status --ignored --short
	branches = branch -a
	remotes = remote -v
	tags = tag -l
	lg = log --graph --all --decorate --abbrev-commit --branches --date=short --pretty=format:\"%C(red)%h%C(reset) %C(green)[%ad]%C(reset) %s %C(cyan)@%an%C(reset) %C(yellow)%d%C(reset)\"
	fp = fetch --prune
	di = diff
	dh = diff --histogram
	dw = diff --word-diff
	dc = diff --cached
	wc = whatchanged
[user]
	email = 6841207+p-snow@users.noreply.github.com
	name = p-snow
	signingkey = BDAF62D24445EFD3
[commit]
	gpgsign = true
[credential]
	helper = <<which(filename="pass-git-helper")>> -m <<home-dir()>>/.config/pass-git-helper/git-pass-mapping.ini
	<<git-config>>
#+END_SRC
*** git attributes

#+BEGIN_SRC gitattributes :tangle (expand-file-name ".config/git/info/attributes") :comments no
,*.c diff=cpp
,*.h diff=cpp
,*.cpp diff=cpp
,*.hpp diff=cpp
,*.cs diff=csharp
,*.m diff=objc
,*.java diff=java
,*.html diff=html
,*.xml diff=html
,*.pl diff=perl
,*.pm diff=perl
,*.t diff=perl
,*.php diff=php
,*.ptml diff=php
,*.py diff=python
,*.rb diff=ruby
,*.js diff=java
,*.csv encoding=cp932
,*.json diff=json
,*.gpg filter=gpg diff=gpg
,*.org diff=org
,*.lisp diff=common-lisp
,*.el diff=elisp
#+END_SRC

** git-annex

[[https://git-annex.branchable.com/git-annex/][git-annex]] aims to manage large files based on git system. It is alse designed to manage copies of binary in distributed repositories. [[https://git-annex.branchable.com/walkthrough/][walkthrough]] offers handy instruction.

[[https://git-lfs.github.com/][Git-LFS]] is alse designed to manage large files. [[https://lwn.net/Articles/774125/][This article]] compares Git-LFS and git-annex precisely.

#+begin_src scheme :noweb-ref guix-base
"git-annex"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://git-annex.branchable.com/news/index.rss" soft_update)
("https://git-annex.branchable.com/devblog/index.rss" soft_update)
#+end_src

#+begin_src gitconfig :noweb-ref git-config
[annex]
	youtube-dl-command = yt-dlp
	synccontent = false
[annex.security]
	allowed-ip-addresses = all
[safe]
	directory = /mnt/ns01/doc
#+end_src

*** sync annex repos
:PROPERTIES:
:CREATED:  [2023-12-06 Wed 16:59]
:ID:       e9524731-4acc-4f4c-bc61-0226990a654a
:END:

#+begin_src conf :noweb yes :noweb-ref cronjob-user
40 */4 * * * <<which(filename="sync-annex-doc")>> 2>&1 | tee <<log-dir()>>/sync-git-annex.log
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name "sync-annex-doc" tangle/local-bin-dir)
GIT=<<which(filename="git")>>
ANNEX=<<which(filename="git-annex")>>

(cd /mnt/exdoc/doc/ 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync && $ANNEX get)
(cd /mnt/vt-m/doc/ 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync && $ANNEX get)
(cd /mnt/vt-h/doc/ 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync && $ANNEX get)
(cd /mnt/vt-j/doc/ 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync && $ANNEX get)
(cd <<doc-dir()>> 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync)

(cd /mnt/exdoc/doc/ 2>/dev/null && $GIT rev-parse --is-inside-work-tree 2>/dev/null && $ANNEX sync)
#+end_src

** ghq

[[https://github.com/x-motemen/ghq][ghq]] is management system for remote git repositories.

#+begin_src scheme :noweb-ref guix-base
"ghq"
#+end_src

#+name: ghq-root
#+begin_src shell :eval no-export
echo ~/data/ghq
#+end_src

#+begin_src gitconfig :noweb yes :noweb-ref git-config
[ghq]
	root = <<ghq-root()>>
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/ghq")
[github.com*]
username_extractor=specific_line
line_username=2
target=github.com
# username_extractor=entry_name
#+end_src

** Pass

[[https://www.passwordstore.org/][Pass]] is a simple password manager.

I've chosen to use gpg/gpg-agent and pass on Ubuntu system since pass (password-store) spouts a warning saying there's gpg version mismatch persistently.
#+begin_src scheme :noweb-ref guix-base
;; "password-store"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/pass-git-helper/git-pass-mapping.ini")
[github.com*]
username_extractor=specific_line
line_username=2
target=github.com
# username_extractor=entry_name
#+end_src

- additional environment variables
  #+BEGIN_SRC shell :noweb-ref bashrc
  export PASSWORD_STORE_CLIP_TIME=25
  #+END_SRC
** mpv

#+begin_src scheme :noweb-ref guix-desktop
;; "mpv-libarchive"
#+end_src

- mpv.conf
  #+begin_src conf :tangle (expand-file-name ".config/mpv/mpv.conf")
  ##################
  # video settings #
  ##################

  # Start in fullscreen mode by default.
  fs=yes


  ###########
  # General #
  ###########

  save-position-on-quit
  no-border                               # no window title bar
  msg-module                              # prepend module name to log messages
  msg-color                               # color log messages on terminal
  term-osd-bar                            # display a progress bar on the terminal
  use-filedir-conf                        # look for additional config files in the directory of the opened file
  pause                                   # no autoplay
  force-window=immediate
  keep-open                               # keep the player open when a file's end is reached
  autofit-larger=100%x95%                 # resize window in case it's larger than W%xH% of the screen
  cursor-autohide-fs-only                 # don't autohide the cursor in window mode, only fullscreen
  # input-media-keys=no                     # enable/disable OSX media keys
  cursor-autohide=1000                    # autohide the curser after 1s

  screenshot-format=png
  screenshot-png-compression=8
  screenshot-template='~/Desktop/%F (%P) %n'

  hls-bitrate=max                         # use max quality for HLS streams


  #########
  # Cache #
  #########

  cache=yes
  cache-secs=10                           # how many seconds of audio/video to prefetch if the cache is active


  #############
  # OSD / OSC #
  #############

  osd-level=1                             # enable osd and display --osd-status-msg on interaction
  osd-duration=2500                       # hide the osd after x ms
  osd-status-msg='${time-pos} / ${duration}${?percent-pos: (${percent-pos}%)}${?frame-drop-count:${!frame-drop-count==0: Dropped: ${frame-drop-count}}}\n${?chapter:Chapter: ${chapter}}'
  # osd-status-msg='${=time-pos}'         # show raw position

  osd-font='Source Sans Pro'
  osd-font-size=64
  osd-color='#CCFFFFFF'                   # ARGB format
  osd-border-color='#DD322640'            # ARGB format
  #osd-shadow-offset=1                    # pixel width for osd text and progress bar
  osd-bar-align-y=0                       # progress bar y alignment (-1 top, 0 centered, 1 bottom)
  osd-border-size=2                       # size for osd text and progress bar
  osd-bar-h=2                             # height of osd bar as a fractional percentage of your screen height
  osd-bar-w=60                            # width of " " "


  #############
  # Subtitles #
  #############

  sub-use-margins
  sub-ass-force-margins

  demuxer-mkv-subtitle-preroll            # try to correctly show embedded subs when seeking
  sub-auto=fuzzy                          # external subs don't have to match the file name exactly to autoload
  embeddedfonts=yes                       # use embedded fonts for SSA/ASS subs
  sub-fix-timing=no                       # do not try to fix gaps (which might make it worse in some cases)
  sub-ass-force-style=Kerning=yes         # allows you to override style parameters of ASS scripts

  # the following options only apply to subtitles without own styling (i.e. not ASS but e.g. SRT)
  sub-font="Source Sans Pro Semibold"
  sub-font-size=36
  sub-color="#FFFFFFFF"
  sub-border-color="#FF262626"
  sub-border-size=3.2
  sub-shadow-offset=1
  sub-shadow-color="#33000000"
  sub-spacing=0.5


  #############
  # Languages #
  #############

  slang=enm,en,eng,de,deu,ger             # automatically select these subtitles (decreasing priority)
  alang=ja,jp,jpn,en,eng,de,deu,ger       # automatically select these audio tracks (decreasing priority)

  #########
  # Image #
  #########

  image-display-duration=4

  #########
  # Audio #
  #########

  audio-file-auto=fuzzy                   # external audio doesn't has to match the file name exactly to autoload
  audio-pitch-correction=yes              # automatically insert scaletempo when playing with higher speed
  volume-max=200                          # maximum volume in %, everything above 100 results in amplification
  volume=100                              # default volume, 100 = unchanged


  ################
  # Video Output #
  ################

  # Active VOs (and some other options) are set conditionally
  # See here for more information: https://github.com/wm4/mpv-scripts/blob/master/auto-profiles.lua
  # The script was modified to import functions from scripts/auto-profiles-functions.lua

  # Defaults for all profiles
  tscale=catmull_rom                      # sharp: oversample <-> linear (triangle) <-> catmull_rom <-> mitchell <-> gaussian <-> bicubic : smooth
  opengl-early-flush=no
  opengl-pbo=yes


  [high-quality]
  profile-desc=cond:is_desktop() and get('width', math.huge) < 3840
  scale=ewa_lanczossharp
  cscale=ewa_lanczossoft
  dscale=mitchell
  scale-antiring=0.7
  cscale-antiring=0.7
  dither-depth=auto
  correct-downscaling=yes
  sigmoid-upscaling=yes
  deband=yes
  hwdec=no

  [mid-quality]
  profile-desc=cond:(is_laptop() and not on_battery() and get('width', math.huge) < 1920) or (is_desktop() and get('width', math.huge) >= 3840)
  scale=spline36
  cscale=bilinear
  dscale=mitchell
  scale-antiring=1.0
  cscale-antiring=1.0
  dither-depth=auto
  correct-downscaling=yes
  sigmoid-upscaling=yes
  deband=yes
  hwdec=no

  [low-quality]
  profile-desc=cond:is_laptop() and (on_battery() or get('width', math.huge) >= 1920)
  scale=bilinear
  cscale=bilinear
  dscale=bilinear
  scale-antiring=0.0
  cscale-antiring=0.0
  dither-depth=no
  correct-downscaling=no
  sigmoid-upscaling=no
  deband=no
  hwdec=auto

  [60FPS]
  profile-desc=cond:is_laptop() and get('container-fps', 0) >= 59
  scale=bilinear
  cscale=bilinear

  [4K]
  profile-desc=cond:get('width', -math.huge) >= 3840
  vd-lavc-threads=32

  [4K-inverted]
  profile-desc=cond:get('width', -math.huge) < 3840
  vd-lavc-threads=0


  [default]


  ###################################
  # Protocol Specific Configuration #
  ###################################

  [protocol.https]
  #cache=yes
  #cache-default=500000                    # size in KB
  #cache-backbuffer=250000                 # size in KB
  cache-secs=100                          # how many seconds of audio/video to prefetch
  user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

  [protocol.http]
  #cache=yes
  #cache-default=500000                    # size in KB
  #cache-backbuffer=250000                 # size in KB
  cache-secs=100                          # how many seconds of audio/video to prefetch
  user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

  [extension.gif]
  cache=no
  no-pause
  loop-file=yes

  [extension.webm]
  #cache=no
  #no-pause
  #loop-file=yes
  #+end_src
- input.conf
  #+begin_src conf :tangle (expand-file-name ".config/mpv/input.conf")
  # mpv keybindings
  #
  # Location of user-defined bindings: ~/.config/mpv/input.conf
  #
  # Lines starting with # are comments. Use SHARP to assign the # key.
  # Copy this file and uncomment and edit the bindings you want to change.
  #
  # List of commands and further details: DOCS/man/input.rst
  # List of special keys: --input-keylist
  # Keybindings testing mode: mpv --input-test --force-window --idle
  #
  # Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
  #
  # Strings need to be quoted and escaped:
  #   KEY show-text "This is a single backslash: \\ and a quote: \" !"
  #
  # You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
  # the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
  #
  # The default keybindings are hardcoded into the mpv binary.
  # You can disable them completely with: --no-input-default-bindings

  # Developer note:
  # On compilation, this file is baked into the mpv binary, and all lines are
  # uncommented (unless '#' is followed by a space) - thus this file defines the
  # default key bindings.

  # If this is enabled, treat all the following bindings as default.
  #default-bindings start

  #MOUSE_BTN0 ignore                      # don't do anything
  #MOUSE_BTN0_DBL cycle fullscreen        # toggle fullscreen on/off
  #MOUSE_BTN2 cycle pause                 # toggle pause on/off
  #MOUSE_BTN3 seek 10
  #MOUSE_BTN4 seek -10
  #MOUSE_BTN5 add volume -2
  #MOUSE_BTN6 add volume 2

  # Mouse wheels, touchpad or other input devices that have axes
  # if the input devices supports precise scrolling it will also scale the
  # numeric value accordingly
  #AXIS_UP    seek 10
  #AXIS_DOWN  seek -10
  #AXIS_LEFT  seek 5
  #AXIS_RIGHT seek -5

  ## Seek units are in seconds, but note that these are limited by keyframes
  #RIGHT seek  5
  #LEFT  seek -5
  #UP    seek  60
  #DOWN  seek -60
  RIGHT  seek  5
  LEFT   seek -5
  UP     seek -60
  DOWN   seek  60
  Ctrl+f seek  3
  Ctrl+b seek -3
  Ctrl+p seek -60
  Ctrl+n seek  60
  # Do smaller, always exact (non-keyframe-limited), seeks with shift.
  # Don't show them on the OSD (no-osd).
  #Shift+RIGHT no-osd seek  1 exact
  #Shift+LEFT  no-osd seek -1 exact
  #Shift+UP    no-osd seek  5 exact
  #Shift+DOWN  no-osd seek -5 exact
  # Skip to previous/next subtitle (subject to some restrictions; see manpage)
  #Ctrl+LEFT   no-osd sub-seek -1
  #Ctrl+RIGHT  no-osd sub-seek  1
  #PGUP add chapter 1                     # skip to next chapter
  #PGDWN add chapter -1                   # skip to previous chapter
  PGUP add chapter -1                     # skip to next chapter
  PGDWN add chapter 1                     # skip to previous chapter
  #Shift+PGUP seek 600
  #Shift+PGDWN seek -600
  #[ multiply speed 0.9091                # scale playback speed
  #] multiply speed 1.1
  #{ multiply speed 0.5
  #} multiply speed 2.0
  #BS set speed 1.0                       # reset speed to normal
  #q quit
  #Q quit-watch-later
  #q {encode} quit 4
  #ESC set fullscreen no
  #ESC {encode} quit 4
  #p cycle pause                          # toggle pause/playback mode
  #. frame-step                           # advance one frame and pause
  #, frame-back-step                      # go back by one frame and pause
  #SPACE cycle pause
  ? playlist-shuffle                      # skip to random file
  #> playlist-next                        # skip to next file
  ENTER playlist-next                     # skip to next file
  #< playlist-prev                        # skip to previous file
  Shift+ENTER playlist-prev               # skip to next file
  #O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
  #o show-progress
  #P show-progress
  #I show-text "${filename}"              # display filename in osd
  #z add sub-delay -0.1                   # subtract 100 ms delay from subs
  #x add sub-delay +0.1                   # add
  #ctrl++ add audio-delay 0.100           # this changes audio/video sync
  #ctrl+- add audio-delay -0.100
  #9 add volume -2
  #/ add volume -2
  #0 add volume 2
  #* add volume 2
  #m cycle mute
  #1 add contrast -1
  #2 add contrast 1
  #3 add brightness -1
  #4 add brightness 1
  #5 add gamma -1
  #6 add gamma 1
  #7 add saturation -1
  #8 add saturation 1
  #Alt+0 set window-scale 0.5
  #Alt+1 set window-scale 1.0
  #Alt+2 set window-scale 2.0
  # toggle deinterlacer (automatically inserts or removes required filter)
  #d cycle deinterlace
  #r add sub-pos -1                       # move subtitles up
  r cycle_values video-rotate 90 180 270 0
  #t add sub-pos +1                       #                down
  #v cycle sub-visibility
  # stretch SSA/ASS subtitles with anamorphic videos to match historical
  #V cycle sub-ass-vsfilter-aspect-compat
  # switch between applying no style overrides to SSA/ASS subtitles, and
  # overriding them almost completely with the normal subtitle style
  #u cycle-values sub-ass-style-override "force" "no"
  #j cycle sub                            # cycle through subtitles
  #J cycle sub down                       # ...backwards
  #SHARP cycle audio                      # switch audio streams
  #_ cycle video
  #T cycle ontop                          # toggle video window ontop of other windows
  #f cycle fullscreen                     # toggle fullscreen
  #s async screenshot                     # take a screenshot
  #S async screenshot video               # ...without subtitles
  #Ctrl+s async screenshot window         # ...with subtitles and OSD, and scaled
  #Alt+s screenshot each-frame            # automatically screenshot every frame
  #w add panscan -0.1                     # zoom out with -panscan 0 -fs
  #e add panscan +0.1                     #      in
  # cycle video aspect ratios; "-1" is the container aspect
  #A cycle-values video-aspect "16:9" "4:3" "2.35:1" "-1"
  #POWER quit
  #PLAY cycle pause
  #PAUSE cycle pause
  #PLAYPAUSE cycle pause
  #STOP quit
  #FORWARD seek 60
  #REWIND seek -60
  #NEXT playlist-next
  #PREV playlist-prev
  #VOLUME_UP add volume 2
  #VOLUME_DOWN add volume -2
  #MUTE cycle mute
  #CLOSE_WIN quit
  #CLOSE_WIN {encode} quit 4
  #E cycle edition                        # next edition
  #l ab-loop                              # Set/clear A-B loop points
  #L cycle-values loop-file "inf" "no"    # toggle infinite looping
  #ctrl+c quit 4

  # Apple Remote section
  #AR_PLAY cycle pause
  #AR_PLAY_HOLD quit
  #AR_CENTER cycle pause
  #AR_CENTER_HOLD quit
  #AR_NEXT seek 10
  #AR_NEXT_HOLD seek 120
  #AR_PREV seek -10
  #AR_PREV_HOLD seek -120
  #AR_MENU show-progress
  #AR_MENU_HOLD cycle mute
  #AR_VUP add volume 2
  #AR_VUP_HOLD add chapter 1
  #AR_VDOWN add volume -2
  #AR_VDOWN_HOLD add chapter -1

  # For tv://
  #h cycle tv-channel -1                  # previous channel
  #k cycle tv-channel +1                  # next channel

  # For dvb://
  #H cycle dvb-channel-name -1            # previous channel
  #K cycle dvb-channel-name +1            # next channel

  #
  # Legacy bindings (may or may not be removed in the future)
  #
  #! add chapter -1                       # skip to previous chapter
  #@ add chapter 1                        #         next

  #
  # Not assigned by default
  # (not an exhaustive list of unbound commands)
  #

  # ? add sub-scale +0.1                  # increase subtitle font size
  # ? add sub-scale -0.1                  # decrease subtitle font size
  # ? sub-step -1                         # immediately display next subtitle
  # ? sub-step +1                         #                     previous
  # ? cycle angle                         # switch DVD/Bluray angle
  # ? add balance -0.1                    # adjust audio balance in favor of left
  Z add balance -0.1                    # adjust audio balance in favor of left
  # ? add balance 0.1                     #                                  right
  X add balance 0.1                     #                                  right
  # ? cycle sub-forced-only               # toggle DVD forced subs
  # ? cycle program                       # cycle transport stream programs
  # ? stop                                # stop playback (quit or enter idle mode)
  #+end_src
- scripts
  #+begin_src lua :tangle (expand-file-name ".config/mpv/scripts/delete_file.lua") :comments no
    local utils = require "mp.utils"

    del_list = {}

    function contains_item(l, i)
       for k, v in pairs(l) do
          if v == i then
             mp.osd_message("undeleting current file")
             l[k] = nil
             return true
          end
       end
       mp.osd_message("deleting current file")
       return false
    end

    function mark_delete()
       local work_dir = mp.get_property_native("working-directory")
       local file_path = mp.get_property_native("path")
       local s = file_path:find(work_dir, 0, true)
       local final_path
       if s and s == 0 then
          final_path = file_path
       else
          final_path = utils.join_path(work_dir, file_path)
       end
       if not contains_item(del_list, final_path) then
          table.insert(del_list, final_path)
       end
    end

    function delete(e)
       if e.reason == "quit" then
          for i, v in pairs(del_list) do
             print("deleting: "..v)
             os.remove(v)
          end
       end
    end

    mp.add_key_binding("ctrl+DEL", "delete_file", mark_delete)
    mp.register_event("end-file", delete)
  #+end_src

** unison
- music directory syncing
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".unison/music.prf")
  # Roots of the synchronization
  root = <<home-dir()>>/mnt/ruizu/Music
  root = <<home-dir()>>/Audio

  # Paths to synchronize
  path = .

  # Ruizu's file system is FAT
  fat = true

  # Overwrite by newer file on confliction
  prefer = newer

  # Show nothing
  silent = true
  confirmbigdel = false

  # Do fast checking
  fastcheck = true

  # Log settings
  log = true
  logfile = <<home-dir()>>/.local/state/log/log/unison/music.log

  #+end_src
- doc directory backup
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".unison/doc.prf")
  # Roots of the synchronization
  root = <<home-dir()>>/mnt/ns01
  root = <<home-dir()>>

  # Paths to synchronize
  path = doc

  # Overwrite by newer file on confliction
  prefer = newer

  # Use this command for displaying diffs
  diff = diff -y -W 79 --suppress-common-lines

  # Write down synchronization activity on log file rather than show in stdout
  auto = true
  confirmbigdel = false
  silent = true
  log = true
  logfile = <<home-dir()>>/.local/state/log/unison/doc.log

  # Use inode number to verify identity rather than ckeck whole byte sequence
  fastcheck = true

  # Abort if device is not mounted
  mountpoint = doc
  #+end_src
** Aspell
aspell - interactive spell checker
#+begin_src conf :tangle (expand-file-name ".aspell.conf")
lang en_US
#+end_src
** textlint
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 14:53]
:ID:       decef153-596d-4821-996e-53cfafe83c8f
:END:

#+begin_src conf :noweb-ref ubuntu-setup :tangle no
install-textlint
#+end_src

#+begin_src shell :tangle no :noweb-ref npm-pkg
textlint @textlint/ast-node-types textlint-rule-preset-ja-spacing textlint-rule-preset-ja-technical-writing textlint-rule-spellcheck-tech-word textlint-rule-ginger textlint-rule-write-good textlint-rule-prh textlint-filter-rule-node-types textlint-plugin-org traverse
#+end_src

- config for English
  #+begin_src json :tangle (expand-file-name ".textlintrc") :comments no
  {
    "rules": {
      "ginger": true,
      "write-good": true,
    }
  }
  #+end_src

- config for Japanese
  #+begin_src json :tangle (expand-file-name ".config/textlint/textlintrc_ja") :comments no
  {
    "rules": {
      "preset-ja-technical-writing": {
        "no-exclamation-question-mark": false,
        "sentence-length": {
          "max": 200
        }
      },
      "spellcheck-tech-word": true,
      "textlint-rule-ginger": {
        "skipPatterns": [
          "`(.*)`"
        ]
      },
      "textlint-rule-write-good": true,
      "preset-ja-spacing": true
    }
  }
  #+end_src

** xkeysnail

#+begin_src scheme :noweb-ref guix-desktop
"xkeysnail"
#+end_src

- config.py
  # #+begin_src python :tangle (expand-file-name ".config/xkeysnail/config.py")
  #+begin_src python :tangle no
  # -*- coding: utf-8 -*-

  import re
  from xkeysnail.transform import *

  define_multipurpose_modmap({
      # SandS
      Key.SPACE: [Key.SPACE, Key.LEFT_SHIFT],

      # Enter is enter when pressed and released. Control when held down.
      Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL],

      Key.LEFT_SHIFT: [Key.EQUAL, Key.LEFT_SHIFT],
      Key.RIGHT_SHIFT: [Key.MINUS, Key.RIGHT_SHIFT],
  })

  define_modmap({
      Key.LEFT_CTRL: Key.CAPSLOCK,
      Key.CAPSLOCK: Key.LEFT_CTRL,
      Key.SYSRQ: Key.RIGHT_META,
  })

  define_keymap(None, {
      K("C-Shift-a"): K("KEY_1"),
      K("C-Shift-s"): K("KEY_2"),
      K("C-Shift-d"): K("KEY_3"),
      K("C-Shift-f"): K("KEY_4"),
      K("C-Shift-g"): K("KEY_5"),
      K("C-Shift-h"): K("KEY_6"),
      K("C-Shift-j"): K("KEY_7"),
      K("C-Shift-k"): K("KEY_8"),
      K("C-Shift-l"): K("KEY_9"),
      K("C-Shift-semicolon"): K("KEY_0"),
  })


  # # [Conditional modmap] Change modifier keys in certain applications
  # define_conditional_modmap(re.compile(r'Emacs'), {
  #     Key.RIGHT_CTRL: Key.ESC,
  # })

  # # [Multipurpose modmap] Give a key two meanings. A normal key when pressed and
  # # released, and a modifier key when held down with another key. See Xcape,
  # # Carabiner and caps2esc for ideas and concept.
  # define_multipurpose_modmap(
  #     # Enter is enter when pressed and released. Control when held down.
  #     {Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL]}

  #     # Capslock is escape when pressed and released. Control when held down.
  #     # {Key.CAPSLOCK: [Key.ESC, Key.LEFT_CTRL]
  #     # To use this example, you can't remap capslock with define_modmap.
  # )


  # # Keybindings for Firefox/Chrome
  # define_keymap(re.compile("Firefox|Google-chrome"), {
  #     # Ctrl+Alt+j/k to switch next/previous tab
  #     K("C-M-j"): K("C-TAB"),
  #     K("C-M-k"): K("C-Shift-TAB"),
  #     # Type C-j to focus to the content
  #     K("C-j"): K("C-f6"),
  #     # very naive "Edit in editor" feature (just an example)
  #     K("C-o"): [K("C-a"), K("C-c"), launch(["gedit"]), sleep(0.5), K("C-v")]
  # }, "Firefox and Chrome")

  # # Keybindings for Zeal https://github.com/zealdocs/zeal/
  # define_keymap(re.compile("Zeal"), {
  #     # Ctrl+s to focus search area
  #     K("C-s"): K("C-k"),
  # }, "Zeal")

  # # Emacs-like keybindings in non-Emacs applications
  # define_keymap(lambda wm_class: wm_class not in ("Emacs", "URxvt"), {
  #     # Cursor
  #     K("C-b"): with_mark(K("left")),
  #     K("C-f"): with_mark(K("right")),
  #     K("C-p"): with_mark(K("up")),
  #     K("C-n"): with_mark(K("down")),
  #     K("C-h"): with_mark(K("backspace")),
  #     # Forward/Backward word
  #     K("M-b"): with_mark(K("C-left")),
  #     K("M-f"): with_mark(K("C-right")),
  #     # Beginning/End of line
  #     K("C-a"): with_mark(K("home")),
  #     K("C-e"): with_mark(K("end")),
  #     # Page up/down
  #     K("M-v"): with_mark(K("page_up")),
  #     K("C-v"): with_mark(K("page_down")),
  #     # Beginning/End of file
  #     K("M-Shift-comma"): with_mark(K("C-home")),
  #     K("M-Shift-dot"): with_mark(K("C-end")),
  #     # Newline
  #     K("C-m"): K("enter"),
  #     K("C-j"): K("enter"),
  #     K("C-o"): [K("enter"), K("left")],
  #     # Copy
  #     K("C-w"): [K("C-x"), set_mark(False)],
  #     K("M-w"): [K("C-c"), set_mark(False)],
  #     K("C-y"): [K("C-v"), set_mark(False)],
  #     # Delete
  #     K("C-d"): [K("delete"), set_mark(False)],
  #     K("M-d"): [K("C-delete"), set_mark(False)],
  #     # Kill line
  #     K("C-k"): [K("Shift-end"), K("C-x"), set_mark(False)],
  #     # Undo
  #     K("C-slash"): [K("C-z"), set_mark(False)],
  #     K("C-Shift-ro"): K("C-z"),
  #     # Mark
  #     K("C-space"): set_mark(True),
  #     K("C-M-space"): with_or_set_mark(K("C-right")),
  #     # Search
  #     K("C-s"): K("F3"),
  #     K("C-r"): K("Shift-F3"),
  #     K("M-Shift-key_5"): K("C-h"),
  #     # Cancel
  #     K("C-g"): [K("esc"), set_mark(False)],
  #     # Escape
  #     K("C-q"): escape_next_key,
  #     # C-x YYY
  #     K("C-x"): {
  #         # C-x h (select all)
  #         K("h"): [K("C-home"), K("C-a"), set_mark(True)],
  #         # C-x C-f (open)
  #         K("C-f"): K("C-o"),
  #         # C-x C-s (save)
  #         K("C-s"): K("C-s"),
  #         # C-x k (kill tab)
  #         K("k"): K("C-f4"),
  #         # C-x C-c (exit)
  #         K("C-c"): K("C-q"),
  #         # cancel
  #         K("C-g"): pass_through_key,
  #         # C-x u (undo)
  #         K("u"): [K("C-z"), set_mark(False)],
  #     }
  # }, "Emacs-like keys")
  #+end_src
- xkeysnail.service

  # #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
  #+begin_src conf :tangle no
  systemctl --user enable xkeysnail
  systemctl --user start xkeysnail
  #+end_src

  # #+begin_src conf :tangle (expand-file-name ".config/systemd/user/xkeysnail.service")
  #+begin_src conf :tangle no
  [Unit]
  Description=xkeysnail

  [Service]
  KillMode=process
  ExecStart=/bin/bash -ic 'pwsudo xkeysnail --watch --quiet %h/.config/xkeysnail/config.py'
  Type=simple
  Restart=always
  # Update DISPLAY to be the same as `echo $DISPLAY` on your graphical terminal.
  Environment=DISPLAY=:0

  [Install]
  WantedBy=default.target
  #+end_src

** SKK
:PROPERTIES:
:ID:       97b009df-7d14-452f-8e39-3da290a01792
:END:

SKK is Simple Kana to Kanji conversion program, an input method of Japanese.

#+begin_src scheme :tangle no :noweb-ref guix-base
"skk-jisyo"
"skktools"
#+end_src

#+name: skk-jisyo-path
#+begin_src bash :noweb tangle :tangle no
. ${HOME}/.bashrc

echo "${GUIX_EXTRA_PROFILES}/base/base/share/skk/"
#+end_src

- TODO: following programs have no guix package.
  It is better to write my own one for my reproducible system.
  + [X] [[https://github.com/skk-dev/skktools][skktools]]
  + [ ] ibus-skk

*** derive unique entries in user-jisyo

#+begin_src shell :eval no :tangle no :noweb-ref midnight-batch
skkdic_uniq.sh
#+end_src

#+begin_src bash :noweb tangle :tangle (expand-file-name "skkdic_uniq.sh" tangle/local-bin-dir)
tmp_euc=$(mktemp)
tmp_utf8=$(mktemp)
skk_dir=<<share-dir()>>/skk
skk_get_dir=${skk_dir}/get-jisyo
dic_orig=${HOME}/.emacs.d/ddskk/jisyo
dic_uniq=${skk_dir}/jisyo.uniq

skkdic-expr2 ${skk_get_dir}/SKK-JISYO.* > ${tmp_euc}
nkf -w -Lu ${tmp_euc} > ${tmp_utf8}
skkdic-expr2 ${dic_orig} - ${tmp_utf8} > ${dic_uniq}

rm -f ${tmp_euc}
rm -f ${tmp_utf8}

echo ${dic_uniq}
#+end_src
** Festival
:PROPERTIES:
:ID:       379230e4-dec0-4f96-becf-7d62159ff598
:END:

[[http://festvox.org/festival/][Festival]] is a framework for building and manipulating speech synthesis engine.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"festival"
#+end_src

- configuration
  #+begin_src scheme :noweb tangle :tangle (expand-file-name ".festivalrc")
  ;; -*- mode:scheme; -*-
  (Parameter.set 'Audio_Required_Format 'aiff)
  (Parameter.set 'Audio_Method 'Audio_Command)
  (Parameter.set 'Audio_Command "paplay $FILE --client-name=Festival --stream-name=Speech")

  ;; add SLT voice and use it as a default one
  (voice-location 'cmu_us_slt_cg
                  (path-as-directory "<<home-dir()>>/.local/share/festival/lib/voices/us/cmu_us_slt_cg")
                  "English American Female")
  (set! voice_default voice_cmu_us_slt_cg)
  #+end_src
- a script to download voices

  #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  download-festival-voices
  #+end_src

  #+begin_src bash :tangle (expand-file-name "download-festival-voices" tangle/local-bin-dir)
  work_dir=~/.local/share/festival
  voices=(
    cmu_us_aew_cg
    cmu_us_rxr_cg
    cmu_us_slt_cg
  )

  if [ ! -d "${work_dir}" ]; then
    mkdir -p "${work_dir}"
  fi

  cd "${work_dir}"
  for voice in "${voices[@]}"; do
    voice_pack_file=festvox_${voice}.tar.gz
    if [ ! -e ${voice_pack_file} ]; then
      wget -c http://festvox.org/packed/festival/2.5/voices/${voice_pack_file}
      tar zxf "${voice_pack_file}" -C ../../share
    fi
  done

  echo "${work_dir}"
  #+end_src
- festival.el

  #+begin_src emacs-lisp :noweb-ref elisp-code
  (use-package festival
    :defer t
    :config
    (say-minor-mode 1)
    (setq festival-tmp-file (make-temp-file "festival-")))
  #+end_src

** Open JTalk
:PROPERTIES:
:ID:       ce99b0cf-dd07-4b9e-86b3-b492a8cfb354
:END:

#+name: hts-voice-dir
#+begin_src emacs-lisp :noweb yes
(expand-file-name "~/.local/share/hts-voice")
#+end_src

- install on Ubuntu
  #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
  open-jtalk open-jtalk-mecab-naist-jdic hts-voice-nitech-jp-atr503-m001
  #+end_src
- download hts voices

  #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  download-hts-voices
  #+end_src

  #+begin_src bash :noweb tangle :tangle (expand-file-name "download-hts-voices" tangle/local-bin-dir)
  data_dir=<<hts-voice-dir()>>
  hts_workdir=/tmp
  hts_fname=MMDAgent_Example-1.8.zip

  if [ ! -d "${data_dir}" ]; then
    mkdir -p "${data_dir}"
  fi

  cd "${hts_workdir}" \
    && curl -sLO http://sourceforge.net/projects/mmdagent/files/MMDAgent_Example/${hts_fname%.zip}/${hts_fname} \
    && unzip -o -d ${data_dir} ${hts_fname} \
    && ln -sfv ${data_dir}/${hts_fname%.zip}/Voice ${data_dir}/
  #+end_src

** Jack

#+begin_src scheme :noweb-ref guix-desktop
"qjackctl"
"qsynth"
"jack-keyboard"
#+end_src

#+begin_src conf :tangle (expand-file-name ".jackdrc")
/usr/bin/jackd -dalsa -dhw:0 -r44100 -p1024 -n3 -Xseq
#+end_src

** XRandR

XRandR is a command line utility for changing display options without restarting X server.

[[https://wiki.archlinux.org/title/xrandr][xrandr - ArchWiki]]

- show avaulable modes for all displays
  #+begin_src shell :results verbatim
  xrandr
  #+end_src

- change mode (resolution) to 1920x1080 for a display identified as "HDMI-2"
  #+begin_src shell
  xrandr --output HDMI-2 --mode 1920x1080
  #+end_src

- change mode back to preferred (maximum)
  #+begin_src shell
  xrandr --output HDMI-2 --auto
  #+end_src

#+begin_src scheme :noweb-ref guix-desktop
"xrandr"
#+end_src
** C/Migemo
:PROPERTIES:
:ID:       9ac77d59-90bd-4054-89c9-dcab29bd7462
:END:

[[https://github.com/koron/cmigemo][C/Migemo]] allows us to search Japanese with incremental ASCII charactor input.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"cmigemo"
"migemo-dict-azik"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/koron/cmigemo/releases.atom" soft_update)
#+end_src

#+name: migemo-dict-path
#+begin_src shell :noweb tangle :tangle no
source ~/.bashrc

echo "${GUIX_EXTRA_PROFILES}/emacs/emacs/share/migemo/"
#+end_src

*** C/Migemo in apt                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-08 Wed 16:57]
:END:

As of [2023-02-08 Wed] C/Migemo is installed via guix package system since [[https://gitlab.com/guix-jp/guix-jp][guix-jp]] has offered that.

# #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
#   cmigemo
# #+end_src

*** AZIK-compliant C/Migemo                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-05 Sun 12:02]
:END:

Caveat: The effect in this section can be made happen to use 'migemo-dict-azik' guix package.

If you are AZIK lover, replace /usr/share/cmigemo/utf-8/roma2hira.dat with the content below to activate AZIK key assign in migemo.

#+begin_src shell :noweb-ref ubuntu-setup :tangle no
MIGEMO_DAT_SYSTEM_DIR=/usr/share/cmigemo/utf-8
MIGEMO_DAT_LOCAL_DIR=~/.local/share/cmigemo/utf-8
ROMA_2_HIRA=roma2hira.dat

if [ -f "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
  (
    cd "${MIGEMO_DAT_SYSTEM_DIR}" \
      && sudo mv ${ROMA_2_HIRA} ${ROMA_2_HIRA}.orig
  )
fi
if [ -h "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
  sudo unlink "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}"
fi
sudo ln -s "${MIGEMO_DAT_LOCAL_DIR}/${ROMA_2_HIRA}" ${MIGEMO_DAT_SYSTEM_DIR}
#+end_src

#+begin_src text :tangle (expand-file-name ".local/share/cmigemo/utf-8/roma2hira.dat")
# vi:set ts=8 sts=8 sw=8 tw=0:
#
# roma2hira.dat - ローマ字→平仮名変換表
#
# Last Change: 18-Oct-2003.
# Written By:  Muraoka Taro  <koron@tka.att.ne.jp>

# こいつをカスタマイズすることでローマ字の入力方式が変わります。
# 現在はMS-IME2000を参考に決定しています。
# 漢字コードの違いを吸収する役割も果たします。
# xnとxtuには「ん」と「っ」を指定する役割があります。
# {from} {to}の形式です。
# 現在は{from}は最大7バイトまで{to}は6バイトまでとなっています。
# {from}と{to}の間は空白文字(isspace())で区切ります。

# http://asiamoth.com/mt/archives/2006-08/05_2313.php

-	ー
~	〜
,	、
.	。
:	ー
[	「
]	」
;	っ
a	あ
ba	ば
bd	べん
be	べ
bh	ぶう
bi	び
bj	ぶん
bk	びん
bl	ぼん
bn	ばん
bo	ぼ
bp	ぼう
bq	ばい
bt	びと
bu	ぶ
bv	びゅう
bw	べい
bx	びょう
bya	びゃ
byj	びゅん
byo	びょ
byp	びょう
byu	びゅ
bz	ばん
ca	ちゃ
cd	ちぇん
ce	ちぇ
cf	ちぇ
ch	ちゅう
ci	ち
cj	ちゅん
ck	ちん
cl	ちょん
cn	ちゃん
co	ちょ
cp	ちょう
cq	ちゃい
cu	ちゅ
cz	ちゃん
da	だ
dch	どぅー
dci	でぃ
dcj	どぅん
dck	でぃん
dcu	どぅ
dd	でん
de	で
df	で
dga	ぢゃ
dge	ぢぇ
dgj	ぢゅん
dgl	ぢょん
dgo	ぢょ
dgq	ぢゃい
dgu	ぢゅ
dgz	ぢゃん
dh	づう
di	ぢ
dj	づん
dk	ぢん
dl	どん
dm	でも
dn	だん
do	ど
dp	どう
dq	だい
dr	である
ds	です
dt	だち
du	づ
dv	ぢゅう
dw	でい
dx	ぢょう
dya	でゃ
dyh	でゅー
dyj	でゅん
dyq	でゃい
dyu	でゅ
dyz	でゃん
dz	だん
e	え
fa	ふぁ
fd	ふぇん
fe	ふぇ
fh	ふう
fi	ふぃ
fj	ふん
fk	ふぃん
fl	ふぉん
fn	ふぁん
fo	ふぉ
fq	ふぁい
fu	ふ
fv	ふゅー
fw	ふぇい
fyh	ふゅー
fyj	ふゅん
fyu	ふゅ
fz	ふぁん
ga	が
gd	げん
ge	げ
gh	ぐう
gi	ぎ
gj	ぐん
gk	ぎん
gl	ごん
gn	がん
go	ご
gp	ごう
gq	がい
gr	がら
gt	ごと
gu	ぐ
gv	ぎゅう
gw	げい
gx	ぎょう
gya	ぎゃ
gyh	ぎゅう
gyj	ぎゅん
gyl	ぎょん
gyo	ぎょ
gyp	ぎょう
gyq	ぎゃい
gyu	ぎゅ
gyz	ぎゃん
gz	がん
ha	は
hd	へん
he	へ
hf	ふ
hga	ひゃ
hgd	ひぇん
hge	ひぇ
hgh	ひゅう
hgj	ひゅん
hgl	ひょん
hgn	ひゃん
hgo	ひょ
hgp	ひょう
hgq	ひゃい
hgu	ひゅ
hgz	ひゃん
hh	ふう
hi	ひ
hj	ふん
hk	ひん
hl	ほん
ho	ほ
hp	ほう
hq	はい
ht	ひと
hu	ふ
hv	ひゅう
hw	へい
hx	ひょう
hya	ひゃ
hyd	ひぇん
hye	ひぇ
hyh	ひゅう
hyj	ひゅん
hyl	ひょん
hyo	ひょ
hyp	ひょう
hyq	ひゃい
hyu	ひゅ
hyz	ひゃん
hz	はん
i	い
ja	じゃ
jd	じぇん
je	じぇ
jf	じゅ
jh	じゅう
ji	じ
jj	じゅん
jk	じん
jl	じょん
jo	じょ
jp	じょう
jq	じゃい
ju	じゅ
jw	じぇい
jz	じゃん
ka	か
kd	けん
ke	け
kf	き
kga	きゃ
kgh	きゅう
kgj	きゅん
kgl	きょん
kgn	きゃん
kgo	きょ
kgp	きょう
kgq	きゃい
kgu	きゅ
kgz	きゃん
kh	くう
ki	き
kj	くん
kk	きん
kl	こん
km	かも
kn	かん
ko	こ
kp	こう
kq	かい
kr	から
kt	こと
ku	く
kv	きゅう
kw	けい
kx	きょう
kya	きゃ
kyh	きゅう
kyj	きゅん
kyl	きょん
kyo	きょ
kyp	きょう
kyq	きゃい
kyu	きゅ
kyz	きゃん
kz	かん
la	ぁ
le	ぇ
li	ぃ
lo	ぉ
ltsu	っ
ltu	っ
lu	ぅ
lwa	ゎ
lya	ゃ
lye	ぇ
lyi	ぃ
lyo	ょ
lyu	ゅ
ma	ま
md	めん
me	め
mf	む
mgn	みゃん
mh	むう
mi	み
mj	むん
mk	みん
ml	もん
mn	もの
mo	も
mp	もう
mq	まい
ms	ます
mt	また
mu	む
mv	みゅう
mw	めい
mx	みょう
mya	みゃ
myh	みゅう
myj	みゅん
myl	みょん
myo	みょ
myp	みょう
myq	みゃい
myu	みゅ
myz	みゃん
mz	まん
na	な
nb	ねば
nd	ねん
ne	ね
nf	ぬ
nga	にゃ
ngh	にゅう
ngj	にゅん
ngl	にょん
ngn	にゃん
ngo	にょ
ngp	にょう
ngq	にゃい
ngu	にゅ
ngz	にゃん
nh	ぬう
ni	に
nj	ぬん
nk	にん
nl	のん
nn	ん
no	の
np	のう
nq	ない
nr	なる
nt	にち
nu	ぬ
nv	にゅう
nw	ねい
nx	にょう
nya	にゃ
nyh	にゅう
nyj	にゅん
nyl	にょん
nyo	にょ
nyp	にょう
nyq	にゃい
nyu	にゅ
nyz	にゃん
nz	なん
o	お
pa	ぱ
pd	ぺん
pe	ぺ
pf	ぽん
pga	ぴゃ
pgh	ぴゅう
pgj	ぴゅん
pgl	ぴょん
pgn	ぴゃん
pgo	ぴょ
pgp	ぴょう
pgq	ぴゃい
pgu	ぴゅ
pgz	ぴゃん
ph	ぷう
pi	ぴ
pj	ぷん
pk	ぴん
pl	ぽん
po	ぽ
pp	ぽう
pq	ぱい
pu	ぷ
pv	ぴゅう
pw	ぺい
px	ぴょう
pya	ぴゃ
pyh	ぴゅう
pyj	ぴゅん
pyl	ぴょん
pyo	ぴょ
pyp	ぴょう
pyq	ぴゃい
pyu	ぴゅ
pz	ぱん
q	ん
ra	ら
rd	れん
re	れ
rh	るう
ri	り
rj	るん
rk	りん
rl	ろん
rn	らん
ro	ろ
rp	ろう
rq	らい
rr	られ
ru	る
rv	りゅう
rw	れい
rx	りょう
rya	りゃ
ryh	りゅう
ryj	りゅん
ryl	りょん
ryo	りょ
ryp	りょう
ryq	りゃい
ryu	りゅ
ryz	りゃん
rz	らん
sa	さ
sd	せん
se	せ
sf	さい
sh	すう
si	し
sj	すん
sk	しん
sl	そん
sn	さん
so	そ
sp	そう
sq	さい
sr	する
ss	せい
st	した
su	す
sv	しゅう
sw	せい
sx	しょう
syi	すぃ
syk	すぃん
sz	さん
ta	た
tb	たび
td	てん
te	て
tgh	とぅー
tgi	てぃ
tgj	とぅん
tgk	てぃん
tgu	とぅ
th	つう
ti	ち
tj	つん
tk	ちん
tl	とん
tm	ため
tn	たん
to	と
tp	とう
tq	たい
tr	たら
tsa	つぁ
tsd	つぇん
tse	つぇ
tsh	つう
tsi	つぃ
tsj	つん
tsk	つぃん
tsl	つぉん
tso	つぉ
tsq	つぁい
tst	として
tsu	つ
tsz	つぁん
tt	たち
tu	つ
tw	てい
tya	てゃ
tyh	てゅー
tyj	てゅん
tyq	てゃい
tyu	てゅ
tyz	てゃん
tz	たん
u	う
va	う゛ぁ
vd	う゛ぇん
ve	う゛ぇ
vh	う゛ー
vi	う゛ぃ
vj	う゛ん
vk	う゛ぃん
vl	う゛ぉん
vn	う゛ぁん
vo	う゛ぉ
vp	う゛ぉう
vq	う゛ぁい
vu	う゛
vv	う゛ゅー
vw	う゛ぇい
vyh	う゛ゅー
vyj	う゛ゅん
vyu	う゛ゅ
vz	う゛ぁん
wa	わ
wd	うぇん
we	うぇ
wi	うぃ
wk	うぃん
wl	うぉん
wn	わん
wo	を
wp	うぉー
wq	わい
wr	われ
wse	ゑ
wsi	ゐ
wso	うぉ
wt	わた
ww	うぇい
wz	わん
xa	しゃ
xd	しぇん
xe	しぇ
xh	しゅう
xi	し
xj	しゅん
xk	しん
xl	しょん
xn	しゃん
xo	しょ
xp	しょう
xq	しゃい
xu	しゅ
xw	しぇい
xz	しゃん
ya	や
yd	いぇん
ye	いぇ
yf	ゆ
yh	ゆう
yj	ゆん
yl	よん
yo	よ
yp	よう
yq	やい
yr	よる
yu	ゆ
yw	いぇい
yz	やん
za	ざ
zc	ざ
zd	ぜん
ze	ぜ
zh	ずう
zi	じ
zj	ずん
zk	じん
zl	ぞん
zn	ざん
zo	ぞ
zp	ぞう
zq	ざい
zr	ざる
zu	ず
zv	ざい
zw	ぜい
zx	ぜい
zyi	ずぃ
zz	ざん
#+end_src

** LilyPond

[[https://lilypond.org/unix.html][LilyPond]] elisp package is included in source tarball available at [[https://lilypond.org/download/source][here]],
you are required to locate that package where emacs can search.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"lilypond"
#+end_src

#+begin_src emacs-lisp :noweb-ref elisp-code
(use-package lilypond-mode
  :delight (LilyPond-mode " LP")
  :mode ("\\.ly$" . LilyPond-mode)
  :custom
  (LilyPond-pdf-command "firefox")
  (LilyPond-midi-command "fluidsynth -a alsa -m alsa_seq -l"))
#+end_src

** Graphviz
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 13:36]
:END:

Documentation is available at [[https://graphviz.org/documentation/][here]] and [[https://graphviz.org/gallery/][gallery]] is also useful.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"graphviz"
"emacs-graphviz-dot-mode"
#+end_src

#+begin_src emacs-lisp :noweb-ref elisp-code
(use-package graphviz-dot-mode
  :after eglot
  :custom
  (graphviz-dot-indent-width 2)
  :config
  (add-to-list 'eglot-server-programs
               '(graphviz-dot-mode "dot-language-server" "--stdio")))
#+end_src

#+begin_src shell :noweb-ref npm-pkg :tangle no
dot-language-server
#+end_src

** Rsync

#+begin_src scheme :noweb-ref guix-base
"rsync"
#+end_src

*** sync server data                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 10:07]
:END:

#+begin_src conf :noweb yes :tangle no
12 1 * * * /bin/bash -ci "sync_sv04 >> $LOG_DIR/sync_sv04.log 2>&1"
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/sync_sv04") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit 0" \
  && rsync -arhv sv04:~/var/backup <<share-dir()>>/sv04
#+end_src

*** backup script                             :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/back_rsync.sh")
#!/usr/bin/env bash

OPT="-aPh"
LINK="--link-dest=../last/"
DEST="ns01:~/data/share/backups"
DATETIME=`date "+%Y%m%d-%H%M"`

ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/data/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

# take a snapshot for pc01
# if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
#   rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
#   ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
# else
#   rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
#   ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
# fi

# take a snapshot for sv04
if mountpoint /mnt/sv04 >/dev/null 2>&1; then
  if ssh ns01 "[ -h ~/data/share/backups/sv04/last ]"; then
    rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
    ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
  else
    rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
    ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
  fi
fi
#+end_src

+ rsync exclude file for pc01
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
  + var
  + var/log
  + var/log/**
  - var/lib/dash
  + var/lib
  + var/lib/**
  + work
  + work/**
  + git
  + git/**
  - *
  #+end_src
+ rsync exclude file for sv04
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
  + var
  + var/backup
  + var/backup/**
  - *
  #+end_src
** libvirt
:PROPERTIES:
:ID:       4736bf4d-4185-4683-818d-700f980bc6ca
:END:

#+begin_src scheme :noweb-ref guix-desktop
"libvirt"
"virt-manager"
#+end_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
qemu-kvm libvirt-clients libvirt-daemon libvirt-daemon-system virtinst virt-manager virt-top bridge-utils
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl enable libvirtd
systemctl start libvirtd
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/libvirt/libvirt.conf")
uri_default = "qemu:///system"
#+end_src

- how to set up local storage pool (named 'local')
  : $ virsh pool-define ~/.config/libvirt/pool.xml
  : $ virsh pool-autostart local
  : $ virsh pool-start local

  #+begin_src xml :noweb tangle :tangle (expand-file-name ".config/libvirt/pool.xml")
  <pool type='dir'>
    <name>local</name>
    <source>
    </source>
    <target>
      <path><<share-dir()>>/libvirt/images</path>
      <permissions>
        <mode>0711</mode>
        <owner>0</owner>
        <group>0</group>
      </permissions>
    </target>
  </pool>
  #+end_src

** Calibre

[[https://calibre-ebook.com/download_linux][Calibre for linux]] is a e-book reader. I use it in the mood of reading epub in GUI app.

#+begin_src scheme :noweb-ref guix-desktop
"calibre"
#+end_src

** yt-dlp
:PROPERTIES:
:CREATED:  [2022-08-19 Fri 08:06]
:END:

#+begin_src scheme :noweb-ref guix-base
"yt-dlp"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/yt-dlp/config")
-o %(title)s.%(ext)s
--trim-filenames 72
#+end_src

** rTorrent
:PROPERTIES:
:CREATED:  [2022-10-05 Wed 15:26]
:ID:       bdc987ad-419b-4f36-922d-de75207d85c0
:END:

[[https://github.com/rakshasa/rtorrent/wiki][rTorrent]] is a bittorrent client using ncurses.

#+begin_src scheme :noweb-ref guix-base
"rtorrent-xmlrpc"
#+End_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
rtorrent
#+end_src

#+name: rtorrent-sock
#+begin_src emacs-lisp :eval no-export
(expand-file-name "~/.local/share/rtorrent-rpc.socket")
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".rtorrent.rc")
network.scgi.open_local = <<rtorrent-sock()>>
execute.nothrow = chmod,770,<<rtorrent-sock()>>
encoding.add = utf8
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl --user enable rtorrent.service
systemctl --user start rtorrent.service
#+end_src

#+name: torrent-dir
#+begin_src shell :noweb yes :eval no-export
realpath "<<share-dir()>>/torrent"
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/user/rtorrent.service")
[Unit]
Description=rTorrent
After=network.target

[Service]
Type=simple
WorkingDirectory=<<torrent-dir()>>
ExecStart=<<which(filename="rtorrent")>> -o system.daemon.set=true
Restart=on-failure
RestartSec=3

[Install]
WantedBy=default.target
#+end_src

** Ledger
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 20:55]
:END:

[[https://www.ledger-cli.org/3.0/doc/ledger-mode.html][Ledger]] is double-entry accounting cli tool. [[https://hledger.org/][hledger]] is feature rich reimplementation of ledger in Haskell. User data in ledger is interoperable for hledger and vice versa.

#+begin_src scheme :noweb-ref guix-base
"ledger"
;; "hledger"
#+end_src

** ripgrep-all
:PROPERTIES:
:CREATED:  [2022-10-26 Wed 10:39]
:END:

[[https://github.com/phiresky/ripgrep-all][ripgrep-all]] or rga command enables to search media files such as pdf documents or epub files in grep-like way.

#+begin_src shell :noweb yes :noweb-ref ubuntu-setup :tangle no
rga_url=https://github.com/phiresky/ripgrep-all/releases/download/v0.9.6
rga_fname=ripgrep_all-v0.9.6-x86_64-unknown-linux-musl.tar.gz
rga_workdir=/tmp
rga_lbinpath=<<home-dir()>>/.local/bin

curl -sL "${rga_url}/${rga_fname}" | tar zxf - -C ${rga_workdir} \
  && cp -fv ${rga_workdir}/${rga_fname%.tar.gz}/{rga,rga-preproc} ${rga_lbinpath}
#+end_src

** Recoll
:PROPERTIES:
:CREATED:  [2023-02-11 Sat 22:11]
:END:

#+begin_src scheme :noweb-ref guix-base
"recoll"
#+end_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
recollcmd
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".recoll/recoll.conf")
topdirs = <<doc-dir()>> ~/data

[<<doc-dir()>>]
followLinks = 1

skippedNames = .git

skippedPaths = <<share-dir()>>/emacs/open-file <<share-dir()>>/emacs/org-subtree-view

indexstemminglanguages = english
#+end_src

*** systemd setting
:PROPERTIES:
:CREATED:  [2023-02-15 Wed 19:41]
:END:

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl --user enable recollindex.service
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/user/recollindex.service")
# Contributed by Frank Dana, licensed as Recoll itself
[Unit]
Description=Recoll real-time document indexing
After=gnome-session-manager.target

[Service]
Type=simple
ExecStart=<<which(filename="recollindex")>> -m -D -x -w 30 -c %h/.recoll/
Restart=on-failure

[Install]
WantedBy=graphical-session.target
#+end_src

** Enchant
:PROPERTIES:
:CREATED:  [2023-12-07 Thu 15:53]
:END:

[[https://abiword.github.io/enchant/src/enchant.html][ENCHANT]] offers efficient spell checking mechanism by using checker in order.

#+begin_src scheme :noweb-ref guix-base
"enchant"
"hunspell"
"hunspell-dict-en"
"hunspell-dict-en-us"
"nuspell"
"aspell"
"aspell-dict-en"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
export ENCHANT_CONFIG_DIR=<<home-dir()>>/.config/enchant
#+end_src

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name ".config/enchant/enchant.ordering")
,*:hunspell,nuspell,aspell
en:hunspell,nuspell,aspell
en_US:hunspell,nuspell,aspell
#+end_src

#+begin_src text :comments no :noweb tangle :tangle (expand-file-name ".config/enchant/en_US.dic")
TempEL
#+end_src

** Modern alternative command line tools
:PROPERTIES:
:CREATED:  [2023-12-17 Sun 13:56]
:END:

They are mostly written in Rust. [[https://github.com/mhoye/moderntools/][moderntools]] offers updated info for this category.

#+begin_src scheme :noweb-ref guix-base
"bat"
"du-dust"
"exa"
"fd"
"zoxide"
"just"
"tmux"
"moreutils"
#+end_src

* Development Infrastructures
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:55]
:END:

** Python

#+begin_src scheme :noweb-ref guix-base
"python"
"python-pip"
"python-sphinx"
"python-lxml"
"python-lsp-server"
"python-jedi"
"python-send2trash"
"python-matplotlib"
#+end_src

** Ruby

#+begin_src scheme :noweb-ref guix-base
"ruby"
"ruby-pry"
"ruby-rubocop"
"ruby-thor"
#+end_src

#+begin_src shell :noweb-ref bashrc
export RUBYLIB=${HOME}/.local/lib

# set path for ruby gems in local
if which ruby >/dev/null && which gem >/dev/null; then
  PATH="$(ruby -r rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
#+end_src

** Rust
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 18:53]
:END:

#+begin_src scheme :noweb-ref guix-base
"rust"
#+end_src

** Common Lisp
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 13:11]
:END:

#+begin_src scheme :noweb-ref guix-base
"sbcl"
"sbcl-slynk"
#+end_src

** Node.js
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 13:52]
:END:

#+name: npm-prefix
#+begin_src shell :eval no-export
echo ${HOME}/.npm-global
#+end_src

#+begin_src scheme :noweb-ref guix-base
"node"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
NODE_PATH="<<npm-prefix()>>/lib/node_modules:${NODE_PATH}"
PATH="<<npm-prefix()>>/bin:${PATH}"
MANPATH="<<npm-prefix()>>/share/man:${MANPATH}"
#+end_src

#+begin_src shell :noweb yes :tangle (expand-file-name ".npmrc")
prefix=<<npm-prefix()>>
#+end_src

- make a directory for global npm packages
  #+begin_src shell :tangle no :noweb yes
  mkdir -pv <<npm-prefix()>>
  #+end_src
- install npm packages
  #+begin_src shell :noweb tangle :tangle (expand-file-name "npm-install" tangle/local-bin-dir)
  npm install -g <<npm-pkg>>
  #+end_src

** asdf-vm                                     :ARCHIVE:
Extendable version manager
- call for init script in bashrc
  #+begin_src shell
  . $HOME/.asdf/asdf.sh
  . $HOME/.asdf/completions/asdf.bash

  export RUBYLIB=${RUBYLIB}:${HOME}/.local/lib
  #+end_src
- define versions
  #+begin_src conf :comments noweb :tangle (expand-file-name ".tool-versions")
  ruby 2.6.8
  python 3.8.5
  #+end_src

  steps to install tools for specific versions
  1. install plugins
     : $ asdf plugin add ruby
     : $ asdf plugin add python

  2. install tools
     : $ cd ~ && asdf install

*** asdf-ruby
#+begin_src conf :comments noweb :tangle (expand-file-name ".default-gems")
thor 1.2.1
pry 0.14.1
rubocop 1.26
exifr 1.2.6
streamio-ffmpeg
#+end_src
*** asdf-python
#+begin_src python :tangle (expand-file-name ".default-python-packages")
lxml
jedi
ical2orgpy
Send2Trash
#+end_src
** Language Servers

*** Bash Language Server
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:49]
:END:

[[https://github.com/bash-lsp/bash-language-server][Bash Language Server]]

#+begin_src shell :noweb-ref npm-pkg :tangle no
bash-language-server
#+end_src

*** Solargraph
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:16]
:END:

[[https://github.com/castwide/solargraph][Solargraph]] is Ruby Language Server.

#+begin_src scheme :noweb-ref guix-base
"ruby-solargraph"
#+end_src

* Stuffs for Dedicated Tasks

** Batch Processing
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 20:29]
:END:

*** Midnight Batch
:PROPERTIES:
:CREATED:  [2023-10-31 Tue 14:03]
:END:

- when to dispatch midnight batch
  #+name: midnight-hour
  #+begin_src text
  4
  #+end_src

- midnight.sh: midnight batch script
  #+begin_src bash :noweb tangle :tangle (expand-file-name "midnight.sh" tangle/local-bin-dir)
  <<midnight-batch>>
  #+end_src

*** Weekend Batch
:PROPERTIES:
:CREATED:  [2023-10-31 Tue 14:03]
:END:

#+begin_src bash :noweb tangle :tangle (expand-file-name "weekend.sh" tangle/local-bin-dir)
<<weekend-batch>>
#+end_src

*** System Batch
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 17:17]
:END:

#+begin_src shell :noweb tangle :tangle (expand-file-name "system.sh" tangle/local-bin-dir)
<<system-batch>>
#+end_src

** Transcode Video Files
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 14:44]
:END:

Transcoding my local video files with open codec, like VP9 and AV1, is effective for disc space usage.

#+begin_src shell :noweb-ref transc-shared
#!/usr/bin/env bash
set -euo pipefail

CRF=28
KBITRATE_AUDIO=128

function usage() {
  cat <<_EOT_
Usage:
  $(basename $0) [OPTIONS] <video_in> [<video_out>]

Description:
  $(basename $0) encodes <video_in> to <video_out> in specified codec.

Options:
  -c <CRF>      CRF value instead of ${CRF} (DEFAULT)
  -B <AUDIO_BR> Audio Bitrate in kbps

_EOT_
}

if [ "${OPTIND}" = 1 ]; then
  while getopts c:B:h OPT
  do
    case ${OPT} in
    c)
      CRF=${OPTARG}
      ;;
    B)
      CRF=${OPTARG}
      ;;
    h)
      usage
      ;;
    \?)
      echo "Try to enter the h option." 1>&2
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi

shift $((OPTIND - 1))

if [ $# -lt 1 ] || [ $# -gt 2 ]; then
  usage
  exit -1
fi

INPUT_VIDEO=$1
if [ ! -e "${INPUT_VIDEO}" ]; then
  echo "${INPUT_VIDEO} does not exist." 1>&2
  exit -1
fi

if [[ $# -eq 2 ]]; then
  output_cand=$2
else
  output_cand=$(basename "${INPUT_VIDEO}").webm
fi
if [ -e "${output_cand}" ]; then
  OUTPUT_VIDEO=${output_cand%.*}_$(date +%Y%m%d_%H%M).webm
else
  OUTPUT_VIDEO="${output_cand}"
fi

WORK_DIR="${INPUT_VIDEO%.*}"
#+end_src

*** vp9 transcoding

- transcode video to vp9
  : $ vp9transc -c 32 video_orig.mkv video_vp9.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name "vp9transc" tangle/local-bin-dir) :comments no
<<transc-shared>>

vp9_opts_pass1="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 1 -an -f null"
vp9_opts_pass2="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 2 -map_metadata 0"
opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
  && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass1} /dev/null \
  && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src
*** av1 transcoding

- transcode video to av1
  : $ av1transc video_orig.mkv video_av1.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name "av1transc" tangle/local-bin-dir) :comments no
<<transc-shared>>

av1_opts_common="-c:v libaom-av1 -cpu-used 2 -row-mt 1 -threads $(nproc) -b:v 0 -crf ${CRF}"
av1_opts_pass1="${av1_opts_common} -pass 1 -an -f null"
av1_opts_pass2="${av1_opts_common} -pass 2 -map_metadata 0"
opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
  && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass1} /dev/null \
  && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src

** Transcode Audio Files                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-13 Mon 18:05]
:END:

- usage
  + encode bulk podcast files for 64kb/s (in Dired)
    : $ nohup parallel opusencode "{}" "{.}".oga ::: *

#+begin_src bash :tangle (expand-file-name "opusencode" tangle/local-bin-dir)
set -euo pipefail

if [[ $# -ge 1 ]]; then
  INPUT_VIDEO=$1
  if [[ $# -eq 2 ]]; then
    OUTPUT_VIDEO=$2
  else
    OUTPUT_VIDEO=$(basename "${INPUT_VIDEO}").oga
  fi
fi

opus_opts="-c:a libopus -b:a 64k -ac 2"

ffmpeg -i "${INPUT_VIDEO}" ${opus_opts} "${OUTPUT_VIDEO}"
#+end_src

** DVD Packing

#+begin_src scheme :noweb-ref guix-desktop
"handbrake"
"dvdbackup"
"libdvdnav"
"libdvdcss"
#+end_src

#+begin_src bash :tangle (expand-file-name "dvdpack" tangle/local-bin-dir)
set -euo pipefail

if [ "${OPTIND}" = 1 ]; then
  while getopts t: OPT
  do
    case ${OPT} in
    t)
      TITLE=${OPTARG}
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi
shift $((OPTIND - 1))

if [[ $# -ge 1 ]]; then
  DVD_DIR=$1
  if [[ $# -eq 2 ]]; then
    DVD_PACK_VIDEO=$2
  else
    DVD_PACK_VIDEO=$(basename "${DVD_DIR}").mkv
  fi
fi

if [ -v TITLE ]; then
  title_opt="--title ${TITLE}"
else
  title_opt='--main-feature'
fi

hb_opts="--x264-preset veryslow --quality 18 --aencoder copy ${title_opt} --markers --all-audio --all-subtitles"

HandBrakeCLI --input "${DVD_DIR}" --output "${DVD_PACK_VIDEO}" ${hb_opts}
#+end_src
** CD Ripping

#+begin_src scheme :noweb-ref guix-desktop
"abcde"
"eyed3"
"lame"
"opus-tools"
"cdrtools"
"easytag"
#+end_src

*** abcde

#+BEGIN_SRC conf :tangle (expand-file-name ".abcde.conf")
# .flac is only desired output format
OUTPUTTYPE="flac"
# or .flac and .opus (bitrate is 256 kbps) will be generated at the same time
# OUTPUTTYPE="flac,opus"
# OPUSENCOPTS='--bitrate 256'

# .flac files will be utterly compressed with verification
FLACOPTS="-V8"

MAXPROCS=4

OUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${TRACKNUM}.${TRACKFILE}'
#+END_SRC

** Tutorial Video Creation
:PROPERTIES:
:CREATED:  [2022-08-15 Mon 20:13]
:END:

#+begin_src scheme :noweb-ref guix-desktop
"slop"
"gimp"
"obs"
"kdenlive"
"audacity"
#+end_src

*** Screenkey
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 16:43]
:END:

#+begin_src scheme :noweb-ref guix-desktop
"python-screenkey"
#+end_src

#+begin_src json :tangle no :tangle (expand-file-name ".config/screenkey.json")  :tangle-mode (identity #o644) :comments no
{
  "timeout": 0.8,
  "key_mode": "composed",
  "bak_mode": "normal",
  "mods_mode": "emacs",
  "opacity": 0.3,
  "screen": 0
}
#+end_src

** Sync Git Repos Automatically
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 16:43]
:END:

#+begin_src conf :noweb yes :noweb-ref cronjob-user
0 */2 * * * <<which(filename="bash")>> -ci "ghq-sync >> $LOG_DIR/ghq-sync.log 2>&1"
#+end_src

#+name: ghq-sync
#+begin_src bash :tangle (expand-file-name "ghq-sync" tangle/local-bin-dir)
function git-one-go {
  local _branch=$(git symbolic-ref -q HEAD | sed 's/refs\/heads\///')
  local _remote=$(git config --get branch.$_branch.pushRemote)
  local _commit_msg="auto-commit by $(whoami) on $(uname -n) at $(date +"%H:%M %b %d")"
  # local _autocommit_cmd="git add -u ; git commit -m \"${_commit_msg}\";"
  if [[ "true" = "$(git config --get --bool branch.$_branch.sync)" ]] ; then
    git add -u ; git commit -m "${_commit_msg}";
    if [ $? != 0 ]; then
      echo "ghq-sync: git commit returned non-zero." >&2
      exit 1
    fi

    git push $_remote $_branch
    if [ $? != 0 ]; then
      echo "ghq-sync: git push returned non-zero. Likely a connection failure." >&2
      exit 1
    fi
  fi
}

ghq_repos=$(ghq list --full-path github.com/p-snow)
for repo_path in ${ghq_repos[@]}; do
  (cd ${repo_path} && git-one-go)
done
#+end_src

*** git-sync                                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 15:14]
:END:

[[https://github.com/simonthum/git-sync][git-sync]] enables to sync (stage, commit and pull/push) git repositories. I use it for my org-file repo in daily basis.

# #+begin_src gitconfig :noweb-ref git-config
#   [branch "main"]
#           syncCommitMsg = "on $(LC_TIME=en_GB.UTF-8 date) from $(uname -n)"
# #+end_src

#+header: :shebang "#!/usr/bin/env bash"
#+begin_src bash :noweb tangle :tangle (expand-file-name "git-sync" tangle/local-bin-dir)
#
# git-sync
#
# synchronize tracking repositories
#
# 2012-20 by Simon Thum and contributors
# Licensed as: CC0
#
# This script intends to sync via git near-automatically
# in "tracking" repositories where a nice history is not
# crucial, but having one at all is.
#
# Unlike the myriad of scripts to do just that already available,
# it follows the KISS principle: It is small, requires nothing but
# git and bash, but does not even try to shield you from git.
#
# Mode sync (default)
#
# Sync will likely get from you from a dull normal git repo with trivial
# changes to an updated dull normal git repo equal to origin. No more,
# no less. The intent is to do everything that's needed to sync
# automatically, and resort to manual intervention as soon
# as something non-trivial occurs. It is designed to be safe
# in that it will likely refuse to do anything not known to
# be safe.
#
# Mode check
#
# Check only performs the basic checks to make sure the repository
# is in an orderly state to continue syncing, i.e. committing
# changes, pull etc. without losing any data. When check returns
# 0, sync can start immediately. This does not, however, indicate
# that syncing is at all likely to succeed.

# command used to auto-commit file modifications
DEFAULT_AUTOCOMMIT_CMD="git add -u ; git commit -m \"%message\";"

# command used to auto-commit all changes
ALL_AUTOCOMMIT_CMD="git add -A ; git commit -m \"%message\";"

# default commit message substituted into autocommit commands
DEFAULT_AUTOCOMMIT_MSG="changes from $(uname -n) on $(date)"


# AUTOCOMMIT_CMD="echo \"Please commit or stash pending changes\"; exit 1;"
# TODO mode for stash push & pop

print_usage() {
  cat << EOF
usage: $0 [-h] [-n] [-s] [MODE]

Synchronize the current branch to a remote backup
MODE may be either "sync" (the default) or "check", to verify that the branch is ready to sync

OPTIONS:
   -h      Show this message
   -n      Commit new files even if branch.\$branch_name.syncNewFiles isn't set
   -s      Sync the branch even if branch.\$branch_name.sync isn't set
EOF
}
sync_new_files_anyway="false"
sync_anyway="false"

while getopts "hns" opt ; do
  case $opt in
  h )
    print_usage
    exit 0
    ;;
  n )
    sync_new_files_anyway="true"
    ;;
  s )
    sync_anyway="true"
    ;;
  esac
done
shift $((OPTIND-1))

#
#    utility functions, some adapted from git bash completion
#

__log_msg()
{
  echo git-sync: $1
}

# echo the git dir
__gitdir()
{
  if [ "true" = "$(git rev-parse --is-inside-work-tree "$PWD" | head -1)" ]; then
    git rev-parse --git-dir "$PWD" 2>/dev/null
  fi
}

# echos repo state
git_repo_state ()
{
  local g="$(__gitdir)"
  if [ -n "$g" ]; then
    if [ -f "$g/rebase-merge/interactive" ]; then
      echo "REBASE-i"
    elif [ -d "$g/rebase-merge" ]; then
      echo "REBASE-m"
    else
      if [ -d "$g/rebase-apply" ]; then
        echo "AM/REBASE"
      elif [ -f "$g/MERGE_HEAD" ]; then
        echo "MERGING"
      elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
        echo "CHERRY-PICKING"
      elif [ -f "$g/BISECT_LOG" ]; then
        echo "BISECTING"
      fi
    fi
    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        echo "|BARE"
      else
        echo "|GIT_DIR"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      git diff --no-ext-diff --quiet --exit-code || echo "|DIRTY"
      #			if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
      #			        git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      #			fi
      #
      #			if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
      #			   if [ -n "$(git ls-files --others --exclude-standard)" ]; then
      #			      u="%"
      #			   fi
      #			fi
      #
      #			if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #				__git_ps1_show_upstream
      #			fi
    fi
  else
    echo "NOGIT"
  fi
}

# check if we only have untouched, modified or (if configured) new files
check_initial_file_state()
{
  local syncNew="$(git config --get --bool branch.$branch_name.syncNewFiles)"
  if [[ "true" == "$syncNew" || "true" == "$sync_new_files_anyway" ]]; then
    # allow for new files
    if [ ! -z "$(git status --porcelain | grep -E '^[^ \?][^M\?] *')" ]; then
      echo "NonNewOrModified"
    fi
  else
    # also bail on new files
    if [ ! -z "$(git status --porcelain | grep -E '^[^ ][^M] *')" ]; then
      echo "NotOnlyModified"
    fi
  fi
}

# look for local changes
# used to decide if autocommit should be invoked
local_changes()
{
  if [ ! -z "$(git status --porcelain | grep -E '^(\?\?|[MARC] |[ MARC][MD])*')" ]; then
    echo "LocalChanges"
  fi
}

# determine sync state of repository, i.e. how the remote relates to our HEAD
sync_state()
{
  local count="$(git rev-list --count --left-right $remote_name/$branch_name...HEAD)"

  case "$count" in
  "") # no upstream
    echo "noUpstream"
    false
    ;;
  "0	0")
    echo "equal"
    true
    ;;
  "0	"*)
    echo "ahead"
    true
    ;;
  ,*"	0")
    echo "behind"
    true
    ;;
  ,*)
    echo "diverged"
    true
    ;;
  esac
}

# exit, issue warning if not in sync
exit_assuming_sync() {
  if [ "equal" == "$(sync_state)" ] ; then
    __log_msg "In sync, all fine."
    exit 0;
  else
    __log_msg "Synchronization FAILED! You should definitely check your repository carefully!"
    __log_msg "(Possibly a transient network problem? Please try again in that case.)"
    exit 3
  fi
}

#
#        Here git-sync actually starts
#

# first some sanity checks
rstate="$(git_repo_state)"
if [[ -z "$rstate" || "|DIRTY" = "$rstate" ]]; then
  __log_msg "Preparing. Repo in $(__gitdir)"
elif [[ "NOGIT" = "$rstate" ]] ; then
  __log_msg "No git repository detected. Exiting."
  exit 128 # matches git's error code
else
  __log_msg "Git repo state considered unsafe for sync: $(git_repo_state)"
  exit 2
fi

# determine the current branch (thanks to stackoverflow)
branch_name=$(git symbolic-ref -q HEAD)
branch_name=${branch_name##refs/heads/}

if [ -z "$branch_name" ] ; then
  __log_msg "Syncing is only possible on a branch."
  git status
  exit 2
fi

# while at it, determine the remote to operate on
remote_name=$(git config --get branch.$branch_name.pushRemote)
if [ -z "$remote_name" ] ; then
  remote_name=$(git config --get remote.pushDefault)
fi
if [ -z "$remote_name" ] ; then
  remote_name=$(git config --get branch.$branch_name.remote)
fi

if [ -z "$remote_name" ] ; then
  __log_msg "the current branch does not have a configured remote."
  echo
  __log_msg "Please use"
  echo
  __log_msg "  git branch --set-upstream-to=[remote_name]/$branch_name"
  echo
  __log_msg "replacing [remote_name] with the name of your remote, i.e. - origin"
  __log_msg "to set the remote tracking branch for git-sync to work"
  exit 2
fi

# check if current branch is configured for sync
if [[ "true" != "$(git config --get --bool branch.$branch_name.sync)" && "true" != "$sync_anyway" ]] ; then
  echo
  __log_msg "Please use"
  echo
  __log_msg "  git config --bool branch.$branch_name.sync true"
  echo
  __log_msg "to enlist branch $branch_name for synchronization."
  __log_msg "Branch $branch_name has to have a same-named remote branch"
  __log_msg "for git-sync to work."
  echo
  __log_msg "(If you don't know what this means, you should change that"
  __log_msg "before relying on this script. You have been warned.)"
  echo
  exit 1
fi

# determine mode
if [[ -z "$1" || "$1" == "sync" ]]; then
  mode="sync"
elif [[ "check" == "$1" ]]; then
  mode="check"
else
  __log_msg "Mode $1 not recognized"
  exit 100
fi

__log_msg "Mode $mode"

__log_msg "Using $remote_name/$branch_name"

# check for intentionally unhandled file states
if [ ! -z "$(check_initial_file_state)" ] ; then
  __log_msg "There are changed files you should probably handle manually."
  git status
  exit 1
fi

# if in check mode, this is all we need to know
if [ $mode == "check" ] ; then
  __log_msg "check OK; sync may start."
  exit 0
fi

# check if we have to commit local changes, if yes, do so
if [ ! -z "$(local_changes)" ]; then
  autocommit_cmd=""
  config_autocommit_cmd="$(git config --get branch.$branch_name.autocommitscript)"

  # discern the three ways to auto-commit
  if [ ! -z "$config_autocommit_cmd" ]; then
    autocommit_cmd="$config_autocommit_cmd"
  elif [[ "true" == "$(git config --get --bool branch.$branch_name.syncNewFiles)" || "true" == "$sync_new_files_anyway" ]]; then
    autocommit_cmd=${ALL_AUTOCOMMIT_CMD}
  else
    autocommit_cmd=${DEFAULT_AUTOCOMMIT_CMD}
  fi

  commit_msg="$(git config --get branch.$branch_name.syncCommitMsg)"
  if [ "" == "$commit_msg" ]; then
    commit_msg=${DEFAULT_AUTOCOMMIT_MSG}
  fi
  autocommit_cmd=$(echo "$autocommit_cmd" | sed "s/%message/$commit_msg/")

  __log_msg "Committing local changes using ${autocommit_cmd}"
  eval $autocommit_cmd

  # after autocommit, we should be clean
  rstate="$(git_repo_state)"
  if [[ ! -z "$rstate" ]]; then
    __log_msg "Auto-commit left uncommitted changes. Please add or remove them as desired and retry."
    exit 1
  fi
fi

# fetch remote to get to the current sync state
# TODO make fetching/pushing optional
__log_msg "Fetching from $remote_name/$branch_name"
git fetch $remote_name $branch_name
if [ $? != 0 ] ; then
  __log_msg "git fetch $remote_name returned non-zero. Likely a network problem; exiting."
  exit 3
fi

case "$(sync_state)" in
"noUpstream")
  __log_msg "Strange state, you're on your own. Good luck."
  exit 2
  ;;
"equal")
  exit_assuming_sync
  ;;
"ahead")
  __log_msg "Pushing changes..."
  git push $remote_name $branch_name:$branch_name
  if [ $? == 0 ]; then
    exit_assuming_sync
  else
    __log_msg "git push returned non-zero. Likely a connection failure."
    exit 3
  fi
  ;;
"behind")
  __log_msg "We are behind, fast-forwarding..."
  git merge --ff --ff-only $remote_name/$branch_name
  if [ $? == 0 ]; then
    exit_assuming_sync
  else
    __log_msg "git merge --ff --ff-only returned non-zero ($?). Exiting."
    exit 2
  fi
  ;;
"diverged")
  __log_msg "We have diverged. Trying to rebase..."
  git rebase $remote_name/$branch_name
  if [[ $? == 0 && -z "$(git_repo_state)" && "ahead" == "$(sync_state)" ]] ; then
    __log_msg "Rebasing went fine, pushing..."
    git push $remote_name $branch_name:$branch_name
    exit_assuming_sync
  else
    __log_msg "Rebasing failed, likely there are conflicting changes. Resolve them and finish the rebase before repeating git-sync."
    exit 1
  fi
  # TODO: save master, if rebasing fails, make a branch of old master
  ;;
esac
#+end_src
* Babel Utility Functions
:PROPERTIES:
:header-args+: :tangle-mode (identity #o755)
:END:
** which path

return absolute path for file using which command

#+name: which
#+begin_src bash :var filename=""
which ${filename}
#+end_src

** hash to number
:PROPERTIES:
:CREATED:  [2023-10-15 Sun 18:41]
:END:

return a number between 0 and max by hashing given string

#+name: hash-to-num
#+header: :var s="str" max_n=10
#+begin_src python
import hashlib

sha256 = hashlib.sha256(s.encode("utf-8"))
return int(sha256.hexdigest(), 16) % (max_n + 1)
#+end_src

** random number

return random number between 0 and max

#+name: random
#+header: :var max=10
#+begin_src emacs-lisp
(calc-eval (format "random(%d)" (1+ max)))
#+end_src

* Specialized Scripts
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 20:22]
:END:

** Declutters                                  :ARCHIVE:

These scripts (declutter_xxx) keep things decluttered.

- trash
  #+begin_src conf
  0 2 * * * /bin/bash -ci "declutter_trash >> $LOG_DIR/declutter_trash.log 2>&1"
  #+end_src

  #+begin_src python :noweb yes :tangle no
  #!/usr/bin/env python3

  import os
  import time
  import datetime
  import shutil
  import glob
  from send2trash import send2trash

  TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
  TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                     list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                     + glob.glob(os.path.join(os.environ['HOME'], 'tmp/*')))

  MAX_STAY_DAYS_IN_TRASH = 7
  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

  suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
  def humansize(nbytes):
      i = 0
      while nbytes >= 1024 and i < len(suffixes)-1:
          nbytes /= 1024.
          i += 1
          f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
      return '%s %s' % (f, suffixes[i])

  def get_size(start_path = '.'):
      total_size = 0
      for dirpath, dirnames, filenames in os.walk(start_path):
          for f in filenames:
              fp = os.path.join(dirpath, f)
              # skip if it is symbolic link
              if not os.path.islink(fp):
                  total_size += os.path.getsize(fp)

      return total_size

  print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))

  NOW = time.time()

  print('--{0} starts to move files neglected more than {1} days to trash box.\n'
        .format(os.path.basename(__file__),
                MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

  tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
  for a_file in [item for sublist in tidyup_lists for item in sublist]:
      atime = os.lstat(a_file).st_atime
      delta_atime = datetime.timedelta(seconds=(NOW - atime))
      if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
          try:
              send2trash(a_file)
          except OSError as error:
              print(error)
          else:
              print('moveed to trash: {}'.format(a_file))

  print('--{0} starts to remove files staying more than {1} days in trash box.'
        .format(os.path.basename(__file__),
                MAX_STAY_DAYS_IN_TRASH))

  rbytes_total = 0
  for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
      lstat = os.lstat(trash_file)
      delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
      if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
          method = 'removed'
          fname = os.path.basename(trash_file)
          if os.path.islink(trash_file):
              method = 'unlinked'
              fsize = 'N/A'
              os.unlink(trash_file)
          elif os.path.isfile(trash_file):
              rbytes = os.path.getsize(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              os.remove(trash_file)
          elif os.path.isdir(trash_file):
              rbytes = get_size(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              fname += '/'
              shutil.rmtree(trash_file)
              print('{}: [{:>9}] {}'.format(method, fsize, fname))

  print('--{0} removes [{1}] in total.\n'
        .format(os.path.basename(__file__),
                humansize(rbytes_total)))

  print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                   datetime.datetime.now()))
  #+end_src
- home directory (ruby implementation)
  #+begin_src ruby :tangle no
  #!/usr/bin/env ruby
  # coding: utf-8

  TRASHES = ["*~", "#*#", ".#*#", "._*", ".DS_Store"]

  class Sweep
    def self.sweep(base_dir)
      puts base_dir
      TRASHES.each do |trash|
        tfiles = File.join("%s/**" % base_dir, trash)
        Dir.glob(tfiles).each do |f|
          if File.delete(f) > 0
            puts "Removed: " + f
          else
            puts "CANNOT Removed: " + f
          end
        end
      end
    end
  end

  ARGV.each do |arg|
    if Dir.exist?(arg) then
      Sweep.sweep(arg)
    end
  end
  #+end_src
- home directory (python implementation)
  #+begin_src python :tangle no
  #!/usr/bin/env python3

  import sys
  import os
  import glob
  import argparse

  TRASH_REGEXPS = ["*~", "#*", ".#*", "._*", ".DS_Store", "*.dvi", "*.aux", "*.bbl"]

  class Sweepy:
      @classmethod
      def sweep_with_regexp(self, base_dir, recursive=False):
          for trash_regexp in TRASH_REGEXPS:
              files = glob.glob("%s/**/" % base_dir + trash_regexp, recursive=recursive)
              for file in files:
                  if os.path.isfile(file):
                      os.remove(file)
                      print("Removed: " + file)
                      @classmethod
      def sweep_broken_symlink(self, base_dir, recursive=False):
          files = glob.glob("%s/*" % base_dir, recursive=recursive)
          dotfiles = glob.glob("%s/.*" % base_dir, recursive=recursive)
          for file in (files + dotfiles):
              if os.path.islink(file):
                  if not os.path.exists(os.readlink(file)):
                      os.unlink(file)
                      print("Unlinked: " + file)

  parser = argparse.ArgumentParser(description='Removes all desired files')
  parser.add_argument('dir', metavar='dir', nargs='?', action='store',
                      help='base directory to search')
  parser.add_argument('-r', dest='recursive', action="store_true", default=False)
  args = parser.parse_args()
  if args.recursive:
      Sweepy.sweep_with_regexp(args.dir, recursive=True)
      Sweepy.sweep_broken_symlink(args.dir, recursive=True)
  else:
      Sweepy.sweep_with_regexp(args.dir, recursive=False)
      Sweepy.sweep_broken_symlink(args.dir, recursive=False)
  #+end_src

** Database back-up scripts
- PostgreSQL
  #+begin_src bash :tangle (expand-file-name ".local/bin/postgres_backup")
  #!/usr/bin/env bash

  # Usage: $ postgres_backup <db_name> <backup_dir>

  POSTGRES_DBNAME=$1
  BACKUP_DIR=$2
  DATE="$(date +%Y%m%d_%H%M)"

  pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

  exit 0
  #+end_src

- MySQL
  #+begin_src shell :tangle (expand-file-name ".local/bin/mysql_backup") :shebang #!/usr/bin/env bash
  BACKUP_DIR=~/data/share/backups/mysql
  RAW_SQL="$(date +%Y%m%d_%H%M)_backup.sql"
  TAR_SQL="${RAW_SQL}.txz"

  (
    cd "${BACKUP_DIR}" || exit 1
    mysqldump --opt --all-databases --events --default-character-set=binary -u root > "${RAW_SQL}"
    tar cfJ "${TAR_SQL}" "${RAW_SQL}"
    rm -f "${RAW_SQL}"
  ) || exit 1

  exit 0
  #+end_src

** filetype

This program determine type of the file.

#+begin_src ruby :tangle (expand-file-name ".local/lib/filetype.rb")
#!/usr/bin/env ruby

require 'pathname'
require 'uri'
require 'shellwords'

class FileType
  ZIP_PREFIXES = ['Zip archive data']

  def self.type(filename, file_cmd_opt = "")
    if  File.exist?(filename)
      local_opt = ""
      if File.symlink?(filename)
        local_opt += "--dereference"
      end
      `file --brief #{file_cmd_opt} #{local_opt} #{Shellwords.shellescape(filename)}`.strip
    elsif filename =~ /https?:\/\/www\.youtube\.com.*/
      `yt-dlp -f worst -q #{Shellwords.shellescape(filename)} -o - 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
    elsif filename =~ URI::DEFAULT_PARSER.make_regexp
      `curl --location --range 0-9999 #{Shellwords.shellescape(filename)} 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
    else
      ''
    end
  end

  def self.mime_type(filename)
    type(filename, "--mime-type")
  end

  def self.block_device?(file)
    type(file).start_with?('block special') &&
      mime_type(file) == 'inode/blockdevice'
  end

  def self.iso9660?(file)
    mime_type(file) == 'application/x-iso9660-image'
  end

  def self.video_dvd_image?(file)
    iso9660?(file) && type(file).start_with?('UDF filesystem data')
  end

  def self.html?(file)
    type(file).start_with?("HTML document")
  end

  def self.pdf?(file)
    type(file).start_with?("PDF document")
  end

  def self.epub?(file)
    type(file) == "EPUB document"
  end

  def self.mobi?(file)
    type(file).start_with?("Mobipocket E-book")
  end

  def self.pgp?(file)
    type(file).start_with?("PGP")
  end

  def self.tarpgp?(file)
    pgp?(file) && file.end_with?('.tar.gpg')
  end

  def self.zip?(file)
    type(file).start_with?(*ZIP_PREFIXES)
  end

  def self.video?(file)
    mime_type(file).start_with?("video/")
  end

  def self.audio?(file)
    mime_type(file).start_with?('audio/')
  end

  def self.image?(file)
    mime_type(file).start_with?("image/")
  end

  def self.playable?(file)
    if File.directory?(file)
      Dir.foreach(file) do |fname|
        next if [".", ".."].include?(fname)
        return false unless playable?("#{file}/#{fname}")
      end
      true
    elsif file =~ /https?:\/\/www\.youtube\.com.*/
      true
    else
      type(file).start_with?("ISO Media", "Audio file") ||
        mime_type(file).start_with?("video", "audio", "image")
    end
  end

  def self.dvd_dir?(file)
    false unless mime_type(file) == 'inode/directory'
    File.exist?(Pathname.new(file).join("VIDEO_TS")) ||
      File.exist?(Pathname.new(file).join("video_ts"))
  end
end
#+end_src
** mediautil

Utility ruby program for manipulating image, audio and video file.

#+begin_src scheme :noweb-ref guix-desktop
"dvd+rw-tools"
#+end_src

#+begin_src ruby :tangle (expand-file-name "mediautil" tangle/local-bin-dir)
require 'thor'
require 'open3'
require 'fileutils'
require 'tempfile'
require 'tmpdir'

require 'filetype'

class MediaUtil < Thor
  OUTFILE_SUFFIX = "_out"
  DEFAULT_VIDEO_EXT = ".mkv"

  class Names < Struct.new(:in_f, :out_f)
    def in_file()
      in_f
    end
    def out_file(extension = nil)
      if out_f
        out_f
      else
        bn = File.basename(in_f, ".*").gsub(/ /, '_')
        ext = ((extension) ? extension : File.extname(in_file))
        default_out = bn + ext
        if File.file?(default_out)
          10.times do |i|
            try_name = bn + "_" + (i+1).to_s + ext
            unless File.file?(try_name)
              return try_name
            end
          end
        end
        default_out
      end
    end
    def title()
      File.basename(out_file, ".*")
    end
  end
  class Commander < Struct.new(:log, :dry)
    def execute(command)
      if dry
        puts command
      else
        log_str, s_code = Open3.capture2e(command)
        if log
          user_cmd = caller.first.scan(/`(.*)'/).flatten.first.to_s
          log_fname = Time.now.strftime("%Y%m%d_%H%M%S_") + user_cmd + ".log"
          File.open(log_fname, "w") do |f|
            f.puts(log_str)
          end
        else
          puts log_str
        end
        exit false unless s_code.success?
        # exit false
      end
    end
  end

  class_option :log, aliases: "L", :type => :boolean,
               :desc => "log stdout and stderr instead they reveal in terminal"
  class_option :dryrun, aliases: "D", :type => :boolean

  desc "info <file>", "show information about the video file or DVD directory"
  option :short, aliases: "s", :type => :boolean
  def info(target)
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(target) || FileType.audio?(target)
      commander.execute("ffprobe \"#{target}\" -hide_banner -show_entries format")
    elsif FileType.image?(target)
      if options[:short]
        commander.execute("identify #{target}")
      else
        commander.execute("identify -verbose #{target}")
      end
    elsif FileType.block_device?(target) ||
          FileType.video_dvd_image?(target) ||
          FileType.dvd_dir?(target)
      commander.execute("HandBrakeCLI -i \"#{target}\" --title 0")
    else
      STDERR.puts "Unknown Media Format"
      exit false
    end
  end

  default_command :encode
  desc "encode", "encode video file"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :vencoder, aliases: "e", :type => :string,
         :banner => "libx265|libx264",
         :desc => "video encoder"
  option :vquality, aliases: "q", :type => :string,
         :banner => "24.0",
         :desc => "video encoding quality"
  option :vbitrate, aliases: "b", :type => :string,
         :banner => "1000",
         :desc => "video encoding bitrate in kbps"
  option :aencoder, aliases: "E", :type => :string,
         :banner => "fdk_aac",
         :desc => "audio encoder"
  option :aquality, aliases: "Q", :type => :string,
         :banner => "100.0",
         :desc => "audio encoding quality"
  option :abitrate, aliases: "B", :type => :string,
         :banner => "128",
         :desc => "audio encoding bitrate in kbps"
  option :display, aliases: "d", :type => :string,
         :banner => "1920:1080",
         :desc => 'display (width:height) in which encoded video fit'
  option :fps, aliases: "f", :type => :string,
         :banner => "30",
         :desc => 'max frame rate'
  option :ffmpeg, :type => :string
  def encode()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    vconf = aconf = pconf = nil
    if options[:vencoder] || options[:vquality]
      vconf = VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
    end
    if options[:aencoder] || options[:aquality]
      aconf = AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
    end
    if options[:display] || options[:fps]
      pconf = PictureConfig.new
      pconf.fit_size(options[:display]) if options[:display]
      pconf.decrease_framerate(options[:fps]) if options[:fps]
    end

    if FileType.video?(equip.in_file) then
      commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                       [FFMPEGOptSet.new(equip.out_file, [vconf, aconf, pconf, "-map_metadata 0", options[:ffmpeg]])]))
    elsif FileType.audio?(equip.in_file) then
      commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                       [FFMPEGOptSet.new(equip.out_file, [aconf])]))
    elsif FileType.image?(equip.in_file) then
      pconf = ImageConfig.new
      commander.execute(ImageMagick.command(equip.in_file,
                                            equip.out_file,
                                            pconf))
    else
      STDERR.puts "Unknown Media Format"
      exit false
    end
  end

  desc 'cdencode', 'rip and encode CD contents'
  option :device, aliases: 'd', :type => :string,
         :desc => 'Device file'
  option :format, aliases: 'f', :type => :string,
         :banner => 'flac,ogg,m4a', :default => 'flac:-8',
         :desc => 'formats with additinal argument like compression level'
  def cdencode()
    commander = Commander.new(options[:log], options[:dryrun])

    abcde_args = []
    abcde_args << "-d #{options[:device]}" if options[:device]
    abcde_args << '-a default'
    if options[:format] then
      abcde_args << "-o '#{options[:format]}'"
    end
    abcde_args << '-G' # getalbumart
    abcde_args << '-x' # Eject CD

    commander.execute("abcde #{abcde_args.join(' ')}")
  end

  desc 'dvdrip', 'rip(backup) DVD contents'
  option :device, aliases: 'd', :type => :string,
         :desc => 'DVD device file'
  option :out, aliases: 'o', :type => :string,
         :desc => 'output directory name'
  option :name, aliases: 'n', :type => :string,
         :desc => 'root directory name of backup data'
  def dvdrip()
    commander = Commander.new(options[:log], options[:dryrun])

    dvdbackup_opts = ['dvdbackup']
    dvdbackup_opts << '--input=%s' % options[:device] if options[:device]
    dvdbackup_opts << '--output=%s' % options[:out] if options[:out]
    dvdbackup_opts << '--name=%s' % options[:name] if options[:name]
    dvdbackup_opts << '--mirror'
    dvdbackup_opts << '--progress'
    dvdbackup_opts << '--verbose'

    commander.execute(dvdbackup_opts.join(' '))
  end

  desc 'dvdencode', 'encode DVD contents'
  option :in, aliases: 'i', :type => :string, :required => true,
         :desc => 'input source, DVD device file or backuped DVD file'
  option :out, aliases: 'o', :type => :string,
         :desc => 'output directory name'
  option :vencoder, aliases: "e", :type => :string,
         :banner => "x265|x264",
         :desc => "video encoder"
  option :vquality, aliases: "q", :type => :string,
         :banner => "24.0",
         :desc => "video encoding quality"
  option :vbitrate, aliases: "b", :type => :string,
         :banner => "1000",
         :desc => "video bitrate in kbps"
  option :aencoder, aliases: "E", :type => :string,
         :banner => "fdk_aac",
         :desc => "audio encoder"
  option :aquality, aliases: "Q", :type => :string,
         :banner => "100.0",
         :desc => "audio encoding quality"
  option :abitrate, aliases: "B", :type => :string,
         :banner => "128",
         :desc => "audio bitrate in kbps"
  option :title, aliases: 't', :type => :string,
         :banner => '1|2|3|...',
         :desc => 'title number'
  option :chapters, aliases: 'c', :type => :string,
         :banner => '1|1-3|1,3,5|...',
         :desc => 'chapter numbers'
  option :audio, aliases: 'a', :type => :string,
         :banner => '1,2,3',
         :desc => 'audio channel'
  option :subtitle, aliases: 's', :type => :string,
         :banner => '1,2',
         :desc => 'subtitle channel'
  option :handbrake, :type => :string,
         :banner => '--handbrake \"--mixdown 5point1,stereo\"',
         :desc => 'HandBrakeCLI options'
  def dvdencode()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.block_device?(equip.in_file) ||
       FileType.video_dvd_image?(equip.in_file) ||
       FileType.dvd_dir?(equip.in_file)
      configs = []
      configs << VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
      configs << AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
      dconf = DVDConfig.new
      dconf.title = options[:title] if options[:title]
      dconf.chapters = options[:chapters] if options[:chapters]
      dconf.audio = options[:audio] if options[:audio]
      dconf.subtitle = options[:subtitle] if options[:subtitle]
      configs << dconf
      commander.execute(HandBrakeCLI.command(equip.in_file,
                                             equip.out_file(DEFAULT_VIDEO_EXT),
                                             configs,
                                             options[:handbrake]))
    end
  end

  desc 'mount <dir>', 'Mount CD/DVD media to dir.'
  option :device, aliases: "d", :type => :string, :required => true,
         :desc => 'device or iso file to mount',
         :banner => '--mount /dev/dvd|image.iso'
  option :type, aliases: 't', :type => :string,
         :desc => 'mount DVD-Video',
         :banner => '--type data|video'
  def mount(dir)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['mount']
    if options[:type] == 'video' || FileType.video_dvd_image?(options[:device])
      cmd_opts << ['-t', 'iso9660', '-o', 'loop']
    end
    cmd_opts << options[:device]
    cmd_opts << dir

    Dir.mkdir(dir) if !Dir.exist?(dir) && !options[:dryrun]
    commander.execute("sudo #{cmd_opts.join(' ')}")
  end

  desc 'umount', 'unmount dir'
  option :remove, aliases: 'r', :type => :boolean,
         :desc => 'remove dir after unmounting'
  def umount(dir)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['umount']
    cmd_opts << dir

    commander.execute("sudo #{cmd_opts.join(' ')}")

    if options[:remove]
      FileUtils.rmdir(dir)
    end
  end

  desc 'mkiso', 'make ISO image file.'
  option :type, aliases: 't', :type => :string, :required => true,
         :desc => 'DVD image type. Data or Video DVD.',
         :banner => '--type data|video'
  option :volume, aliases: 'V', :type => :string,
         :desc => 'Volume Label'
  option :out, aliases: 'o', :type => :string,
         :desc => 'ISO image file name.',
         :banner => '--out movie.iso'
  def mkiso(file)
    names = Names.new(file, options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    mkisofs_opts = ['mkisofs']
    mkisofs_opts << ["-V", "\"#{options[:volume]}\""] if options[:volume]
    if options[:type] == "data"
      mkisofs_opts << ["-r", "-l", "-J"]
    elsif options[:type]
      mkisofs_opts << "-dvd-video"
    else
      exit 1
    end
    mkisofs_opts << ["-o", "\"#{names.out_file('.iso')}\""]
    mkisofs_opts << "\"#{file}\""

    commander.execute(mkisofs_opts.join(" "))
  end

  desc 'dvdburn <file>', 'Burn file to DVD.'
  option :iso, aliases: 'I', :type => :boolean,
         :desc => 'Set this option if <file> is ISO 9660 compliant.'
  option :volume, aliases: 'V', :type => :string, :default => 'DVD_VIDEO',
         :desc => 'Volume Label'
  option :video, aliases: 'v', :type => :boolean,
         :desc => 'Create DVD video image file to burn.'
  option :speed, aliases: 's', :type => :string, :default => '4',
         :desc => 'Burning Speed',
         :banner => 'n'
  option :device, aliases: 'd', :type => :string,
         :desc => 'Device file', :default => '/dev/sr0'
  def dvdburn(file)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['growisofs']
    cmd_opts << '-dvd-compat'
    cmd_opts << '-speed=%s' % options[:speed]
    if FileType.iso9660?(file) || options[:iso]
      cmd_opts << '-Z %s=%s' % [options[:device], file]
    else
      cmd_opts << '-Z %s' % options[:device]
      mkisofs_opts = []
      mkisofs_opts << ['-V', "\"#{options[:volume]}\""] if options[:volume]
      if options[:video]
        mkisofs_opts << '-dvd-video'
      else # Data-DVD
        mkisofs_opts << ['-r', '-l', '-R']
      end
      mkisofs_opts << file
      cmd_opts << mkisofs_opts
    end

    commander.execute(cmd_opts.join(' '))
  end

  desc "cdburn", "burn files to CD device"
  option :in, aliases: "i", :type => :string, :required => true,
         :desc => "Root Directory for image file"
  option :volume, aliases: "v", :type => :string, :required => true,
         :desc => "Volume ID"
  option :device, aliases: "d", :type => :string,
         :desc => "Device file", :default => "/dev/sr0"
  def cdburn()
    commander = Commander.new(options[:log], options[:dryrun])

    commander.execute("mkisofs -V \"#{options[:volume]}\" -J -r #{options[:in]} | cdrecord -v dev=#{options[:device]} -waiti -")
  end

  desc "screenshot", "take a screenshot of a video at a time"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :time, aliases: "t", :type => :string,
         :desc => "ex. 00:10:22.300"
  def screenshot()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])
    if FileType.video?(equip.in_file) then
      args = ['ffmpeg']
      args << ('-ss %s' % options[:time]) if options[:time]
      args << '-i %s' % equip.in_file
      args << '-vframes 1'
      args << '-q:v 2'
      args << equip.out_file('.jpg')
      commander.execute(args.join(' '))
    end
  end

  desc "clip", "clip a video with specific time span"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :time_begin, aliases: "b", :type => :string,
         :desc => "ex. 00:10:22.300"
  option :time_end, aliases: "e", :type => :string
  def clip()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(equip.in_file) then
      if options[:time_begin] or options[:time_end] then
        in_opts = []
        in_opts << "-ss #{options[:time_begin]}" if options[:time_begin]
        in_opts << "-to #{options[:time_end]}" if options[:time_end]
        out_opts = []
        out_opts << "-vcodec copy"
        out_opts << "-acodec copy"
        out_opts << "-map_metadata 0"
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, in_opts)],
                                         [FFMPEGOptSet.new(equip.out_file, out_opts)]))
      end
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "crop", "extract a specific rectangle of a image/video"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :width, aliases: "w", :type => :numeric, :required => true
  option :height, aliases: "h", :type => :numeric, :required => true
  option :xpos, aliases: "x", :type => :numeric,
         :desc => "x coordinate of an original image where cropped image of top-left corner overlaps"
  option :ypos, aliases: "y", :type => :numeric
  def crop()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    width = options[:width]
    height = options[:height]
    xpos = options[:xpos] ? options[:xpos] : 0
    ypos = options[:ypos] ? options[:ypos] : 0
    if FileType.image?(names.in_file) then
      opt = '-crop %dx%d+%dx%d' % [width, height, xpos, ypos]
      commander.execute("convert #{opt} #{names.in_file} #{names.out_file}")
    elsif FileType.video?(names.in_file) then
      args = ['ffmpeg']
      args << '-i %s' % names.in_file
      args << '-vf crop=%d:%d:%d:%d' % [width, height, xpos, ypos]
      args << "-map_metadata 0"
      args << names.out_file
      commander.execute(args.join(' '))
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "trim", "trim a image/video with automated detection"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :threshold, aliases: "t", :type => :string,
         :desc => "threshold where trimming begin and end"
  def trim()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.image?(names.in_file) then
      commander.execute("convert -trim #{names.in_file} #{names.out_file}")
    elsif FileType.audio?(names.in_file) then
      threshold = (options[:threshold]) ? options[:threshold] : "-40dB"
      commander.execute("ffmpeg -i #{names.in_file} -af \"silenceremove=start_periods=1:start_duration=0:start_threshold=#{threshold}:detection=peak\" #{names.out_file}")
    end
  end

  desc "resize", "resize the image"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :width, aliases: "w", :type => :string,
         :banner => "e.g. 300",
         :desc => "resized image width"
  option :height, aliases: "h", :type => :string,
         :banner => "e.g. 200",
         :desc => "resized image height"
  option :operation, aliases: "p", :type => :string,
         :banner => "enlarge|shrink",
         :desc => "permitted operation for resizing"
  def resize()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(names.in_file) then
      if options[:width] and options[:height]
        out_opts = []
        out_opts << format("-vf scale=%s:%s,setsar=1:1", options[:width], options[:height])
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(names.in_file, [])],
                                         [FFMPEGOptSet.new(names.out_file, out_opts)]))
      end
    elsif FileType.image?(names.in_file) then
      return if options[:width] == nil && options[:height] == nil
      if options[:operation] == "enlarge"
        op = "<"
      elsif options[:operation] == "shrink"
        op = ">"
      else
        op = ""
      end
      geometry = format("%sx%s%s", options[:width], options[:height], op)
      commander.execute("convert -resize #{geometry} #{names.in_file} #{names.out_file}")
    end
  end

  desc "concat", "concat multiple files"
  option :in, aliases: "i", :type => :array, :required => true
  option :out, aliases: "o", :type => :string
  def concat()
    names = Names.new(options[:in][0], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    srcs = options[:in]
    output = names.out_file

    if srcs.all? { |src| FileType.video?(src) }
      src_list = ""
      src_file = Tempfile.open()
      chap_file = Tempfile.open()
      chap_file.write("### Create Chapterfile ###\n")
      files_to_remove = []
      time_accumulated = Time.new(0)
      srcs.each_with_index do |src, index|
        valid_src =
          if src =~ /^\p{Ascii}+$/
            src
          else
            Dir::Tmpname.create('base') do |src_dup|
              FileUtils.cp(src, src_dup)
              files_to_remove << src_dup
              src_dup
            end
          end
        src_file.write("file '#{File.expand_path(valid_src)}'\n")
        chap_file.write("CHAPTER#{index + 1}=#{time_accumulated.strftime('%H:%M:%S.%L')}\n")
        chap_file.write("CHAPTER#{index + 1}NAME=#{File.basename(src, File.extname(src))}\n")
        duration = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "#{src}"`.strip().to_f()
        time_accumulated += duration
      end
      src_file.flush
      commander.execute("ffmpeg -n -f concat -safe 0 -i #{src_file.path} -c:v copy -c:a copy -c:s copy -map 0:v -map 0:a -map 0:s? #{output}")
      src_file.close
      chap_file.flush
      commander.execute("MP4Box -chap #{chap_file.path} #{output}")
      chap_file.close
      src_file.unlink
      chap_file.unlink
      FileUtils.rm_f(files_to_remove)
    elsif srcs.all? { |src| FileType.image?(src) }
      commander.execute "convert #{srcs.join(' ')} #{output}"
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "diff", "measure the difference by providing SSIM value"
  option :out, aliases: "o", :type => :string
  def diff(file1, file2)
    commander = Commander.new(options[:log], options[:dryrun])

    if ((FileType.video?(file1) and FileType.video?(file2)) or
        (FileType.image?(file1) and FileType.image?(file2))) then
      if options[:out] then
        commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim=#{options[:out]} -an -f null -")
      else
        commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim -an -f null -")
      end
    end
  end

  desc "mux", "mux to one file which has streams correspond with input files"
  option :video, aliases: "v", :type => :string, :required => true
  option :audio, aliases: "a", :type => :string, :required => true
  option :audio_delay, aliases: "d", :type => :string
  option :out, aliases: "o", :type => :string
  def mux()
    names = Names.new(options[:video], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    in_optsets = []
    in_optsets << FFMPEGOptSet.new(options[:video], [])
    aconf = []
    aconf << "-itsoffset #{options[:audio_delay]}" if options[:audio_delay]
    in_optsets << FFMPEGOptSet.new(options[:audio], aconf)
    commander.execute(FFMPEG.command(in_optsets,
                                     [FFMPEGOptSet.new(names.out_file, [])]))
  end
end

class MainConfig
  attr_accessor :start, :end
end

class VideoConfig
  attr_accessor :encode, :quality, :bitrate, :preset, :tune, :profile, :level

  DEFAULT_ENCODE = 'vp9'
  DEFAULT_QUALITY = '26'
  DEFAULT_BITRATE = '1000'

  def initialize(encode, quality=nil, bitrate=nil)
    @encode = encode
    @quality = quality
    @bitrate = bitrate

    case @encode
    when "x265"
      @preset = "veryslow"
      @tune = "ssim"
      @profile = "main"
      @level = nil
    when "x264"
      @preset = "veryslow"
      @tune = "film"
      @profile = "main"
      @level = "4.1"
    end
  end
end

class PictureConfig
  # conversion options
  attr_accessor :vf_opts, :fps

  def initialize()
    @vf_opts = []
    @vf_opts << "format=yuv420p"
  end

  # down-size to fit to display (width:heigh) in keeping aspect ratio
  def fit_size(display_size)
    @vf_opts << "scale=#{display_size}:force_original_aspect_ratio=decrease"
    @vf_opts << "pad=((iw+1)/2)*2:((ih+1)/2)*2" # avoid width/height to odd
  end

  def decrease_framerate(fps)
    @fps = fps
  end
end

class AudioConfig
  attr_accessor :encode, :quality, :bitrate

  DEFAULT_ENCODE = 'opus'
  DEFAULT_QUALITY = '100'
  DEFAULT_BITRATE = '128'

  def initialize(encode, quality=nil, bitrate=nil)
    # @encode = (encode ? encode : DEFAULT_ENCODE)
    @encode = encode
    @quality = quality
    @bitrate = bitrate
  end

  def quality
    case @encode
    when 'opus'
    else
      @quality
    end
  end

  def bitrate
    case @encode
    when 'opus'
      (@bitrate ? @bitrate : DEFAULT_BITRATE)
    else
      @bitrate
    end
  end
end

class DVDConfig
  attr_accessor :title, :chapters, :audio, :subtitle, :options
  attr_accessor :chapter_marker

  def initialize
    @chapter_marker = true
  end
end

class ImageConfig
  attr_reader :quality # 1~100
end

class FFMPEGOptSet < Struct.new(:fname, :optset)
end

class FFMPEG
  def self.command(in_optsets, out_optsets)
    opts = ["ffmpeg"]

    infilep = proc do |fname, optset|
      opt_arr = []
      optset.each do |opt|
        if opt.instance_of?(String)
          opt_arr << opt
        end
      end
      opt_arr << ["-i", "\"#{fname}\""]
      next opt_arr
    end
    in_optsets.each do |in_optset|
      opts << infilep.call(in_optset.fname, in_optset.optset)
    end

    outfilep = proc do |fname, optset|
      oopts = []
      optset.each do |opt|
        if opt.instance_of?(VideoConfig)
          case opt.encode
          when 'av1'
            oopts << format("-c:v librav1e")
            if opt.bitrate
              oopts << format("-b:v %sk", opt.bitrate)
            end
          when 'vp9'
            oopts << format("-c:v libvpx-vp9")
            if opt.quality
              oopts << format("-crf %s", opt.quality)
              oopts << format("-b:v 0")
            elsif opt.bitrate
              oopts << format("-b:v %s", opt.bitrate)
            end
          when 'h265'
            oopts << format("-c:v libx265")
            oopts << format("-crf %s", opt.quality)
            oopts << format("-preset %s", opt.preset) if opt.preset
            oopts << format("-tune %s", opt.tune) if opt.tune
            # Currently, ffmpeg ​does not support setting profiles on x265
            oopts << format("-profile:v %s", opt.profile) if opt.profile && opt.encoder == 'x264'
            oopts << format("-level %s", opt.level) if opt.level
          else
            oopts << format("-c:v copy")
          end
        elsif opt.instance_of?(AudioConfig)
          case opt.encode
          when 'opus'
            oopts << format("-c:a lib%s", opt.encode)
            oopts << format("-b:a %sk", opt.bitrate) if opt.bitrate
          when 'aac'
            oopts << format("-c:a libfdk_aac")
            if opt.quality
              oopts << format("-aq %s", opt.quality)
              oopts << format("-b:a 0")
            elsif opt.bitrate
              oopts << format("-b:a %s", opt.bitrate)
            end
          else
            oopts << format("-c:a copy")
          end
        elsif opt.instance_of?(PictureConfig)
          oopts << format("-vf \"%s\"", opt.vf_opts.join(",")) if opt.vf_opts && opt.vf_opts.any?
          oopts << format("-r %s", opt.fps) if opt.fps
        elsif opt.instance_of?(String)
          oopts << opt
        end
      end
      oopts << "\"#{fname}\""
      next oopts
    end
    out_optsets.each do |out_optset|
      opts << outfilep.call(out_optset.fname, out_optset.optset)
    end

    opts.join(" ")
  end
end

class HandBrakeCLI
  def self.command(input, output, configs, raw_option)
    cmd_opts = ["HandBrakeCLI"]
    cmd_opts << format("--input \"%s\"", input)
    cmd_opts << format("--output \"%s\"", output)
    configs.each do |config|
      if config.instance_of?(VideoConfig)
        case config.encode
        when 'vp9'
          cmd_opts << format("--encoder VP9")
          if config.quality
            cmd_opts << format("--quality %s", config.quality)
            cmd_opts << format("--vb 0")
          elsif config.bitrate
            cmd_opts << format("--vb %s", config.bitrate)
          end
          cmd_opts << format("--encoder-preset veryslow")
        when 'h265' || 'hevc'
          cmd_opts << format("--encoder x265")
          if config.quality
            cmd_opts << format("--quality %s", config.quality)
            cmd_opts << format("--vb 0")
          elsif config.bitrate
            cmd_opts << format("--vb %s", config.bitrate)
          end
          cmd_opts << format("--encoder-preset %s", config.preset) if config.preset
          cmd_opts << format("--encoder-tune %s", config.tune) if config.tune
          cmd_opts << format("--encoder-profile %s", config.profile) if config.profile
          cmd_opts << format("--encoder-level %s", config.level) if config.level
        else
          cmd_opts << format("--encoder %s", config.encode) if config.encode
          cmd_opts << format("--quality %s", config.quality) if config.quality
          cmd_opts << format("--vb %s", config.bitrate) if config.bitrate
        end
      elsif config.instance_of?(AudioConfig)
        case config.encode
        when 'opus'
          cmd_opts << format("--aencoder %s", config.encode)
          cmd_opts << format("--aq %s", config.quality) if config.quality
          cmd_opts << format("--ab %s", config.bitrate) if config.bitrate
        when 'aac'
          cmd_opts << format("--aencoder ca_haac")
          if config.quality
            cmd_opts << format("--aq %s", config.quality)
            cmd_opts << format("--ab 0")
          elsif config.bitrate
            cmd_opts << format("--ab %s", config.bitrate)
          end
        else
          cmd_opts << format("--aencoder copy")
        end
      elsif config.instance_of?(DVDConfig)
        cmd_opts << (config.title ? format("--title %s", config.title) : "--main-feature")
        cmd_opts << format("--chapters %s", config.chapters) if config.chapters
        cmd_opts << "--markers" if config.chapter_marker
        cmd_opts << (config.audio ? format("--audio %s", config.audio) : "--all-audio" )
        cmd_opts << (config.subtitle ? format("--subtitle %s", config.subtitle) : "--all-subtitles" )
      end
    end

    cmd_opts << raw_option if raw_option

    cmd_opts.join(" ")
  end
end

class ImageMagick
  COMMAND = "convert %s %s %s %s "

  def self.command(input, output, pconfig, raw_option="")
    input_opt = ""
    output_opt = ""
    if pconfig.instance_of?(ImageConfig) then
      input_opt += "-quality %s" % pconfig.quality if pconfig.quality
      s = COMMAND % [input, input_opt, output, output_opt]
      s
    end
  end
end

MediaUtil.start(ARGV)
#+end_src
** genalbum

Personal script for encoding family pictures and movies.

#+begin_src ruby :tangle (expand-file-name "genalbum" tangle/local-bin-dir)
require 'fileutils'
require 'time'
require 'exifr'
require 'streamio-ffmpeg'
require 'pathname'
require 'thor'

PICTURE_FILE_EXTS = [".jpg"]
MOVIE_FILE_EXTS = [".mp4"]
ALBUM_DIR_NAME = "album/"
RENAME_DIR_NAME = "rename/"
WEB_DIR_NAME = "album_web/"
IMG_PREFIX = "img_"

class GenAlbum < Thor
  default_command :album
  desc "[album] -i <img_dir>", "generate album"
  option :in, aliases: "i", :type => :string, :required => true
  def album
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = ALBUM_DIR_NAME

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    Dir.glob(src_path + "/*").each do |img_file|
      basename = File::basename(img_file)
      src_file = src_path + "/" + basename
      dest_file = dest_path + "/" + basename
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        system("convert -resize \"4096x>\" -quality 92 #{src_file} #{dest_file}")
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        system("mediautil encode -i #{src_file} -o #{dest_file} -q 22.0 -Q 100.0")
      end
    end
  end

  desc "web -i <img_dir>", "generate lightweight album for web"
  option :in, aliases: "i", :type => :string, :required => true
  def web
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = WEB_DIR_NAME

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    Dir.glob(src_path + "/*").each do |img_file|
      basename = File::basename(img_file)
      src_file = src_path + "/" + basename
      dest_file = dest_path + "/" + basename
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        system("convert -resize \"1024x>\" -quality 80 #{src_file} #{dest_file}")
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        system("mediautil encode -i #{src_file} -o #{dest_file} -q 26.0 -Q 100.0")
      end
    end
  end

  desc "renmae -i <img_dir>", "rename image files in chlonological order"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  def rename
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = ((options[:out]) ? options[:out] : RENAME_DIR_NAME)

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    img_time = {}
    Dir.glob(src_path + "/*").each do |img_file|
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        pic = EXIFR::JPEG.new(img_file)
        if pic.exif? && pic.date_time_original then
          img_time[img_file] = pic.date_time_original
        else
          img_time[img_file] = Time.now
        end
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        movie = FFMPEG::Movie.new(img_file)
        time = movie.creation_time
        if time then
          img_time[img_file] = time
        else
          img_time[img_file] = Time.now
        end
      end
    end
    img_time = img_time.sort_by{ |_, v| v }

    digit = img_time.length.to_s.length
    digit = 2 if digit < 2
    img_time.each_with_index do |(img, time), i|
      ext = File.extname(img).downcase
      base = IMG_PREFIX + "%0#{digit}d" % (i + 1) + ext
      src_file = img
      dest_file = dest_path + "/" + base
      system("cp #{src_file} #{dest_file}")
    end
  end
end

GenAlbum.start(ARGV)
#+end_src

** nhp                                         :ARCHIVE:
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-file-name ".local/bin/nhp")
#!/usr/bin/env bash

readonly MAIL_FROM="<<email>>"
readonly MAIL_TO="<<email>>"

function usage() {
  cat <<_EOT_
Usage:
  $(basename "$0") [options] command|exefile

Description:
  $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

Options:
  -l <logfile>  log file name
  -p <pidfile>  process id file name
  -h            help

_EOT_
  exit 1
}

if [ "${OPTIND}" = 1 ]; then
  while getopts l:p:h OPT
  do
    case ${OPT} in
    l)
      opt_logfile=${OPTARG}
      ;;
    p)
      opt_pidfile=${OPTARG}
      ;;
    h)
      usage
      ;;
    \?)
      echo "Try to enter the h option." 1>&2
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi

shift $((OPTIND - 1))

function mailtome() {
  local _command=$1
  local _whole_command=$2
  local _logfile_rel=$4

  if [ "$3" -eq 0 ]; then
    _result='success'
  else
    _result='failed'
  fi
  _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

  mailfrom=${MAIL_FROM}
  mailto=${MAIL_TO}
  subject="${_result}: ${_command} @ $(uname -n)"
  msg1="command line      : ${_whole_command}"
  msg2="exit status(nohup): $3"
  msg3="execution time    : $5"
  msg4="pwd               : $(pwd)"
  msg5="Log data (stdout/stderr) is stored in following file:"
  msg6="${_logfile}"

  {
    echo "${msg1}"
    echo "${msg2}"
    echo "${msg3}"
    echo "${msg4}"
    echo "${msg5}"
    echo "${msg6}"
  } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
}
export -f mailtome

if [ $# -eq 1 ] && [ -x "$1" ]; then
  utility="$1"
elif [ $# -gt 0 ] && type "$1" >/dev/null; then
  utility="$*"
else
  exit 1
fi

LOG_DIR=${HOME}/.local/state/log/$(basename "$0")
fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p "${LOG_DIR}"
fi

if [ -v "opt_logfile" ]; then
  logfile=${opt_logfile}
else
  logfile="${LOG_DIR}/${fname_default}.log"
fi

if [ -v "opt_pidfile" ]; then
  pidfile=${opt_pidfile}
else
  pidfile="${LOG_DIR}/${fname_default}.pid"
fi

(
  start_time=$(date +%s)
  nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
  PID=$!
  echo $PID >"${pidfile}"
  wait $PID
  EXIT_STATUS=$?
  end_time=$(date +%s)
  exec_time=$((end_time-start_time))
  ((h=exec_time/3600))
  ((m=(exec_time%3600)/60))
  ((s=exec_time%60))
  exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
  mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
)
echo "$1 has finished successfully"

exit 0
#+end_src

** sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-file-name "sendmail.py" tangle/local-bin-dir)
import sys
import argparse
import subprocess
import smtplib
import ssl
from email.mime.text import MIMEText
from email.utils import formatdate

def sendmail(mail_to, mail_from, subject, message):
    smtp_host = 'smtp.<<my-domain()>>'
    smtp_port = '465'
    smtp_user = '<<email>>'.split(sep='@')[0]
    smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

    mime_msg = MIMEText(message)
    mime_msg['Subject'] = subject
    mime_msg['From'] = mail_from
    mime_msg['To'] = mail_to
    mime_msg["Date"] = formatdate(None, True)

    if smtp_port == '465':
        context = ssl.create_default_context()
        smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

    if smtp is not None:
        smtp.login(smtp_user, smtp_pass)
        smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
        smtp.quit()


DESC = 'sendmail.py sends mail'
parser = argparse.ArgumentParser(description=DESC)
parser.add_argument('-s', '--subject')
parser.add_argument('-f', '--mailfrom')
parser.add_argument('to')
args = parser.parse_args()

message = sys.stdin.read()
sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

** pwsudo

Nifty script that executes command with elevating privilege using password from pass command.

#+begin_src shell :noweb tangle :tangle (expand-file-name "pwsudo" tangle/local-bin-dir)
_userid=$(whoami)
_hostname=$(hostname)

pas=$(pass show "${_hostname}/${_userid}" 2>/dev/null) \
  && ( echo "${pas}" | head -1 | sudo -sES -p "" "$@" ) \
  || sudo -sES "$@"

exit $?
#+end_src

** gitsync                                     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-09-29 Thu 16:42]
:END:

- gitsync-local
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-local")
  #!/usr/bin/env bash

  function usage() {
    cat <<_EOT_
  Usage:
    $0 <prj_root>

  Description:
    $0 adds file changes in git projects under root_dir to the repository

  Options:
    prj_root:  a root directory that has git projects as children

  _EOT_
    exit 1
  }

  # parameter check
  if [ $# -ne 1 ]; then
    usage
    exit 1
  fi
  root_dir=$1

  if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
      while read repo
      do
        cd ${repo} || continue

        # skip if this is not git repo
        git rev-parse || continue

        echo "repository: ${repo}"

        cd `git rev-parse --show-toplevel`
        sync_mode=`git config sync.mode`
        case "${sync_mode}" in
        "auto" )
          # Remove deleted files
          git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
          # Add new files
          git add . >/dev/null 2>&1
          git commit -m "$(date)";;
        "manual" )
          git add -u >/dev/null 2>&1
          git commit -m "$(date)";;
        "none" )
        ;;
        esac
      done
    }
  then
    printf "\nAll done.\n"
  else
    printf "\nFix and redo.\n"
  fi
  #+end_src

- gitsync-remote
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-remote")
  #!/usr/bin/env bash

  # Local bare repository name
  syncrepo=origin

  # Display repository name only once
  log_repo() {
    [ "x$lastrepo" == "x$repo" ] || {
      printf "\nREPO: ${repo}\n"
      lastrepo="$repo"
    }
  }

  # Log a message for a repository
  log_msg() {
    log_repo
    printf "  $1\n"
  }

  # fast-forward reference $1 to $syncrepo/$1
  fast_forward_ref() {
    log_msg "fast-forwarding ref $1"
    current_ref=$(cat .git/HEAD)
    if [ "x$current_ref" = "xref: refs/heads/$1" ]
    then
      # Check for dirty index
      files=$(git diff-index --name-only HEAD --)
      git merge refs/remotes/$syncrepo/$1
    else
      git branch -f $1 refs/remotes/$syncrepo/$1
    fi
  }

  # Push reference $1 to $syncrepo
  push_ref() {
    log_msg "Pushing ref $1"
    if ! git push --tags --quiet $syncrepo $1
    then
      exit 1
    fi
  }

  # Check if a ref can be moved
  #   - fast-forwards if behind the sync repo and is fast-forwardable
  #   - Does nothing if ref is up to date
  #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
  #   - Fails if ref and $syncrop/ref have diverged
  check_ref() {
    revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
    revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
    if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
    then
      # Ref $1 is up to date.
      :
    elif [ "x$revlist1" = "x" ]
    then
      # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
      fast_forward_ref $1 || exit 1
    elif [ "x$revlist2" = "x" ]
    then
      # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
      push_ref $1 || exit 1
    else
      log_msg "Ref $1 and $syncrepo/$1 have diverged."
      exit 1
    fi
  }

  # Check all local refs with matching refs in the $syncrepo
  check_refs () {
    git for-each-ref refs/heads/* | while read sha1 commit ref
    do
      ref=${ref/refs\/heads\//}
      git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
      do
        if [ "x$sha1" != "x" -a "x$sha2" != "x" ]
        then
          check_ref $ref || exit 1
        fi
      done
    done
  }

  # parameter check
  if [ $# -ne 1 ]; then
    usage
    exit 1
  fi
  root_dir=$1

  # For all repositories under $reporoot
  #   Check all refs matching $syncrepo and fast-forward, or push as necessary
  #   to synchronize the ref with $syncrepo
  #   Bail out if ref is not fastforwardable so user can fix and rerun
  retval=0
  if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
      while read repo
      do
        cd ${repo}

        # continue if this is not git repo
        git rev-parse 2> /dev/null || continue

        upd=$(git remote update $syncrepo 2>&1 || retval=1)
        [ "x$upd" = "xFetching $syncrepo" ] || {
          log_repo
          printf "$upd\n"
        }
        check_refs || retval=1
      done
      exit $retval
    }
  then
    printf "\nAll done.\n"
  else
    printf "\nFix and redo.\n"
  fi

  exit $retval
  #+end_src

** filetype-cli                                :ARCHIVE:
Wrapper script for [[* filetype][filetype.rb]].

#+begin_src ruby :tangle (expand-file-name "filetype-cli" tangle/local-bin-dir)
#!/usr/bin/env ruby

require 'thor'
require 'filetype'

class FileTypeCLI < Thor
  default_command :check
  desc "check", "check whether the file is the speicfied type."
  option :type, aliases: "t", :type => :string, :required => true,
         :bannar => '--type image'
  def check(file)
    unless FileType.respond_to?("#{options[:type]}?")
      $stderr.print("file type '#{options[:type]}' is not valid.")
      exit 1
    end

    status = FileType.send("#{options[:type]}?", file)
    unless status
      $stderr.print("#{file} is not of #{options[:type]}?")
      exit 1
    end

    exit 0
  end
end

FileTypeCLI.start(ARGV)
#+end_src
** strip ruby
A program strips all ruby tags in a HTML stream. All HTML contents are expected to be from STDIN and go out as STDOUT. This procedure is mainly for html files converted from pdf and epub files.
Stripping rules are:
- <ruby> tag will be stripped
- <rt> tree for furigana tree will be removed
- <rp> tree contains parenthes for non-ruby-support brouwser will be removed
- <rb> tag for delimiter will be stripped
- <rtc> tree for semantic word will be removed

#+begin_src python :tangle (expand-file-name "strip_ruby" tangle/local-bin-dir)
import sys
import lxml.html as html

INPUT_STR = sys.stdin.read()
ROOT = html.fromstring(INPUT_STR).getroottree()

for ruby in ROOT.xpath('//ruby'):
    for rt in ruby.xpath('//rt'):
        rt.drop_tree()
    for rp in ruby.xpath('//rp'):
        rp.drop_tree()
    for rb in ruby.xpath('//rb'):
        rb.drop_tag()
    for rtc in ruby.xpath('//rtc'):
        rtc.drop_tree()
        ruby.drop_tag()

CONTENT = html.tostring(ROOT, encoding="utf-8", method='html', pretty_print=True)
print(CONTENT.decode())
#+end_src
* Local Variables
:PROPERTIES:
:CREATED:  [2023-12-14 Thu 21:36]
:END:

# Local Variables:
# compile-command: "make tangle"
# eval: (add-hook 'after-save-hook #'my/compile-default-command nil t)
# auto-save-visited-mode: nil
# buffer-save-without-query: t
# End:
