#+TITLE: My Configuration Collection
#+PROPERTY: tangle-dest       ~/dotfiles
#+PROPERTY: header-args       :mkdirp yes
#+PROPERTY: header-args:bash  :shebang "#!/usr/bin/env bash\nset -euo pipefail\n"

#+STARTUP: overview

* Personal Information
** Local Directories
+ home directory
  #+name: home-dir
  #+begin_src shell :eval no-export
    echo "${HOME}"
  #+end_src
+ share directory
  #+name: share-dir
  #+begin_src shell :eval no-export
    echo "${HOME}/data/share"
  #+end_src
+ video directory
  #+name: video-dir
  #+begin_src shell :eval no-export
    echo "${HOME}/data/videos"
  #+end_src
+ audio directory
  #+name: audio-dir
  #+begin_src shell :eval no-export
    echo "${HOME}/data/audios"
  #+end_src
** Email
#+name: email
#+begin_src bash
  echo -n "${EMAIL}"
#+end_src
+ account name
  #+name: account
  #+begin_src shell :eval no-export
    echo -n "${EMAIL}" | cut -d'@' -f1
  #+end_src
+ network name
  #+name: my-network
  #+begin_src shell :eval no-export
    echo -n "${EMAIL}" | cut -d'@' -f2
  #+end_src
* Linux Distributions
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 14:59]
:END:
** Ubuntu
:PROPERTIES:
:CREATED:  [2022-10-06 Thu 15:32]
:END:

initialization script for a ubuntu account

#+begin_src shell :noweb tangle :noweb-sep "\n\n" :tangle (expand-file-name ".local/bin/initialize-ubuntu-desktop") :shebang #!/bin/bash :tangle-mode (identity #o755)
  install-apt-packages
  start-systemd-services

  <<ubuntu-setup>>
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/install-apt-packages") :shebang #!/bin/sh :tangle-mode (identity #o755)
  sudo apt-get install -y \
       <<apt-pkgs>>
#+end_src

** Linux Mint (Cinnamon Desktop)
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 15:00]
:ID:       f3cd9a3b-9ff5-4cc8-807e-846f3f04c97a
:END:

initialization script for a linuxmint account

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/initialize-linuxmint-desktop") :shebang #!/bin/sh :tangle-mode (identity #o755)
  initialize-ubuntu-desktop

  <<linuxmint-setup>>
#+end_src

- Back-up Cinnamon Desktop Configuration
  #+begin_src conf :noweb yes :noweb-ref cronjob-pc
    30 1 */2 * * env bash -ci "dconf dump /org/cinnamon/ > ~/.config/linuxmint/cinnamon.conf"
  #+end_src

  To thaw backed up config
  #+begin_src conf :noweb yes :noweb-ref linuxmint-setup
    dconf load /org/cinnamon/ < <<home-dir()>>/.config/linuxmint/cinnamon.conf
  #+end_src

** GNU Guix

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/SystemCrafters/guix-installer/releases.atom" soft_update)
#+end_src

#+begin_src shell :noweb-ref bashrc
  GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

  # fill in a variable below like a comment line
  # if you'd like to acticate specific profiles under GUIX_EXTRA_PROFILES
  ACTIVE_PROFILE_NAMES=()
  # ACTIVE_PROFILE_NAMES=(base emacs)

  profiles=()
  if [ ${#ACTIVE_PROFILE_NAMES[@]} -eq 0 ]; then
    profiles="${GUIX_EXTRA_PROFILES}/*"
  else
    for name in ${ACTIVE_PROFILE_NAMES[@]}; do
      profiles+=("${GUIX_EXTRA_PROFILES}/${name}")
    done
  fi

  for profile in ${profiles[@]}; do
    GUIX_PROFILE="${profile}/$(basename ${profile})"
    if [ -f ${GUIX_PROFILE}/etc/profile ]; then
      . "${GUIX_PROFILE}"/etc/profile
    fi
  done

  export GUIX_PROFILE="$HOME/.guix-profile"
  . "$GUIX_PROFILE/etc/profile"

  export GUIX_PROFILE="$HOME/.config/guix/current"
  . "$GUIX_PROFILE/etc/profile"

  export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"


  if [ -n "$GUIX_ENVIRONMENT" ]; then
      if [[ $PS1 =~ (.*)"\\$" ]]; then
          PS1="${BASH_REMATCH[1]} [env]\\\$ "
      fi
  fi
#+end_src

*** Channel definitions

#+begin_src scheme :tangle (expand-file-name ".config/guix/base-channels.scm")
  (list (channel
         (name 'nonguix)
         (url "https://gitlab.com/nonguix/nonguix"))
        (channel
         (name 'guix)
         (url "https://git.savannah.gnu.org/git/guix.git")))
#+end_src

*** Manifests
- base
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/base.scm")
    (specifications->manifest
     '("coreutils"
       "diffutils"
       "parallel"
       "gawk"
       "sed"
       "tar"
       "zip"
       "unzip"
       "zstd"
       "shadow"
       "sshfs"
       "grep"
       "ripgrep"
       "less"
       "gnupg"
       "pwgen"
       "file"
       "nkf"
       "lsof"
       "tree"
       "poppler"
       "pass-git-helper"
       "stow"
       "pandoc"
       "nss-certs"
       "openssl"
       "glibc"
       "glibc-locales"
       "procps"
       "time"
       "htop"
       "net-tools"
       "curl"
       "wget"
       "ghc-tldr"
       "speedtest-cli"
       "parted"
       "fdisk"
       "gptfdisk"
       "smartmontools"
       "ddrescue"
       "sqlite"
       "libarchive"
       "ffmpeg"
       "dav1d"
       "jq"
       "pup"
       <<base-pkgs>>))
  #+end_src
- desktop
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/desktop.scm")
    (specifications->manifest
     '("font-adobe-source-han-sans"
       "imagemagick"
       "pulseaudio"
       "gparted"
       "vlc"
       "gcompris-qt"
       "gnome-disk-utility"
       <<desktop-pkgs>>))
  #+end_src
- creative
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/creative.scm")
    (specifications->manifest
     '(;; "krita"
       <<creative-pkgs>>))
  #+end_src
- devel (software development)
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/devel.scm")
    (specifications->manifest
     '("binutils"
       "make"
       "llvm"
       "cmake"
       "libtool"
       "texinfo"
       "shellcheck"
       "global"
       "perl"
       <<devel-pkgs>>))
  #+end_src
- emacs
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/emacs.scm")
    (specifications->manifest
     '("isync"
       <<emacs-pkgs>>
       "stunnel"
       "wordnet"))
  #+end_src
- wine
  #+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/wine.scm")
    (specifications->manifest
     '("wine64"
       "winetricks"))
  #+end_src
*** Activating Profiles

This script accepts a space-separated list of manifest file names (without extension) under the =~/.config/guix/manifests= folder and then installs those profiles for the first time.  For example:

: activate-profiles base emacs

#+begin_src sh :tangle :tangle (expand-file-name ".local/bin/activate-profiles") :shebang #!/bin/sh :tangle-mode (identity #o755)
  GREEN='\033[1;32m'
  RED='\033[1;30m'
  NC='\033[0m'
  GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

  profiles=$*
  if [ $# -eq 0 ]; then
      profiles="$HOME/.config/guix/manifests/*.scm";
  fi

  for profile in $profiles; do
    # Remove the path and file extension, if any
    profileName=$(basename $profile)
    profileName="${profileName%.*}"
    profilePath="$GUIX_EXTRA_PROFILES/$profileName"
    manifestPath=$HOME/.config/guix/manifests/$profileName.scm

    if [ -f $manifestPath ]; then
      echo
      echo -e "${GREEN}Activating profile:" $manifestPath "${NC}"
      echo

      mkdir -p $profilePath
      guix package --manifest=$manifestPath --profile="$profilePath/$profileName"

      # Source the new profile
      GUIX_PROFILE="$profilePath/$profileName"
      if [ -f $GUIX_PROFILE/etc/profile ]; then
          . "$GUIX_PROFILE"/etc/profile
      else
          echo -e "${RED}Couldn't find profile:" $GUIX_PROFILE/etc/profile "${NC}"
      fi
    else
      echo "No profile found at path" $profilePath
    fi
  done
#+end_src
*** Updating Channels

This script makes it easy to update all channels to the latest commit based on an original channel file.

: update-channels

You can use ~/.config/guix/channels.scm to replicate exact packages on another machine with

: guix pull -C ~/.config/guix/channels.scm

#+begin_src sh :tangle (expand-file-name ".local/bin/update-channels") :shebang #!/bin/sh :tangle-mode (identity #o755)
  guix pull --channels=$HOME/.config/guix/base-channels.scm
  guix describe --format=channels > ~/.config/guix/channels.scm
#+end_src
* System Components
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:14]
:END:
** Font
:PROPERTIES:
:CREATED:  [2022-09-07 Wed 19:08]
:END:

*** Fontconfig

#+begin_src scheme :noweb-ref desktop-pkgs
  "fontconfig"
#+end_src

#+begin_src scheme :noweb-ref desktop-pkgs
  "font-ipa-ex"
  "font-google-noto"
  "font-inconsolata"
#+end_src

#+begin_src shell :noweb-ref apt-pkgs :noweb-sep " \\\n" :tangle no
  fonts-ipafont-mincho fonts-ipafont-gothic
#+end_src

#+begin_src xml :noweb tangle :tangle (expand-file-name ".config/fontconfig/fonts.conf")
  <?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <dir><<home-dir()>>/.guix-extra-profiles/desktop/desktop/share/fonts</dir>
  </fontconfig>
#+end_src

install available fonts by rescanning font directories
#+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  fc-cache -rvf
#+end_src

*** Font Viewer
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:24]
:END:

#+begin_src scheme
  "gnome-font-viewer"
#+end_src

** Bash

#+begin_src scheme :noweb-ref base-pkgs
  "bash"
#+end_src

- bash profile
  #+BEGIN_SRC shell :tangle (expand-file-name ".bash_profile")
    #!/usr/bin/env bash

    if [ -f ~/.bashrc ]; then
       source ~/.bashrc
    fi
  #+END_SRC
- bashrc
  #+BEGIN_SRC shell :noweb yes :tangle (expand-file-name ".bashrc")
    #!/usr/bin/env bash

    if [ -f ~/.bashrc.secret ]; then
       source ~/.bashrc.secret
    fi

    export VIEWER=less

    USER_PATHS=(
      "${HOME}/usr/bin"
      "${HOME}/.local/bin"
    )
    for path in "${USER_PATHS[@]}"; do
      if [ -d "${path}" ]; then
        export PATH="${path}:$PATH"
      fi
    done

    if [ -e $HOME/.bash_aliases ]; then
      source $HOME/.bash_aliases
    fi
    if [ -e $HOME/.bash_functions ]; then
      source $HOME/.bash_functions
    fi

    # prompt
    MACHINE=$(echo $(uname -n) | awk -F . '{print $1}')
    PS1="[\u@${MACHINE}:\\W]\n\$ "

    # function/variable used in libvterm/emacs
    vterm_printf(){
      if [ -n "$TMUX" ]; then
        # Tell tmux to pass the escape sequences through
        # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
      elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
      else
        printf "\e]%s\e\\" "$1"
      fi
    }

    vterm_prompt_end(){
      vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
    }

    PROMPT_COMMAND='echo -ne "\033]0;${HOSTNAME}:${PWD}\007"'

    case ${TERM} in
    dumb)
      ;;
    xterm-256color)
      export LANG=en_US.UTF-8
      PS1=$PS1'\[$(vterm_prompt_end)\]'
      ;;
    ,*)
      export LANG=ja_JP.UTF-8
      ;;
    esac

    export WINEARCH=win64
    export WINEPREFIX=~/.wine

    <<bashrc>>
  #+END_SRC
- aliases
  #+begin_src shell :tangle (expand-file-name ".bash_aliases")
    alias ..="cd ../"
    alias l="ls -F"
    alias ll="l -lh"
    alias la="l -a"
    alias lal="l -alh"
    alias lld="l -ld"
    alias cp="cp -i"
    alias mv="mv -i"
    alias rm="rm -i"
    alias rmf="rm -rf"
    alias mkdir="mkdir -pv"
    alias rmdir="rmdir -v"
    alias ff='find . -type f -iname'

    alias cputemp='cat /sys/class/thermal/thermal_zone0/temp'
    alias ipaddr="hostname -I | cut -f1 -d' '"
  #+end_src
- functions
  #+begin_src shell :tangle (expand-file-name ".bash_functions")
    function cl() {
        DIR="$*";
            # if no DIR given, go home
            if [ $# -lt 1 ]; then
              DIR=$HOME;
        fi;

        builtin cd "${DIR}" && \
          # use your preferred ls command
          ls -F --color=auto
    }

    function cpuinfo {
      cores=$(nproc)
      frequency=$(grep MHz /proc/cpuinfo | head -1 | awk -F ' ' '{print $4" MHz"}')
      model=$(grep "model name" /proc/cpuinfo | head -1 | sed -r 's/^.{13}//')
      echo "CPU Model: $model"
      echo "CPU Cores: $cores"
      echo "Frequency: $frequency"
    }

    function dual() {
      if [ $# -eq 0 ]; then
        du_arg="./* ./.[^.]*"
      else
        du_arg=""
        for v in "$@"
        do
          if [ -f ${v} ]; then
            du_arg="${du_arg} ${v}"
          elif [ -d ${v} ]; then
            du_arg="${du_arg} ${v}/* ${v}/.[^.]*"
          fi
        done
      fi

      ionice -c2 -n7 nice -n19 du -scD ${du_arg} 2>/dev/null
    }
    export -f dual

    function mkcdir() {
      mkdir -p -- "$1" && cd -P -- "$1"
    }

    function rms() {
      read -p 'shred all files - are you sure (y/n) ? ' ans
      test x$ans == xy && (
        for file in "$@"; do
          if [ -f "${file}" ]; then
            shred -uzv "${file}"
          elif [ -d "${file}" ]; then
            find "${file}" -type f -exec shred -uzv {} \;
            rm -rf "${file}"
          fi
        done
      )
    }

    # A simple script to check on system resources
    function chksys() {
      clear

      echo "Memory Usage:"
      /usr/bin/free -h

      echo $'\n'$"Disk Usage:"
      /bin/df -h /dev/sd[a-z][1-9] 2>/dev/null

      echo $'\n'$"Uptime:"
      /usr/bin/uptime
    }
  #+end_src
- profile
  #+BEGIN_SRC shell :tangle (expand-file-name ".profile")
    # ~/.profile: executed by the command interpreter for login shells.
    # This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
    # exists.
    # see /usr/share/doc/bash/examples/startup-files for examples.
    # the files are located in the bash-doc package.

    # the default umask is set in /etc/profile; for setting the umask
    # for ssh logins, install and configure the libpam-umask package.
    #umask 022

    # if running bash
    if [ -n "$BASH_VERSION" ]; then
        # include .bash_profile if it exists
        if [ -f "$HOME/.bash_profile" ]; then
            . "$HOME/.bash_profile"
        fi
    fi

    # set PATH so it includes user's private bin if it exists
    if [ -d "$HOME/bin" ] ; then
        PATH="$HOME/bin:$PATH"
    fi

    # set PATH so it includes user's private bin if it exists
    if [ -d "$HOME/.local/bin" ] ; then
        PATH="$HOME/.local/bin:$PATH"
    fi
  #+END_SRC
** Systemd

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/start-systemd-services") :shebang #!/bin/sh :tangle-mode (identity #o755)
  <<systemd-service>>
#+end_src

*** systemd-tmpfiles

[[https://www.freedesktop.org/software/systemd/man/systemd-tmpfiles-setup.service.html][systemd-tmpfiles]] manages file creation and deletion. In this section, all settings focus on user level file cleanup and deletion under /home directory.

You may need to enable systemd-tmpfiles service for user
: $ cd /usr/lib/systemd/user
: $ cp systemd-tmpfiles-* ~/.config/systemd/user/
#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
  systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/user-tmpfiles.d/cleanup.conf")
  D <<home-dir()>>/.local/share/Trash/files 0700 - - 1w
  d <<home-dir()>>/tmp 0755 - - 5d
  d <<home-dir()>>/Downloads 0755 - - 4w
  <<tmpfiles-cleanup>>
#+end_src

** Vixie Cron

#+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  crontab -r
  crontab <<home-dir()>>/.config/crontab/pc
#+end_src

#+begin_src conf :noweb yes :tangle (expand-file-name ".config/crontab/pc")
  MAILTO="<<email()>>"

  BIN_DIR="<<home-dir()>>/bin"
  LOG_DIR="<<home-dir()>>/.local/state/log"

  <<cronjob-pc>>
#+end_src

** Btrfs

Btrfs is a CoW (Copy on Write) file system supports snapshot and send/recv mechanism.

#+begin_src scheme :noweb-ref base-pkgs
  "btrfs-progs"
#+end_src

*** btrbk

[[https://digint.ch/btrbk/doc/btrbk.1.html][Btrbk]] supports for taking snapshots and backups

#+begin_src scheme :noweb-ref base-pkgs
  "btrbk"
#+end_src

**** btrbk.conf

[[https://digint.ch/btrbk/doc/btrbk.conf.5.html][btrbk.conf documentation]]

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/btrbk/btrbk.conf")
  snapshot_dir snapshots
  timestamp_format long
  incremental yes

  volume /mnt/home
    subvolume incumbents/home
      snapshot_name home-local
      snapshot_preserve 36h 3d 2w
      snapshot_preserve_min 6h
    subvolume incumbents/home
      snapshot_name home-backup
      target send-receive /mnt/exbak/backups
      target_preserve 10w 6m 1y
      target_preserve_min latest
#+end_src

**** snapshot/backup script

- snapshot
  #+begin_src conf :noweb yes :noweb-ref cronjob-pc
    */15 * * * * /bin/bash -ci "pwsudo btrbk --config ~/.config/btrbk/btrbk.conf --loglevel error snapshot *-local >> $LOG_DIR/snaphome.log 2>&1"
  #+end_src

- backup

  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/bkhome") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
    BTRBK_CONF=~/.config/btrbk/btrbk.conf

    pwsudo btrbk --config "${BTRBK_CONF}" --dry-run run *-backup \
     && pwsudo btrbk --config "${BTRBK_CONF}" run *-backup
  #+end_src

  #+begin_src conf :noweb yes :noweb-ref cronjob-pc
    30 * * * * /bin/bash -ci "bkhome >> $LOG_DIR/bkhome.log 2>&1"
  #+end_src

*** snapshots management                      :ARCHIVE:

A structure described below is expected under all devices.

/mountpoint/
├── backups
├── incumbents
└── snapshots

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_snap") :tangle-mode (identity #o755)
  #!/usr/bin/env bash
  set -euo pipefail

  DATETIME=`date "+%Y%m%d-%H%M"`
  BTRFS_MNTS=("/mnt/ssd01"
              "/mnt/nvme01")

  # back up server data beforehand
  ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit" \
    && rsync -arhv sv04:~/var/backup ~/share/sv04

  # take snapshots for all btrfs subvolumes
  for btrfs_mnt in ${BTRFS_MNTS[@]}; do
    if mountpoint ${btrfs_mnt} >/dev/null 2>&1; then
      for subv in ${btrfs_mnt}/incumbents/*; do
        subv_base=$(basename ${subv})
        if [ ! -d "${btrfs_mnt}/snapshots/${subv_base}" ]; then
          mkdir -p "${btrfs_mnt}/snapshots/${subv_base}"
        fi
        btrfs subvolume snapshot "${subv}" "${btrfs_mnt}/snapshots/${subv_base}/${DATETIME}"
      done
    fi
  done
  #+end_src

*** backup to another device                  :ARCHIVE:

: $ btrfs_back

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_back") :tangle-mode (identity #o755)
  #!/usr/bin/env bash
  set -euo pipefail

  MNT_SSD=/mnt/ssd01
  MNT_HDD=/mnt/hdd01

  function backup_subvol() {
    local _src_snap_dir=$1
    local _src_back_dir=$2
    local _dst_back_dir=$3

    echo "Name: $(basename ${_src_back_dir})"

    mkdir -pv "${_src_back_dir}"
    mkdir -pv "${_dst_back_dir}"

    src_back_last=$((ls -d "${_src_back_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename) || echo -n "")
    snap_last=$(ls -d "${_src_snap_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename || echo -n "")

    # create readonly clone of last snapshot
    if [[ "${src_back_last}" < "${snap_last}" ]]; then
      echo btrfs subv snap -r "${_src_snap_dir}/${snap_last}" "${_src_back_dir}/${src_back_last}"
    fi

    exit;

    # determine parent btrfs subvolume
    parent=
    dst_backs=$(ls -d "${_dst_back_dir}"/* 2>/dev/null | sort || echo -n "")
    if [ ${#dst_backs} -ne 0 ]; then
      for dst_back in "${dst_backs[@]}"; do
        test=$(basename ${dst_back})
        if [ -d "${_src_back_dir}/${test}" ]; then
          parent=${test}
        fi
      done
    fi

    # determine subvolume to send in source device
    subvol=
    if [ ${#src_back_last} -ne 0 ]; then
      if [[ "${parent}" < "${src_back_last}" ]] && [ ! -d "${_dst_back_dir}/${src_back_last}" ]; then
        subvol=${src_back_last}
      fi
    fi

    echo "Parent: ${parent}"
    echo "Subvol: ${subvol}"

    if [ -n "${parent}" ] && [ -n "${subvol}" ]; then
      echo "Invoke incremental backup"
      sudo btrfs send -p "${_src_back_dir}/${parent}" "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
    elif [ -z "${parent}" ] && [ -n "${subvol}" ]; then
      echo "Invoke full backup"
      sudo btrfs send "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
    fi

    echo "--------"
  }

  backup_subvol "${MNT_SSD}"/snapshots/doc "${MNT_SSD}"/backups/doc "${MNT_HDD}"/backups/doc
  # backup_subvol "${MNT_SSD}"/snapshots/share "${MNT_SSD}"/backups/share "${MNT_HDD}"/backups/share
#+end_src
** XDG

#+begin_src scheme :noweb-ref base-pkgs
  "xdg-utils"
#+end_src

*** xdg-mime
- ask default application for text/plain
  : $ xdg-mime query default text/plain

#+begin_src conf :tangle (expand-file-name ".config/mimeapps.list") :tangle-mode (identity #o644)
  [Added Associations]
  inode/directory=io.github.celluloid_player.Celluloid.desktop;nemo.desktop;

  [Default Applications]
  inode/directory=nemo.desktop
#+end_src

** GnuPG (gpg)
[[https://wiki.archlinux.org/title/GnuPG][
GnuPG - ArchWiki]]

- gpg config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg.conf")
    with-keygrip
  #+end_src
- gpg-agent config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg-agent.conf")
    # pinentry-program /usr/bin/pinentry-curses
    pinentry-program /usr/bin/pinentry
    allow-emacs-pinentry
    allow-loopback-pinentry
    enable-ssh-support
    max-cache-ttl <<hours-in-sec(h=700)>>
    default-cache-ttl <<hours-in-sec(h=700)>>
    default-cache-ttl-ssh <<hours-in-sec(h=48)>>
  #+end_src
- mandatory config to use pinentry-curses for gpg-agent

  #+begin_src shell :noweb-ref bashrc
    export GPG_TTY=$(tty)

    # Refresh gpg-agent tty in case user switches into an X session
    gpg-connect-agent updatestartuptty /bye >/dev/null
  #+end_src

  #+begin_src conf :tangle (expand-file-name ".ssh/config")
    Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
  #+end_src
- utility
  #+name: hours-in-sec
  #+begin_src emacs-lisp :var h=1
    (* h 60 60)
  #+end_src

* Application Configurations
:PROPERTIES:
:header-args+: :tangle-mode (identity #o444)
:END:

** GNU Emacs

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
  export EDITOR="emacsclient -c -a emacs"
#+end_src

*** general configuration

**** early-init.el
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/early-init.el")
:END:

These process must be evaluated beforehand.

***** global variable definitions

#+begin_src emacs-lisp :noweb tangle
  (setf user-emacs-directory
        (expand-file-name "emacs" "<<share-dir()>>"))
  (setf user-emacs-directory-default
        (expand-file-name (file-name-as-directory "~/.emacs.d")))

  (defvar my/user-share-directory "<<share-dir()>>")
#+end_src
***** package.el

#+begin_src emacs-lisp
  (require 'package)

  (customize-set-variable
   'package-archives
   '(("gnu" . "http://elpa.gnu.org/packages/")
     ("melpa" . "http://melpa.org/packages/")))
  (customize-set-variable 'package-enable-at-startup nil)
  (customize-set-variable 'package-user-dir
                          (expand-file-name "elpa" user-emacs-directory-default))

  (package-initialize t)
#+end_src

***** straight.el

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/raxod502/straight.el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (customize-set-variable 'straight-recipes-gnu-elpa-use-mirror t)
  (customize-set-variable 'straight-base-dir user-emacs-directory-default)
  (customize-set-variable 'straight-vc-git-default-clone-depth 1)

  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory-default))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (with-eval-after-load 'hydra
    (defhydra hydra-straight (global-map "C-x -"
                                         :color blue)
      "Straight"
      ("c" straight-check-package)
      ("C" straight-check-all)
      ("r" straight-rebuild-package)
      ("R" straight-rebuild-all)
      ("f" straight-fetch-package)
      ("F" straight-fetch-all)
      ("p" straight-pull-package-and-deps)
      ("P" straight-pull-all)
      ("m" straight-merge-package)
      ("M" straight-merge-all)
      ("n" straight-normalize-package)
      ("N" straight-normalize-all)
      ("u" straight-push-package)
      ("U" straight-push-all)
      ("v" straight-freeze-versions)
      ("V" straight-thaw-versions)
      ("w" straight-watcher-start)
      ("W" straight-watcher-quit)
      ("g" straight-get-recipe)
      ("e" straight-prune-build)
      ("q" nil)))
#+end_src

***** use-package

[[https://jwiegley.github.io/use-package/][Official manual]] is handy especially when you look up [[https://jwiegley.github.io/use-package/keywords/][Keywords]].

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-use-package"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/jwiegley/use-package/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (require 'use-package)

  (customize-set-variable
   'use-package-ensure-function 'straight-use-package-ensure-function)
#+end_src

use-package depends on following packages internally

****** diminish

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-diminish"
#+end_src

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src

****** delight

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-delight"
#+end_src

#+begin_src emacs-lisp
  (use-package delight)
#+end_src

***** load cl-lib

Use 'cl-lib' rather than 'cl' package since it is [[https://www.gnu.org/savannah-checkouts/gnu/emacs/news/NEWS.27.1][officially deprecated]].

#+begin_src emacs-lisp
  (require 'cl-lib)
#+end_src
**** init.el
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/init.el")
:END:

init.el devote itself to call for remaining config files.

#+begin_src emacs-lisp
  (customize-set-variable
   'custom-file
   (expand-file-name "custom.el" user-emacs-directory-default))
  (when (file-exists-p custom-file)
    (load custom-file))

  (dolist (file (directory-files "~/.emacs.d/lisp" t "\.el$"))
    (funcall #'load-file file))
  (dolist (file (directory-files "~/.emacs.d/site-lisp" t "\.el$"))
    (funcall #'load-file file))
  (dolist (file (directory-files "~/.emacs.d/secrets" t "\.el$"))
    (funcall #'load-file file))
  (dolist (file (directory-files "~/.emacs.d/user" t "\.el$"))
    (funcall #'load-file file))
#+end_src
**** Personal Preferences
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/02-preferences.el")
:END:

Settings in this section are influenced a great deal by my personal preference. Please be meticulous when you borrow.

***** Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-o") #'open-line)
  (global-set-key (kbd "M-SPC") #'cycle-spacing)
  (global-set-key (kbd "C-c k") #'kill-this-buffer)
  (global-set-key (kbd "<f5>") #'revert-buffer-quick)
  (global-set-key (kbd "M-z") #'zap-up-to-char)
  (global-set-key (kbd "C-c d") #'copy-from-above-command)

  ;; M-u for `universal-argument'
  (substitute-key-definition 'upcase-word
                             'universal-argument
                             global-map)

  (substitute-key-definition 'upcase-region
                             'upcase-dwim
                             global-map)
  (substitute-key-definition 'downcase-region
                             'downcase-dwim
                             global-map)
  (global-set-key (kbd "C-x C-c") #'capitalize-dwim)

  ;; suppress prompting in (up/down)case-region
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

- Bind for C-x C-b, use [[help:ibuffer][ibuffer]] which has more features than [[help:list-buffers][list-buffers]] based on [[https://irreal.org/blog/?p=10329][this advice]].
  #+begin_src emacs-lisp
    (substitute-key-definition 'list-buffers
                               'ibuffer
                               global-map)
  #+end_src
- lambda-key
  [[https://www.emacswiki.org/emacs/DocumentingKeyBindingToLambda][lambda-key]] is nice idea to remedy lambda bindings with define-key.

  #+begin_src emacs-lisp
    (defun lambda-key (keymap key def)
      "Wrap`define-key' to provide documentation."
      (set 'sym (make-symbol (documentation def)))
      (fset sym def)
      (define-key keymap key sym))
  #+end_src

***** Language

[[info:emacs#Language Environments][emacs#Language Environments]]

#+begin_src emacs-lisp
  ;; language and locale
  (set-language-environment "Japanese")
  (setq system-time-locale "C")

  ;; coding system
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
  (set-selection-coding-system 'utf-8-unix)

  ;; prefer-coding-system take effect equally to follows
  (set-buffer-file-coding-system 'utf-8-unix)
  (set-file-name-coding-system 'utf-8-unix)
  (set-terminal-coding-system 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (setq locale-coding-system 'utf-8-unix)
#+end_src
***** Startup Conditions

#+begin_src emacs-lisp
  ;; do not use basic GUI facets
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)

  ;; fringe is preferably as thin as possible
  (set-fringe-mode 15)

  ;; do not use visual bell
  (setf visible-bell nil)

  ;; conceal distractions at startup
  (setf initial-scratch-message "")
  (setf inhibit-startup-screen t)

  ;; use emacs in full screen mode
  (use-package emacs
    :no-require t
    :hook
    ((after-init server-after-make-frame) .
     (lambda ()
       (when (member (window-system) '(x ns w32))
         (set-frame-parameter nil 'fullscreen 'fullboth)))))

  ;; enable subword-mode by default
  (global-subword-mode 1)
#+end_src
***** Fontsets

#+begin_src emacs-lisp
  (create-fontset-from-ascii-font "IPAGothic" nil "default")
  (set-fontset-font "fontset-default" 'japanese-jisx0208 "IPAGothic")

  (create-fontset-from-ascii-font "IPAexMincho" nil "exmincho")
  (set-fontset-font "fontset-exmincho" 'japanese-jisx0208 "IPAexMincho")

  (create-fontset-from-ascii-font "IPAexGothic" nil "exgothic")
  (set-fontset-font "fontset-exgothic" 'japanese-jisx0208 "IPAexGothic")

  (create-fontset-from-ascii-font "IPAMincho" nil "mincho")
  (set-fontset-font "fontset-mincho" 'japanese-jisx0208 "IPAMincho")

  (create-fontset-from-ascii-font "Inconsolata" nil "code")
  (set-fontset-font "fontset-code" 'latin (font-spec :family "Inconsolata" :weight 'Regular :width 'SemiCondensed))

  ;; foreign fonts for all fontsets
  (set-fontset-font t 'emoji "Noto Color Emoji")
  (set-fontset-font t 'symbol "Noto Color Emoji")
  (set-fontset-font t 'symbol "Noto Sans CJK JP" nil 'append)
  (set-fontset-font t 'symbol "Noto Sans Symbols" nil 'append)
  (set-fontset-font t 'symbol "Noto Sans Symbols2" nil 'append)
#+end_src

***** Faces
:PROPERTIES:
:CREATED:  [2022-09-11 Sun 16:55]
:END:

Caveat: There are some face definitions which use an extra large font since I am [[https://en.wikipedia.org/wiki/Visual_impairment][visually impaired]].

#+begin_src emacs-lisp
  (defvar my/default-pixel-width 2560 "Default display width in pixel.")
  (defmacro my/normalized-font-size (original-size)
    "THis macro culculates normalized font size for display resolution at runtime.
  It tries to proportionate ORIGINAL-SIZE in `my/default-pixel-width' in the display at runtime."
    `(truncate (* ,original-size (/ (float (x-display-pixel-width))
                                    ,my/default-pixel-width))))

  (set-face-attribute 'default
                      nil
                      :font "fontset-default"
                      :height (my/normalized-font-size 630))
  (set-face-attribute 'fixed-pitch
                      nil
                      :font "fontset-default")
  (set-face-attribute 'variable-pitch
                      nil
                      :font "fontset-exmincho")

  (use-package face
    :no-require t
    :hook
    ((eww-mode twittering-mode nov-mode mu4e-view-mode elfeed-show-mode)
     . (lambda ()
         (buffer-face-set
          (or (ignore-errors (check-face 'my/reading-face))
              (defface my/reading-face `((t . (:font "fontset-exgothic"
                                                     :height ,(my/normalized-font-size 850))))
                "My customized face offers great legibility for reading articles.")))))
    ((Info-mode help-mode helpful-mode woman-mode)
     . (lambda ()
         (buffer-face-set
          (or (ignore-errors (check-face 'my/document-face))
              (defface my/document-face `((t . (:font "fontset-default"
                                                      :height ,(my/normalized-font-size 720))))
                "My customized face offers large fixed fonts for documentations.")))))
    ((org-mode text-mode mu4e-compose-mode)
     . (lambda ()
         (buffer-face-set
          (or (ignore-errors (check-face 'my/writing-face))
              (defface my/writing-face `((t . (:font "fontset-default"
                                                     :height ,(my/normalized-font-size 655))))
                "My customized face offers relatively small fixed fonts for writing.")))))
    ((prog-mode shell-mode term-mode vterm-mode eshell-mode calendar-mode)
     . (lambda ()
         (buffer-face-set
          (or (ignore-errors (check-face 'my/code-face))
              (defface my/code-face `((t . (:font "fontset-code"
                                                  :height ,(my/normalized-font-size 640))))
                "My customized face offers condensed fonts for programming code.")))))
    ((dired-mode mu4e-headers-mode elfeed-search-update)
     . (lambda ()
         (buffer-face-set
          (or (ignore-errors (check-face 'my/list-face))
              (defface my/list-face `((t . (:font "fontset-mincho"
                                                  :height ,(my/normalized-font-size 670))))
                "My customized face offers variable pitch fonts for displaying lists."))))))
#+end_src

***** Modifier Keys

#+begin_src emacs-lisp
  (cond
   ((string= window-system "x")
    (setf x-alt-keysym  'alt
          x-meta-keysym 'meta))
   ((string= window-system "ns")
    ;; IME inline patch
    (setf mac-use-input-method-on-system nil)
    (setf mac-control-modifier       'control
          mac-command-modifier       'meta
          mac-option-modifier        'super
          mac-right-option-modifier  'alt
          mac-right-control-modifier 'super
          mac-function-modifier      'hyper)))
#+end_src

***** Performance Tuning
:PROPERTIES:
:CREATED:  [2022-09-16 Fri 12:08]
:END:

#+begin_src emacs-lisp
  (setq-default bidi-display-reordering nil)
#+end_src

**** Custom Variables
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/01-custom.el")
:ID:       587bc395-6321-4f59-97e6-6f0b62518b20
:END:

Entries in this section represnets [[info:emacs#Customization Groups][Customization Groups]] hierarchy.

***** Files

#+begin_src emacs-lisp
  (customize-set-variable 'create-lockfiles nil)
  (customize-set-variable 'remote-file-name-inhibit-locks t)
#+end_src

****** Auto Revert

[[info:emacs#Auto Revert][Auto Revert]]: Keeping buffers automatically up-to-date.

#+begin_src emacs-lisp
  (use-package autorevert
    :diminish (global-auto-revert-mode auto-revert-mode)
    :custom
    (auto-revert-verbose nil)
    (global-auto-revert-non-file-buffers t)
    (auto-revert-interval 3)
    (global-auto-revert-mode t))
#+end_src

****** Auto Save

System crashing jeopardizes our precious text data. Emacs [[info:emacs#Auto Save][auto saving mechanism]] come to the rescue.

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
  d <<share-dir()>>/emacs/auto-save-list 0755 - - 2w
#+end_src

#+begin_src emacs-lisp
  (customize-set-variable 'auto-save-interval 200)
  (customize-set-variable 'auto-save-timeout 25)
  (customize-set-variable 'auto-save-default nil)
  (customize-set-variable 'auto-save-list-file-prefix
                          (file-name-concat user-emacs-directory "auto-save-list/.saves-"))

  (customize-set-variable 'auto-save-visited-mode t)
  (customize-set-variable 'auto-save-visited-interval 900)
  (put 'auto-save-visited-mode 'disabled nil)

  (customize-set-variable 'delete-by-moving-to-trash t)
  (customize-set-variable 'delete-auto-save-files t)
  (customize-set-variable 'kill-buffer-delete-auto-save-files t)
  (customize-set-variable 'save-some-buffers-default-predicate 'save-some-buffers-root)
#+end_src

****** Uniquify

[[info:emacs#Uniquify][Uniquify]] shows buffer name easy to distinguish.

#+begin_src emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'post-forward))
#+end_src

****** Recentf

[[info:emacs#File Conveniences][emacs#File Conveniences]]

#+begin_src emacs-lisp
  (use-package recentf
    :custom
    (recentf-exclude '(".gz" ".xz" ".zip" ".gpg"))
    (recentf-max-saved-items 200)
    (recentf-max-menu-items 15)
    (recentf-auto-cleanup "1:23am")
    :config
    (recentf-mode 1))
#+end_src
****** Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :defer t
    :custom
    (tramp-default-method "ssh")
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
    (add-to-list 'tramp-remote-path "~/bin"))

  (defun sudo ()
    "Use TRAMP to `sudo' the current buffer"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+end_src
****** Find File

#+begin_src emacs-lisp
  (customize-set-variable
   'revert-buffer-quick-short-answers t)

  (add-to-list 'safe-local-eval-forms
               '(add-hook 'after-save-hook
                          #'my/compile-default-command nil t))
  (add-to-list 'safe-local-eval-forms
               '(add-hook 'magit-mode-hook
                          #'my/compile-default-command nil t))
#+end_src

***** Environment

****** Frames
******* Cursor

#+begin_src emacs-lisp
  (customize-set-variable 'blink-cursor-blinks 15)
  (customize-set-variable 'blink-cursor-delay 0.7)
  (customize-set-variable 'blink-cursor-interval 0.35)
  (customize-set-variable 'blink-cursor-mode t)
#+end_src

****** Display

#+begin_src emacs-lisp
  (customize-set-variable 'text-scale-mode-step 1.0625)
  (customize-set-variable 'highlight-nonselected-windows t)
  (customize-set-variable 'truncate-lines t)
  ;; avoid to break at whitespace in Japanese
  (customize-set-variable 'word-wrap-by-category t)
  ;; suppress curved quotes in docstring (for emacs25)
  (customize-set-variable 'text-quoting-style 'straight)
#+end_src

****** Windows

[[https://www.masteringemacs.org/article/demystifying-emacs-window-manager?utm_source=newsletter&utm_medium=email&utm_campaign=rss][This blog post]] is must-read when you tweak display-buffer facilities or something related to display settings.

#+begin_src emacs-lisp
  (customize-set-variable 'scroll-step 1)
  (customize-set-variable 'next-screen-context-lines 2)
  ;; display buffer
  (customize-set-variable 'display-buffer-base-action
                          '((display-buffer-same-window
                             display-buffer-reuse-window
                             display-buffer-reuse-mode-window
                             display-buffer-in-previous-window)))
#+end_src

******* Winner

Triple Escape (M-ESC ESC) has got to reset window layout by tweaking buffer-quit-function.

#+begin_src emacs-lisp
  (use-package winner
    :bind (("C-z" . winner-undo)
           ("C-M-z" . winner-redo))
    :custom
    (winner-mode t)
    :config
    (setq buffer-quit-function 'winner-undo))
#+end_src

******* Windmove

You can now switch windows with your shift key by pressing S-<left>, S-<right>, S-<up>, S-<down>.

#+begin_src emacs-lisp
  (use-package windmove
    :custom
    (windmove-mode t)
    (windmove-wrap-around t)
    :config
    (windmove-default-keybindings '(control shift)))
#+end_src

****** Minibuffer

#+begin_src emacs-lisp
  (define-key minibuffer-mode-map
    (kbd "C-h") #'delete-backward-char)
  (define-key minibuffer-mode-map
    (kbd "M-h") #'backward-kill-word)

  (customize-set-variable 'history-length 300)
  (customize-set-variable 'history-delete-duplicates t)
  (customize-set-variable 'enable-recursive-minibuffers t)
  (customize-set-variable 'minibuffer-depth-indicate-mode t)
  (customize-set-variable 'read-file-name-completion-ignore-case t)
  (customize-set-variable 'read-minibuffer-restore-windows t)
  (customize-set-variable 'minibuffer-default-prompt-format " [%s]")

  (add-hook 'minibuffer-setup-hook 'my/minibuffer-setup-function)
  (defun my/minibuffer-setup-function ()
    ;; disable input method in mini buffer
    (when current-input-method
      (deactivate-input-method))
    ;; decrease font size to 90% in minibuffer
    (setq-local face-remapping-alist '((default :height 0.9))))
#+end_src


******* Savehist

[[help:savehist-mode][savehist-mode]] saves minibuffer history and additionals.

#+begin_src emacs-lisp
  (use-package savehist
    :custom
    (savehist-save-minibuffer-history t)
    (savehist-additional-variables '(kill-ring))
    :config
    (savehist-mode 1))
#+end_src

****** Menu

[[https://christiantietze.de/posts/2022/12/use-file-open-dialog-for-file-actions/][This blog post]] demonstrates for emacsers who have disabled file pickers and dialog boxes to adversely use them temporalily.

#+begin_src emacs-lisp
  (customize-set-variable 'use-short-answers t)
  (customize-set-variable 'use-file-dialog nil)
#+end_src

****** Mode Line

#+begin_src emacs-lisp
  (defvar my/mode-line-buffer-name-length-max 15
    "Fixed length for displaying buffer name in mode line.")

  (customize-set-variable 'line-number-mode nil)
  (customize-set-variable 'column-number-mode nil)
  (customize-set-variable 'mode-line-compact t)
  (customize-set-variable
   'mode-line-format
   '("%e"
     mode-line-front-space
     (:eval
      (let ((mode-line-buffer-name
             (replace-regexp-in-string " %\\([[:ascii:]]\\)" " %%\\1"
                                       (truncate-string-to-width
                                        (buffer-name) my/mode-line-buffer-name-length-max nil ? t))))
        (cond
         (buffer-read-only
          (propertize mode-line-buffer-name 'face 'underline))
         ((buffer-modified-p)
          (propertize mode-line-buffer-name 'face 'warning))
         (mode-line-buffer-name))))
     (:eval
      (cond
       ((and line-number-mode
             column-number-mode)
        mode-line-position-column-line-format)
       (line-number-mode mode-line-position-line-format)
       (column-number-mode mode-line-position-column-format)))
     " "
     global-mode-string))
#+end_src

******* Display Time

#+begin_src emacs-lisp
  (customize-set-variable
   'display-time-string-forms
   '((propertize (format-time-string "%H:%M" now) 'face 'mode-line-highlight)))
  (customize-set-variable 'display-time-mode t)
#+end_src

****** Mouse

Mouse needs to be unobtrusive in my Emacs experience.

#+begin_src emacs-lisp
  (use-package mouse
    :custom
    (mouse-1-click-follows-link nil)
    (mouse-highlight nil)
    (mouse-wheel-mode nil))
#+end_src

***** Convenience

#+begin_src emacs-lisp
  (require 'repeat)

  (customize-set-variable 'repeat-mode t)
#+end_src

****** Abbreviations

#+begin_src emacs-lisp
  (use-package abbrev
    :diminish abbrev-mode
    :custom
    (save-abbrevs t)
    :config
    (setq-default abbrev-mode t)
    (setf abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory))
    (quietly-read-abbrev-file))
#+end_src

****** Hippie Expand

[[https://www.masteringemacs.org/article/text-expansion-hippie-expand][As this post mentions]], Hippie Expansion is superior for auto typing to dabbrev, skeleton, and even company.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :config
    (global-set-key [remap dabbrev-expand] 'hippie-expand))
#+end_src

****** Hl Line

#+begin_src emacs-lisp
  (use-package hl-line
    :hook (vterm-mode . (lambda () (hl-line-mode -1)))
    :config
    (hl-line-mode 1))
#+end_src
****** Visual Line

#+begin_src emacs-lisp
  (use-package visual-line
    :no-require t
    :after adaptive-wrap
    :hook
    ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode mu4e-view-mode nov-mode twittering-mode)
     . visual-line-mode)
    ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode mu4e-view-mode nov-mode twittering-mode)
     . adaptive-wrap-prefix-mode)
    :custom
    (global-visual-line-mode nil))
#+end_src

****** Whitespace

[[info:emacs#Useless Whitespace][emacs#Useless Whitespace]]

#+begin_src emacs-lisp
  (use-package whitespace
    :diminish ((global-whitespace-mode . "Ws")
               (whitespace-mode . "ws"))
    :hook
    ((org-mode prog-mode dired-mode) . whitespace-mode)
    (eww-mode . whitespace-turn-off)
    (before-save . delete-trailing-whitespace)
    :custom
    (whitespace-style
     '(face trailing tabs tab-mark spaces space-mark empty missing-newline-at-eof))
    (whitespace-space-regexp "\\(\x3000+\\)")
    (whitespace-trailing-regexp "\\([ \t\u00A0]+\\)$")
    (whitespace-display-mappings
     '((space-mark ?\x3000 [?\u2423])
       (tab-mark   ?\t   [?\u00BB ?\t])))
    (global-whitespace-mode nil))
#+end_src

****** So Long

#+begin_src emacs-lisp
  (require 'so-long)

  (customize-set-variable 'global-so-long-mode t)
#+end_src

****** Tab Bar

#+begin_src emacs-lisp
  (use-package tab-bar
    :hook (after-init . (lambda ()
                          (define-key ctl-x-map "t" tab-prefix-map)))
    :custom
    (tab-bar-mode t)
    (tab-bar-show 2)
    (tab-bar-history-mode t)
    (tab-bar-tab-hints t)
    :config
    (global-set-key (kbd "M-[") 'tab-bar-history-back)
    (global-set-key (kbd "M-]") 'tab-bar-history-forward))
#+end_src

****** Ffap

#+begin_src emacs-lisp
  (require 'ffap)

  (ffap-bindings)
#+end_src

****** Kmacro

The power of keyboard macro is more than repeating editing commands. [[https://masteringemacs.org/article/keyboard-macros-are-misunderstood][This post explains fluently]].

#+begin_src emacs-lisp
  (require 'kmacro)

  (defalias 'kmacro-insert-macro 'insert-kbd-macro)
  (define-key kmacro-keymap (kbd "I") #'kmacro-insert-macro)
#+end_src

***** Editing

****** Indent

See also [[id:4a58219c-74dd-4135-b56d-876b0db2cd83][aggressive-indent-mode]]

#+begin_src emacs-lisp
  (customize-set-variable 'tab-always-indent 'complete)
  (customize-set-variable 'indent-tabs-mode nil)
  (customize-set-variable 'tab-first-completion 'word-or-paren-or-punct)
#+end_src

****** Electricity

#+begin_src emacs-lisp
  (customize-set-variable 'electric-indent-mode 1)
#+end_src

****** Fill

#+begin_src emacs-lisp
  (customize-set-variable 'fill-column 80)
  (customize-set-variable 'sentence-end-double-space nil)
#+end_src

****** Killing

#+begin_src emacs-lisp
  (customize-set-variable 'yank-pop-change-selection t)
#+end_src

****** Undo

The older undo step which exceeds [[help:undo-limit][undo-limit]] in byte is eliminated at garbage collection.
The oldest undo step, if undo info exceeds [[help:undo-strong-limit][undo-strong-limit]] in total, is removed instantaneously.
No more new undo step than [[help:undo-outer-limit][undo-outer-limit]] could not be registered.

#+begin_src emacs-lisp
  (customize-set-variable 'undo-limit 320000)
  (customize-set-variable 'undo-strong-limit 480000)
  (customize-set-variable 'undo-outer-limit 48000000)
  (customize-set-variable 'undo-no-redo t)
#+end_src

****** Matching
******* Isearch

#+begin_src emacs-lisp
  (provide 'isearch)

  (customize-set-variable 'isearch-allow-motion t)

  (define-key isearch-mode-map (kbd "C-j") #'isearch-exit)
#+end_src

******* Bookmark

#+begin_src emacs-lisp
  (use-package bookmark
    :bind ("C-c b" . bookmark-jump)
    :custom
    (bookmark-menu-confirm-deletion t)
    (bookmark-watch-bookmark-file 'silent))
#+end_src

***** Multimedia

****** Image

[[https://xenodium.com/emacs-viewing-webp-images/][This post]] teaches me how to enable converting external formats (i.e. webp) to internal ones.

#+begin_src emacs-lisp
  (use-package image
    :custom
    (image-use-external-converter t))
#+end_src

***** Development

****** Internal
******* Storage Allocation

#+begin_src emacs-lisp
  (customize-set-variable 'gc-cons-threshold (* 10 gc-cons-threshold))
#+end_src

****** Lisp
******* Shortdoc

#+begin_src emacs-lisp
  (use-package shortdoc
    :bind ("<help> D" . shortdoc-display-group))
#+end_src

******* Re Builder

#+begin_src emacs-lisp
  (use-package re-builder
    :custom
    (reb-re-syntax 'string))
#+end_src

******* Comp

For [[info:elisp#Native Compilation][native compilation feature]] introduced at Emacs 28.1.

#+begin_src emacs-lisp
  (use-package comp
    :custom
    (native-comp-async-report-warnings-errors 'silent)
    (native-comp-async-query-on-exit t))
#+end_src

******* Eldoc

#+begin_src emacs-lisp
  (require 'eldoc)

  (customize-set-variable 'eldoc-echo-area-display-truncation-message nil)
  (customize-set-variable 'eldoc-echo-area-prefer-doc-buffer 'maybe)
#+end_src

****** Debug

#+begin_src emacs-lisp
  (customize-set-variable 'message-log-max 10000)
#+end_src

***** Data

****** Save Place

File-related tweaks including [[info:emacs#Customize Save][Customizing Saving of Files]].

#+begin_src emacs-lisp
  (require 'saveplace)

  (customize-set-variable 'save-place-abbreviate-file-names t)
  (customize-set-variable 'save-place-version-control t)
  (customize-set-variable 'save-place-mode t)
#+end_src

****** Compression

- Jka Compr (auto compression mode)
  #+begin_src emacs-lisp
    (customize-set-variable 'auto-compression-mode t)
  #+end_src

****** Tar

#+begin_src emacs-lisp
  (require 'tar-mode)
#+end_src

****** Archive

#+begin_src emacs-lisp
  (require 'archive-mode)
#+end_src

***** Editing Basics

#+begin_src emacs-lisp
  (customize-set-variable 'seft-mark-command-repeat-pop t)
  (customize-set-variable 'mark-ring-max 32)
  ;; delsel
  (customize-set-variable 'delete-selection-mode t) ; inserted text replaces the text in region
  ;; files
  (customize-set-variable 'mode-require-final-newline 'visit-save)
  (customize-set-variable 'make-backup-files nil)
  (customize-set-variable 'delete-auto-save-files t)
  (customize-set-variable 'enable-remote-dir-locals t)
#+end_src

***** External

****** EasyPG (epg)

#+begin_src emacs-lisp
  (use-package epg
    :custom
    (epg-pinentry-mode 'loopback))
#+end_src

****** Server

#+begin_src emacs-lisp
  (use-package server
    :custom
    (server-client-instructions t)
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

****** Processes
******* Proced

[[https://www.masteringemacs.org/article/displaying-interacting-processes-proced][This blog post]] explains how to use proced, process monitoring package for emacs.

#+begin_src emacs-lisp
  (use-package proced
    :no-require t
    :custom
    (proced-auto-update-flag t)
    (proced-auto-update-interval 3))
#+end_src

****** Browse Url

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-o") #'browse-url-at-point)
#+end_src

****** locate

#+begin_src emacs-lisp :noweb yes
  (use-package locate
    :custom
    (locate-command "plocate")
    (locate-make-command-line #'my/plocate-make-command-line)
    (locate-fcodes-file "<<plocate-db()>>")
    (locate-update-path (expand-file-name "~/")))

  (defun my/plocate-make-command-line (search-string)
    (list locate-command "-d" "<<plocate-db()>>" "--ignore-case" "--existing" "--regexp" search-string))
#+end_src

***** Applications

****** Ispell

#+begin_src emacs-lisp
  (use-package flyspell
    :diminish "fs"
    :if (executable-find "aspell")
    :after (hydra)
    :custom
    (ispell-program-name "aspell")
    (flyspell-issue-message-flag nil)
    :config
    ;; avoid checking for Japanese characters
    (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
    (setq-default ispell-extra-args '("--sug-mode=ultra"
                                      "--lang=en_US"))
    (when (string-match-p "--camel-case"
                          (shell-command-to-string (concat ispell-program-name " --help")))
      (push "--camel-case" ispell-extra-args))
    (bind-keys :map flyspell-mode-map
               ("C-,"   . nil)
               ("C-."   . nil)
               ("C-;"   . nil)
               ("C-c $" . nil)
               ("C-M-i" . nil))
    (defhydra hydra-flyspell (flyspell-mode-map "C-c $"
                                                :color red)
      "Flyspell"
      ("c" flyspell-buffer)
      ("n" flyspell-goto-next-error)
      ("." flyspell-auto-correct-word)
      ("q" nil "quit")))
#+end_src

****** News

******* Gnus

******** Auth Source

#+begin_src emacs-lisp
  (use-package auth-source
    :custom
    (auth-source-gpg-encrypt-to `(,user-mail-address))
    :config
    (add-to-list 'auth-sources "~/.netrc.gpg"))

  (use-package auth-source-pass
    :config
    (auth-source-pass-enable))
#+end_src

****** Calc (The GNU Emacs Calculator)

#+begin_src emacs-lisp
  (use-package calc
    :bind ("<f7>" . calc)
    :config
    (setf calc-display-trail nil))
#+end_src
****** Calendar
[[https://github.com/emacs-jp/japanese-holidays/releases.atom][japanese-holidays]]

#+begin_src emacs-lisp
  (use-package calendar
    :commands calendar
    :straight japanese-holidays
    :hook
    ((calendar-today-visible calendar-today-invisible) . japanese-holiday-mark-weekend)
    (calendar-today-visible . calendar-mark-today)
    (calendar-move . my/japanese-holiday-show)
    :custom
    (calendar-left-margin 0)
    (calendar-right-margin 0)
    (calendar-intermonth-spacing 1)
    (calendar-mark-holidays-flag t)
    (japanese-holiday-weekend '(0 6))
    (japanese-holiday-weekend-marker
     '(holiday nil nil nil nil nil japanese-holiday-saturday))
    :config
    (require 'japanese-holidays)
    ;; add 'holiday-general-holidays to calendar-holidays
    ;; if you want holidays in the U.S. to be counted as your holidays.
    (setf calendar-holidays
          (append japanese-holidays holiday-local-holidays holiday-other-holidays))
    (bind-keys :map calendar-mode-map
               ("v" . my/calendar-show-items)))

  (defun my/japanese-holiday-show (&rest _args)
    "Show holiday information in mini buffer if date on which the cursor is any holidays."
    (let* ((date (calendar-cursor-to-date t))
           (calendar-date-display-form '((format "%s年 %s月 %s日（%s）" year month day dayname)))
           (date-string (calendar-date-string date))
           (holiday-list (calendar-check-holidays date)))
      (when holiday-list
        (message "%s: %s" date-string (mapconcat #'identity holiday-list "; ")))))
#+end_src
****** Package

#+begin_src emacs-lisp
  (customize-set-variable 'package-native-compile t)
#+end_src

***** Text

****** View

#+begin_src emacs-lisp
  (use-package view
    :diminish view-mode "vw")
#+end_src

***** Hypermedia
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 16:59]
:END:
****** Dictionary
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 17:01]
:END:

#+begin_src shell :noweb-ref apt-pkgs :noweb-sep " \\\n" :tangle no
  dictd dict \
        dict-gcide dict-wn \
        dict-jargon dict-foldoc dict-vera \
        dict-freedict-eng-jpn dict-freedict-jpn-eng
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
  systemctl start dictd
#+end_src

#+begin_src emacs-lisp
  (customize-set-variable 'dictionary-use-single-buffer t)
  (customize-set-variable 'dictionary-server nil)

  (with-eval-after-load 'dictionary
    (setq switch-to-buffer-obey-display-actions t)
    (add-to-list 'display-buffer-alist
                 '("^\\*Dictionary\\*"
                   display-buffer-in-tab))
    (add-hook 'dictionary-mode-hook
              #'my/lazy-view-enter))
#+end_src

**** Input Methods
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/input-method.el")
:END:

***** ddskk

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-ddskk"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/skk-dev/ddskk/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (defvar skk-dir (expand-file-name "skk" my/user-share-directory))
  (defvar skk-dotemacs-dir (expand-file-name "ddskk" user-emacs-directory-default))

  (use-package ddskk
    :defer t
    :bind ("C-x j" . skk-mode)
    :init
    (customize-set-variable 'default-input-method "japanese-skk")
    (defface skk-candidate `((t . (:font "fontset-default"
                                         :height ,(my/normalized-font-size 860))))
      "Default face for ddskk candidates."
      :group 'skk-dcomp)
    (setq skk-get-jisyo-directory (expand-file-name "get-jisyo" skk-dir))
    :custom
    (skk-kakutei-key (kbd "C-x j"))
    (skk-user-directory (expand-file-name "ddskk" user-emacs-directory))
    (skk-init-file (expand-file-name "skk-init.el" skk-dotemacs-dir))
    (skk-byte-compile-init-file t)
    (skk-tut-file
     (expand-file-name "etc/SKK.tut" (straight--repos-dir "ddskk")))
    ;; cursor color
    (skk-use-color-cursor t)
    (skk-cursor-hiragana-color "orange")
    (skk-cursor-katakana-color "SpringGreen3")
    (skk-cursor-latin-color "DodgerBlue3")
    (skk-cursor-jisx0201-color "purple3")
    ;; mode line string
    (skk-latin-mode-string "A")
    (skk-hiragana-mode-string "あ")
    (skk-katakana-mode-string "ア")
    (skk-jisx0201-mode-string "ｱ")
    (skk-jisx0208-latin-mode-string "Ａ")
    ;; AZIK
    (skk-use-azik t)
    (skk-azik-keyboard-type 'us101)
    ;; conversion
    (skk-egg-like-newline t)
    (skk-henkan-strict-okuri-precedence t)
    (skk-check-okurigana-on-touroku t)
    ;; annotation
    (skk-show-annotation t)
    (skk-annotation-delay 0.3)
    ;; how candidates behave
    (skk-show-candidates-always-pop-to-buffer t)
    (skk-henkan-number-to-display-candidates 10)
    (skk-show-candidates-nth-henkan-char 3)
    (skk-henkan-show-candidates-keys
     '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0))
    ;; set face for candidates list
    (skk-treat-candidate-appearance-function
     (lambda (candidate listing-p)
       (cond
        ((string-match ";" candidate)
         (put-text-property 0 (match-beginning 0)
                            'face 'skk-candidate
                            candidate)
         (put-text-property (match-beginning 0)
                            (length candidate) 'face 'shadow candidate))
        (t
         (put-text-property 0 (length candidate)
                            'face 'skk-candidate
                            candidate)))
       candidate))
    ;; bind C-q for hankaku-kana input mode
    (skk-use-jisx0201-input-method t)
    ;; dynamic conversion
    (skk-dcomp-activate nil)
    (skk-dcomp-multiple-activate nil)
    ;; config file
    (skk-record-file (expand-file-name "record" skk-dir))
    (skk-emacs-id-file (expand-file-name "emacs-id" skk-dir))
    ;; jisyo
    (skk-share-private-jisyo t)
    (skk-compare-jisyo-size-when-saving t)
    (skk-save-jisyo-instantly t)
    ;; jisyo file/directory
    (skk-jisyo `(,(expand-file-name "jisyo" skk-dir) . utf-8))
    (skk-backup-jisyo (expand-file-name "jisyo.bak" skk-dir))
    (skk-large-jisyo (expand-file-name "SKK-JISYO.L" skk-get-jisyo-directory))
    (skk-itaiji-jisyo (expand-file-name "SKK-JISYO.itaiji" skk-get-jisyo-directory))
    (skk-extra-jisyo-file-list
     (seq-remove (lambda (dic)
                   (seq-some (lambda (suffix)
                               (string-suffix-p (symbol-name suffix) dic))
                             '(L itaiji tar)))
                 (append (file-expand-wildcards (expand-file-name "SKK-JISYO.*" skk-get-jisyo-directory))
                         (file-expand-wildcards (expand-file-name "open-jisyo/SKK-JISYO.*" skk-dir)))))
    ;; jisyo server
    ;; (skk-server-host "localhost")
    ;; (skk-server-portnum 1178)
    ;; (skk-server-inhibit-startup-server t)
    ;; study
    (skk-study-file (expand-file-name "study" skk-dir))
    (skk-study-backup-file (expand-file-name "study.bak" skk-dir)))
#+end_src

***** skk init file

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/ddskk/skk-init.el")
  ;; -*- mode:emacs-lisp; -*-
  (setq skk-rom-kana-rule-list
        (append skk-rom-kana-rule-list
                '(("!" nil skk-purge-from-jisyo)
                  ("xka" nil ("ヵ" . "ヵ"))
                  ("xke" nil ("ヶ" . "ヶ"))
                  ("n" nil nil)
                  ("nn" nil ("ナノ" . "なの"))
                  ("nm" nil ("ノミ" . "のみ"))
                  ("ks" nil ("コソ" . "こそ"))
                  ("kna" nil ("カナ" . "かな"))
                  ("kno" nil ("コノ" . "この"))
                  ("ym" nil ("ヤマ" . "やま"))
                  ("yk" nil ("ユキ" . "ゆき"))
                  ("tga" nil ("タガ" . "たが"))
                  ("vj" nil ("ヴン" . "ぶん"))
                  ("hm" nil ("ハマ" . "はま"))
                  ;; followings are for preventing from changing to zenkaku eisu mode by pressing 'L'
                  ("bL" nil ("ボン" . "ぼん"))
                  ("byL" nil ("ビョン" . "びょん"))
                  ("cL" nil ("チョン" . "ちょん"))
                  ("dL" nil ("ドン" . "どん"))
                  ("fL" nil ("フォン" . "ふぉん"))
                  ("gL" nil ("ゴン" . "ごん"))
                  ("gyL" nil ("ギョン" . "ぎょん"))
                  ("hL" nil ("ホン" . "ほん"))
                  ("hgL" nil ("ヒョン" . "ひょん"))
                  ("hyL" nil ("ヒョン" . "ひょん"))
                  ("jL" nil ("ジョン" . "じょん"))
                  ("kL" nil ("コン" . "こん"))
                  ("kgL" nil ("キョン" . "きょん"))
                  ("kyL" nil ("キョン" . "きょん"))
                  ("mL" nil ("モン" . "もん"))
                  ("mgL" nil ("ミョン" . "みょん"))
                  ("myL" nil ("ミョン" . "みょん"))
                  ("nL" nil ("ノン" . "のん"))
                  ("ngL" nil ("ニョン" . "にょん"))
                  ("nyL" nil ("ニョン" . "にょん"))
                  ("pL" nil ("ポン" . "ぽん"))
                  ("pgL" nil ("ピョン" . "ぴょん"))
                  ("pyL" nil ("ピョン" . "ぴょん"))
                  ("rL" nil ("ロン" . "ろん"))
                  ("ryL" nil ("リョン" . "りょん"))
                  ("sL" nil ("ソン" . "そん"))
                  ("syL" nil ("ション" . "しょん"))
                  ("tL" nil ("トン" . "とん"))
                  ("tyL" nil ("チョン" . "ちょん"))
                  ("vL" nil ("ヴォン" . "う゛ぉん"))
                  ("wL" nil ("ウォン" . "うぉん"))
                  ("xL" nil ("ション" . "しょん"))
                  ("xxL" nil ("→" . "→"))
                  ("yL" nil ("ヨン" . "よん"))
                  ("zL" nil ("ゾン" . "ぞん"))
                  ("zyL" nil ("ジョン" . "じょん")))))

  (add-hook 'skk-azik-load-hook
            (lambda ()
              (dolist (key '("kA" "kE" "tU" "wA"))
                (setq skk-rom-kana-rule-list
                      (skk-del-alist key skk-rom-kana-rule-list)))))
#+end_src

**** Themes
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/themes.el")
:END:
***** modus-themes

I love modus-theme which [[https://protesilaos.com/codelog/2019-08-07-emacs-modus-themes/][conforms to WCAG AAA]]
[[https://protesilaos.com/codelog/2022-04-21-modus-themes-colour-theory/][This blog post]] explains how the package determines colors theoretically and perceptually.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-modus-themes"
#+end_src

#+begin_src emacs-lisp
  (use-package modus-themes
    :init
    ;; Add all your customizations prior to loading the themes
    (setq modus-themes-region '(bg-only no-extend)
          modus-themes-bold-constructs t
          modus-themes-italic-constructs t
          modus-themes-paren-match '(bold intense underline)
          modus-themes-syntax '(alt-syntax)
          modus-themes-headings
          '(((1 . (background overline background 1.0))
             (2 . (overline rainbow 1.0))
             (3 . (overline 1.0))
             (t . (monochrome))))
          modus-themes-org-blocks 'tinted-background)
    ;; Load the theme files before enabling a theme
    (modus-themes-load-themes)
    :config
    ;; Load the theme of your choice:
    (modus-themes-load-vivendi)
    :bind ("<f6>" . modus-themes-toggle))
#+end_src
**** Dired
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/dired.el")
:END:

#+begin_src emacs-lisp
  (use-package dired
    :bind (:map dired-mode-map
                ;; workaround against dired-find-file for cdr
                ("C-j" . (lambda ()
                           (interactive)
                           (call-interactively #'dired-find-file)))
                ("^" . dired-up-directory)
                ("(" . dired-hide-details-mode)
                (")" . dired-hide-details-mode)
                ("E" . dired-create-empty-file)
                ("Y" . dired-do-relsymlink)
                ("e" . wdired-change-to-wdired-mode)
                ("C-o" . nil)
                ("o" . dired-open-file)
                ("C-c C-o" . dired-open-file)
                ("C-c C-s" . my/dired-share))
    :hook (dired-mode . dired-hide-details-mode)
    :custom
    (dired-kill-when-opening-new-dired-buffer t)
    (dired-do-revert-buffer t)
    (dired-auto-revert-buffer t)
    (dired-copy-dereference t)
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'top)
    (dired-listing-switches "-ahgG --time-style=iso --group-directories-first")
    (dired-dwim-target 'dired-dwim-target-recent)
    (dired-hide-details-hide-information-lines nil)
    (dired-compress-file-default-suffix ".zst")
    (dired-isearch-filenames t)
    (dired-open-use-nohup t)
    (dired-open-query-before-exit nil)
    (completion-ignored-extensions nil)
    :config
    (require 'dired-x)
    (require 'dired-open)
    (advice-add #'dired-do-delete :around #'my/advice-dired-control-deletion)
    (advice-add #'dired-do-flagged-delete :around #'my/advice-dired-control-deletion)
    (put 'dired-find-alternate-file 'disabled nil))

  (use-package dired-aux
    :config
    (setq dired-compress-files-alist
          (append dired-compress-files-alist
                  '(("\\.tar\\.7z\\'" . "tar cf - %i | 7z a -si %o")
                    ("\\.7z\\'" . "7z a %o %i"))))
    (add-to-list 'dired-compress-file-suffixes
                 '("\\.tar\\.7z\\'" "" "7z x -so %i | tar xf -")))

  (use-package dired-async
    :config
    (dired-async-mode 1))

  (defun my/advice-dired-control-deletion (oldfun &rest r)
    "Enable file deleting functions to control deleting procedure
  whether files are going to be in trash box."
    (let ((delete-by-moving-to-trash
           (if (equal current-prefix-arg '(4))
               nil t)))
      (apply oldfun (cdr r))))

  (defun my/dired-share ()
    "Share file with remote device via KDE Connect."
    (interactive)
    (let ((files (dired-get-marked-files nil nil)))
      (mapc (lambda (file)
              (shell-command
               (mapconcat 'identity
                          (list "kdeconnect-cli" "-d" "a30587ededf4c2d2"
                                "--share" (shell-quote-argument
                                           file)) " ")))
            files)))
#+end_src
***** dired-rsync

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-dired-rsync"
#+end_src

#+begin_src emacs-lisp
  (use-package dired-rsync
    :after dired
    :bind (:map dired-mode-map
                ("C-c C-r" . dired-rsync))
    :custom
    (dired-rsync-options "-auz --info=progress2"))
#+end_src

***** dired-single                          :ARCHIVE:

#+begin_src emacs-lisp :tangle no
  ("https://github.com/crocket/dired-single/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package dired-single
    :straight t
    :after dired
    :bind (:map dired-mode-map
                ("C-j" . dired-single-buffer)
                ("^" . dired-single-up-directory)))
#+end_src

***** dired-hacks

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-dired-hacks"
#+end_src

#+begin_src emacs-lisp
  (use-package dired-subtree
    :after dired
    :bind (:map dired-mode-map
                ("TAB" . dired-subtree-cycle)))

  (use-package dired-narrow
    :after dired
    :bind
    (:map dired-mode-map
          ("z" . dired-narrow))
    (:map dired-narrow-map
          ("C-j" . exit-minibuffer)))
#+end_src

***** dired-hide-dotfiles

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/mattiasb/dired-hide-dotfiles/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :straight t
    :after dired
    :bind (:map dired-mode-map
                ("," . dired-clean-directory)
                ("." . dired-hide-dotfiles-mode))
    :config
    (dired-hide-dotfiles-mode -1))
#+end_src

***** find-dired

#+begin_src emacs-lisp
  (use-package find-dired
    :custom
    (find-grep-options "-n -H --no-heading -q")
    (find-ls-option '("-print0 | xargs -0 ls -ldN" . "-ldN")))

  (with-eval-after-load 'hydra
    (defhydra hydra-find-dired (global-map "M-s d"
                                           :color teal)
      "find dired"
      ("f" find-dired)
      ("F" find-lisp-find-dired)
      ("g" find-grep-dired)
      ("n" find-name-dired)
      ("d" find-lisp-find-dired-subdirectories)
      ("q" nil "quit")))
#+end_src

**** EWW
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/eww.el")
:END:

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
  d <<share-dir()>>/emacs/eww-view-in-org 0755 - - 3d
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'shr
    (customize-set-variable 'shr-width 10000)
    (customize-set-variable 'shr-use-fonts nil)
    (customize-set-variable 'shr-image-animate t)
    (customize-set-variable 'shr-use-colors nil)
    (customize-set-variable 'shr-max-image-proportion 0.4)
    ;; never use cookies
    (customize-set-variable 'shr-cookie-policy nil))

  (use-package eww
    :delight " EW"
    :defer t
    :hook
    (eww-after-render . my/eww-rename-buffer)
    :custom
    ;; set enough large column number to prevent from inserting line break
    (eww-header-line-format nil)
    :config
    (bind-keys :map eww-mode-map
               ("C" . eww-set-character-encoding)
               ("C-j" . eww-follow-link)
               ("T" . eww-goto-title-heading)
               ("L" . my/eww-goto-heading)
               ("O" . my/eww-view-in-org)
               :map eww-bookmark-mode-map
               ("C-j" . eww-bookmark-browse)))

  (defun my/eww-rename-buffer ()
    "Rename the name of current EWW buffer.

  If associated HTML file have a title tag, use title as a buffer name.
  Otherwise, use a current URL."
    (let ((title (plist-get eww-data :title))
          (url (file-name-base (eww-current-url))))
      (rename-buffer (format "eww: %s" (or (if (and title (> (length title) 0))
                                               title nil)
                                           url "")) t)))

  (defun my/eww-view-in-org ()
    "Convert current html page into one org file and show it.

  This is handy if you would like to check a page index comfortably."
    (interactive)
    (let ((source (plist-get eww-data :source))
          (src-html (make-temp-file "source-"))
          (dst-org (file-name-concat user-emacs-directory
                                     "eww-view-in-org"
                                     (format "%s.org" (org-id-uuid))))
          (coding-system-for-write 'utf-8-unix)
          (org-startup-folded t))
      (with-temp-buffer
        (insert source)
        (make-directory
         (file-name-directory (directory-file-name dst-org)) t)
        (write-region (point-min) (point-max) src-html nil)
        (call-process-shell-command (format "pandoc %s -f html -t org -o %s"
                                            (shell-quote-argument src-html)
                                            (shell-quote-argument dst-org)))
        (delete-file src-html))
      (find-file dst-org t)
      (goto-char (point-min))
      (org-ctrl-c-tab)))

  (defun eww-headings-dom ()
    "Return heading list as a dom from xml."
    (let ((source (plist-get eww-data :source))
          (dom nil))
      (with-temp-buffer
        (let ((source-file (make-temp-file "source-"))
              (coding-system-for-write 'utf-8-unix))
          (insert source)
          (write-region (point-min) (point-max) source-file nil)
          (erase-buffer)
          (call-process "extract_headings" source-file t)
          (delete-file source-file)
          (libxml-parse-xml-region (point-min) (point-max))))))

  (defun eww-goto-title-heading ()
    "Set point to a line which contaings the possible heading."
    (interactive)
    (when-let* ((headings-dom (eww-headings-dom))
                (possible-heading (cl-reduce (lambda (node-a node-b)
                                               (if (not (bound-and-true-p node-a))
                                                   (if (not (bound-and-true-p node-b))
                                                       nil
                                                     node-b)
                                                 (if (>= (string-to-number (dom-attr node-a 'proximity))
                                                         (string-to-number (dom-attr node-b 'proximity)))
                                                     node-a node-b)))
                                             (dom-children headings-dom)
                                             :initial-value nil))
                (possible-text (dom-text possible-heading))
                (match-pos (or (re-search-forward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1)
                               (re-search-backward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1))))
      (beginning-of-line)
      (recenter-top-bottom 0)))

  (defun my/eww-goto-heading ()
    "Go to selected heading line."
    (interactive)
    (setq lexical-binding t)
    (when-let* ((headings-root (eww-headings-dom))
                (cur-buf (current-buffer))
                (heading (completing-read
                          "Heading : "
                          (mapcar (lambda (heading-node)
                                    (when-let* ((heading (dom-text heading-node))
                                                (tag (symbol-name (dom-tag heading-node)))
                                                (match-pos (string-match "h\\([1-6]\\{1\\}\\)" tag))
                                                (indent (- (string-to-number (match-string 1 tag)) 1)))
                                      (format "%s%s"
                                              (apply 'concat (make-list indent "  "))
                                              heading)))
                                  (dom-children headings-root))))
                (match (string-match "\\(?:  \\)*\\(.*\\)" heading))
                (heading (match-string 1 heading))
                (match-pos (or (re-search-forward (build-regex heading) nil t 1)
                               (re-search-backward (build-regex heading) nil t 1))))
      (with-current-buffer cur-buf
        (switch-to-buffer cur-buf)
        (beginning-of-line)
        (recenter-top-bottom 0))))

  (defmacro build-regex (str)
    "Return a regexp representation for `STR'."
    `(format "^[[:blank:]SVG Image]*%s[[:blank:]]*$"
             ,str))
#+end_src

***** extract_headings
#+begin_src python :tangle (expand-file-name ".local/bin/extract_headings") :tangle-mode (identity #o755)
  #!/usr/bin/env python3

  # This script extract most probable page heading.

  import sys
  import lxml.html as html
  from lxml import etree
  import difflib

  if len(sys.argv) == 1:
      INPUT_STR = sys.stdin.read()
      ROOT = html.fromstring(INPUT_STR).getroottree()
  else:
      sys.exit(1)

  OUT_ROOT = etree.Element("headings")

  # extract title text
  title = ''
  title_text_arr = ROOT.xpath('//title[1]//text()')
  if len(title_text_arr):
      title = title_text_arr[0]
      OUT_ROOT.set("title", title.strip())

  htag_text_arr = ROOT.xpath('//*[self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6]')
  for i in range(len(htag_text_arr)):
      text = ''
      texts = htag_text_arr[i].xpath('.//text()')
      if len(texts) == 1:
          text = texts[0].strip()
      elif len(texts) > 1:
          text = ''.join(map(str.strip, texts))
      else:
          continue
      proximity = difflib.SequenceMatcher(None, title, text).ratio()
      heading = etree.Element(htag_text_arr[i].tag)
      heading.text = text
      heading.set('proximity', str(proximity))
      OUT_ROOT.append(heading)

  out_root_str = etree.tostring(OUT_ROOT, encoding='utf-8', method='xml', pretty_print=True)
  if type(out_root_str) is bytes:
      out_root_str = out_root_str.decode()
      print(out_root_str)
#+end_src
**** Info
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/info.el")
:END:

#+begin_src emacs-lisp
  (with-eval-after-load 'info
    (require 'info-look)
    (autoload 'info-lookup-add-help "info-look")
    (customize-set-variable 'Info-use-header-line nil)
    (customize-set-variable
     'Info-additional-directory-list
     `(,(expand-file-name "~/.local/share/info")
       ,@(let ((guix-custom-dir "~/.guix-extra-profiles")
               custom-info-path)
           (remq nil (mapcar (lambda (prof)
                               (setq custom-info-path (file-name-concat guix-custom-dir prof prof "share/info"))
                               (when (file-directory-p custom-info-path)
                                 custom-info-path))
                             (directory-files guix-custom-dir))))))
    (define-key Info-mode-map (kbd "C-j") #'Info-follow-nearest-node)
    (define-key Info-mode-map (kbd "a") #'info-apropos))
#+end_src

**** Magit
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/magit.el")
:END:

[[https://github.com/magit/magit][Magit]] is git front end for emacs which is outstandingly powerful.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-magit"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/magit/magit/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package magit
    :delight
    (magit-status-mode " MG")
    (magit-revision-mode " MG")
    :bind (:map magit-status-mode-map
                ("C-j" . magit-visit-thing)
                ("/"   . magit-file-checkout)
                (";"   . magit-list-repositories)
                :map magit-log-mode-map
                ("C-j" . magit-visit-thing)
                :map magit-repolist-mode-map
                ("C-j" . magit-repolist-status))
    :custom
    (magit-repository-directories '(("~/git" . 1))))
#+end_src

***** git-modes

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-git-modes"
#+end_src

#+begin_src emacs-lisp
  (use-package git-modes)
#+end_src

***** orgit

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-orgit"
#+end_src

#+begin_src emacs-lisp
  (use-package orgit
    :after (magit org)
    :custom
    (orgit-remote "github"))
#+end_src

***** git-annex

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-git-annex"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/jwiegley/git-annex-el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package git-annex
    :custom-face
    (git-annex-dired-annexed-available ((t (:foreground "green yellow"))))
    (git-annex-dired-annexed-unavailable ((t (:foreground "red3")))))
#+end_src

***** magit-annex

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-magit-annex"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/magit/magit-annex/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package magit-annex)
#+end_src

**** Mu4e
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/mu4e.el")
:END:

You need to [[https://www.djcbsoftware.nl/code/mu/mu4e/Initializing-the-message-store.html][issue 'mu init' command]] before using mu4e.
Command in practice presumably looks like:
: mu init --maildir=~/data/share/mail --muhome=~/data/share/mu --my-address=jim@example.com --my-address=bob@example.com

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "mu"
#+end_src

#+begin_src emacs-lisp
  (use-package mu4e
    :delight
    (mu4e-main-mode    " MU")
    (mu4e-headers-mode " MU")
    (mu4e-view-mode    " MU")
    (mu4e-compose-mode " MU")
    :custom
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-hide-index-messages t)
    (mu4e-context-policy 'pick-first)
    (mu4e-compose-context-policy 'ask)
    (mu4e-update-interval 300)
    (mu4e-split-view t)
    (mu4e-headers-date-format "%y%m%d")
    (mu4e-headers-time-format " %R")
    (mu4e-headers-fields
     '((:human-date . 6)
       (:flags      . 3)
       (:from       . 16)
       (:subject)))
    (mu4e-headers-results-limit 1000)
    (mu4e-headers-advance-after-mark t)
    (mu4e-change-filenames-when-moving t)
    (mu4e-view-show-images t)
    (mu4e-html2text-command (lambda (msg)
                              (plist-put msg :body-html
                                         (with-temp-buffer
                                           (insert (or (mu4e-message-field msg :body-html) ""))
                                           (shell-command-on-region (point-min) (point-max) "nkf -w -Lu" (current-buffer) t)
                                           (or (buffer-string) "")))
                              (mu4e-shr2text msg)))
    (message-send-mail-function 'smtpmail-send-it)
    (mm-sign-option nil)
    (mml-secure-openpgp-sign-with-sender t)
    (mml-default-sign-method 'pgpmime)
    :config
    (require 'mu4e)
    (require 'org-mu4e)
    (bind-keys :map mu4e-headers-mode-map
               ("C-j" . mu4e-headers-view-message)
               :map mu4e-view-mode-map
               ("C-j" . push-button)
               ("C-c C-a" . mu4e-view-attachment-action)
               :map mu4e-compose-mode-map
               ("C-x C-o" . org-mu4e-compose-org-mode))
    (add-to-list 'mu4e-view-actions
                 '("external browser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions
                 '("XWidget View" . mu4e-action-view-with-xwidget) t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
    (add-hook 'after-init-hook (lambda () (mu4e t))))
#+end_src

***** mu4e-alert

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-mu4e-alert"
#+end_src

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :commands mu4e-alert-view-unread-mails
    :defer 5
    :custom
    (mu4e-alert-modeline-formatter
     (lambda (count)
       (if (> count 0)
           (format " M:%d" count)
         "")))
    :config
    (mu4e-alert-set-default-style 'fringe)
    (mu4e-alert-enable-notifications)
    (mu4e-alert-enable-mode-line-display))
#+end_src

***** additional tweaks

- file attachment in dired ([[https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html][source]])
  : gnus-dired-attach (C-c RET C-a)

  #+begin_src emacs-lisp
    (use-package gnus-dired
      :after mu4e-compose
      :hook
      (dired-mode . turn-on-gnus-dired-mode)
      :custom
      (gnus-dired-mail-mode 'mu4e-user-agent))
  #+end_src

- use contact info from org-contacts

  #+begin_src emacs-lisp
    (use-package mu4e-actions
      :after (mu4e org-contacts)
      :config
      (setq mu4e-org-contacts-file (car org-contacts-files))
      (add-to-list 'mu4e-headers-actions
                   '("Contact to add" . mu4e-action-add-org-contact) t)
      (add-to-list 'mu4e-view-actions
                   '("Contact to add" . mu4e-action-add-org-contact) t))
  #+end_src

**** Elfeed
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/elfeed.el")
:END:

[[https://github.com/skeeto/elfeed][Elfeed]] is a powerful RSS feed reader with tag capability that is one of core software in my input workflow.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-elfeed"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/skeeto/elfeed/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package elfeed
    :delight
    (elfeed-show-mode   " EF")
    (elfeed-search-mode " EF")
    :commands (elfeed)
    :init
    (defface elfeed-search-unchecked-title-face
      nil
      "Face used in search mode for unchecked entry titles."
      :group 'elfeed)
    (defface elfeed-search-checked-title-face
      nil
      "Face used in search mode for checked entry titles."
      :group 'elfeed)
    :custom-face
    (elfeed-search-title-face ((t (:foreground "#4D4D4D"))))
    (elfeed-search-unchecked-title-face ((t (:foreground "cornflowerblue"))))
    (elfeed-search-checked-title-face ((t (:foreground "darkblue"))))
    :custom
    (elfeed-use-curl t)
    (elfeed-curl-max-connections 1024)
    (elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory))
    (elfeed-search-date-format '("%Y%m%d" 8 :left))
    (elfeed-search-title-min-width 100)
    (elfeed-search-title-max-width 120)
    (elfeed-search-trailing-width 160)
    (elfeed-sort-order 'ascending)
    (elfeed-enclosure-default-dir "~/Downloads/")
    (elfeed-save-multiple-enclosures-without-asking t)
    :config
    (setf elfeed-search-print-entry-function
          'my/elfeed-search-print-entry)
    (defalias 'elfeed-search-tag-all-unchecked
      (elfeed-expose #'elfeed-search-tag-all 'unchecked)
      "Add the `unchecked' tag to all selected entries.")
    (defalias 'elfeed-search-untag-all-unchecked
      (elfeed-expose #'elfeed-search-untag-all 'unchecked)
      "Remove the `unchecked' tag from all selected entries.")
    (defalias 'elfeed-search-tag-all-checked
      (elfeed-expose #'elfeed-search-tag-all 'checked)
      "Add the `checked' tag to all selected entries.")
    (defalias 'elfeed-search-untag-all-checked
      (elfeed-expose #'elfeed-search-untag-all 'checked)
      "Remove the `checked' tag from all selected entries.")
    (bind-keys :map elfeed-search-mode-map
               ("C-j" . elfeed-search-show-entry)
               ("o" . elfeed-search-open-url)
               ("C-c C-o" . elfeed-search-open-url)
               ("f" . scroll-up-line)
               ("e" . scroll-down-line)
               ("q" . elfeed-kill-buffer)
               ("Q" . quit-window)
               ("x" . elfeed-search-update--force)
               ("c" . (lambda () (interactive)
                        (elfeed-search-untag-all-unread)
                        (unless (use-region-p) (forward-line -1))
                        (elfeed-search-tag-all-unchecked)))
               ("C" . elfeed-search-untag-all-unchecked)
               ("r" . (lambda () (interactive)
                        (elfeed-search-untag-all-unread)
                        (unless (use-region-p) (forward-line -1))
                        (elfeed-search-untag-all-unchecked)
                        (unless (use-region-p) (forward-line -1))
                        (elfeed-search-tag-all-checked)
                        (unless (use-region-p) (forward-line -1))
                        (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))))
               ("R" . elfeed-search-untag-all-checked)
               ("d" . elfeed-search-untag-all-unread)
               ("Dv" . elfeed-search-download-video)
               ("Da" . elfeed-search-download-audio)
               ("D=" . elfeed-search-show-media-duration))
    (add-to-list 'elfeed-search-face-alist '(unchecked elfeed-search-unchecked-title-face))
    (add-to-list 'elfeed-search-face-alist '(checked elfeed-search-checked-title-face)))

  (defun my/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer with my style."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (mapconcat
                      (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                      tags ","))
           (title-width (- (window-width) 10 elfeed-search-trailing-width))
           (title-column (elfeed-format-column
                          title (elfeed-clamp
                                 elfeed-search-title-min-width
                                 title-width
                                 elfeed-search-title-max-width)
                          :left)))
      (when feed-title
        (insert (propertize (elfeed-format-column feed-title 6 :left)
                            'face 'elfeed-search-feed-face) " "))
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (when tags
        (insert "(" tags-str ")"))))

  (defun elfeed-search-open-url ()
    "Visit the current entry in your browser using 'eww-browse-url'."
    (interactive)
    (elfeed-search-untag-all-unchecked)
    (unless (use-region-p) (forward-line -1))
    (elfeed-search-tag-all-checked)
    (unless (use-region-p) (forward-line -1))
    (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))
    (unless (use-region-p) (forward-line -1))
    (elfeed-search-browse-url))

  (defun elfeed-search-download-video ()
    "Downlaod video file."
    (interactive)
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
               when (or (caar (elfeed-entry-enclosures entry))
                        (elfeed-entry-link entry))
               do (let ((title (elfeed-entry-title entry)))
                    (my/download-video it title)))
      (mapc #'elfeed-search-update-entry entries)
      (unless (or elfeed-search-remain-on-entry (use-region-p))
        (forward-line))))

  (defun elfeed-search-download-audio ()
    "Download audio file."
    (interactive)
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
               when (or (caar (elfeed-entry-enclosures entry))
                        (elfeed-entry-link entry))
               do (let ((title (elfeed-entry-title entry)))
                    (my/download-audio it title)))
      (mapc #'elfeed-search-update-entry entries)
      (unless (or elfeed-search-remain-on-entry (use-region-p))
        (forward-line))))

  (defun elfeed-search-show-media-duration ()
    "Show duration of media attached to current entry."
    (interactive)
    (let* ((entry (elfeed-search-selected :single))
           (url (or (caar (elfeed-entry-enclosures entry))
                    (elfeed-entry-link entry))))
      (show-media-duration url)))

  (defun elfeed-search-org-capture-derived (&optional arg)
    "Create actionable org task derived from current elfeed entry.

  If called with C-u prefix, ask user to specify tags and target."
    (interactive "P")
    (let ((entries (elfeed-search-selected)))
      (save-window-excursion
        (cl-loop for entry in entries
                 do (progn
                      (elfeed-show-entry entry)
                      (let ((org-capture-derived-tags (format ":web:%s"
                                                              (cond
                                                               ((or (member 'video (elfeed-entry-tags entry))
                                                                    (member 'audio (elfeed-entry-tags entry)))
                                                                "ac_watch:")
                                                               (t "ac_read:"))))
                            (org-capture-derived-target "f215ba42-6610-4019-a0a5-f790ebb26e29")
                            (org-capture-derived-deadline-in-day 7))
                        (call-interactively #'org-capture-derived))
                      (elfeed-kill-buffer))))
      (elfeed-search-untag-all-unchecked)
      (unless (use-region-p) (forward-line -1))
      (elfeed-search-tag-all-checked)
      (mapc #'elfeed-search-update-entry entries)))
#+end_src

***** elfeed-org

[[https://github.com/remyhonig/elfeed-org][elfeed-org]] allow me to express feeds for elfeed in org file.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-elfeed-org"
#+end_src

#+begin_src emacs-lisp
  (use-package elfeed-org
    :after (elfeed org)
    :custom
    (rmh-elfeed-org-files '("~/org/lists/feeds.org"))
    (rmh-elfeed-org-ignore-tag "ignore")
    (rmh-elfeed-org-auto-ignore-invalid-feeds t)
    :config
    (elfeed-org))
#+end_src

Packages managed by other than guix (i.e. straight.el or apt) are encouraged to register feed since updating information channel is desirable to exist.

#+begin_src emacs-lisp :noweb yes
  (advice-add #'rmh-elfeed-org-process
              :after #'my/elfeed-org-add-feeds)

  (defun my/elfeed-org-add-feeds (rmh-elfeed-org-files rmh-elfeed-org-tree-id)
    "Add feeds in addition to feeds in `rmh-elfeed-org-files'.

  This function needs to be invoked after `rmh-elfeed-org-process' which clear all feeds."
    (setf elfeed-feeds
          (append elfeed-feeds
                  '(;; s-exps for feeds will be inserted here
                    <<elfeed-feeds>>))))
#+end_src

**** Terminal emulators (Shells)
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/shell.el")
:END:

#+begin_src emacs-lisp
  (setf shell-command-switch "-c")
  (customize-set-variable 'shell-command-prompt-show-cwd t)

  (shell-command-with-editor-mode 1)
#+end_src

***** shell

#+begin_src emacs-lisp
  (use-package shell
    :delight " SM"
    :commands (shell)
    :custom
    (shell-has-auto-cd t)
    :config
    (bind-keys :map shell-mode-map
               ("C-j" . comint-send-input)))
#+end_src

***** term

#+begin_src emacs-lisp
  (use-package term
    :delight
    (term-mode " TR")
    :config
    (bind-keys :map term-mode-map
               ("C-j" . term-send-input)))
#+end_src

***** vterm

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-vterm"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/akermu/emacs-libvterm/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package vterm
    :delight " VT"
    :diminish ((vterm-copy-mode . "vc"))
    :custom
    (vterm-min-window-width 55)
    (vterm-buffer-name-string "vterm %s")
    :config
    (bind-keys :map vterm-mode-map
               ("C-h" . vterm-send-backspace)
               ("M-h" . vterm-send-meta-backspace)
               ("C-y" . vterm-yank)
               ("M-y" . vterm-yank-pop)
               ("C-o" . nil)
               ("M-l" . nil)
               :map vterm-copy-mode-map
               ("C-j" . vterm-copy-mode-done))
    (advice-add 'consult-yank-from-kill-ring :around #'advice/vterm-yank-pop))

  (defun advice/vterm-yank-pop (orig-fun &rest args)
    (if (eq major-mode 'vterm-mode)
        (let ((inhibit-read-only t)
              (yank-undo-function (lambda (_start _end) (vterm-undo))))
          (cl-letf (((symbol-function 'insert-for-yank)
                     (lambda (str) (vterm-send-string str t))))
            (apply orig-fun args)))
      (apply orig-fun args)))
#+end_src

****** multi-vterm

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-multi-vterm"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/suonlight/multi-vterm/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package multi-vterm
    :after vterm
    :bind (:map vterm-mode-map
                ("C-c M-n" . multi-vterm-next)
                ("C-c M-p" . multi-vterm-prev)))

  (defun my/multi-vterm (&optional arg)
    "Switch between existing vterm buffers.

  Spawn a new vterm buffer if there's no available vterm buffer.
  If command prefix ARG is simgle `C-u', spawn a vterm buffer forcibly regardless of condition."
    (interactive "P")
    (if (equal arg '(4))
        (multi-vterm)
      (multi-vterm-next)))
#+end_src

***** eshell

#+begin_src emacs-lisp
  (use-package eshell
    :delight " ES"
    :hook
    (eshell-kill . eshell-command-alert)
    :custom
    (eshell-prompt-function
     #'(lambda ()
         (format "[%s]\n%s"
                 (eshell/basename (eshell/pwd))
                 (if (= (user-uid) 0) "# " "$ "))))
    (eshell-prompt-regexp "[#$] ")
    (eshell-visual-subcommands '(("git" "log" "diff" "show")))
    :config
    (setq eshell-path-env (getenv "PATH")))

  (defun eshell-command-alert (process status)
    "Send `alert' with severity based on STATUS when PROCESS finished."
    (let* ((cmd (process-command process))
           (buffer (process-buffer process))
           (msg (format "%s: %s" (mapconcat 'identity cmd " ")  status)))
      (if (string-prefix-p "finished" status)
          (alert msg :buffer buffer :severity  'normal)
        (alert msg :buffer buffer :severity 'urgent))))
#+end_src

**** Org-mode
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/org.el")
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://updates.orgmode.org/feed/releases" soft_update)
#+end_src

***** basic preference for org core features

Basic settings for built-in Org features. Similar to [[id:587bc395-6321-4f59-97e6-6f0b62518b20][this section]], all entries obey customize group hierarchy for Org mode.

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :mode (("\\.org$" . org-mode))
    :interpreter (("org" . org-mode))
    :config
    (add-hook 'org-log-buffer-setup-hook
              (lambda ()
                (setq skk-dcomp-activate 'eolp)
                (setq skk-dcomp-multiple-activate nil))))

  (defvar org-warning-keyword-0 "UG" "TODO keyword acronym standing for 'UrGent'")
  (defvar org-todo-keyword-0 "TD" "TODO keyword acronym standing for 'To Do'")
  (defvar org-todo-keyword-1 "GO" "TODO keyword acronym standing for 'Get On'")
  (defvar org-todo-keyword-2 "IP" "TODO keyword acronym standing for 'In Progressn'")
  (defvar org-todo-keyword-4 "SD" "TODO keyword acronym standing for 'SomeDay'")
  (defvar org-done-keyword-0 "DN" "TODO keyword acronym standing for 'DoNe'")
  (defvar org-done-keyword-1 "CX" "TODO keyword acronym standing for 'Cancel'")
  (defvar org-done-keyword-2 "PD" "TODO keyword acronym standing for 'PenDing'")
#+end_src

****** Org Agenda

#+begin_src emacs-lisp
  (use-package org-agenda
    :after (org org-ql)
    :bind (:map org-agenda-mode-map
                ("C-j" . org-agenda-switch-to)
                ("M" . org-agenda-month-view))
    :hook
    (org-agenda-mode . (lambda ()
                         (delete-other-windows)
                         (org-agenda-to-appt t '((category "appt")))))
    :custom
    (org-agenda-start-on-weekday 1)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-include-diary t)
    (org-stuck-projects `(,(concat "+" my/org-project-tag)
                          (,org-todo-keyword-0 ,org-todo-keyword-1 ,org-todo-keyword-2)
                          nil ""))
    ;; next 3 custom settings contribute to build agenda view fast
    (org-agenda-inhibit-startup t)
    (org-agenda-dim-blocked-tasks nil)
    (org-agenda-use-tag-inheritance nil)
    (org-agenda-files
     (mapcar (lambda (sub-dir)
               (file-name-as-directory
                (file-name-concat org-directory sub-dir)))
             '("agenda")))
    (org-agenda-prefix-format '((agenda   . "%?-12t% s")
                                (timeline . "  %s")
                                (todo     . " ")
                                (tags     . " ")
                                (search   . " ")))
    (org-agenda-custom-commands
     `(("a" "Week-agenda"
        agenda ""
        ((org-agenda-skip-function
          (lambda ()
            ;; skip entries whose tag is 'web' and does not have todo state
            (and (save-excursion
                   (and (member "web" (org-get-tags))
                        (not (member (org-get-todo-state)
                                     `(,org-todo-keyword-0
                                       ,org-todo-keyword-1
                                       ,org-todo-keyword-2)))))
                 (progn (outline-next-heading) (point)))))))
       ("l" "Log entries in a week"
        agenda ""
        ((org-agenda-span (if (equal current-prefix-arg '(4))
                              'day 'week))
         (org-agenda-start-with-log-mode t)
         (org-agenda-include-inactive-timestamps nil)
         (org-agenda-include-diary t)
         (org-agenda-sorting-strategy
          '(time-up
            deadline-up
            todo-state-up
            priority-down))))
       ("L" "Log entry timeline on today with default org-agenda-prefix-format"
        agenda ""
        ((org-agenda-prefix-format (eval (car (get 'org-agenda-prefix-format 'standard-value))))
         (org-agenda-span (if (equal current-prefix-arg '(4))
                              'day 'week))
         (org-agenda-start-with-log-mode t)
         (org-agenda-include-inactive-timestamps nil)
         (org-agenda-include-diary t)
         (org-agenda-sorting-strategy
          '(time-up
            deadline-up
            todo-state-up
            priority-down))))
       ;; KEEP IN MIND
       ;; invoking `org-clock-sum-all' is required before showing effort table
       ("e" . "Effort table")
       ("ei" "today"
        ((org-ql-search-block `(or (todo ,org-warning-keyword-0)
                                   (todo ,org-todo-keyword-2)
                                   (and (clocked :on today)
                                        (or (todo) (done))
                                        (not (habit))
                                        (not (tags "web"))))
                              ((org-ql-block-header "Today's task"))))
        ((org-agenda-overriding-header "Today's Task")
         (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
         (org-agenda-view-columns-initially t)
         (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
       ("eg" "this week"
        ((org-ql-search-block `(or (todo ,org-warning-keyword-0)
                                   (todo ,org-todo-keyword-1)
                                   (todo ,org-todo-keyword-2))
                              ((org-ql-block-header "This Week's task"))))
        ((org-agenda-overriding-header "This Week's Task")
         (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
         (org-agenda-view-columns-initially t)
         (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
       ("ed" "done task"
        ((org-ql-search-block `(or (todo ,org-done-keyword-0)
                                   (todo ,org-done-keyword-1)
                                   (todo ,org-done-keyword-2))
                              ((org-ql-block-header "Done task"))))
        ((org-agenda-overriding-header "Done Task")
         (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM(Total){:}")
         (org-agenda-view-columns-initially t)
         (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
       ("i" "Today's agenda"
        ((todo "Today's agenda"
               ((org-agenda-sorting-strategy '(priority-up))))
         (org-ql-search-block `(heading ,(format-time-string "%Y-%m-%d %A"))
                              ((org-agenda-files `(,(file-name-concat org-directory "archive" (format-time-string "archive_%Y.org"))))
                               (org-ql-block-header "Today in datetree archive")))
         (org-ql-search-block `(or (todo ,org-warning-keyword-0)
                                   (todo ,org-todo-keyword-2))
                              ((org-ql-block-header "Today's task")))
         (org-ql-search-block `(and (planning :on today)
                                    (not (todo ,org-todo-keyword-2
                                               ,org-done-keyword-0
                                               ,org-done-keyword-1
                                               ,org-done-keyword-2))
                                    (not (tags "web"))
                                    (not (habit)))
                              ((org-ql-block-header "Scheduled/Deadlined on today")))
         (org-ql-search-block `(and (habit)
                                    (todo ,org-todo-keyword-0)
                                    (scheduled :to today)
                                    (not (tags "bad_habit"))
                                    (not (tags-inherited "ARCHIVE")))
                              ((org-ql-block-header "Habits to take")))
         (org-ql-search-block `(and (ts-active :on today)
                                    (not (or (todo ,org-todo-keyword-2)
                                             (habit) (done))))
                              ((org-ql-block-header "Today's common event")))
         (org-ql-search-block '(and (done)
                                    (closed :on today))
                              ((org-ql-block-header "Completed tasks on today")))))
       ("g" "This Week's agenda"
        ((org-ql-search-block `(heading ,(format-time-string "%G-W%V"))
                              ((org-agenda-files `(,(file-name-concat org-directory "archive" (format-time-string "archive_%Y.org"))))
                               (org-ql-block-header "This week in datetree archive")))
         (org-ql-search-block `(or (todo ,org-todo-keyword-1))
                              ((org-ql-block-header "This week's tasks")))
         (org-ql-search-block `(or (todo ,org-warning-keyword-0)
                                   (todo ,org-todo-keyword-2))
                              ((org-ql-block-header "Today's tasks")))
         (org-ql-search-block `(and (planning :from 0 :to 6)
                                    (not (todo ,org-todo-keyword-2
                                               ,org-done-keyword-0
                                               ,org-done-keyword-1
                                               ,org-done-keyword-2))
                                    (not (tags "web"))
                                    (not (habit)))
                              ((org-ql-block-header "Scheduled/Deadlined this week")))
         (org-ql-search-block `(and (and (ts-active :from 0 :to 6)
                                         (not (deadline))
                                         (not (scheduled))
                                         (not (closed)))
                                    (not (or (todo ,org-todo-keyword-1
                                                   ,org-todo-keyword-2)
                                             (done))))
                              ((org-ql-block-header "This week's common event"))))
        ((org-agenda-sorting-strategy
          '(todo-state-up priority-down deadline-up))))
       ("t" "All tasks"
        ((org-ql-search-block `(todo ,org-warning-keyword-0)
                              ((org-ql-block-header "Urgent task")))
         (org-ql-search-block `(todo ,org-todo-keyword-2)
                              ((org-ql-block-header "Today's task")))
         (org-ql-search-block `(todo ,org-todo-keyword-1)
                              ((org-ql-block-header "This week's task")))
         (org-ql-search-block `(and (todo ,org-todo-keyword-0)
                                    (not (habit)))
                              ((org-ql-block-header "Remaining task")))))
       ("d" "Done tasks"
        ((org-ql-search-block '(done)
                              ((org-ql-block-header "Done/Canceled/Pending task")))))
       ("p" "Projects" tags ,(concat "+" my/org-project-tag))
       ("h" "Habits in consistency graph"
        agenda ""
        ((org-agenda-span 'day)
         (org-agenda-use-time-grid nil)
         (org-agenda-prefix-format '((agenda . "")))
         (org-habit-show-all-today t)
         (org-habit-graph-column 32)
         (org-habit-preceding-days 14)
         (org-habit-following-days 21)
         (org-agenda-sorting-strategy '(scheduled-up))
         ;; display habits only
         (org-agenda-skip-function
          (lambda ()
            (and (save-excursion
                   (not (org-is-habit-p)))
                 (progn (outline-next-heading) (point)))))))
       ("H" "show all habits"
        ((org-ql-search-block '(habit)
                              ((org-ql-block-header "All Habits"))))
        ((org-agenda-sorting-strategy '(scheduled-up))))))
    :config
    (dolist (dir '("archive" "lists" "wiki" "notes"))
      (mapc (lambda (org-file)
              (add-to-list 'org-agenda-text-search-extra-files
                           org-file))
            (directory-files (expand-file-name dir org-directory)
                             t
                             (rx (one-or-more not-newline)
                                 (or ".org" ".org.gpg")
                                 line-end)))))

  (defun org-agenda-cmp-latest-clock-log (a b)
    "Compare two org entry A and B in terms of clock log.

  This function can be used as `org-agenda-cmp-user-defined' in `org-agenda-sorting-strategy'."
    (let* ((marker-a (get-text-property 1 'org-marker a))
           (time-a (org-get-latest-clock-log-time marker-a))
           (marker-b (get-text-property 1 'org-marker b))
           (time-b (org-get-latest-clock-log-time marker-b)))
      (if (time-less-p time-a time-b) -1 +1)))

  (defun org-clock-sum-all ()
    "Sum the times for all agenda files."
    (interactive)
    (save-excursion
      (mapc (lambda (file)
              (with-current-buffer (or (org-find-base-buffer-visiting file)
                                       (find-file-noselect file))
                (org-clock-sum)
                (org-clock-sum-today)))
            (org-agenda-files))))

  (defun org-get-latest-clock-log-time (pom)
    "Get the latest clock log time stamp in org entry at POM as a time object.

  If entry at POM has no clock log time stamp, this function returns 0."
    (org-with-point-at pom
      (save-excursion
        (setq end-of-subtree (org-end-of-subtree))
        (setq latest-time 0)
        (org-back-to-heading t)
        (org-show-all)
        (while (re-search-forward org-drawer-regexp end-of-subtree t)
          (when (string= (match-string 1) (org-clock-drawer-name))
            (while (progn
                     (forward-line 1)
                     (when (org-match-line (concat "^[ \t]*" org-clock-string "[ \t]*" org-tsr-regexp-both))
                       (setq match-ts
                             (if (match-string 3)
                                 (match-string 3) (match-string 1)))
                       (when (time-less-p latest-time
                                          (apply 'encode-time (parse-time-string match-ts)))
                         (setq latest-time (apply 'encode-time (parse-time-string match-ts)))))
                     (not (org-match-line org-clock-drawer-end-re))))))))
    latest-time)
#+end_src

****** Org Capture

#+begin_src emacs-lisp
  (use-package org-capture
    :after org
    :hook
    (org-capture-mode . (lambda ()
                          (delete-other-windows)))
    :custom
    (org-directory (expand-file-name "~/org"))
    (org-reverse-note-order nil)
    (org-capture-bookmark nil)
    (org-capture-templates
     `(("e" "Entry"
        entry (id "58e12e3e-da50-4089-9d22-565986637121")
        "* %?")
       ("t" "Task"
        entry (id "58e12e3e-da50-4089-9d22-565986637121")
        ,(format "* %s %%?\n"
                 org-todo-keyword-0))
       ("p" "Project"
        entry (id "58e12e3e-da50-4089-9d22-565986637121")
        "* %? [/] :project:\n- [ ] insert ID property if necessary"
        :jump-to-captured t)
       ("M" "Append memo to clocking task"
        item (clock)
        "- %i%?"))))
#+end_src

****** Org Startup

#+begin_src emacs-lisp
  (customize-set-variable 'org-startup-folded t)
  (customize-set-variable 'org-startup-truncated t)
  (customize-set-variable 'org-startup-with-inline-images t)
  ;; allow _{}/^{} format for sub/super script
  (customize-set-variable 'org-use-sub-superscripts '{})
#+end_src

****** Org TODO

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (customize-set-variable 'org-enforce-todo-dependencies t)
    (customize-set-variable
     'org-todo-keywords
     `((sequence ,(format "%s(t/!)" org-todo-keyword-0)
                 ,(format "%s(u/!)" org-warning-keyword-0)
                 ,(format "%s(g/!)" org-todo-keyword-1)
                 ,(format "%s(i/!)" org-todo-keyword-2)
                 "|"
                 ,(format "%s(d/@)" org-done-keyword-0)
                 ,(format "%s(x/@)" org-done-keyword-1)
                 ,(format "%s(p/@)" org-done-keyword-2))
       (sequence ,(format "%s(t/!)" org-todo-keyword-0)
                 ,(format "%s(s/!)" org-todo-keyword-4)
                 "|"
                 ,(format "%s(x/@)" org-done-keyword-1)
                 ,(format "%s(p/@)" org-done-keyword-2))))
    (customize-set-variable
     'org-todo-keyword-faces
     `((,org-warning-keyword-0 . "red1")
       (,org-todo-keyword-0    . "green1")
       (,org-todo-keyword-1    . "DeepPink1")
       (,org-todo-keyword-2    . "DodgerBlue1")
       (,org-todo-keyword-4    . "SpringGreen")
       (,org-done-keyword-0    . "gray30")
       (,org-done-keyword-1    . "dark gray")
       (,org-done-keyword-2    . "sea green")))
    (customize-set-variable 'org-log-done 'time)
    (customize-set-variable 'org-log-into-drawer t)
    (customize-set-variable 'org-log-states-order-reversed t)
    (add-hook 'org-after-todo-state-change-hook
              #'my/org-remove-priority-if-done)
    (add-hook 'org-after-todo-state-change-hook
              #'my/org-remove-done-if-nonrepeated-habit)
    (add-hook 'org-after-todo-state-change-hook
              #'my/org-close-project))

  ;;;###autoload
  (defun my/org-remove-priority-if-done ()
    "Remove priority if todo state of the entry at point has changed to `org-done-keywords'."
    (when (and
           ;; the entry has one of org-done-keywords
           (string-match-p
            (eval `(rx (or ,org-done-keyword-0
                           ,org-done-keyword-1
                           ,org-done-keyword-2)))
            org-state)
           ;; the entry has been set any priority
           (/= 21000 (save-excursion
                       (save-match-data
                         (beginning-of-line)
                         (and (looking-at org-heading-regexp)
                              (org-get-priority (match-string 0)))))))
      (org-priority 'remove)))

  (defun my/org-remove-done-if-nonrepeated-habit ()
    "Reset todo state of the entry at point if it is habit without repeats."
    (when (and (string-match-p org-done-keyword-0
                               org-state)
               (org-is-habit-p)
               (not (org-get-scheduled-time (point))))
      (org-todo "")))

  (defun my/org-close-project ()
    "Try to close the project entry which this entry belongs.

  If the project entry has BLOCKER property, Ord EDNA prohibit the entry to close."
    (when (member org-state
                  `(,org-done-keyword-0 ,org-done-keyword-1 ,org-done-keyword-2))
      (save-excursion
        (org-back-to-heading t)
        (org-speed-move-safe 'outline-up-heading)
        (and (member my/org-project-tag (org-get-tags))
             (org-todo org-done-keyword-0)))))
#+end_src

****** Org Structure

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)

  (customize-set-variable 'org-startup-indented t)
  (customize-set-variable 'org-bookmark-names-plist nil)
  (customize-set-variable 'org-M-RET-may-split-line '((default . nil)))
#+end_src

******* Org Edit Structure

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-edit-src-auto-save-idle-delay 30)
    (org-adapt-indentation nil)
    (org-special-ctrl-a/e t)
    (org-catch-invisible-edits 'smart)
    :config
    (add-to-list 'org-structure-template-alist (cons "sh" "src shell"))
    (add-to-list 'org-structure-template-alist (cons "tx" "src text"))
    (add-to-list 'org-structure-template-alist (cons "el" "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist (cons "py" "src python")))

  (use-package org-src
    :after org
    :custom
    (org-src-window-setup 'current-window)
    :config
    (advice-add #'org-edit-src-save
                :before
                (lambda ()
                  "Delete trailing whitespace."
                  (delete-trailing-whitespace))))
#+end_src

******* Org Plain lists

#+begin_src emacs-lisp
  (use-package org-list
    :after org
    :custom
    (org-list-demote-modify-bullet '(("-" . "+") ("+" . "-") ("*" . "-")
                                     ("1." . "1)") ("1)" . "1.") ("*" . "1.")))
    (org-cycle-include-plain-lists 'integrate)
    (org-list-use-circular-motion t)
    (org-list-allow-alphabetical t))
#+end_src

******* Org Archive

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-archive)
    (customize-set-variable 'org-archive-default-command 'org-archive-set-tag)
    (customize-set-variable 'org-cycle-open-archived-trees t))

  (advice-add #'org-archive-subtree :around
              #'my/org-archive-subtree--iso-datetree)

  ;;;###autoload
  (defun my/org-archive-subtree--iso-datetree (oldfun &rest r)
    "Move the current subtree to the archive.

  If archiving location is datetree, it supposed to be iso week tree."
    (interactive)
    (when (member (org-get-todo-state)
                  `(,org-warning-keyword-0 ,org-todo-keyword-0 ,org-todo-keyword-1 ,org-todo-keyword-2))
      (org-todo org-done-keyword-1))
    (let* ((todo-state (org-get-todo-state))
           (closed-time (org-entry-get nil "CLOSED" t))
           (org-archive-location
            (cond
             ((member todo-state
                      `(nil ,org-done-keyword-0 ,org-done-keyword-1))
              (format "%s::datetree/"
                      (file-name-concat org-directory "archive"
                                        (format "archive_%s.org"
                                                (if closed-time
                                                    (nth 5
                                                         (parse-time-string
                                                          (substring closed-time 1 -1)))
                                                  (format-time-string "%Y"))))))
             ((member todo-state
                      `(,org-todo-keyword-4 ,org-done-keyword-2))
              (format "%s::* suspended tasks"
                      (file-name-concat org-directory "archive" "suspended.org"))))))
      (when (stringp org-archive-location)
        (org-relate-interrelate)
        (advice-add #'org-datetree-find-date-create :override
                    #'org-datetree-find-iso-week-create)
        (apply oldfun r)
        (advice-remove #'org-datetree-find-date-create
                       #'org-datetree-find-iso-week-create))))

  (with-eval-after-load 'org-ql-view
    (push '("Archive entries" .
            (lambda ()
              "Search for matched entries in archive files.
  User is supposed to select 'org-agenda-files as buffers-files in `org-ql-search' command."
              (interactive)
              (let ((org-agenda-files (file-expand-wildcards (file-name-concat org-directory "archive" "archive_*.org"))))
                (call-interactively 'org-ql-search))))
          org-ql-views))

  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "C") #'my/org-archive-find--iso-datetree))

  (with-eval-after-load 'calendar
    (define-key calendar-mode-map (kbd "C") #'my/org-archive-find--iso-datetree))

  ;;;###autoload
  (defun my/org-archive-find--iso-datetree (date)
    "Find and visit the location of DATE in archivee file.

  DATE must be a string representing the date to find and parsable with `format-time-string'.

  If called interactively, it prompt the user to select the date to find."
    (interactive
     (cond
      ((eq major-mode 'calendar-mode)
       (list (calendar-date-string (calendar-cursor-to-date))))
      ((eq major-mode 'org-agenda-mode)
       (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                       (user-error "Don't know which date to open in calendar")))
              (date (calendar-gregorian-from-absolute day)))
         (list (calendar-date-string date))))
      (t (let ((date-select (org-read-date)))
           (list date-select)))))
    (let* ((d (parse-time-string date))
           (day (decoded-time-day d))
           (month (decoded-time-month d))
           (year (decoded-time-year d)))
      (find-file (file-name-concat org-directory "archive" (format "archive_%d.org" year)))
      (org-datetree-find-iso-week-create `(,month ,day ,year))))
#+end_src

******* Org Inline Tasks

#+begin_src emacs-lisp
  (use-package org-inlinetask
    :after org
    :custom
    (org-inlinetask-default-state org-todo-keyword-0)
    (org-inlinetask-min-level 10))
#+end_src
****** Org Tags

#+begin_src emacs-lisp
  (customize-set-variable 'org-use-tag-inheritance "ARCHIVE")
  (customize-set-variable 'org-tags-column -57)

  (defvar my/org-project-tag "project" "A tag for projects")
#+end_src

****** Org Properties

#+begin_src emacs-lisp
  (customize-set-variable 'org-use-property-inheritance "TIMELIMIT.*")
  (customize-set-variable 'org-highest-priority ?A)
  (customize-set-variable 'org-lowest-priority ?Z)
  (customize-set-variable 'org-default-priority ?E)
  (customize-set-variable 'org-global-properties
                          '(("Effort_ALL". "0 0:10 0:20 0:30 1:00 1:30 2:00 3:00 4:00 6:00 8:00")))
#+end_src

****** Org Refile

#+begin_src emacs-lisp
  (use-package org-refile
    :after org
    :hook (org-after-refile-insert . my/org-archive-suspended-task)
    :custom
    (org-refile-targets
     `((org-agenda-files :tag . ,my/org-project-tag)
       (,(directory-files-recursively org-directory "\\.org$") :tag . "refile"))))

  (defun my/org-archive-suspended-task ()
    "Archive this entry to the file for suspended tasks if the TODO state fits the bill."
    (interactive)
    (when (member (org-entry-get nil "TODO")
                  `(,org-todo-keyword-4 ,org-done-keyword-2))
      (org-archive-subtree)))
#+end_src
****** Org Time

#+begin_src emacs-lisp
  (customize-set-variable 'org-time-stamp-custom-formats
                          '("<%m-%d %a>" . "<%H:%M>"))
#+end_src

******* Org Progress

******** Org Clock

#+begin_src emacs-lisp
  (use-package org-clock
    :after org
    :custom
    (org-clock-into-drawer "CLOCK")
    (org-clock-out-when-done t)
    (org-clock-persist t)
    (org-clock-persist-file (file-name-concat user-emacs-directory "org-clock-save.el"))
    (org-clock-persist-query-resume nil)
    (org-clock-string-limit 20)
    (org-clock-continuously t)
    (org-clock-ask-before-exiting nil)
    (org-clock-out-remove-zero-time-clocks t)
    :config
    (org-clock-persistence-insinuate))
#+end_src

****** Org Appearance

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-hide-leading-stars t)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-image-actual-width 100)
    (org-display-remote-inline-images 'cache))
#+end_src

****** Babel

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "plantuml"
#+end_src

#+begin_src emacs-lisp
  (use-package ob-core
    :after org
    :custom
    (org-confirm-babel-evaluate nil)
    (org-babel-load-languages
     '((C        . t)
       (java     . t)
       (R        . t)
       (shell    . t)
       (ruby     . t)
       (python   . t)
       (org      . t)
       (lua      . t)
       (ledger   . t)
       (gnuplot  . t)
       (dot      . t)
       (plantuml . t)
       (lilypond . t)))
    (org-babel-python-command (executable-find "python3"))
    (org-babel-ruby-command (executable-find "ruby"))
    :config
    (add-to-list 'org-src-lang-modes
                 '("dot" . graphviz-dot))
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (cond
     ((string= system-type "gnu/linux")
      (customize-set-variable `org-plantuml-jar-path (expand-file-name "plantuml.jar" "~/.guix-profile/share/java")))
     ((string= system-type "darwin")
      (customize-set-variable 'org-plantuml-jar-path "/usr/local/Cellar/plantuml/8041/plantuml.8041.jar"))))
#+end_src

****** Org ID

#+begin_src emacs-lisp
  (use-package org-id
    :after org
    :custom
    (org-id-locations-file
     (expand-file-name ".org-id-locations" org-directory))
    (org-id-track-globally t)
    (org-id-link-to-org-use-id 'create-if-interactive))
#+end_src

****** Org Crypt

#+begin_src emacs-lisp
  (use-package org-crypt
    :after org
    :custom
    (org-crypt-key user-mail-address)
    (org-tags-exclude-from-inheritance '("crypt"))
    :config
    (org-crypt-use-before-save-magic))
#+end_src

****** Org Attach

#+begin_src emacs-lisp
  (require 'org-attach)

  (customize-set-variable 'org-attach-preferred-new-method nil)
#+end_src

****** Org Link

#+begin_src emacs-lisp
  (require 'ol)

  (org-link-set-parameters "src" :follow #'org-babel-ref-resolve)
  (org-link-set-parameters
   "sudo"
   (lambda (cmd)
     "Run CMD with sudo."
     (shell-command
      (concat "echo " (shell-quote-argument (read-passwd "Password? "))
              " | sudo -S " cmd))))
#+end_src

******* Org Follow Link

#+begin_src emacs-lisp
  (use-package ol
    :custom
    (org-link-elisp-confirm-function nil)
    :config
    (setf (alist-get 'file org-link-frame-setup) 'find-file))
#+end_src

****** Org Export

******* Org Export General

#+begin_src emacs-lisp
  (use-package ox
    :defer t
    :after org
    :custom
    (org-export-with-smart-quotes t)
    (org-export-with-emphasize t)
    (org-export-with-special-strings t)
    (org-export-with-fixed-width t)
    (org-export-with-timestamps t)
    (org-export-preserve-breaks nil)
    (org-export-with-sub-superscripts nil)
    (org-export-with-archived-trees 'headline)
    (org-export-with-author nil)
    (org-export-with-broken-links 'mark)
    (org-export-with-clocks nil)
    (org-export-with-creator nil)
    (org-export-with-drawers '(not "LOGBOOK"))
    (org-export-with-date nil)
    (org-export-with-entities t)
    (org-export-with-email nil)
    (org-export-with-footnotes t)
    (org-export-headline-levels 5)
    (org-export-with-inlinetasks t)
    (org-export-with-section-numbers nil)
    (org-export-with-planning nil)
    (org-export-with-priority nil)
    (org-export-with-properties nil)
    (org-export-with-statistics-cookies t)
    (org-export-with-tags nil)
    (org-export-with-tasks t)
    (org-export-with-latex t)
    (org-export-time-stamp-file nil)
    (org-export-with-title t)
    (org-export-with-toc nil)
    (org-export-with-todo-keywords nil)
    (org-export-with-tables t)
    (org-export-default-language "ja")
    (org-export-dispatch-use-expert-ui nil))
#+end_src

******* Org Export HTML

#+begin_src emacs-lisp
  (use-package ox-html
    :defer t
    :after ox
    :custom
    (org-html-preamble t)
    (org-html-postamble 'auto)
    (org-html-with-latex t)
    (org-html-container-element "div")
    (org-html-doctype "xhtml-strict"))
#+end_src

******* Org Export LaTeX

#+begin_src emacs-lisp
  (use-package ox-latex
    :defer t
    :after ox
    :custom
    (org-latex-pdf-process '("platex %f"
                             "platex %f"
                             "bibtex %b"
                             "platex %f"
                             "platex %f"
                             "dvipdfmx %b.dvi"))
    (org-latex-default-class "jsarticle")
    :config
    (add-to-list 'org-latex-classes
                 '("jsarticle"
                   "\\documentclass[dvipdfmx,12pt]{jsarticle}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
                 `("beamer"
                   "\\documentclass[presentation,dvipdfmx,18pt]{beamer}\n"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

****** Org Plot

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "gnuplot"
  "emacs-gnuplot"
  "emacs-mkmcc-gnuplot-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package org-plot
    :after org)
#+end_src

***** external packages for org
****** org-edna
:PROPERTIES:
:CREATED:  [2022-10-24 Mon 15:28]
:END:

[[https://www.nongnu.org/org-edna-el/][Org Edna]] allows to org entries to be blockers and action triggers, which is very intresting feature especially for managing successive set of tasks or any correlated tasks.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-edna"
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-edna)
    (org-edna-mode 1))
#+end_src

****** org-contacts

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-contacts"
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-contacts)
    (customize-set-variable 'org-contacts-files
                            `(,(file-name-concat org-directory "lists" "contacts.org.gpg"))))
#+end_src
****** org-drill

[[https://gitlab.com/phillord/org-drill][org-drill]] helps me to learn english words and phrases. [[https://youtu.be/SGzdFtN_NqE][This video]] introduces how I use org-drill.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-drill"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://gitlab.com/phillord/org-drill/-/tags?format=atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package org-drill
    :after org
    :custom
    (org-drill-spaced-repetition-algorithm 'sm5)
    (org-drill-sm5-initial-interval 10.0)
    (org-drill-add-random-noise-to-intervals-p t)
    (org-drill-adjust-intervals-for-early-and-late-repetitions-p t)
    (org-drill-days-before-old 20)
    (org-drill-learn-fraction 0.65)
    (org-drill-overdue-interval-factor 1.6))
#+end_src

****** org-ql

[[https://github.com/alphapapa/org-ql][Org QL]] enables me to issue queries to search org entries with either SQL-like format or plain search strings.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-ql"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/alphapapa/org-ql/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-ql)
    (require 'org-ql-search)
    (customize-set-variable 'org-ql-search-directories-files-recursive t)
    (org-ql-defpred (tags-expanded expanded-tags tags-x xtags) (&rest tags)
      "Return non-nil if current heading has one or more of TAGS.
  If TAGS contains a group tag, all tags in the group is used to match.
  Both inherited and local tags is tested."
      :normalizers ((`(,predicate-names . ,tags)
                     `(tags-expanded ,@tags)))
      :body (apply #'org-ql--predicate-tags
                   (seq-uniq (--mapcat (org-tags-expand it t)
                                       tags))))
    (org-ql-defpred (category-inherited) (&rest categories)
      "Return non-nil if current heading has CATEGORY.
  Ancestors are looked up If current heading has no CATEGORY."
      :body (when-let ((category (or (org-get-category (point))
                                     (org-entry-get (point) "CATEGORY" t))))
              (cl-typecase categories
                (null t)
                (otherwise (member category categories)))))
    (with-eval-after-load 'org-expiry
      (require 'org-element)
      (org-ql-defpred expired ()
        "Return non-nil if the entry is expired."
        :body (org-expiry-expired-p))))
#+end_src

****** org-ml

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/ndwarshuis/org-ml/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package org-ml
    :straight t
    :after org)
#+end_src

****** org-roam
org-roam v2

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-roam"
  "emacs-emacsql-sqlite3"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/org-roam/org-roam/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package org-roam
    :after org
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n S" . org-roam-db-sync))
    :custom
    (org-roam-directory org-directory)
    (org-roam-db-location (file-name-concat user-emacs-directory "org-roam.db"))
    (org-roam-database-connector 'sqlite3)
    (org-roam-db-update-on-save nil)
    (org-roam-db-extra-links-exclude-keys
     '((node-property "ROAM_REFS")
       (node-property "PARENT")
       (keyword "transclude")))
    :config
    (setq org-roam-mode-sections
          (list #'org-roam-backlinks-section
                #'org-roam-reflinks-section
                #'org-roam-unlinked-references-section)))
#+end_src
****** org-mime

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-mime"
#+end_src

#+begin_src emacs-lisp
  (use-package org-mime
    :after org
    :config
    (push '("Send An Email") org-speed-commands))
#+end_src

****** org-web-tools

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-web-tools"
#+end_src

#+begin_src emacs-lisp
  (use-package org-web-tools
    :after org
    :demand t
    :bind (("C-c C-;" . org-web-tools-insert-link-for-url)))
#+end_src

****** org-volume

[[https://github.com/akirak/org-volume][org-volume]] can be used to insert book information in dynamic block.

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/akirak/org-volume/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package org-volume
    :straight (org-volume
               :host github
               :repo "akirak/org-volume"
               :branch "master"))
#+end_src

****** org-clock-convenience

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/dfeich/org-clock-convenience/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package org-clock-convenience
    :straight t
    :after (org)
    :bind (:map org-agenda-mode-map
                ("@"   . org-clock-convenience-fill-gap)
                ("C-@" . org-clock-convenience-fill-gap-both)))
#+end_src

****** org-reveal

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-reveal"
#+end_src

#+begin_src emacs-lisp
  (use-package ox-reveal
    :after ox)
#+end_src

****** org-expiry

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-org-contrib"
#+end_src

#+begin_src emacs-lisp
  (require 'org-expiry)

  (customize-set-variable 'org-expiry-inactive-timestamps t)
  (customize-set-variable 'org-expiry-handler-function
                          'org-expiry-archive-subtree)

  (add-hook 'org-capture-prepare-finalize-hook
            #'org-expiry-insert-created)

  (org-expiry-insinuate)
#+end_src

****** ob-async

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-ob-async"
#+end_src

#+begin_src emacs-lisp
  (use-package ob-async
    :after ob-core)
#+end_src
****** ob-lilypond

#+begin_src emacs-lisp
  (use-package ob-lilypond
    :after (org lilypond-mode)
    :custom
    ;; (org-babel-lilypond-commands '("lilypond" "firefox" "fluidsynth -a alsa -m alsa_seq -l"))
    (org-babel-lilypond-commands '("lilypond" "firefox" "xdg-open"))
    (org-babel-lilypond-arrange-mode t))
#+end_src

****** ox-hugo

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-ox-hugo"
#+end_src

#+begin_src emacs-lisp
  (use-package ox-hugo
    :defer t
    :after ox)
#+end_src

***** utility functions for org

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
  d <<share-dir()>>/emacs/org-readable 0755 - - 3d
#+end_src

#+begin_src emacs-lisp
  (defun my/org-babel-lob-ingest-batch ()
    (interactive)
    (mapc (lambda (dir)
            (dolist (f (directory-files (expand-file-name dir org-directory) "\.org$"))
              (org-babel-lob-ingest f)))
          '("agenda" "lists" "wiki" "notes")))

  (defvar org-readable-directory
    (expand-file-name "org-readable"
                      user-emacs-directory)
    "A directory where generated html files are located in org-readable.")

  (defun org-readable ()
    "Show current org subtree in EWW."
    (interactive)
    (let* ((heading (org-get-heading t t t t))
           (org-export-show-temporary-export-buffer nil)
           (export-buf-name "*Org HTML Export*")
           (org-export-with-broken-links 'mark)
           (org-export-babel-evaluate nil)
           (id (org-id-get))
           (uuid (downcase (if id id (org-id-uuid))))
           (org-readable-file (format "%s/%s.html" org-readable-directory uuid)))
      (org-html-export-as-html nil t nil)
      (with-current-buffer export-buf-name
        (write-file org-readable-file)
        (eww-open-file org-readable-file))))

  (defun org-property-copy-as-kill ()
    "Prompt user to select property to append to the kill ring.

  If property's value matches $(...) format, ... is interpreted as shell command and execute it."
    (interactive)
    (let* ((properties (org-entry-properties))
           (prop-key-to-copy
            (completing-read "Property name: "
                             (mapcar #'(lambda (var) (car var)) properties))))
      (when (stringp prop-key-to-copy)
        (let* ((prop-value (cdr (assoc prop-key-to-copy properties)))
               (str-to-copy
                (cond
                 ((string-match "$(\\(.+\\))" prop-value)
                  (shell-command-to-string (match-string 1 prop-value)))
                 (t prop-value))))
          (kill-new str-to-copy)))))

  (defun my/org-reset-dwim ()
    "Do reset procedure in each context."
    (interactive)
    (cond
     ((org-at-table-p) (org-table-blank-field))
     ((org-in-subtree-not-table-p)
      (org-save-outline-visibility t
        (org-reset-checkbox-state-subtree)))))

  (defun my/org-clock-remove-old-clock-entries (n &optional min)
    "Remove clock entries whose end is older than N weeks in current subtree.
  Skip over dangling clock entries."
    (interactive "nnumber of weeks: ")
    (org-save-outline-visibility t
      (save-excursion
        (org-back-to-heading t)
        (org-show-all)
        (let ((drawer (re-search-forward org-clock-drawer-start-re (save-excursion (org-end-of-subtree)) t))
              (case-fold-search t))
          (when drawer
            (let* ((min-applied min)
                   (re org-clock-line-re)
                   (end (save-excursion (re-search-forward org-clock-drawer-end-re (save-excursion (org-end-of-subtree)) nil)))
                   (end-mkr (set-marker (mark-marker) end)))
              (while (re-search-forward re (marker-position end-mkr) t)
                (skip-chars-forward " \t\r")
                (looking-at org-tr-regexp-both)
                (unless (and (numberp min-applied)
                             (natnump (setq min-applied (1- min-applied))))
                  (when (>= (/ (time-to-number-of-days (org-time-since (match-string-no-properties 2))) 7)
                            (float n))
                    (kill-whole-line)))))))
        (org-clock-remove-empty-clock-drawer))))

  (defun my/org-remove-old-state-change-entries (n)
    "Remove state change entries whose inactive timestamp is older than N weeks in current subtree.

  This command remove all lines that have an old inactive timestamp regardless
   whether it is a state change log or not."
    (interactive "nnumber of weeks: ")
    (org-save-outline-visibility t
      (save-excursion
        (org-back-to-heading t)
        (org-show-all)
        (let* ((drawer-end (save-excursion (re-search-forward org-logbook-drawer-re (save-excursion (org-end-of-subtree)) t)))
               (case-fold-search t)
               (re org-ts-regexp-inactive)
               (end-mkr (set-marker (mark-marker) drawer-end)))
          (goto-char (match-beginning 0))
          (while (re-search-forward re (marker-position end-mkr) t)
            (when (>= (/ (time-to-number-of-days (org-time-since (match-string-no-properties 0))) 7)
                      (float n))
              (kill-whole-line))))
        (org-clock-remove-empty-clock-drawer))))

  (defun org-download-video-link-at-point (&optional playlistp)
    "Download video file at point.
  With `C-u' prefix arg, try to download all videos in playlist.

  Video file is expected to appear in org-link."
    (interactive "P")
    (org-link-at-point-map (lambda (url title)
                             (my/download-video url title playlistp))))

  (defun org-download-audio-link-at-point ()
    "Download audio file at point.

  Audio file is expected to appear in org-link."
    (interactive)
    (org-link-at-point-map (lambda (url title)
                             (my/download-audio url title))))

  (defun org-show-media-duration-at-point ()
    "Show duration of media at point."
    (interactive)
    (org-link-at-point-map (lambda (url title)
                             (show-media-duration url))))

  (defun org-link-at-point-map (function)
    "Call `FUNCTION' with url and title obtained from org-link at point."
    (let* ((context (org-element-lineage
                     (org-element-context)
                     '(link)
                     t))
           (type (org-element-property :type context))
           (path (org-element-property :path context))
           (desc (when-let ((begin (org-element-property :contents-begin context))
                            (end (org-element-property :contents-end context)))
                   (buffer-substring begin end))))
      (cond
       ((string-match-p "https?" type)
        (funcall function (org-link-unescape (concat type ":" path)) desc))
       ((string-match-p "elfeed" type)
        (save-excursion
          (org-open-at-point)
          (when (eq major-mode 'elfeed-show-mode)
            (when-let ((url (or (caar (elfeed-entry-enclosures elfeed-show-entry))
                                (elfeed-entry-link elfeed-show-entry)))
                       (title (elfeed-entry-title elfeed-show-entry)))
              (funcall function url title))
            (quit-window)))))))

  (defun org-send-email (&optional arg)
    "Send a html email extracted from current org entry.

  Given a `\\[universal-argument]' prefix `ARG', send an ascii email instead."
    (interactive "P")
    (cond
     ((equal arg '(4))
      (call-interactively #'org-send-email-ascii))
     (t
      (let ((org-mime-use-property-inheritance t))
        (call-interactively #'org-mime-org-subtree-htmlize)))))

  (defun org-send-email-ascii ()
    "Send a mail whose contents converted from current org entry.

  Format of mail contents is plain text."
    (interactive)
    (let ((heading (org-get-heading t t t t))
          (org-export-show-temporary-export-buffer nil)
          (export-buf-name "*Org ASCII Export*")
          (org-export-with-toc nil)
          (org-export-with-author nil))
      (org-ascii-export-as-ascii nil t t t)
      (mail-simple-send (or (org-entry-get (point) "MAIL_TO" t)
                            (read-string "MAIL_TO: "))
                        heading
                        (with-current-buffer export-buf-name
                          (buffer-string)))
      (kill-buffer export-buf-name)))

  (defun org-display-iso-week-at-point ()
    "Display ISO 8601 week number correspoinds to time stamp at point."
    (interactive)
    (let ((ts (org-timestamp-at-point)))
      (when ts
        (message "W%s" (format-time-string "%V" (org-read-date nil t ts nil))))))

  (defun org-timestamp-at-point ()
    "Return time stamp string at point."
    (let ((ts-bound (org-in-regexp (org-re-timestamp 'all))))
      (when ts-bound
        (buffer-substring (car ts-bound) (cdr ts-bound)))))

  (defun my/org-alter-heading ()
    "Interpolate heading for this org entry."
    (interactive)
    (let* ((old-heading (org-get-heading t t t t))
           (new-heading (read-string "Heading: " old-heading)))
      (save-excursion
        (org-back-to-heading t)
        (replace-string old-heading new-heading nil
                        (line-beginning-position) (line-end-position))
        (org-align-tags))
      (org-add-log-setup 'state new-heading old-heading 'state)))
#+end_src

***** keybindings for org

speed commands and hydra-org.

#+begin_src emacs-lisp
  (use-package org-keys
    :after org
    :custom
    (org-use-speed-commands
     (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))
    (org-speed-commands
     '(("Outline Navigation")
       ("n" . (org-speed-move-safe 'org-next-visible-heading))
       ("p" . (org-speed-move-safe 'org-previous-visible-heading))
       ("f" . (org-speed-move-safe 'org-forward-heading-same-level))
       ("b" . (org-speed-move-safe 'org-backward-heading-same-level))
       ("F" . org-next-block)
       ("B" . org-previous-block)
       ("u" . (org-speed-move-safe 'outline-up-heading))
       ("j" . org-goto)
       ("g" . (org-refile t))
       ("Outline Visibility")
       ("c" . org-ctrl-c-tab)
       ("C" . org-shifttab)
       (" " . org-display-outline-path)
       ("N" . my/toggle-narrow-dwim)
       ("z" . org-toggle-narrow-to-subtree)
       ("=" . org-columns)
       ("/" . org-sparse-tree)
       ("Outline Structure Editing")
       ("U" . org-metaup)
       ("D" . org-metadown)
       ("r" . org-metaright)
       ("l" . org-metaleft)
       ("R" . org-shiftmetaright)
       ("L" . org-shiftmetaleft)
       ("i" . (progn (forward-char 1) (call-interactively 'org-insert-heading-respect-content)))
       ("^" . org-sort)
       ("w" . org-refile)
       ("a" . org-archive-subtree-default-with-confirmation)
       ("@" . org-mark-subtree)
       ("#" . org-toggle-comment)
       ("x" . org-expiry-process-entry)
       ("Clock Commands")
       ("I" . org-clock-in)
       ("O" . (lambda ()
                (interactive)
                (let ((org-clock-out-remove-zero-time-clocks nil))
                  (org-clock-out nil t))))
       ("X" . org-clock-cancel)
       ("Meta Data Editing")
       ("t" . org-todo)
       ("," . (org-priority))
       ("0" . (org-priority ?\ ))
       (":" . org-set-tags-command)
       ("P" . org-set-property)
       ("e" . org-set-effort)
       ("E" . org-inc-effort)
       ("s" . org-schedule)
       ("d" . org-deadline)
       ("v" . org-property-copy-as-kill)
       ("W" . (lambda (m) (interactive "sMinutes before warning: ") (org-entry-put (point) "APPT_WARNTIME" m)))
       ("Org Capture")
       ("Misc")
       ("$" . org-archive-subtree)
       ("!" . org-readable)
       ("o" . org-open-at-point)
       ("M" . org-send-email)
       ("?" . org-speed-command-help)
       ("<" . (org-agenda-set-restriction-lock 'subtree))
       (">" . (org-agenda-remove-restriction-lock)))))

  (with-eval-after-load 'hydra
    (defhydra hydra-org (global-map "C-o"
                                    :color teal)
      "Org Search"
      ("a" org-agenda)
      ("c" org-capture)
      ("t" org-set-tags-command)
      ("j" org-clock-goto)
      ("g" consult-org-agenda)
      ("h" consult-outline)
      ("ee" my/org-english-capture)
      ("ed" my/org-english-drill)
      ("eD" my/org-english-drill-resume)
      ("ec" my/cloze-deletion-replace)
      ("s" org-store-link)
      ("C-s" org-save-all-org-buffers)
      ("TAB" org-indent-mode)
      ("i" org-info-find-node)
      ("&" org-mark-ring-goto)
      ("I" org-clock-in)
      ("O" org-clock-out)
      ("X" org-clock-cancel)
      ("qq" org-ql-search)
      ("qv" org-ql-view)
      ("r" my/org-archive-find--iso-datetree)
      ("le" my/org-english-lookup)
      ("bi" my/org-babel-lob-ingest-batch)
      ("@" org-mark-subtree)
      ("=" org-clock-sum-all)
      ("SPC" my/org-reset-dwim)
      ("C-g" nil "quit")))
#+end_src

****** org mode map

#+begin_src emacs-lisp
  (let ((map org-mode-map))
    (define-key map (kbd "C-j") #'org-return)
    (define-key map (kbd "C-M-j") #'org-return-indent)
    (define-key map (kbd "M-j") #'org-meta-return)
    (define-key map (kbd "C-S-p") #'org-previous-item)
    (define-key map (kbd "C-S-n") #'org-next-item)
    (define-key map (kbd "C-S-u") #'org-up-element)
    (define-key map (kbd "C-$") #'org-down-element)
    (define-key map (kbd "C-<") #'org-previous-link)
    (define-key map (kbd "C->") #'org-next-link)
    (define-key map (kbd "C-c @") #'org-mark-element)
    (define-key map (kbd "C-c C-SPC") #'org-mark-subtree)
    (define-key map (kbd "C-c D v") #'org-download-video-link-at-point)
    (define-key map (kbd "C-c D a") #'org-download-audio-link-at-point)
    (define-key map (kbd "C-c D =") #'org-show-media-duration-at-point)
    (define-key map (kbd "C-c !") #'org-readable)
    (define-key map (kbd "C-c C-a") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "M-h") nil))
#+end_src

**** Completion framework
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/completion.el")
:END:

***** vertico

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-vertico"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/minad/vertico/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (bind-keys :map vertico-map
               ("M-w" . vertico-save))
    (vertico-mode))
#+end_src

***** consult

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-consult"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/minad/consult/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb tangle
  (use-package consult
    :after vertico
    :bind
    (:map global-map
          ("C-;" . consult-buffer)
          ("C-c m" . consult-mode-command)
          ("C-c r" . consult-recent-file)
          ("C-c g" . consult-outline)
          ("C-x M-:" . consult-complex-command)
          ("M-y" . consult-yank-pop)
          ("C-M-y" . consult-yank-from-kill-ring)
          ("M-g M-g" . consult-goto-line)
          ("M-g m" . consult-mark)
          ("M-g M" . consult-global-mark)
          ("M-g i" . consult-imenu)
          ("M-g I" . consult-imenu-multi)
          ("M-s e" . consult-isearch)
          ("M-s \\" . consult-locate)
          ("M-s g" . consult-grep)
          ("M-s G" . consult-git-grep)
          ("M-s r" . consult-ripgrep)
          ("M-s l" . consult-line)
          ("M-s L" . consult-line-multi)
          ("M-s m" . consult-multi-occur)
          ("M-s k" . consult-keep-lines)
          ("M-s u" . consult-focus-lines)
          :map isearch-mode-map
          ("M-n" . consult-isearch)
          ("M-l" . consult-line)
          ("M-L" . consult-line-multi)
          :map minibuffer-local-map
          ("C-M-n" . consult-history)
          :map help-map
          ("a" . consult-apropos)
          :map org-mode-map
          ("C-c h" . consult-org-heading))
    :custom
    (consult-line-start-from-top t)
    (consult-project-root-function #'project-root-function)
    (consult-locate-args "plocate -d <<plocate-db()>> --ignore-case --existing --regexp"))

  (defun project-root-function ()
    (when-let (project (project-current))
      (car (project-roots project))))
#+end_src

****** consult-dir

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-consult-dir"
#+end_src

#+begin_src emacs-lisp
  (use-package consult-dir
    :bind (("C-x C-d" . consult-dir)
           :map vertico-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))
#+end_src

***** embark

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-embark"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/oantolin/embark/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C-." . embark-act)
           ("M-." . embark-dwim)
           ("<help> B" . embark-bindings)
           :map embark-file-map
           ("b" . browse-url))
    :init
    (setq prefix-help-command #'embark-prefix-help-command) ;
    :custom
    (embark-mixed-indicator-delay 3)
    :hook
    (embark-collect-mode . consult-preview-at-point-mode)
    :config
    (require 'embark-consult)
    (require 'embark-org)
    (require 'avy-embark-collect)
    (push 'embark--allow-edit
          (alist-get 'shell-command-on-region embark-target-injection-hooks)))
#+end_src

***** marginalia

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-marginalia"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/minad/marginalia/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package marginalia
    :custom
    (marginalia-field-width 180)
    :config
    (marginalia-mode))
#+end_src

***** orderless

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-orderless"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/oantolin/orderless/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package orderless
    :custom (completion-styles '(orderless)))
#+end_src

****** migemo support

#+begin_src emacs-lisp
  (defun orderless-migemo (component)
    (let ((pattern (migemo-get-pattern component)))
      (condition-case nil
          (progn (string-match-p pattern "") pattern)
        (invalid-regexp nil))))

  (orderless-define-completion-style orderless-default-style
    (orderless-matching-styles '(orderless-literal
                                 orderless-regexp)))

  (orderless-define-completion-style orderless-migemo-style
    (orderless-matching-styles '(orderless-literal
                                 orderless-regexp
                                 orderless-migemo)))

  ;; uncomment below if you wish to apply migemo globally
  ;; (setq orderless-matching-styles '(orderless-literal orderless-regexp orderless-migemo))

  (setq completion-category-overrides
        '((command (styles orderless-default-style))
          (file (styles orderless-migemo-style))
          (project-file (styles orderless-migemo-style))
          (buffer (styles orderless-migemo-style))
          (symbol (styles orderless-default-style))
          (consult-location (styles orderless-migemo-style))
          (multi-category (styles orderless-migemo-style))
          (consult-org-heading (styles orderless-migemo-style))
          (consult-location (styles orderless-migemo-style))
          (org-roam-node (styles orderless-migemo-style))
          (unicode-name (styles orderless-migemo-style))
          (variable (styles orderless-default-style))))
#+end_src

**** text-mode derivatives
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/text-mode.el")
:END:

***** text-mode

- subword-mode enables to recognize 'RSS' and 'Feed' are separate words in 'RSSFeed'

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'my/turn-on-input-method)

  ;;;###autoload
  (defun my/turn-on-input-method ()
    "Turn on `default-input-method' if buffer text does not seem to consist of ASCII."
    (when (and
           ;; this function should be applied to text-mode rather than its inheritor
           (eq major-mode 'text-mode)
           ;; target buffer must be front not buried
           (eq (current-buffer) (window-buffer)))
      (if (my/ascii-string-p (buffer-string))
          (activate-input-method nil)
        (activate-input-method default-input-method))
      (visual-line-mode 1)
      (toggle-truncate-lines -1)))
#+end_src

***** nxml-mode

#+begin_src emacs-lisp
  (use-package nxml-mode
    :delight (nxml-mode " XM")
    :mode (("\.xml$"   . nxml-mode)
           ("\.xsl$"   . nxml-mode)
           ("\.xhtml$" . nxml-mode)
           ("\.page$"  . nxml-mode)
           ("\.plist$" . nxml-mode))
    :hook (nxml-mode . my/prog-mode-hook-function)
    :custom
    (nxml-child-indent 2)
    (nxml-attribute-indent 2)
    (nxml-slash-auto-complete-flag t)
    :config
    (setq-local tab-width 2)
    ;; pattern in hideshow mode for nxml mode
    (add-to-list 'hs-special-modes-alist
                 (list 'nxml-mode
                       "<!--\\|<[^/>]*[^/]>"
                       "-->\\|</[^/>]*[^/]>"
                       "<!--"
                       'nxml-forward-element
                       nil)))
#+end_src

***** yaml-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-yaml-mode"
#+end_src

#+begin_src emacs-lisp
  (require 'yaml-mode)
#+end_src

***** json-mode
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 15:07]
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-json-mode"
#+end_src

#+begin_src emacs-lisp
  (require 'json-mode)
#+end_src

***** tex-mode

#+begin_src emacs-lisp
  (use-package tex-mode
    :mode ("\\.tex$" . latex-mode)
    :hook ((tex-mode . (lambda () (setq ispell-parser 'tex))))
    :config
    (my/add-dash-docsets-hook 'latex-mode-hook '("LaTeX")))
#+end_src

**** prog-mode derivatives
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/prog-mode.el")
:END:

***** prog-mode

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook
            #'my/prog-mode-hook-function)

  (defun my/prog-mode-hook-function ()
    (hl-line-mode -1)
    (hs-minor-mode -1)
    (flyspell-prog-mode)
    (display-fill-column-indicator-mode 1))
#+end_src

***** sh-mode

#+begin_src emacs-lisp
  (use-package sh-script
    :delight " SH"
    :commands sh-mode
    :mode ("\\.sh$" . sh-mode)
    :custom
    (sh-basic-offset 2)
    (sh-indent-after-if '+)
    (sh-indent-for-case-label 0)
    (sh-indent-for-case-alt '+)
    :config
    (my/add-dash-docsets-hook 'sh-mode-hook '("Bash")))
#+end_src

***** emacs-lisp-mode

I'm in the trial of pp-eval-last-sexp instead of eval-last-sexp adviced from [[https://karthinks.com/software/an-elisp-editing-tip/][this blog post]]

#+begin_src emacs-lisp
  (use-package elisp-mode
    :commands emacs-lisp-mode
    :hook (emacs-lisp-mode . (lambda ()
                               (setq-local tab-width 8)
                               (eldoc-mode 1)))
    :config
    (require 'eldoc)
    (substitute-key-definition 'eval-last-sexp
                               'pp-eval-last-sexp
                               global-map)
    (my/add-dash-docsets-hook 'emacs-lisp-mode-hook
                              '("Emacs Lisp")))

  (defun my/elisp-mode-eval-buffer ()
    (interactive)
    (message "Evaluated buffer")
    (eval-buffer))

  (define-key emacs-lisp-mode-map (kbd "C-c C-c") #'my/elisp-mode-eval-buffer)
  (define-key lisp-interaction-mode-map (kbd "C-c C-c") #'my/elisp-mode-eval-buffer)
#+end_src

***** scheme-mode

#+begin_src scheme :noweb-ref devel-pkgs
  "mit-scheme"
#+end_src

***** c-mode

#+begin_src emacs-lisp
  (use-package cc-mode
    :custom
    (c-tab-always-indent t)
    (c-auto-align-backslashes nil)
    (c-echo-syntactic-information-p t)
    (c-default-style "my/c-style")
    :config
    (my/add-dash-docsets-hook 'c-mode-common-hook
                              '("C"))
    (c-toggle-auto-newline 1)
    (c-add-style "my/c-style"
                 '((c-basic-offset . 4)
                   (c-comment-only-line-offset . 0)
                   (c-hanging-braces-alist
                    . ((brace-if-brace before after)
                       (substatement-open before after)))
                   (c-hanging-colons-alist
                    . ((case-label after)))
                   (c-cleanup-list
                    . (brace-else-brace
                       brace-elseif-brace
                       empty-defun-braces
                       defun-close-semi
                       list-close-comma
                       scope-operator))
                   (c-offsets-alist
                    . ((arglist-intro . +)
                       (arglist-cont-nonempty . c-lineup-arglist)))))
    (c-add-style "my/objc-style"
                 '((c-basic-offset . 2)
                   (c-comment-only-line-offset . 0)
                   (c-hanging-braces-alist
                    . ((brace-if-brace before after)
                       (substatement-open before after)))
                   (c-hanging-colons-alist
                    . ((case-label after)))
                   (c-cleanup-list
                    . (brace-else-brace
                       brace-elseif-brace
                       empty-defun-braces
                       defun-close-semi
                       list-close-comma
                       scope-operator))
                   (c-offsets-alist
                    . ((arglist-intro . +)
                       (arglist-cont-nonempty . c-lineup-arglist))))))
#+end_src

***** python-mode

#+begin_src emacs-lisp
  (use-package python
    :mode "\\.py\\'"
    :interpreter "python"
    :delight " PY"
    :hook
    ((python-mode inferior-python-mode) . my-python-mode-hook)
    (lsp-mode . (lambda ()
                  (add-to-list 'lsp-disabled-clients 'jedi)
                  (add-to-list 'lsp-enabled-clients 'pyls)))
    :config
    (my/add-dash-docsets-hook 'python-mode-hook
                              '("Python 3"))
    (my/add-dash-docsets-hook 'inferior-python-mode-hook
                              '("Python 3")))

  (defvar python-mode-initialized nil)

  (defun my-python-mode-hook ()
    (setq-local flycheck-checker 'python-pylint)
    (jedi:setup)
    (jedi-mode 1)
    (unless python-mode-initialized
      (setq python-mode-initialized t)
      (info-lookup-add-help
       :mode 'python-mode
       :regexp "[a-zA-Z_0-9.]+"
       :doc-spec
       '(("(python)Python Module Index" )
         ("(python)Index"
          (lambda
            (item)
            (cond
             ((string-match
               "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
              (format "%s.%s" (match-string 2 item)
                      (match-string 1 item))))))))))
#+end_src

****** emacs-project

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-company-jedi"
#+end_src

#+begin_src emacs-lisp
  (use-package company-jedi
    :after python
    :hook (python-mode . my/python-mode-hook)
    :custom
    (jedi:tooltip-method nil)
    :config
    (defun my/python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi)))
#+end_src

***** ruby-mode

#+begin_src emacs-lisp
  (use-package ruby-mode
    :delight " RB"
    :mode (("\\.rb$"   . ruby-mode)
           ("Capfile$" . ruby-mode)
           ("Gemfile$" . ruby-mode))
    :interpreter (("ruby"    . ruby-mode)
                  ("rbx"     . ruby-mode)
                  ("jruby"   . ruby-mode))
    :config
    (setq ruby-indent-level 2)
    (setq ruby-insert-encoding-magic-comment nil)
    (add-hook 'ruby-mode-hook
              '(lambda ()
                 (setq-local flycheck-checker 'ruby-rubocop)))
    (add-to-list 'hs-special-modes-alist
                 `(ruby-mode
                   ,(rx (or "def" "class" "module" "do" "if" "{" "[")) ; Block start
                   ,(rx (or "}" "]" "end"))                       ; Block end
                   ,(rx (or "#" "=begin"))                        ; Comment start
                   ruby-forward-sexp nil))
    (my/add-dash-docsets-hook 'ruby-mode-hook '("Ruby")))
#+end_src

****** inf-ruby

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-inf-ruby"
#+end_src

#+begin_src emacs-lisp
  (use-package inf-ruby
    :config
    (setq inf-ruby-default-implementation "pry")
    (add-to-list 'inf-ruby-implementations '("pry" . "pry"))
    (setq inf-ruby-eval-binding "Pry.toplevel_binding")
    (setq inf-ruby-first-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)> *")
    (setq inf-ruby-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)[>*\"'] *"))
#+end_src

***** lua-mode

# #+begin_src scheme :tangle no :noweb-ref emacs-pkgs
#   "emacs-lua-mode"
# #+end_src

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-mode))
#+end_src

***** perl-mode

#+begin_src emacs-lisp
  (use-package perl-mode
    :delight " PL")
#+end_src

***** web-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-web-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package web-mode
    :delight " WB"
    :mode (("\\.phtml$"     . web-mode)
           ("\\.tpl\\.php$" . web-mode)
           ("\\.jsp$"       . web-mode)
           ("\\.as[cp]x$"   . web-mode)
           ("\\.erb$"       . web-mode)
           ("\\.html?$"     . web-mode))
    :custom
    (web-mode-attr-indent-offset        2)
    (web-mode-attr-value-indent-offset  2)
    (web-mode-code-indent-offset        2)
    (web-mode-css-offset                2)
    (web-mode-markup-indent-offset      2)
    (web-mode-sql-indent-offset         2)
    (web-mode-block-padding             2)
    (web-mode-script-padding            2)
    :config
    (my/add-dash-docsets-hook 'web-mode-hook '("HTML")))
#+end_src

***** css-mode

#+begin_src emacs-lisp
  (with-eval-after-load 'css-mode
    (customize-set-variable 'css-indent-offset 2)
    (my/add-dash-docsets-hook 'css-mode-hook '("CSS")))
#+end_src

***** js2-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-js2-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package js2-mode
    :delight " J2"
    :mode (("\\.js\\(on\\)?\\'" . js2-mode)
           ("\\.eslintrc\\'"    . js2-mode))
    :hook (js2-mode . (lambda ()
                        (setq-local flycheck-checker 'javascript-eslint)
                        (setq-local flycheck-disabled-checkers '(javascript-jshint javascript-jscs))))
    :custom
    (flycheck-javascript-eslint-executable "eslint")
    (my/add-dash-docsets-hook 'js2-mode-hook '("JavaScript")))

  (use-package js
    :delight " JS"
    :custom
    (js-indent-level 2))
#+end_src

***** sql-mode

#+begin_src emacs-lisp
  (use-package sql
    :delight " SQ"
    :commands (sql-mode)
    :mode (("\\.sql$" . sql-mode))
    :bind (:map sql-interactive-mode-map
                ("C-j" . comint-send-input))
    :hook (sql-mode . (lambda ()
                        (setq-local flycheck-checker 'sql-sqlint))))
#+end_src

***** plantuml-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-plantuml-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :delight " UM"
    :custom
    (plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    :config
    (my/add-dash-docsets-hook 'plantuml-mode-hook '("PlantUML")))
#+end_src

***** conf

#+begin_src emacs-lisp
  (use-package conf-mode
    :delight " CF")
#+end_src

***** generic-x

#+begin_src emacs-lisp
  (use-package generic-x
    :mode (("\\.conf$"     . apache-conf-generic-mode)
           ("\\.htaccess$" . apache-conf-generic-mode)))
#+end_src

**** special-mode derivatives
:PROPERTIES:
:CREATED:  [2022-08-23 Tue 18:51]
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/special-mode.el")
:END:

***** special mode

#+begin_src emacs-lisp
  (define-key special-mode-map (kbd "C-j") #'push-button)
#+end_src

***** help
:PROPERTIES:
:ID:       a55da7a2-6525-4788-ba56-085eb61928d4
:END:

#+begin_src emacs-lisp
  (customize-set-variable 'help-enable-symbol-autoload t)
  (customize-set-variable 'describe-bindings-outline t)

  (with-eval-after-load 'help
    (define-key help-map (kbd "C-?") #'help-for-help)
    (define-key help-map (kbd "c") #'describe-face)
    (define-key help-map (kbd "K") #'describe-keymap)
    (define-key help-map (kbd "C-l") #'find-library))
#+end_src

***** woman

#+begin_src emacs-lisp
  (autoload #'woman "woman" nil t)
#+end_src

**** Programming
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/programming.el")
:END:

***** sMerge
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 19:57]
:END:

sMerge can be used to solve merging problems. The code below kicks off sMerge if there is a collision sign.

#+begin_src emacs-lisp
  (autoload 'smerge-mode "smerge-mode" nil t)

  (defun my/try-smerge ()
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^<<<<<<< " nil t)
        (smerge-mode 1))))
  (add-hook 'find-file-hook 'my/try-smerge t)
#+end_src

***** Next Error

#+begin_src emacs-lisp
  (customize-set-variable 'next-error-message-highlight t)
#+end_src

***** Hideshow

#+begin_src emacs-lisp
  (use-package hideshow
    :diminish "hs"
    :bind (("C-c TAB" . hs-toggle-hiding)))
#+end_src

***** imenu

#+begin_src emacs-lisp
  (use-package imenu
    :custom
    (imenu-auto-rescan t))
#+end_src
***** compile

#+begin_src emacs-lisp
  (use-package compile
    :bind (:map compilation-mode-map
                ("C-j" . compile-goto-error)))

  (defun my/compile-default-command ()
    "Compile `compile-command'."
    (funcall #'compile compile-command)
    (quit-window))
#+end_src

***** grep

#+begin_src emacs-lisp
  (use-package grep
    :custom
    (grep-program "rg")
    :config
    (bind-keys :map grep-mode-map
               ("C-j" . compile-goto-error)))

  (defun my/grep-ripgrep-all ()
    "Grep many kind of files like pdf, epub and more."
    (interactive)
    (let ((grep-find-command '("rga --with-filename --no-heading --line-number --color never -e '' ./* ./**/*" . 66)))
      (call-interactively 'grep-find)))

  (global-set-key (kbd "M-s R") 'my/grep-ripgrep-all)
#+end_src

***** executable
This customization is based on [[https://emacsredux.com/blog/2021/09/29/make-script-files-executable-automatically/][this advice]]

#+begin_src emacs-lisp
  (use-package executable
    :hook (after-save
           . executable-make-buffer-file-executable-if-script-p))
#+end_src

***** paren

#+begin_src emacs-lisp
  (require 'paren)

  (customize-set-variable 'show-paren-style 'parenthesis)
  (customize-set-variable 'show-paren-delay 0.25)
  (customize-set-variable 'show-paren-mode nil)
#+end_src

***** project

#+begin_src emacs-lisp
  (use-package project)
#+end_src

***** log-view

#+begin_src emacs-lisp
  (use-package log-view
    :delight
    (log-view-mode " LV")
    :mode ("\\.log$" . log-view-mode)
    :hook ((log-view-mode . my/prog-mode-hook-function )
           (log-view-mode . auto-revert-tail-mode)))
#+end_src

***** vc (version control)
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:
***** ediff

#+begin_src emacs-lisp
  (use-package ediff
    :commands ediff-files
    :custom
    (ediff-window-setup-function 'ediff-setup-windows-default)
    (ediff-split-window-function 'split-window-horizontally))
#+end_src
***** vc-hooks

#+begin_src emacs-lisp
  (use-package vc-hooks
    :custom
    (vc-follow-symlinks t))
#+end_src
**** other third-party packages
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/lisp/packages.el")
:END:

***** pcre2el
:PROPERTIES:
:CREATED:  [2022-12-06 Tue 16:50]
:END:

[[https://github.com/joddie/pcre2el][pcre2el]] is not only the converter between PCRE, emacs lisp style regexp and RX representation. It support re-builder as a conversion environment. Great!

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-pcre2el"
#+end_src

#+begin_src emacs-lisp
  (use-package pcre2el)
#+end_src

***** iedit
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 18:02]
:END:

[[https://github.com/victorhge/iedit][IEdit]] is not only replacement for M-%/C-M-% but it highlights symbol occurences to change. [[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][This advise]] would be useful for anyone who needs dedicated command to replace symbols in defun.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-iedit"
#+end_src

#+begin_src emacs-lisp
  (customize-set-variable 'iedit-toggle-key-default (kbd "C-\""))
  (customize-set-variable 'iedit-auto-narrow t)

  ;; require clause should sit here to supress key occupation warning
  (require 'iedit)

  (global-set-key (kbd "C-\"") 'iedit-mode)
#+end_src

***** ledger-mode / flycheck-ledger
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 21:08]
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-ledger-mode"
  "emacs-flycheck-ledger"
#+end_src

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))

  (autoload 'ledger-mode "ledger-mode" "A major mode for Ledger" t)
  (with-eval-after-load 'ledger-mode
    (require 'flycheck-ledger))

  (customize-set-variable 'ledger-reconcile-default-commodity "\\")
#+end_src

***** mentor
:PROPERTIES:
:CREATED:  [2022-10-04 Tue 22:09]
:END:

[[https://github.com/skangas/mentor][mentor]] is a [[id:bdc987ad-419b-4f36-922d-de75207d85c0][rTorrent]] client for emacs.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-mentor"
#+end_src

#+begin_src emacs-lisp :noweb tangle
  (autoload #'mentor "mentor" nil t)

  (with-eval-after-load 'mentor
    (customize-set-variable 'mentor-rtorrent-download-directory
                            (expand-file-name "data/media/torrent"
                                              "<<home-dir()>>"))
    (customize-set-variable 'mentor-rtorrent-keep-session t)
    (customize-set-variable 'mentor-rtorrent-external-rpc
                            "<<rtorrent-sock()>>"))
#+end_src

***** Geiser
:PROPERTIES:
:CREATED:  [2022-09-06 Tue 15:26]
:END:

[[info:guix#The Perfect Setup][guix#The Perfect Setup]]

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "guile"
  "emacs-geiser"
  "emacs-geiser-guile"
#+end_src

***** consult-dash
:PROPERTIES:
:CREATED:  [2022-08-05 Fri 16:56]
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-dash-docs"
#+end_src

#+begin_src emacs-lisp
  (use-package dash-docs
    :custom
    (dash-docs-docsets-path
     (file-name-concat my/user-share-directory "dash/docsets")))

  (add-to-list 'load-path
               (expand-file-name "elpa/consult-dash-20220621.226" user-emacs-directory-default))

  (use-package consult-dash
    :after dash-docs
    :bind ("M-s M-d" . consult-dash))

  (defmacro my/add-dash-docsets-hook (hook docsets)
    `(add-hook ,hook
               (lambda ()
                 (when (functionp 'consult-dash)
                   (setq-local consult-dash-docsets ,docsets)))))
#+end_src

***** eglot
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:32]
:END:

[[https://github.com/joaotavora/eglot][Eglot]]

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-eglot"
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :hook ((sh-mode ruby-mode) . eglot-ensure)
    :custom
    (eglot-extend-to-xref t))
#+end_src

***** denote
:PROPERTIES:
:CREATED:  [2022-08-02 Tue 20:08]
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-denote"
#+end_src

#+begin_src emacs-lisp
  (require 'denote)

  (customize-set-variable 'denote-directory
                          (file-name-concat org-directory "notes"))

  (with-eval-after-load 'org-capture
    (setq denote-org-capture-specifiers "%l\n%i\n%?")
    (add-to-list 'org-capture-templates
                 '("n" "New note (with denote.el)" plain
                   (file denote-last-path)
                   #'denote-org-capture
                   :no-save t
                   :immediate-finish nil
                   :kill-buffer t
                   :jump-to-captured t)))
#+end_src

***** tree-sitter
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 10:14]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/emacs-tree-sitter/elisp-tree-sitter/releases.atom" soft_update)
  ("https://github.com/emacs-tree-sitter/tree-sitter-langs/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package tree-sitter-langs
    :straight t)

  (use-package tree-sitter
    :straight t
    :after tree-sitter-langs
    :hook ((tree-sitter-after-on . tree-sitter-hl-mode))
    :config
    (global-tree-sitter-mode 1))
#+end_src

***** xr                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-07-30 Sat 16:12]
:END:

[[https://elpa.gnu.org/packages/xr.html][XR]] converts Emacs regular expressions to the structured rx form, thus being an inverse of rx.

#+begin_src scheme :tangle no
  "emacs-xr"
#+end_src

***** Whole Line Or Region

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/purcell/whole-line-or-region/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :straight t
    :config
    (whole-line-or-region-global-mode 1))
#+end_src
***** projectile                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
  (use-package projectile
    :hook
    (find-file . projectile-mode-switch-dwim)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :custom
    (projectile-project-search-path (expand-file-name "~/git"))
    (projectile-switch-project-action 'projectile-dired)
    (projectile-track-known-projects-automatically nil)
    (projectile-mode-line-prefix " P")
    (projectile-mode-line-function 'projectile-short-mode-line)
    :config
    (projectile-load-known-projects)
    (bind-keys :map projectile-command-map
               ("C-s" . projectile-save-project-buffers)))

  (defun projectile-mode-switch-dwim ()
    "Intelligently switch on/off projectile mode."
    (when-let* ((bfn (buffer-file-name))
                (vc-registered (buffer-file-name)))
      (setq-local projectile-mode t)))

  (defun projectile-short-mode-line ()
    "Report project name and type in the modeline."
    (let ((project-name (projectile-project-name)))
      (format "%s:%s"
              projectile-mode-line-prefix
              (or project-name "-"))))
#+end_src

***** counsel-projectile             :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after projectile
    :config
    (bind-keys :map projectile-command-map
               ("p" . counsel-projectile-switch-project)
               ("sG" . counsel-projectile-grep)
               ("sS" . counsel-projectile-ag)
               ("sR" . counsel-projectile-rg)
               ("si" . counsel-projectile-git-grep)))
#+end_src
***** ag.el                          :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
  ;; (use-package ag :straight t)
#+end_src

***** ripgrep.el                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
  ;; (use-package ripgrep :straight t)
#+end_src

***** wgrep

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-wgrep"
#+end_src

#+begin_src emacs-lisp
  (use-package wgrep
    :custom
    (wgrep-auto-save-buffer t)
    (wgrep-enable-key "e"))
#+end_src

***** dumb-jump

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is "jump to definition" package without tagging.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-dumb-jump"
#+end_src

#+begin_src emacs-lisp
  (use-package dumb-jump
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window)
           ("M-g /" . dumb-jump-back)
           ("M-g l" . dumb-jump-quick-look)))
#+end_src

***** visual-regexp                         :ARCHIVE:

#+begin_src scheme :tangle no
  "emacs-visual-regexp"
#+end_src

#+begin_src emacs-lisp
  (use-package visual-regexp
    :bind ("C-%" . vr/query-replace))
#+end_src

****** visual-regexp-steroids

#+begin_src emacs-lisp :tangle no
  ("https://github.com/benma/visual-regexp-steroids.el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package visual-regexp-steroids
    :straight t
    :after (visual-regexp)
    :config
    (setq vr/engine 'python))
#+end_src

***** avy

[[https://karthinks.com/software/avy-can-do-anything/][This post]] tell me how we can concoct efficient editing workflow with avy.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-avy"
#+end_src

#+begin_src emacs-lisp
  (use-package avy
    :config
    (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark))

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
#+end_src

****** avy-migemo

#+begin_src emacs-lisp
  (use-package avy-migemo
    :straight t
    :bind (("M-g M-a" . avy-migemo-goto-char-timer)
           ("M-g a" . avy-migemo-goto-char-timer)
           :map isearch-mode-map
           ("M-a" . avy-migemo-isearch)))
#+end_src

***** paredit

Handy commands
- press '(' to insert '()' pair
- C-<left/right> to barf and slurp s-expressions
- call paredit-splice-sexp to strip embracing parenthes
- press M-<up> or M-r to delete upper sexp except pointing one
- DEL, C-d, C-k act like originals but care for parenthes
- press DEL to remedy unbalanced parenthes
- press C-q ( to insert ( char manually

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-paredit"
#+end_src

#+begin_src emacs-lisp
  (use-package paredit
    :bind (:map paredit-mode-map
                ("<backspace>" . paredit-backward-delete)
                ("C-M-g" .  paredit-splice-sexp)
                ("M-s" . nil)
                ("C-M-;" . paredit-comment-dwim)
                ("M-;" . nil))
    :hook (((emacs-lisp-mode scheme-mode) . enable-paredit-mode)
           (paredit-mode . show-paren-local-mode)))
#+end_src

- workaround
  Thanks to [[https://andreyorst.gitlab.io/posts/2021-09-30-why-is-paredit-is-so-un-emacsy/][this blog post]], a couple of commands in paredit.el are fixed with transient-mark-mode

  #+begin_src emacs-lisp
    (defvar my/paredit-delete-region-functions
      '(paredit-forward-delete
        paredit-backward-delete)
      "List of `paredit-mode' functions that should support tmm region deletion.")

    (defvar my/paredit-kill-region-functions
      '(paredit-forward-kill-word
        paredit-backward-kill-word)
      "List of `paredit-mode' functions that should support tmm region killing.")

    (defun my/paredit-fix-transient-mark-mode (orig-fn &rest args)
      "Allow deleting/killing a region if expression is balanced."
      (if (and transient-mark-mode
               mark-active)
          (cond ((memq this-command my/paredit-delete-region-functions)
                 (paredit-delete-region (region-beginning) (region-end)))
                ((memq this-command my/paredit-kill-region-functions)
                 (paredit-kill-region (region-beginning) (region-end)))
                (t (apply orig-fn args)))
        (apply orig-fn args)))

    (dolist (fun (append my/paredit-delete-region-functions
                         my/paredit-kill-region-functions))
      (advice-add fun :around #'my/paredit-fix-transient-mark-mode))
  #+end_src

***** lsp-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-lsp-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((python-mode) . lsp-deferred))
#+end_src

****** lsp-ivy                      :ARCHIVE:ignore:

#+begin_src emacs-lisp
  ;; (use-package lsp-ivy
  ;;   :straight t
  ;;   :after lsp
  ;;   :hook (lsp-mode . lsp-ivy-mode))
#+end_src

***** company-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-company"
#+end_src

#+begin_src emacs-lisp
  (use-package company
    :hook (prog-mode . company-mode)
    :bind (:map company-active-map
                ("C-j" . company-complete-selection)
                ("<backspace>" . backward-delete-char-untabify)
                ("C-h" . company-show-doc-buffer)
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)))
#+end_src

***** flycheck

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-flycheck"
#+end_src

#+begin_src emacs-lisp
  (use-package flycheck
    :diminish
    :hook (prog-mode . flycheck-mode-on-safe)
    :custom
    (global-flycheck-mode t)
    (flycheck-check-syntax-automatically
     '(save new-line idle-change))
    (flycheck-display-errors-delay 10.0)
    (flycheck-checker-error-threshold 1000)
    (flycheck-textlint-config ".textlintrc")
    :config
    (add-hook 'flycheck-mode-hook
              (lambda ()
                (if (my/ascii-string-p (buffer-string))
                    (setq flycheck-textlint-config ".textlintrc")
                  (setq flycheck-textlint-config ".config/textlint/textlintrc_ja"))))
    (add-to-list 'display-buffer-alist
                 `(,flycheck-error-message-buffer
                   . (display-buffer-reuse-window
                      display-buffer-in-previous-window
                      display-buffer-pop-up-window
                      . ((window-height . 5))))))
#+end_src

***** twittering-mode

useful tips:
- invoke twittering-toggle-show-replied-statuses on "in reply to" state to show replied messages
- invoke twittering-view-user-page (C-c C-v) on user name to jump to user profile page in default browser

Disclaimers: An unexpected incident might occur if twittering-icon-mode call lay at :config section of use-package

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/hayamiz/twittering-mode/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (defvar my/twittering-resource-dir
    (expand-file-name "twmode" user-emacs-directory))

  (use-package twittering-mode
    :straight (twittering-mode
               :host github
               :repo "hayamiz/twittering-mode"
               :fork (:host github
                            :repo "p-snow/twittering-mode"))
    :delight " TW"
    :after hydra
    :commands twit
    :hook
    (twittering-mode . twittering-icon-mode)
    :custom
    (twittering-private-info-file
     (expand-file-name "twittering-mode.gpg" my/twittering-resource-dir))
    (twittering-user-id-db-file
     (expand-file-name "user-info.gz" my/twittering-resource-dir))
    (twittering-use-master-password t)
    (twittering-use-ssl t)
    (twittering-number-of-tweets-on-retrieval 50)
    (twittering-use-icon-storage t)
    (twittering-icon-storage-file
     (expand-file-name "icons.gz" my/twittering-resource-dir))
    (twittering-icon-storage-limit 2000)
    (twittering-convert-fix-size 24)
    (twittering-initial-timeline-spec-string '(":home" ":mentions"))
    (twittering-edit-skeleton 'inherit-any)
    (twittering-display-remaining t)
    (twittering-timeline-header "")
    (twittering-timeline-footer "")
    (twittering-status-format
     (concat "%RT{%FACE[bold]{RT by %S\n}}"
             "%i %S,"
             "%FACE[font-lock-constant-face]{%FIELD-IF-NONZERO[ ↺%d]{retweet_count}}"
             "%FACE[font-lock-warning-face]{%FIELD-IF-NONZERO[ ♡%d]{favorite_count}}"
             " %@{}:\n"
             "%T %r%QT{\n+----\n%i %S, %@{}:\n%T %r%R\n+----}\n "))
    :config
    (bind-keys :map twittering-mode-map
               ("C-c C-l" . nil)
               ;; move cursor
               ("f" . scroll-up-line)
               ("e" . scroll-down-line)
               ("E" . my/twittering-previous-status-and-top)
               ("SPC" . my/twittering-next-status-and-top)
               ;; create/delete tweets(messages)
               ("u" . twittering-update-status-interactive)
               ("j" . twittering-enter)
               ("J" . twittering-reply-to-user)
               ("RET" . twittering-enter)
               ("o" . my/twittering-open)
               ("C-c C-o" . my/twittering-open)
               ("d" . twittering-direct-message)
               ("k" . twittering-delete-status)
               ("y" . twittering-push-uri-onto-kill-ring)
               ("Y" . twittering-push-tweet-onto-kill-ring)
               ;; response to tweets
               ("r" . twittering-native-retweet)
               ("R" . my/twittering-quote-retweet)
               ("b" . twittering-favorite)
               ("B" . twittering-unfavorite)
               ("l" . twittering-follow)
               ("L" . twittering-unfollow)
               ("t" . twittering-toggle-show-replied-statuses)
               ("T" . twittering-toggle-or-retrieve-replied-statuses)
               ;; switch between timelines
               ("n" . twittering-switch-to-next-timeline)
               ("p" . twittering-switch-to-previous-timeline)
               ("." . twittering-visit-timeline)
               ("@" . twittering-other-user-timeline)
               ("/" . my/twittering-search)
               ("?" . twittering-search)
               ("c1" . twittering-home-timeline)
               ("c2" . (lambda ()
                         (interactive)
                         (twittering-visit-timeline ":mentions")))
               ("c3" . (lambda ()
                         (interactive)
                         (twittering-visit-timeline ":retweets_of_me")))
               ("c4" . (lambda ()
                         (interactive)
                         (twittering-search "from:_p_snow")))
               ("c5" . (lambda ()
                         (interactive)
                         (twittering-visit-timeline ":favorites")))
               ("c6" . (lambda ()
                         (interactive)
                         (twittering-visit-timeline ":direct_message_events")))))

  (defun my/twittering-next-status-and-top ()
    "docstring"
    (interactive)
    (twittering-goto-next-status)
    (recenter-top-bottom 0))

  (defun my/twittering-previous-status-and-top ()
    "docstring"
    (interactive)
    (twittering-goto-previous-status)
    (recenter-top-bottom 0))

  (defun my/twittering-quote-retweet ()
    "docstring"
    (interactive)
    (let ((orig-tweet-uri (twittering-push-uri-onto-kill-ring)))
      (twittering-update-status (format "\n%s" orig-tweet-uri))
      (next-line -1 t)))

  (defun my/twittering-search (&optional arg)
    ""
    (interactive "P")
    (let* ((spec (get-text-property (point) 'goto-spec))
           (username (get-text-property (point) 'username))
           (word (cond
                  ((use-region-p) (buffer-substring (region-beginning) (region-end)))
                  ((stringp spec) spec)
                  ((eq (car spec) 'user) (format "@%s" (cadr spec)))
                  ((stringp username) username))))
      (twittering-search (and (not arg) word))))

  (defun my/twittering-open (&optional arg)
    ""
    (interactive "P")
    (let ((uri (or (get-text-property (point) 'uri)
                   (if (get-text-property (point) 'field)
                       (let* ((id (get-text-property (point) 'id))
                              (status (twittering-find-status id)))
                         (twittering-get-status-url-from-alist status))
                     nil))))
      (browse-url uri)))
#+end_src

***** comment-dwim-2                        :ARCHIVE:

#+begin_src emacs-lisp :tangle no
  ("https://github.com/remyferre/comment-dwim-2/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package comment-dwim-2
    :straight t
    :defer 1
    :bind ("M-;" . comment-dwim-2)
    :config
    (setf comment-dwim-2--inline-comment-behavior 'reindent-comment
          cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

***** undo-tree

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-undo-tree"
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
  d <<share-dir()>>/emacs/undo-tree 0755 - - 3w
#+end_src

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
    (defvar undo-tree-excludes '("/gnu/store"))
    :hook
    ((text-mode prog-mode) .
     (lambda ()
       (when-let ((file-visited (or buffer-file-name
                                    org-src-source-file-name)))
         (unless (seq-some (lambda (exclude)
                             (string-match-p exclude
                                             file-visited))
                           undo-tree-excludes)
           (undo-tree-mode 1)))))
    :custom
    (undo-tree-enable-undo-in-region t)
    (undo-tree-auto-save-history nil)
    (undo-tree-limit 320000)
    (undo-tree-strong-limit 480000)
    (undo-tree-outer-limit 64000000)
    :config
    (define-key undo-tree-map (kbd "C-?") nil)
    (add-to-list 'undo-tree-history-directory-alist `("." . ,(expand-file-name "undo-tree" user-emacs-directory)))
    (setq undo-tree-visualizer-buffer-name "*undo tree*")
    (add-to-list 'display-buffer-alist
                 `(,undo-tree-visualizer-buffer-name . (display-buffer-in-side-window
                                                        . ((side . right)
                                                           (window-width . 15))))))
#+end_src

***** quickrun                              :ARCHIVE:

#+begin_src emacs-lisp
  ;; (use-package quickrun)
#+end_src

***** expand-region

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-expand-region"
#+end_src

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-,"   . er/expand-region)
           ("C-M-," . er/contract-region))
    :config
    (push 'er/mark-outside-pairs er/try-expand-list))
#+end_src

***** helpful                               :ARCHIVE:

helpful-mode shows more than [[id:a55da7a2-6525-4788-ba56-085eb61928d4][help-mode]].

# #+begin_src scheme :tangle no :noweb-ref emacs-pkgs
#   "emacs-helpful"
# #+end_src

#+begin_src emacs-lisp
  (use-package helpful
    :bind
    (:map help-map
          ("f" . helpful-callable)
          ("v" . helpful-variable)
          ("k" . helpful-key))
    (:map helpful-mode-map
          ("w" . helpful-push-symbol-onto-kill-ring) )
    :config
    (bind-keys :map helpful-mode-map
               ("f" . scroll-up-line)
               ("e" . scroll-down-line)
               ("SPC" . my/forward-paragraph)
               ("E" . my/backward-paragraph)
               ("2" . backward-button)
               ("3" . forward-button)
               ("4" . push-button)))

  (defun helpful-push-symbol-onto-kill-ring ()
    "Push symbol name to kill ring."
    (interactive)
    (let ((symbol (symbol-name helpful--sym)))
      (kill-new (symbol-name helpful--sym))
      (message "COPY: %s" symbol)))
#+end_src

***** define-word

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/abo-abo/define-word/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package define-word
    :straight t
    :custom
    (define-word-displayfn-alist
      '((wordnik . my/define-word--display-in-buffer)
        (openthesaurus . my/define-word--display-in-buffer)
        (webster . my/define-word--display-in-buffer)
        (weblio . my/define-word--display-in-buffer)))
    (define-word-default-service 'wordnik)
    :config
    (setf (cdr (assoc 'wordnik define-word-services))
          '("http://wordnik.com/words/%s" my/define-word--parse-wordnik-all))
    (push '(weblio "https://ejje.weblio.jp/content/%s"
                   my/define-word--parse-weblio)
          define-word-services)
    (push '("<b>\\(.*?\\)</b>" bold)
          define-word--tag-faces)
    ;; fix issue #31 temporally
    (defun my/define-word--fix-31 (define-word-orig &rest args)
      "Fix `define-word' backends that require a user agent (like wordnik)."
      (let ((url-request-extra-headers
             '(("User-Agent" .
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36"))))
        (apply define-word-orig args)))
    (advice-add #'define-word :around #'my/define-word--fix-31))

  (defun my/define-word ()
    "docstring"
    (interactive)
    (if (use-region-p)
        (call-interactively #'define-word-at-point)
      (call-interactively #'define-word)))

  (defun my/define-word--display-in-buffer (definition)
    "docstring"
    (let* ((buf-name "*DEFINE WORD*")
           (buffer (get-buffer-create buf-name))
           (display-buffer-alist
            `((,buf-name
               (display-buffer-same-window)))))
      (with-current-buffer buffer
        (read-only-mode -1)
        (erase-buffer)
        (insert definition)
        (goto-char (point-min))
        (save-excursion (xml-parse-string))
        (read-only-mode 1))
      (display-buffer buffer)))

  (defun my/define-word--parse-wordnik-example ()
    (save-excursion
      (let (beg
            results
            (define-word-limit 10))
        (re-search-forward "<h2>Examples" nil t)
        (save-excursion
          (setq beg (re-search-forward "<div class=\"relatedWords-module\">" nil t)))
        (while (re-search-forward "<p class=\"text\">\\(.*\\)</p>" beg t)
          (push "---" results)
          (push (match-string 1) results))
        (when (setq results (nreverse results))
          (define-word--convert-html-tag-to-face (define-word--join-results results))))))

  (defvar my/define-word-part-map-alist '(("adjective" "adj.")
                                          ("adverb" "adv.")
                                          ("intransitive verb" "v.i.")
                                          ("transitive verb" "v.t.")))


  (defun my/define-word--parse-wordnik ()
    (let ((str (define-word--parse-wordnik)))
      (with-temp-buffer
        (insert str)
        (mapc (lambda (abbrev-map)
                (goto-char (point-min))
                (while (re-search-forward (format "\\(%s\\)" (car abbrev-map)) nil t)
                  (let ((match (match-string 1)))
                    (replace-match
                     (propertize (cadr abbrev-map) 'face (text-properties-at (point)))))))
              my/define-word-part-map-alist)
        (buffer-string))))

  (defun my/define-word--parse-wordnik-related-word ()
    "docstring"
    (save-excursion
      (save-match-data
        (seq-reduce
         (lambda (accum group)
           (let (results
                 (define-word-limit 20))
             (if (re-search-forward (format "<h3>%s" group) nil t)
                 (progn (save-excursion
                          (setq beg (re-search-forward "<div class=\"related-group-header clearfix\">" nil t)))
                        (push (concat group ":") results)
                        (while (re-search-forward "<span data-definition-for=\"\\([^\"]*\\)\"" beg t)
                          (push (concat "- " (match-string 1)) results)
                          (re-search-forward "</span>"))
                        (concat (when accum (concat accum "\n\n"))
                                (when (setq results (nreverse results))
                                  (define-word--convert-html-tag-to-face (define-word--join-results results)))))
               accum)))
         '("antonym" "equivalents" "hypernyms" "hyponyms" "same context")
         nil))))

  (defun my/define-word--parse-wordnik-all ()
    ""
    (let* ((def (funcall #'my/define-word--parse-wordnik))
           (rel (funcall #'my/define-word--parse-wordnik-related-word))
           (exp (funcall #'my/define-word--parse-wordnik-example)))
      (concat ;; "Definitions:\n" (funcall #'define-word--parse-wordnik) "\n\n"
       (when def (format "Definitions:\n%s\n\n" def))
       (when rel (format "%s\n\n" rel))
       (when exp (format "Examples:\n%s\n" exp)))))

  (defun my/define-word--parse-weblio ()
    (save-excursion
      (let (beg
            results
            (define-word-limit 10))
        (re-search-forward "<span class=\"squareCircle description\">\n[[:blank:]]*意味・対訳</span>" nil t)
        (save-excursion
          (setq beg (re-search-forward "</div>" nil t)))
        (while (re-search-forward "<span class=\"content-explanation  ej\">\n[[:blank:]]*\\([^<]*\\)</span>" beg t)
          (push (match-string 1) results))
        (when (setq results (nreverse results))
          (define-word--convert-html-tag-to-face (define-word--join-results results))))))
#+end_src

***** synosaurus

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-synosaurus"
#+end_src

#+begin_src emacs-lisp
  (use-package synosaurus
    :custom
    (synosaurus-choose-method 'default))
#+end_src

***** exec-path-from-shell

A GNU Emacs library to ensure environment variables inside Emacs look the same as in the user's shell.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-exec-path-from-shell"
#+end_src

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac))
      (exec-path-from-shell-initialize)))
#+end_src

***** migemo.el

migemo allows me to search incrementally Japanese words using roma-ji expression.

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/emacs-jp/migemo/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package migemo
    :straight t
    :ensure-system-package cmigemo
    :custom
    (migemo-command "cmigemo")
    (migemo-options '("-q" "--emacs"))
    (migemo-directory "/usr/share/cmigemo/utf-8")
    (migemo-dictionary "/usr/share/cmigemo/utf-8/migemo-dict")
    (migemo-user-dictionary nil)
    (migemo-coding-system 'utf-8-unix)
    (migemo-regex-dictionary nil)
    :config
    (migemo-init))
#+end_src

****** ivy-migemo                   :ARCHIVE:ignore:

#+begin_src emacs-lisp
  (use-package ivy-migemo
    :after migemo)
#+end_src

***** jaword
:PROPERTIES:
:CREATED:  [2022-08-13 Sat 18:01]
:END:

Jaword.elはbackward-wordやforward-wordを日本語に対応させる機能を提供します。これらのコマンドはデフォルトではひらがな・カタカナ・漢字の境界を単語の区切りとするのに対し、jaword.elを使用するとより正確に日本語の単語単位での移動が可能です。

#+begin_src emacs-lisp :tangle no
  ("https://github.com/zk-phi/jaword/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package jaword
    :straight t
    :custom
    (jaword-enable-subword t)
    :hook ((skk-mode
            . (lambda ()
                (jaword-mode 1)))
           (input-method-activate
            . (lambda ()
                (when (string= current-input-method "japanese-skk")
                  (jaword-mode 1))))
           (input-method-deactivate
            . (lambda ()
                (when (string= current-input-method "japanese-skk")
                  (jaword-mode -1))))))
#+end_src

***** hungry-delete                         :ARCHIVE:

Aggressively delete successive white spaces.

#+begin_src emacs-lisp :tangle no
  ("https://github.com/nflath/hungry-delete/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package hungry-delete
    :straight t
    :diminish
    :config
    (global-hungry-delete-mode 1))
#+end_src

***** aggressive-indent-mode
:PROPERTIES:
:ID:       4a58219c-74dd-4135-b56d-876b0db2cd83
:END:

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-aggressive-indent"
#+end_src

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :diminish (aggressive-indent-mode . "ai")
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src
***** adaptive-wrap

adaptive-wrap and visual-line-mode are active in a bundle in a bunch of major modes.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-adaptive-wrap"
#+end_src

#+begin_src emacs-lisp
  (use-package adaptive-wrap)
#+end_src

***** restart-emacs

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-restart-emacs"
#+end_src

#+begin_src emacs-lisp
  (use-package restart-emacs
    :bind (("C-M-<delete>"   . restart-emacs)
           ("C-M-S-<delete>" . save-buffers-kill-emacs)))
#+end_src
***** pangu-spacing                         :ARCHIVE:

#+begin_src emacs-lisp :tangle no
  ("https://github.com/coldnew/pangu-spacing/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
  (use-package pangu-spacing
    :straight t
    :diminish pangu-spacing-mode
    :custom
    (pangu-spacing-real-insert-separtor t)
    :config
    (setq pangu-spacing-chinese-before-english-regexp
          (rx (group-n 1 (category japanese))
              (group-n 2 (in "a-zA-Z0-9"))))
    (setq pangu-spacing-chinese-after-english-regexp
          (rx (group-n 1 (in "a-zA-Z0-9"))
              (group-n 2 (category japanese)))))
#+end_src
***** which-key                             :ARCHIVE:

[[https://github.com/justbur/emacs-which-key][which-key]] guides me "which key is available" after current key stroke in the mini buffer.

#+begin_src scheme :tangle no
  "emacs-which-key"
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :custom
    (which-key-use-C-h-commands t)
    (which-key-max-description-length 43)
    (which-key-idle-delay 0.7)
    (which-key-separator " : ")
    (which-key-side-window-max-height 0.5)
    :config
    (which-key-mode 1)
    (which-key-setup-side-window-bottom))
#+end_src
***** hydra

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-hydra"
#+end_src

#+begin_src emacs-lisp
  (use-package hydra
    :custom
    (hydra-is-helpful nil))
#+end_src
***** pass

Major mode for manupulating password store file.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-pass"
#+end_src

#+begin_src emacs-lisp
  (use-package pass
    :config
    (bind-keys :map pass-mode-map
               ("C-j" . pass-view)))
#+end_src

***** password-store

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-password-store"
#+end_src

#+begin_src emacs-lisp
  (use-package password-store
    :custom
    (password-store-time-before-clipboard-restore 25))
#+end_src

***** nov.el

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-nov-el"
#+end_src

#+begin_src emacs-lisp
  (use-package nov
    :demand t
    :mode ("\\.epub$" . nov-mode)
    :hook (nov-mode . nov-abbreviate-file-name)
    :custom
    (nov-variable-pitch nil)
    (nov-text-width t)
    :config
    (bind-keys :map nov-mode-map
               ("C-j" . nov-browse-url)))

  (defun nov-abbreviate-file-name ()
    "Shorten `nov-file-name' using `directory-abbrev-alist'."
    (setq nov-file-name (abbreviate-file-name nov-file-name)))
#+end_src
***** yasnippet

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-yasnippet"
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet
    :delight (snippet-mode " SN")
    :diminish (yas-minor-mode . "ys")
    :hook
    ((prog-mode org-mode shell-mode) . yas-minor-mode-on)
    :custom
    (yas-triggers-in-field t)
    (yas-snippet-dirs
     `(,(expand-file-name "snippets" user-emacs-directory-default)))
    :config
    ;; work around code
    (yas-reload-all))
#+end_src
****** yasnippet-snippets

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-yasnippet-snippets"
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src
***** pdf-tools

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-pdf-tools"
#+end_src

#+begin_src emacs-lisp
  (use-package pdf-tools
    :delight
    (pdf-view-mode " PV")
    :mode ("\\.pdf$" . pdf-view-mode)
    :hook
    (pdf-view-mode . pdf-view-midnight-minor-mode)
    (pdf-view-mode . pdf-view-fit-page-to-window)
    :custom
    (pdf-view-display-size 'fit-width))
#+end_src

***** rainbow-mode

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-rainbow-mode"
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :diminish
    (rainbow-mode . "rb")
    :hook
    ((css-mode scss-mode php-mode html-mode) . rainbow-mode)
    :custom
    (rainbow-html-colors t)
    (rainbow-x-colors t)
    (rainbow-latex-colors t)
    (rainbow-ansi-colors t))
#+end_src
***** alert

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "mpg321"
  "emacs-alert"
#+end_src

#+begin_src emacs-lisp
  (use-package alert
    :config
    (set-face-background 'alert-saved-fringe-face nil)
    (alert-add-rule :status '(buried)
                    :mode   'mu4e-alert
                    :style  'fringe)
    (alert-add-rule :status '(buried)
                    :mode   'dired-mode
                    :style  'fringe)
    (alert-add-rule :status '(buried)
                    :mode   'org-mode
                    :style  'libnotify))
#+end_src

#+begin_src shell :tangle (expand-file-name ".local/bin/volget") :tangle-mode (identity #o755)
  #!/usr/bin/env bash

  pactl list sinks | grep '^[[:space:]]Volume:' | head -n $(($SINK + 1 )) | tail -n 1 | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,'
#+end_src

***** ts

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-ts"
#+end_src

#+begin_src emacs-lisp
  (use-package ts)
#+end_src

***** app-launcher                          :ARCHIVE:

#+begin_src emacs-lisp
  (use-package app-launcher
    :straight '(app-launcher
                :host github
                :repo "SebastienWae/app-launcher"))
#+end_src

***** tldr

I ran into a problem with downloading TL;DR document. I forcibly download, uncompress and locate that to `tldr-directory-path'.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-tldr"
#+end_src

#+begin_src emacs-lisp
  (use-package tldr
    :custom
    (tldr-use-word-at-point t))
#+end_src

***** burly

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "emacs-burly"
#+end_src

#+begin_src emacs-lisp
  (require 'burly)
#+end_src

*** further customization
**** handy functionalities
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/site-lisp/features.el")
:END:

***** power management
Shut down emacs automatically when remaining power of laptop PC lower than [[help:battery-load-low][battery-load-low]]
to avoid accidental data loss.

#+begin_src emacs-lisp
  (require 'battery)

  (run-with-timer 60 60 #'kill-emacs-auto)

  (defun kill-emacs-auto ()
    "Kill Emacs if remaining machine power lower than `battery-load-low'."
    (when-let* ((data (and battery-status-function (funcall battery-status-function)))
                (percentage (car (read-from-string (cdr (assq ?p data)))))
                (power (cdr (assq ?L data))))
      (when (and (numberp percentage)
                 (< percentage battery-load-low)
                 (stringp power)
                 (string= power "BAT"))
        (save-buffers-kill-emacs t))))
#+end_src

***** lazy viewing

It's confortable to read long material such as web page , epub file or email with snappy control. Lazy View offers transient keymap that allow users to move cursor and scroll page with simple key stroke.

#+begin_src emacs-lisp
  (use-package emacs
    :bind ("C-c v" . my/lazy-view-enter)
    :hook ((help-mode Info-mode eww-mode nov-mode mu4e-view-mode woman-mode)
           . my/lazy-view-enter))

  (defvar my/lazy-view-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "<SPC>") #'my/forward-paragraph)
      (define-key map (kbd "E") #'my/backward-paragraph)
      (define-key map (kbd "f") #'scroll-up-line)
      (define-key map (kbd "e") #'scroll-down-line)
      (define-key map (kbd "F") #'forward-char)
      (define-key map (kbd "B") #'backward-char)
      (define-key map (kbd "N") #'next-line)
      (define-key map (kbd "P") #'previous-line)
      (define-key map (kbd "C-a") #'move-beginning-of-line)
      (define-key map (kbd "C-e") #'move-end-of-line)
      (define-key map (kbd "C-v") #'scroll-up-command)
      (define-key map (kbd "M-v") #'scroll-down-command)
      (lambda-key map (kbd ">") '(lambda () "Scroll right one column." (interactive)
                                   (scroll-left 1)))
      (define-key map (kbd "C->") #'scroll-left)
      (lambda-key map (kbd "<") '(lambda () "Scroll left one column." (interactive)
                                   (scroll-right 1)))
      (define-key map (kbd "C-<") #'scroll-right)
      (define-key map (kbd "+") #'text-scale-adjust)
      (define-key map (kbd "-") #'text-scale-adjust)
      (define-key map (kbd "=") #'text-scale-adjust)
      (define-key map (kbd "0") #'text-scale-adjust)
      (define-key map (kbd "\\") #'toggle-truncate-lines)
      (define-key map (kbd "|") #'visual-line-mode)
      map))

  (defun my/lazy-view-enter ()
    "Activate my/lazy-view-map in current buffer."
    (interactive)
    (set-transient-map my/lazy-view-map
                       #'my/lazy-view-keep
                       #'my/lazy-view-exit)
    (set-face-attribute 'fringe nil :background "LightSeaGreen"))

  (defun my/lazy-view-keep ()
    (if (member this-command
                `(beginning-of-visual-line
                  end-of-visual-line
                  recenter-top-bottom
                  reposition-window
                  Info-next-reference
                  Info-prev-reference
                  Info-up
                  Info-history-back
                  Info-history-forward
                  Info-follow-nearest-node
                  Info-forward-node
                  Info-backward-node
                  forward-button
                  backward-button
                  shr-next-link
                  shr-previous-link
                  eww-follow-link
                  eww-back-url
                  eww-forward-url
                  eww-goto-title-heading
                  eww-reload
                  nov-browse-url
                  nov-next-document
                  nov-previous-document
                  ,@(mapcar (lambda (key-command)
                              (let ((cmd (cdr key-command)))
                                (and (commandp cmd)
                                     cmd)))
                            (cdr my/lazy-view-map))))
        t nil))

  (defun my/lazy-view-exit ()
    (set-face-attribute 'fringe nil :background nil))

  (defun my/forward-paragraph ()
    (interactive)
    (forward-paragraph 2)
    (backward-paragraph 1)
    (forward-line 1)
    (recenter-top-bottom 0))

  (defun my/backward-paragraph ()
    (interactive)
    (backward-paragraph 2)
    (forward-paragraph 1)
    (backward-paragraph 1)
    (forward-line 1)
    (recenter-top-bottom 0))
#+end_src

***** lookup functions

#+begin_src emacs-lisp
  (defmacro define-lookup-function (fun search-prefix)
    "Create lookup function named FUN using SEARCH-PREFIX for querying.

  if WORD-FIXED is given, use it as a search word."
    (declare (indent 1))
    `(defun ,fun (word &optional arg)
       "Issue search query with WORD.

  Use a string in region for WORD if region is active.
  If called with prefix argument, prompt the user to input WORD regardless region is active or not."
       (interactive (let ((region-str (when (use-region-p)
                                        (buffer-substring (region-beginning) (region-end)))))
                      (list (cond
                             ((and (stringp region-str)
                                   (equal current-prefix-arg nil))
                              region-str)
                             (t
                              (read-string "Enter URL or keywords: " region-str))))))
       (let ((eww-search-prefix ,search-prefix))
         (eww word 4))))

  (define-lookup-function lookup-google "https://www.google.com/search?q=")
  (define-lookup-function lookup-wikipedia-en "https://en.wikipedia.org/wiki/")
  (define-lookup-function lookup-wikipedia-ja "https://ja.wikipedia.org/wiki/")
  (define-lookup-function lookup-amazon "https://www.amazon.co.jp/gp/search/?field-keywords=")
  (define-lookup-function lookup-melpa "https://melpa.org/#/?q=")
  (define-lookup-function lookup-duckduckgo "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
  (define-lookup-function lookup-eijiro "https://eow.alc.co.jp/search?q=")
  (define-lookup-function lookup-weblio "https://www.weblio.jp/content/")
  (define-lookup-function lookup-youtube "https://www.youtube.com/results?search_query=")

  (with-eval-after-load 'hydra
    (defhydra hydra-lookup (global-map "C-c l"
                                       :color blue)
      "Lookup"
      ("g" lookup-google)
      ("G" lookup-duckduckgo "duckduckgo")
      ("w" lookup-wikipedia-ja)
      ("W" lookup-wikipedia-en)
      ("d" (lambda (&optional arg)
             (interactive "P")
             (if (equal arg '(4))
                 (funcall-interactively #'dictionary-search nil)
               (dictionary-lookup-definition))))
      ("a" lookup-amazon "amazon.co.jp")
      ("m" lookup-melpa "melpa")
      ("l" lookup-weblio "weblio")
      ("y" lookup-youtube "youtube")
      ("e" my/define-word)
      ("j" (lambda ()
             (interactive)
             (let ((define-word-default-service 'weblio))
               (my/define-word)))
       "japanese translation")
      ("J" lookup-eijiro)
      ("s" synosaurus-lookup "synosaurus-lookup")
      ("S" synosaurus-choose-and-replace "synosaurus-replace")
      ("oe" my/org-english-lookup)
      ("q" nil "quit")))
#+end_src

***** tldr

#+begin_src emacs-lisp
  (defun my/tldr (command)
    "Show the output of tldr for COMMAND in a dedicated buffer."
    (interactive (list (read-string "Coomand: ")))
    (let* ((buf-name "*TL;DR*")
           (buffer (get-buffer-create buf-name)))
      (with-current-buffer buffer
        (read-only-mode -1)
        (erase-buffer)
        (insert (shell-command-to-string (format "tldr %s"
                                                 (shell-quote-argument command))))
        (ansi-color-apply-on-region (point-min) (point-max))
        (goto-char (point-min))
        (read-only-mode 1))
      (display-buffer buffer '((display-buffer-pop-up-window)
                               . ((window-height . 8))))
      (switch-to-buffer-other-window buffer)))
#+end_src

***** sending email

#+begin_src emacs-lisp
  (defun mail-simple-send (mailto subject body)
    "Default function to send a mail with SUBJECT and BODY to myself."
    (save-excursion
      (let ((message-kill-buffer-on-exit t))
        (message-mail mailto subject)
        (message-goto-body)
        (insert body)
        (message-send-and-exit))))

  (defun mail-buffer (mailto)
    "Send the current buffer contents as a email.

  If region is active, send the string in the region instead."
    (let ((mail-subj (buffer-name))
          (mail-body (if (use-region-p)
                         (buffer-substring (region-beginning) (region-end))
                       (buffer-string))))
      (mail-simple-send mailto mail-subj mail-body)))
#+end_src

***** download media file

#+begin_src emacs-lisp :noweb tangle
  (defvar my/download-video-dir
    (file-name-concat "<<video-dir()>>" "downloads")
    "Directory where downloaded video locate.")

  (defun my/download-video (url &optional filename playlistp)
    "Download video from `URL'.

  If optional argument `FILENAME' is passed, try to use this as filename.
  If optional argument `PLAYLISTP' is passed, try to download all videos in playlist
  instead of single video."
    (interactive (list (read-string "URL: ")))
    (when (string-match "https?://www.youtube.com.+" url)
      (let* ((url-orig (match-string 0 url))
             (urlobj-orig (url-generic-parse-url url-orig))
             (pq-orig (url-path-and-query urlobj-orig))
             (yt-url
              (if (and (not playlistp)
                       (string= (car pq-orig) "/watch")
                       (assoc-string "list" (url-parse-query-string (cdr pq-orig))))
                  (url-recreate-url
                   (url-parse-make-urlobj (url-type urlobj-orig)
                                          (url-user urlobj-orig)
                                          (url-password urlobj-orig)
                                          (url-host urlobj-orig)
                                          (url-portspec urlobj-orig)
                                          (concat (car pq-orig) "?"
                                                  (url-build-query-string
                                                   (list (assoc "v" (url-parse-query-string (cdr pq-orig))))))
                                          (url-target urlobj-orig)
                                          (url-attributes urlobj-orig)
                                          (url-fullness urlobj-orig)))
                url)))
        (setq lexical-binding t)
        (setq url-lex url)
        (setq filename-lex (if filename
                               (replace-regexp-in-string
                                "[\\?\"/:|’]" "" filename)
                             nil))
        (message "Downloading: %s" (or filename-lex url))
        (set-process-sentinel
         (start-process-shell-command
          "download video" nil
          (format "cd \"%1$s\" && nohup yt-dlp %2$s \"%3$s\" >/dev/null 2>&1"
                  (expand-file-name my/download-video-dir)
                  (mapconcat #'identity
                             (list (format "--format \"%s\"" (ytdl-format))
                                   (when (and filename-lex
                                              (not playlistp)
                                              (not (string= (car pq-orig) "/playlist")))
                                     (format "--output %s" (shell-quote-argument filename-lex)))
                                   (when playlistp "--yes-playlist --ignore-errors --download-archive downloaded.txt"))
                             " ")
                  yt-url))
         (lambda (process desc)
           (when (eq (process-status process) 'exit)
             (let ((exit-status (process-exit-status process)))
               (if (= exit-status 0)
                   (alert (format "Downloaded: %s" (or filename-lex url-lex)) :severity 'normal :style 'fringe)
                 (alert (format "Failed(%d): %s" exit-status (or filename-lex url-lex)) :severity 'urgent :style 'fringe)))))))))

  (defvar my/download-audio-dir
    (file-name-concat "<<audio-dir()>>" "downloads")
    "Directory where downloaded audio locate.")

  (defun my/download-audio (url &optional filename)
    "Download audio from `URL'.

  If optional argument `FILENAME' is given use this as a filename."
    (interactive (list (read-string "URL: ")))
    (setq lexical-binding t)
    (setq url-lex url)
    (setq filename-lex (if filename
                           (replace-regexp-in-string
                            "[\\?\"/:|’]" "" filename)
                         nil))
    (message "Downloading: %s" (or filename-lex url))
    (set-process-sentinel
     (start-process-shell-command
      "download audio" nil
      (format "cd %s && nohup %s >/dev/null 2>&1"
              (shell-quote-argument (expand-file-name my/download-audio-dir))
              (if (string-match-p "https?://www.youtube.com.+" url)
                  (format "yt-dlp --extract-audio %s" url)
                (concat (format "curl -LJs %s" url)
                        (and filename-lex
                             (format " -o %s.%s" filename-lex
                                     (file-name-extension url)))))))
     (lambda (process desc)
       (when (eq (process-status process) 'exit)
         (let ((exit-status (process-exit-status process)))
           (if (= exit-status 0)
               (alert (format "Downloaded: %s" (or filename-lex url-lex)) :severity 'normal :style 'fringe)
             (alert (format "Failed(%d): %s" exit-status (or filename-lex url-lex)) :severity 'urgent :style 'fringe)))))))

  (defun show-media-duration (url)
    "Return a duration value for media located at URL."
    (when-let ((duration (cond
                          ((string-match "https?://www.youtube.com.+" url)
                           (car (split-string (shell-command-to-string
                                               (format "yt-dlp --get-duration %s" url)))))
                          ((string-match "https?://.+" url)
                           (car (split-string (shell-command-to-string
                                               (format "ffmpeg -i \"%s\" 2>&1 | grep Duration | awk -F '[ ]+' '{print substr($3, 0, length($3)-1)}'" url))))))))
      (message "Duration: %s" (if (stringp duration)
                                  duration "N/A"))))

  (defun my/download-video-at-point ()
    "Download video file from url currently pointed."
    (interactive)
    (when-let ((url (thing-at-point-url-at-point)))
      (my/download-video url)))

  (defun my/download-audio-at-point ()
    "Download audio file from url currently pointed."
    (interactive)
    (let ((url (thing-at-point-url-at-point)))
      (when url
        (my/download-audio url))))

  (defun my/show-media-duration-at-point ()
    "Show duration of media file which cursor currently pointed."
    (interactive)
    (if-let* ((url (thing-at-point-url-at-point)))
        (show-media-duration url)))

  (defun ytdl-format ()
    "Return appropriate format option value for youtube-dl command."
    (let* ((ipv4-addr (shell-command-to-string "hostname -I | cut -f1 -d' ' | tr -d '\n'"))
           (wifi-ssid (shell-command-to-string "iwgetid -r | tr -d '\n'"))
           (fmt-quality (cond
                         ;; using mobile Wi-Fi
                         ((string-prefix-p "192.168.179." ipv4-addr)
                          "b[filesize<20M] / w")
                         ;; using wired network or broad wifi
                         ((or (string-prefix-p "192.168.100." ipv4-addr)
                              (member wifi-ssid '("saint_laurent_ap" "FREE_SPOT")))
                          "bv*[height<=720]+ba/b")
                         ;; using unknown network
                         (t
                          "wv*+wa/w"))))
      (format "%s" fmt-quality)))

  (global-set-key (kbd "C-c D v") 'my/download-video-at-point)
  (global-set-key (kbd "C-c D a") 'my/download-audio-at-point)
  (global-set-key (kbd "C-c D =") 'my/show-media-duration-at-point)
#+end_src

***** text to speech

#+begin_src emacs-lisp :noweb tangle
  (require 'festival)

  (defcustom my/say-maximum-duration 30
    "Maximum speech duration in second for `my/say'.")
  (defvar my/say--timer nil "Timer used to cancel speech process.")
  (defvar my/say--open-jtalk-process "Say<Open-JTalk>"
    "Fixed name for a process running Open JTalk.")

  (defun my/say (string)
    "Say out `STRING'.

  If an argument is given as `STRING', speech that text. Otherwise the buffer text
   is spoken unless region is active.

  As of now, English and Japanese are supported for speech. Spoken language is
   determined by a string, specifically a string entirely consists of ASCII
   characters is identified as English. Otherwise the string is spoken in Japanese."
    (interactive (list (if (region-active-p)
                           (buffer-substring (region-beginning) (region-end))
                         (buffer-string))))
    (let ((my/say-lang 'en))
      (if (string-match-p
           (format "\\`[%s]+\\'" "[:ascii:]’“”–") string)
          ;; festival-say-string is unusable if region is active
          (if (region-active-p)
              (festival-say-region (region-beginning) (region-end))
            (festival-say-string string))
        (my/say--open-jtalk string)
        (setq my/say-lang 'ja))
      (setq my/say--timer
            (cond
             ((eq my/say-lang 'en)
              (run-with-timer my/say-maximum-duration nil
                              (lambda ()
                                (festival-kill-process)
                                (setq my/say--timer nil))))
             ((eq my/say-lang 'ja)
              (run-with-timer my/say-maximum-duration nil
                              (lambda ()
                                (and (get-process my/say--open-jtalk-process)
                                     (interrupt-process my/say--open-jtalk-process))
                                (setq my/say--timer nil))))))))
  (global-set-key (kbd "C-x \"") #'my/say)

  (defun my/say-cancel ()
    "Cancel speech process that has started by `my/say'."
    (interactive)
    (and my/say--timer
         (progn (cancel-timer my/say--timer)
                (setq my/say--timer nil)))
    (if (and festival-process
             (string= (process-status festival-process)
                      "run"))
        (festival-kill-process)
      (and (get-process my/say--open-jtalk-process)
           (interrupt-process my/say--open-jtalk-process))))
  (global-set-key (kbd "C-x C-\"") #'my/say-cancel)
  (with-eval-after-load 'embark
    (define-key embark-region-map "\"" #'my/say))

  (defun my/say--open-jtalk (text)
    "Speech TEXT in Japanese using Open JTalk."
    (start-process-shell-command
     my/say--open-jtalk-process nil
     (format "echo %s | open_jtalk -x /var/lib/mecab/dic/open-jtalk/naist-jdic -m <<hts-voice-dir()>>/Voice/mei/mei_angry.htsvoice -ow /tmp/a.wav && aplay /tmp/a.wav"
             (replace-regexp-in-string "[\t\r\n\v\f]+" " " text))))
#+end_src

****** jsay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/jsay") :tangle-mode (identity #o755)
  #!/usr/bin/env bash

  readonly DIC="${HOME}/usr/share/hts/dic"
  readonly VOICE="${HOME}/usr/share/hts/voice/mei_normal.htsvoice"
  readonly AUDIO_FILE=`mktemp ${HOME}/tmp/jsay_XXXXXXXX.wav`

  open_jtalk -x ${DIC} -m ${VOICE} -ow ${AUDIO_FILE}
  aplay --quiet ${AUDIO_FILE}
  rm -f ${AUDIO_FILE}

  exit 0
#+end_src

****** esay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/esay") :tangle-mode (identity #o755)
  #!/usr/bin/env bash

  readonly VOICE="${HOME}/usr/share/hts/voice/cmu_us_arctic_slt.htsvoice"
  readonly AUDIO_FILE=`mktemp ${HOME}/tmp/esay_XXXXXXXX.wav`

  flite_hts_engine -m ${VOICE} -o ${AUDIO_FILE}
  aplay --quiet ${AUDIO_FILE}
  rm -f ${AUDIO_FILE}

  exit 0
#+end_src

***** collective hydra definitions

#+begin_src emacs-lisp
  (with-eval-after-load 'hydra
    (defhydra hydra-launcher (global-map "M-o"
                                         :color blue)
      "Launch"
      ("e" eshell)
      ("v" my/multi-vterm)
      ("V" multi-vterm-project)
      ("D" dired-jump)
      ("=" ediff)
      ("@" twit)
      ("g" magit-status)
      ("r" re-builder)
      ("w" eww)
      ("W" eww-switch-to-buffer)
      ("m" mu4e)
      ("M" mu4e-alert-view-unread-mails)
      ("p" proced)
      ("P" list-processes)
      ("d" run-dig)
      ("if" ifconfig)
      ("iw" iwconfig)
      ("I" ping)
      ("b" battery)
      ("c" calendar)
      ("%" calc)
      ("?" woman)
      ("t" mentor)
      ("\\" locate-with-filter)
      (";" my/tldr)
      ("q" quickrun)
      ("C-g" nil "cancel"))
    (defhydra hydra-toggle
      (global-map "C-c t"
                  :color pink
                  :pre (set-face-background 'mode-line "DarkOrange4")
                  :post (set-face-background 'mode-line "gray10"))
      "Toggle"
      ("t" visual-line-mode)
      ("T" toggle-truncate-lines)
      ("i" adaptive-wrap-prefix-mode)
      ("p" variable-pitch-mode)
      ("w" whitespace-mode)
      ("l" display-line-numbers-mode)
      ("L" line-number-mode)
      ("C" column-number-mode)
      ("v" view-mode)
      ("r" rainbow-mode)
      ("\\" toggle-input-method)
      ("F" toggle-frame-fullscreen)
      ("SPC" pangu-spacing-mode)
      ("q" nil "quit")))
#+end_src

***** show the day in calendar

#+begin_src emacs-lisp
  (defun my/calendar-show-items ()
    "Show items on the day pointed in calendar view."
    (interactive)
    (let* ((calendar-date-display-form calendar-iso-date-display-form)
           (date (calendar-date-string (calendar-cursor-to-date)))
           (d (parse-time-string date))
           (year (decoded-time-year d))
           (files (file-expand-wildcards (file-name-concat org-directory "archive" "archive_*.org")))
           (buffer-name-prefix "==")
           (buffer-name (concat buffer-name-prefix date))
           (display-buffer-alist
            `((,buffer-name-prefix
               (display-buffer-reuse-mode-window
                display-buffer-pop-up-window)))))
      (org-ql-search files `(and (or (parent (heading ,date))
                                     (ts-a :on ,date))
                                 (not (tags "web" "drill")))
        :buffer buffer-name)
      (other-window 1)))
#+end_src

***** disable external IME (fcitx)

As of 28.1, Emacs won't steal keyboard focus at startup which means we can use external input methods. But I'm confortable with shutting out external IM, fcitx in my case. Restarting fcitx makes my desire come true.

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (call-process-shell-command "fcitx -r")))
#+end_src

***** replace regexp with re-builder and query-replace-regexp trick

Great idea using re-builder when query-replace-regexp borrowed from [[https://karthinks.com/software/bridging-islands-in-emacs-1/][this post]].

#+begin_src emacs-lisp
  (defvar my/re-builder-positions nil
    "Store point and region bounds before calling re-builder")

  (advice-add 're-builder
              :before
              (defun my/re-builder-save-state (&rest _)
                "Save into `my/re-builder-positions' the point and region
  positions before calling `re-builder'."
                (setq my/re-builder-positions
                      (cons (point)
                            (when (region-active-p)
                              (list (region-beginning)
                                    (region-end)))))))

  (defun reb-replace-regexp (&optional delimited)
    "Run `query-replace-regexp' with the contents of re-builder. With
  non-nil optional argument DELIMITED, only replace matches
  surrounded by word boundaries."
    (interactive "P")
    (reb-update-regexp)
    (let* ((re (reb-target-binding reb-regexp))
           (replacement (query-replace-read-to
                         re
                         (concat "Query replace"
                                 (if current-prefix-arg
                                     (if (eq current-prefix-arg '-) " backward" " word")
                                   "")
                                 " regexp"
                                 (if (with-selected-window reb-target-window
                                       (region-active-p)) " in region" ""))
                         t))
           (pnt (car my/re-builder-positions))
           (beg (cadr my/re-builder-positions))
           (end (caddr my/re-builder-positions)))
      (with-selected-window reb-target-window
        (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                                          ; to control where in the buffer the replacement starts
                                          ; with re-builder
        (setq my/re-builder-positions nil)
        (reb-quit)
        (query-replace-regexp re replacement delimited beg end))))

  (define-key reb-mode-map (kbd "RET") #'reb-replace-regexp)
  (define-key reb-lisp-mode-map (kbd "RET") #'reb-replace-regexp)
  (global-set-key (kbd "C-%") #'re-builder)
#+end_src

***** repeat maps
:PROPERTIES:
:CREATED:  [2022-10-14 Fri 17:43]
:END:

#+begin_src emacs-lisp
  (defvar my/delete-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map "\C-d" (lambda ()
                               (interactive)
                               (setq repeat-map 'my/delete-repeat-map)
                               (if (eq major-mode 'org-mode)
                                   (org-delete-char 1)
                                 (delete-char 1))))
      (define-key map "\M-d" (lambda ()
                               (interactive)
                               (setq repeat-map 'my/delete-repeat-map)
                               (if jaword-mode
                                   (jaword-kill 1)
                                 (kill-word 1))))
      (define-key map "\C-h" (lambda ()
                               (interactive)
                               (setq repeat-map 'my/delete-repeat-map)
                               (if (eq major-mode 'org-mode)
                                   (org-delete-backward-char 1)
                                 (delete-backward-char 1))))
      (define-key map "\M-h" (lambda ()
                               (interactive)
                               (setq repeat-map 'my/delete-repeat-map)
                               (if jaword-mode
                                   (jaword-kill -1)
                                 (backward-kill-word 1))))
      map)
    "Keymap to repeat `next-error' key sequences.  Used in `repeat-mode'.")
  (put 'delete-char 'repeat-map 'my/delete-repeat-map)
  (put 'org-delete-char 'repeat-map 'my/delete-repeat-map)
  (put 'kill-word 'repeat-map 'my/delete-repeat-map)
  (put 'jaword-kill 'repeat-map 'my/delete-repeat-map)
#+end_src

***** utility lisp functions/commands

#+begin_src emacs-lisp
  (defun my/copy-line-number ()
    "Copy the line number of current point into the kill ring."
    (interactive)
    (let ((line-number (number-to-string (line-number-at-pos))))
      (message "Line number: %s" line-number)
      (kill-new line-number)))
  (global-set-key (kbd "C-M-S-w") 'my/copy-line-number)

  (defun my/insert-time-stamp (&optional arg)
    "Insert date string with format derived in deterministic way with ARG."
    (interactive "P")
    (let* ((simple-fmt "%Y%m%d")
           (concise-fmt "%Y-%m-%d")
           (verbose-fmt "%Y-%m-%d %H:%M:%S")
           (fmt-in-use (cond
                        ((equal arg '(16))
                         (read-string "time format: "
                                      "%Y-%m-%d %H:%M:%S"))
                        ((equal arg '(4))
                         verbose-fmt)
                        (t (cond
                            ((eq major-mode 'text-mode) concise-fmt)
                            ((eq major-mode 'dired-mode) simple-fmt)
                            (t simple-fmt))))))
      (insert (format-time-string fmt-in-use))))
  (global-set-key (kbd "C-c .") 'my/insert-time-stamp)

  (defun my/drag-line-backward ()
    "Drag up current line for one."
    (interactive)
    (transpose-lines 1)
    (previous-line 2))
  (global-set-key (kbd "M-S-<up>") 'my/drag-line-backward)

  (defun my/drag-line-forward ()
    "Drag down current line for one."
    (interactive)
    (next-line 1)
    (transpose-lines 1)
    (previous-line 1))
  (global-set-key (kbd "M-S-<down>") 'my/drag-line-forward)

  (defun my/comment-box (b e)
    "Draw a box comment around the region but arrange for the region
    to extend to at least the fill column. Place the point after the
    comment box."
    (interactive "r")
    (let ((e (copy-marker e t)))
      (goto-char b)
      (end-of-line)
      (insert-char ?  (- fill-column (current-column)))
      (comment-box b e 1)
      (goto-char e)
      (set-marker e nil)))

  (defun my/ascii-string-p (string)
    "Return non-nil if `STRING' seems to be made of ASCII."
    (if (length> string 0)
        (string-match-p
         (format "\\`[%s]+\\'" "[:ascii:]’“”–")
         string)
      t))
#+end_src

**** original features
***** org-password-store

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/org-password-store.el")
  (require 'password-store)

  (defcustom my/org-password-store-property "PASSWORD_STORE"
    "Property used in my/password-store feature to get password-store entry name attached to current org entry.")

  (defmacro with-password-store-entry (entry &rest body)
    "Eval BODY that can refer password-store ENTRY."
    (declare (indent defun))
    `(let ((entry (or ,entry
                      (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                      (password-store--completing-read t))))
       ,@body))

  (defmacro with-password-store-entry-field (entry field &rest body)
    "Eval BODY which can refer password-store ENTRY and FIELD..

  Plus, OBDY can refer value of FIELD named field-value."
    (declare (indent defun))
    `(let* ((entry (or ,entry
                       (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                       (password-store--completing-read t)))
            (field (or ,field
                       (password-store-read-field entry)))
            (field-value (password-store-get-field entry field)))
       ,@body))

  (defun my/password-store-copy ()
    "Add the secret to system clipboard and the username to primary `x-selection'.

  `password-store-copy' is responsible for managing the kill ring."
    (interactive)
    (with-password-store-entry-field nil "username"
      (password-store-copy entry)
      (gui-set-selection 'PRIMARY
                         (or (password-store-get-field entry "username")
                             (password-store-get-field entry "email")
                             (nth 1 (password-store-parse-entry entry))))
      (message "USERNAME => X-SEL, SECRET => CLIPBOARD")))

  (defun my/password-store-copy-field ()
    "Add field for entry into the kill ring.

  entry and field is determined by appropriate manner."
    (interactive)
    (with-password-store-entry-field nil nil
      (password-store-copy-field entry field)))

  (defun my/password-store-url (&optional arg)
    "Browse url stored in entry by appropriate manner determined by ARG."
    (interactive "P")
    (with-password-store-entry-field nil "url"
      (browse-url field-value)))

  (defun my/password-store-show-field ()
    "Show a field value in the minibuffer.

  Password-store entry and field used to derive this value are from org property
  or selected by user."
    (interactive)
    (with-password-store-entry-field nil nil
      (message "%s: %s" field field-value)))

  (defun my/password-store-create ()
    (interactive)
    (let* ((input (read-string "Entry-name or URL: "))
           (domain (when (string-match-p browse-url-button-regexp input)
                     (string-trim-right
                      (shell-command-to-string (format "echo %s | awk -F[/:] '{print $4}'"
                                                       (shell-quote-argument input)))))))
      (with-password-store-entry (cond
                                  ((> (length domain) 0) domain)
                                  (input))
        (when (derived-mode-p 'org-mode)
          (org-entry-put (point) my/org-password-store-property entry))
        (password-store-edit entry))))

  (defun my/password-store-edit ()
    (interactive)
    (with-password-store-entry nil
      (password-store-edit entry)))

  ;; TODO: make my/password-store-insert as soon after
  ;;     : password-store--run-insert has been implemented

  (defun my/password-store-remove ()
    (interactive)
    (with-password-store-entry nil
      (password-store-remove entry)
      (when (derived-mode-p 'org-mode)
        (org-entry-delete (point) my/org-password-store-property))))

  (defun my/password-store-web-login ()
    "Open url for the entry at point.

  Additionally the username and the secret are saved in X selection and clipboard respectively."
    (interactive)
    (my/password-store-copy)
    (funcall-interactively #'my/password-store-url '(16)))

  (advice-add #'password-store-clear :before #'my/password-store-clear)

  (defun my/password-store-clear (&optional field)
    "Overwrite clipboard data so that password once saved in clipboard is deleted
   for security risk.

  FIELD originally for messaging is ignored in this function."
    (interactive)
    (when password-store-kill-ring-pointer
      (kill-new "")
      (setcar kill-ring-yank-pointer "")))

  (with-eval-after-load 'hydra
    (defhydra hydra-password-store (global-map "C-o p"
                                               :color teal)
      "Password store"
      ("cc" my/password-store-copy)
      ("cf" my/password-store-copy-field)
      ("s" my/password-store-show-field)
      ("w" my/password-store-url)
      ("l" my/password-store-web-login)
      ("n" my/password-store-create)
      ("e" my/password-store-edit)
      ("v" my/password-store-edit)
      ("k" my/password-store-remove)
      ("q" nil "quit")))
#+end_src

***** org-archive-datetree                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-08-10 Wed 14:51]
:END:

#+begin_src emacs-lisp :tangle no
  (require 'org)
  (require 'org-agenda)

  (defcustom my/org-archive-before-archive-hook nil
    "Hook that is run right before a archive process begins."
    :group 'org-archive-datetree
    :type 'hook)

  (defun my/org-archive-file (&optional year)
    "Return a path of archive file.

  If optional argument `YEAR' is passed that year's file is returned instead of current year's."
    (let* ((record-year (or year (ts-year (ts-now))))
           (record-file-cand (format "%s/archive/archive_%s.org" org-directory record-year))
           (record-file
            (if (file-exists-p record-file-cand)
                record-file-cand
              (expand-file-name "archive/archive_0000.org" org-directory))))
      (if (or (file-exists-p record-file)
              (file-symlink-p record-file))
          record-file
        nil)))

  (defvar my/org-archive-file (my/org-archive-file))

  (defun my/org-archive-files ()
    "Return list of archive files."
    (append (directory-files (expand-file-name "archive" org-directory) t "archive_[[:digit:]]\\{4\\}\\.org" nil)
            org-agenda-files))

  (defvar my/org-archive-files (my/org-archive-files))

  (defun my/org-archive-find-date (date)
    "Find and visit the location of DATE in archivee file.

  DATE must be a string representing the date to find and parsable with `format-time-string'.

  If called interactively, it prompt the user to select the date to find."
    (interactive
     (cond
      ((eq major-mode 'calendar-mode)
       (list (calendar-date-string (calendar-cursor-to-date))))
      ((eq major-mode 'org-agenda-mode)
       (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                       (user-error "Don't know which date to open in calendar")))
              (date (calendar-gregorian-from-absolute day)))
         (list (calendar-date-string date))))
      (t (let ((date-select (org-read-date)))
           (list date-select)))))
    (let* ((d (parse-time-string date))
           (day (decoded-time-day d))
           (month (decoded-time-month d))
           (year (decoded-time-year d)))
      (find-file (my/org-archive-file year))
      (org-datetree-find-iso-week-create `(,month ,day ,year))))

  (defun my/org-archive-subtree ()
    "Refile current subtree to archive file using latest timestamp."
    (interactive)
    (let* ((ts (car (sort (org-timestamps-in-entry) #'ts>)))
           (year (ts-year (or ts (ts-now))))
           (save-file (my/org-archive-file year))
           (tags (org-get-local-tags))
           (todo (org-get-todo-state)))
      (when-let* ((pos (with-current-buffer (find-file-noselect save-file)
                         (save-excursion
                           (if (and (member "web" tags)
                                    (not (member todo '("DN" "PD"))))
                               (org-find-exact-headline-in-buffer "untouched items")
                             (org-datetree-find-iso-week-create `(,(ts-month ts)
                                                                  ,(ts-day ts)
                                                                  ,(ts-year ts)))
                             (point))))))
        (run-hooks 'my/org-archive-before-archive-hook)
        (org-refile nil nil (list nil save-file nil pos)))
      (org-save-all-org-buffers)
      (setq this-command 'my/org-archive-subtree)))

  (defun my/org-agenda-archive-subtree ()
    "Refile the entry or subtree belonging to the current agenda entry."
    (interactive)
    (org-agenda-archive-with 'my/org-archive-subtree))

  (defun my/org-ql-view-archive-subtree ()
    "Refile the entry or subtree belonging to the current agenda entry."
    (interactive)
    (org-agenda-archive-with 'my/org-archive-subtree)
    (org-ql-view-refresh))

  (defun my/org-archive-search (query)
    "Search org entries matched QUERY in archive files using `org-ql-search'."
    (interactive (list (read-string "Query: ")))
    (let ((files (my/org-archive-files)))
      (org-ql-search files query)))

  (bind-keys :map org-agenda-mode-map
             ("$" . my/org-agenda-archive-subtree)
             ("C" . my/org-archive-find-date)
             :map org-ql-view-map
             ("$" . my/org-ql-view-archive-subtree)
             :map calendar-mode-map
             ("C" . my/org-archive-find-date))

  (push '("Archive entries" . my/org-archive-search)
        org-ql-views)

  ;; TODO: This function can be rewritten with org-ml
  ;;;###autoload
  (defun org-timestamps-in-entry ()
    "Return timestamp objects for all Org timestamps in entry."
    (interactive (list current-prefix-arg))
    (save-excursion
      (goto-char (org-entry-beginning-position))
      (org-show-entry)
      (org-narrow-to-element)
      (let* ((parsetree (org-element-parse-buffer))
             (ts-list nil))
        (org-element-map parsetree '(planning clock timestamp)
          (lambda (elm)
            (cl-case (org-element-type elm)
              ('planning
               (add-to-list 'ts-list (ts-parse-org-element (or (org-element-property :closed elm)
                                                               (org-element-property :scheduled elm)
                                                               (org-element-property :deadline elm)))
                            t))
              ('clock
               (add-to-list 'ts-list (ts-parse-org-element (org-element-property :value elm)) t))
              ('timestamp
               (add-to-list 'ts-list (ts-parse-org-element elm) t)))))
        (widen)
        ts-list)))

  (provide 'my/org-archive-datetree)
#+end_src

***** org-capture-derived

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/org-capture-derived.el")
  (require 'thingatpt)
  (require 'whitespace)

  (with-eval-after-load 'org-capture
    (mapc (lambda (template)
            (add-to-list 'org-capture-templates
                         template))
          '(("x" "actionable entry for manual input"
             entry
             (function org-capture-derived-target-function)
             "* %(org-capture-derived-insert-todo)%? %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)")
            ("X" "Actionable entry for automated input"
             entry
             (function org-capture-derived-target-function)
             "* %(org-capture-derived-insert-todo)%a %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)"
             :immediate-finish t))))

  (defvar org-capture-derived-todo nil
    "Todo state to be set to an org entry which org-capture-derived creates.

  User should set this value locally, otherwise unexpected results occur.")
  (defvar org-capture-derived-tags nil
    "Tags represented with colon(:) to be set to an org entry which org-capture-derived creates.

  User should set this value locally, otherwise unexpected results occur.")
  (defvar org-capture-derived-target nil "docstring")
  (defvar org-capture-derived-deadline-in-day nil "docstring")

  (defun org-capture-derived-target-function ()
    ""
    (cond
     ((listp org-capture-derived-target)
      (set-buffer (org-capture-target-buffer (nth 1 org-capture-derived-target)))
      (org-capture-put-target-region-and-position)
      (widen)
      (goto-char (nth 3 org-capture-derived-target)))
     ((and (stringp org-capture-derived-target)
           (string-match-p thing-at-point-uuid-regexp org-capture-derived-target))
      (org-id-goto org-capture-derived-target))))

  (defun org-capture-derived (&optional arg)
    "C-u user is asked for all arguments
  C-u C-u create manually"
    (interactive "P")
    ;; insert ID property unless existing
    (cond
     ((and (eq major-mode 'org-mode)
           (not (equal arg '(16))))
      (org-id-get nil t)))
    (let* ((todo-in-org
            (when (derived-mode-p 'org-mode)
              (org-entry-get (point) "DERIVED_TODO" t)))
           (org-capture-derived-todo
            (or todo-in-org
                org-capture-derived-todo))
           (tags-in-org
            (when (derived-mode-p 'org-mode)
              (org-entry-get (point) "DERIVED_TAGS" t)))
           (org-capture-derived-tags
            (or (when (not (equal arg '(4)))
                  (or tags-in-org
                      org-capture-derived-tags))
                (read-string "Tags: " tags-in-org)))
           (target-in-org
            (when (derived-mode-p 'org-mode)
              (org-entry-get (point) "DERIVED_TARGET" t)))
           (org-capture-derived-target
            (or (when (not (equal arg '(4)))
                  (or target-in-org
                      org-capture-derived-target))
                (org-refile-get-location)))
           (deadline-str-in-org
            (when (derived-mode-p 'org-mode)
              (org-entry-get (point) "DERIVED_DEADLINE_IN_DAY" t)))
           (deadline-num-in-org
            (if (stringp deadline-str-in-org) (string-to-number deadline-str-in-org) nil))
           (org-capture-derived-deadline-in-day
            (if (equal arg '(4))
                (read-number "Deadline in day: "
                             deadline-num-in-org)
              (or deadline-num-in-org
                  org-capture-derived-deadline-in-day))))
      (if (equal arg '(16))
          (org-capture nil "x")
        (org-capture nil "X"))))

  (defun org-capture-derived-insert-todo ()
    ""
    (if (stringp org-capture-derived-todo)
        (if (string-match-p whitespace-trailing-regexp
                            org-capture-derived-todo)
            org-capture-derived-todo
          (format "%s " org-capture-derived-todo))
      ""))

  (defun org-capture-derived-insert-deadline ()
    ""
    (if (numberp org-capture-derived-deadline-in-day)
        (let ((week-ahead (encode-time
                           (seq-map-indexed (lambda (element index)
                                              (if (= index 3)
                                                  (+ element org-capture-derived-deadline-in-day)
                                                element))
                                            (decode-time (current-time))))))
          (format-time-string "DEADLINE: <%Y-%m-%d %a>" week-ahead))
      ""))
#+end_src

***** org-relate

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/org-relate.el")
  (require 'thingatpt)
  (require 'org-ql-search)

  (defconst org-relate-property "PARENT"
    "Property name for child nodes to look up parent node.")
  (defcustom org-relate-parent-tag-list
    `(,my/org-project-tag "refile")
    "A list of tags all parent nodes must have one of them.")
  (defcustom org-relate-target-files
    (directory-files-recursively org-directory "\\.org$")
    "A list of target files to search relation nodes.")

  (with-eval-after-load 'org
    (bind-key "C-c %" #'org-relate-search
              org-mode-map))

  (with-eval-after-load 'org-keys
    (setf (map-elt org-speed-commands "%") #'org-relate-search)
    (setf (map-elt org-speed-commands "&") #'org-relate-interrelate)
    (push '("Org-Relate Operation") org-speed-commands))

  (with-eval-after-load 'org-agenda
    (bind-keys :map org-agenda-mode-map
               ("&" . org-agenda-relation-interrelate)))

  (defun org-relate-search ()
    "Search for entries related to the entry at point.

  User who would like to search for parent and children of that, namely siblings,
   must press 'p'.
  User who would like to search for children of this entry must press 'c'.
  User who would like to search for friends either pointing to this entry
   or pointed from this entry must be press 'f'.
  User who would like to search for all listed above must press 'a'."
    (interactive)
    (let* ((org-super-agenda-properties-inherit nil)
           (char (read-char-from-minibuffer "Target: [a]ll [p]arent [c]hild [f]riend"))
           (queries (seq-remove 'null
                                (cond
                                 ((equal char ?a) (list (org-relate--search-parent-org-ql-query)
                                                        (org-relate--search-children-org-ql-query)
                                                        (org-relate--search-friends-refer-org-ql-query)
                                                        (org-relate--search-friends-referred-org-ql-query)
                                                        (org-relate--search-siblings-org-ql-query)))
                                 ((equal char ?p) (list (org-relate--search-parent-org-ql-query)
                                                        (org-relate--search-siblings-org-ql-query)))
                                 ((equal char ?c) (list (org-relate--search-children-org-ql-query)))
                                 ((equal char ?f) (list (org-relate--search-friends-refer-org-ql-query)
                                                        (org-relate--search-friends-referred-org-ql-query)))))))
      (if queries
          (org-ql-search org-relate-target-files
            (seq-reduce (lambda (accum elem)
                          (push elem (cdr (last accum)))
                          accum)
                        (mapcar 'car queries)
                        '(or))
            :super-groups (mapcar 'cdr queries))
        (message "No query found"))))

  (defun org-relate--search-children-org-ql-query ()
    (when-let* ((id (org-id-get))
                (rel-prop-link (format "[[id:%s]]" id)))
      `((or (property ,org-relate-property ,id)
            (property ,org-relate-property ,rel-prop-link)) .
            (:name "Children" :auto-property ,org-relate-property))))

  (defun org-relate--search-parent-org-ql-query ()
    (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
              (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
              (parent-id (match-string 0 prop-ref)))
        `((property "ID" ,parent-id) .
          (:name "Parent" :auto-property "ID"))))

  (defun org-relate--search-siblings-org-ql-query ()
    (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
              (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
              (parent-id (match-string 0 prop-ref))
              (parent-id-link (format "[[id:%s]]" parent-id)))
        `((or (property ,org-relate-property ,parent-id)
              (property ,org-relate-property ,parent-id-link)) .
              (:name "Siblings" :auto-property ,org-relate-property))))

  (defun org-relate--search-friends-refer-org-ql-query ()
    (when-let* ((id (org-id-get))
                (ref-re (format "\\[\\[id:%s\\].*\\]" id)))
      `((regexp ,ref-re) .
        (:name "Friends pointing to this entry" :regexp ,ref-re))))

  (defun org-relate--search-friends-referred-org-ql-query ()
    (let* ((id-link-re (format "\\[\\[id:\\(%s\\)\\].*\\]" thing-at-point-uuid-regexp))
           (end (or (save-excursion
                      (outline-next-heading))
                    (point-max))))
      (when (save-excursion
              (re-search-forward id-link-re end t))
        `((property "ID" ,(match-string 1)) .
          (:name "Friends to whom this entry is pointing" :auto-property ("ID" ,(match-string 1)))))))

  (defun org-relate-interrelate ()
    "Make parent-child relationship by inserting property.

  This command must be called in parent node which should have one of `org-relate-parent-tag-list'."
    (interactive)
    ;; relate the entry at point and its children if the entry has some of `org-relate-parent-tag-list'
    (save-excursion
      (org-back-to-heading)
      (when (cl-some (lambda (parent-tag)
                       (member parent-tag (org-get-tags)))
                     org-relate-parent-tag-list)
        (let* ((ref-id (org-id-get-create))
               (ent-link (format "[[id:%s]]" ref-id)))
          (and (org-goto-first-child)
               (cl-labels ((set-ref-id-to-siblings
                            (ref-link)
                            (org-set-property org-relate-property
                                              ref-link)
                            (and (org-goto-sibling)
                                 (set-ref-id-to-siblings ref-link))))
                 (set-ref-id-to-siblings ent-link))))))
    ;; relate the entry at point and a parent if the parent has some of `org-relate-parent-tag-list'
    (let (parent-link)
      (save-excursion
        (org-up-heading-safe)
        (when (seq-some (lambda (parent-tag)
                          (member parent-tag (org-get-tags)))
                        org-relate-parent-tag-list)
          (setq parent-link (format "[[id:%s]]" (org-id-get-create)))))
      (and parent-link
           (org-set-property org-relate-property
                             parent-link))))

  (defun org-agenda-relation-interrelate ()
    "Invoke `org-relate-interrelate' in agenda view."
    (interactive)
    (org-agenda-check-no-diary)
    (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                         (org-agenda-error)))
           (buffer (marker-buffer hdmarker))
           (pos (marker-position hdmarker))
           (inhibit-read-only t)
           newhead)
      (org-with-remote-undo buffer
        (with-current-buffer buffer
          (widen)
          (goto-char pos)
          (org-show-context 'agenda)
          (call-interactively 'org-relate-interrelate)
          (end-of-line 1)
          (setq newhead (org-get-heading))))))

  (provide 'org-relate)
#+end_src

***** clocktable-by-tag with org-clock

Provide a function to Build a clock table summing up time by tag.

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/clocktable-by-tag.el")
  (require 'org-table)
  (require 'org-clock)

  (defun clocktable-by-tag/shift-cell (n)
    (let ((str ""))
      (dotimes (i n)
        (setq str (concat str "| ")))
      str))

  (defun clocktable-by-tag/insert-tag (params)
    (let ((match (plist-get params :match)))
      (insert "|--\n")
      (insert (format "| %s | *Tag time* |\n" match))
      (let ((total 0))
        (mapcar
         (lambda (file)
           (let ((clock-data (with-current-buffer (find-file-noselect file)
                               (org-clock-get-table-data (buffer-name) params))))
             (when (> (nth 1 clock-data) 0)
               (setq total (+ total (nth 1 clock-data)))
               (insert (format "| | File *%s* | %.2f |\n"
                               (file-name-nondirectory file)
                               (/ (nth 1 clock-data) 60.0)))
               (dolist (entry (nth 2 clock-data))
                 (insert (format "| | . %s%s | %s %.2f |\n"
                                 (org-clocktable-indent-string (nth 0 entry))
                                 (replace-regexp-in-string "|" "\\vert\{\}" (nth 1 entry) nil t)
                                 (clocktable-by-tag/shift-cell (nth 0 entry))
                                 (/ (nth 4 entry) 60.0)))))))
         (org-agenda-files))
        (if (= total 0)
            (save-excursion
              (re-search-backward "*Tag time*")
              (forward-line -1)
              (dotimes (i 2)
                (org-table-kill-row)))
          (save-excursion
            (re-search-backward "*Tag time*")
            (org-table-next-field)
            (org-table-blank-field)
            (insert (format "*%.2f*" (/ total 60.0))))))
      (org-table-align)))

  (defun org-dblock-write:clocktable-by-tag (params)
    (funcall indent-line-function)
    (insert "| Tag | Headline | Time (h) |\n")
    (insert "|     |          | <r>  |\n")
    (let ((matches
           (org-global-tags-completion-table)))
      (mapcar (lambda (match)
                (let ((match-str (car match))
                      (case-fold-search nil))
                  (when (string-match-p "^AC_" match-str)
                    (setq params (plist-put params :match match-str))
                    (clocktable-by-tag/insert-tag params))))
              matches)))

  (provide 'clocktable-by-tag)
#+end_src

***** narrow-dwim

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/narrow-dwim.el")
  (bind-key* "C-x n" 'my/toggle-narrow-dwim)

  (defun my/toggle-narrow-dwim (arg)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix ARG, don't widen, just narrow even if buffer is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not arg))
           (when (org-buffer-narrowed-p)
             (when org-startup-indented
               (org-indent-mode 1))
             (visual-line-mode -1)
             (adaptive-wrap-prefix-mode -1))
           (widen)
           (setq-local truncate-lines t))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((and (boundp 'org-src-mode) org-src-mode (not arg))
           (org-edit-src-exit))
          ((condition-case err
               (org-edit-src-code)
             (user-error nil)))
          ((derived-mode-p 'org-mode)
           (cond ((org-at-block-p)
                  (org-narrow-to-block))
                 ((org-at-heading-p)
                  (org-narrow-to-subtree)
                  (adaptive-wrap-prefix-mode))
                 (t (org-narrow-to-element)))
           (org-indent-mode -1)
           (visual-line-mode 1))
          ((eq major-mode 'dired-mode)
           (dired-subtree-narrow))
          (t (narrow-to-defun))))

  ;; (add-hook 'post-command-hook 'highlight-narrowed-buffer)
  ;; (defun highlight-narrowed-buffer ()
  ;;   "Highlight narrowed buffer.

  ;; Narrowed buffer have a fringe with highlighting color.
  ;; Plus text size in the buffer becomes a little bit larger."
  ;;   (unless (or (member last-command
  ;;                       '(text-scale-adjust))
  ;;               (eq major-mode 'Info-mode)
  ;;               (string-match-p (rx (seq line-start "CAPTURE-" (one-or-more ascii) line-end))
  ;;                               (buffer-name)))
  ;;     (let ((hl-fringe-color "purple2")
  ;;           (hl-text-scale (sqrt 2)))
  ;;       (set-face-attribute
  ;;        'fringe nil :background (if (buffer-narrowed-p)
  ;;                                    (progn
  ;;                                      (text-scale-set hl-text-scale)
  ;;                                      hl-fringe-color)
  ;;                                  (progn
  ;;                                    (when (= text-scale-mode-amount hl-text-scale)
  ;;                                      (text-scale-set 0))
  ;;                                    nil))))))
#+end_src
***** weather

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/weather.el")
  ;; 気象庁配信の天気情報を加工して表示

  (require 'request)
  (require 'cl-lib)

  (defvar weather-areas
    '(((url . "http://www.drk7.jp/weather/xml/14.xml")
       (pref . "神奈川県")
       (area . "西部"))
      ((url . "http://www.drk7.jp/weather/xml/22.xml")
       (pref . "静岡県")
       (area . "中部"))))

  (defun weather-area-show (weather-area-alist weather-buffer)
    (lexical-let ((url (assoc-default 'url weather-area-alist))
                  (pref (assoc-default 'pref weather-area-alist))
                  (area (assoc-default 'area weather-area-alist))
                  (buffer weather-buffer))
      (request
        url
        :parser
        (lambda ()
          (let ((xml-string (string-as-multibyte (string-as-unibyte (buffer-string)))))
            (with-temp-buffer
              (erase-buffer)
              (insert xml-string)
              (libxml-parse-xml-region (point-min) (point-max)))))
        :success
        (cl-function
         (lambda (&key data &allow-other-keys)
           (when data
             (with-current-buffer buffer
               (insert (format "%s %s\n" pref area))
               (mapcar
                (lambda (info-node)
                  (insert
                   (format "%s %s %s %s\n"
                           (dom-attr info-node 'date)
                           (apply (lambda (max-temp-node min-temp-node)
                                    (format "%2d/%2d℃"
                                            (string-to-number (dom-text min-temp-node))
                                            (string-to-number (dom-text max-temp-node))))
                                  (dom-by-tag (dom-child-by-tag info-node 'temperature) 'range))
                           (apply (lambda (node-1 node-2 node-3 node-4)
                                    (format "%2d-%2d-%2d-%2d％"
                                            (string-to-number (dom-text node-1))
                                            (string-to-number (dom-text node-2))
                                            (string-to-number (dom-text node-3))
                                            (string-to-number (dom-text node-4))))
                                  (dom-by-tag (dom-child-by-tag info-node 'rainfallchance) 'period))
                           (dom-text (dom-child-by-tag info-node 'weather)))))
                (dom-by-tag (dom-by-id data area) 'info))
               (insert "\n"))))))))

  (defun weather ()
    (interactive)
    (let ((buffer (get-buffer-create "weather")))
      (mapcar (lambda (weather-area)
                (weather-area-show weather-area buffer))
              weather-areas)
      (switch-to-buffer buffer)))

  (provide 'weather)
#+end_src
***** view-file (deprecated)                :ARCHIVE:

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/view-file.el")
  (defcustom my/view-file--temp-dir "~/tmp/view-file"
    "Directory in which we will work for uncompresssing, decrypting and htmlize.")
  (defvar my/view-file--open-file nil
    "Target file which we will actually open.
  User should not change this value.")
  (defvar my/view-file--remove-files nil
    "List of files which we will remove afterward.
  User should not change this value.")

  ;; TODO: support line/search args to jump to the desired position
  (defun my/view-file (file &optional system)
    "Open FILE in my preferable way.

  if SYSTEM is non-nii open FILE using preferable application in system."
    (setq my/view-file--open-file (expand-file-name file))
    (make-directory my/view-file--temp-dir t)

    ;; decrypt file if it is encrypted
    (when-let* ((match (string-match "\\(.+\\)\.gpg$" my/view-file--open-file))
                (decrypt-file (expand-file-name (file-name-base my/view-file--open-file)
                                                (expand-file-name my/view-file--temp-dir)))
                (context (epg-make-context epa-protocol)))
      (epg-context-set-passphrase-callback context
                                           #'epa-passphrase-callback-function)
      (epg-decrypt-file context my/view-file--open-file decrypt-file)
      (setq my/view-file--open-file decrypt-file)
      (add-to-list 'my/view-file--remove-files decrypt-file))

    ;; uncompress file if it is tarball
    (let* (uncompress-file
           (uncompress-command
            (cond
             ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?gz$" my/view-file--open-file)
              (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                      my/view-file--temp-dir))
              (format "gzip -dc %s | tar -xf - -C %s"
                      (shell-quote-argument my/view-file--open-file)
                      (shell-quote-argument uncompress-file)))
             ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?zst$" my/view-file--open-file)
              (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                      my/view-file--temp-dir))
              (format "unzstd -c %s | tar -xf - -C %s"
                      (shell-quote-argument my/view-file--open-file)
                      (shell-quote-argument uncompress-file)))
             ((string-match "\\(.+\\)\\.zip$" my/view-file--open-file)
              (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                      my/view-file--temp-dir))
              (format "unzip -o -d %s %s"
                      (shell-quote-argument uncompress-file)
                      (shell-quote-argument my/view-file--open-file))))))
      (when (and (stringp uncompress-file)
                 (stringp uncompress-command))
        (make-directory uncompress-file t)
        (call-process-shell-command
         uncompress-command)
        (add-to-list 'my/view-file--remove-files uncompress-file)
        (setq my/view-file--open-file uncompress-file)))

    ;; convert pdf/epub to html
    (let* ((dirname-html
            (expand-file-name (file-relative-name my/view-file--open-file "/")
                              (expand-file-name my/view-file--temp-dir)))
           (filename-html
            (concat (file-name-as-directory dirname-html)
                    "index.html"))
           (command
            (cond
             ((= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
              (format "cat %s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %s"
                      (shell-quote-argument my/view-file--open-file)
                      (shell-quote-argument filename-html)))
             ((= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0)
              (format "cat %s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%s - | strip_ruby > %s"
                      (shell-quote-argument my/view-file--open-file)
                      (shell-quote-argument dirname-html)
                      (shell-quote-argument filename-html))))))
      (when (and (null system)
                 (stringp command))
        (unless (file-exists-p filename-html)
          (make-directory dirname-html t)
          (call-process-shell-command command)
          ;; reuse html only if pdf/epub file is not ecrypted
          (when (member my/view-file--open-file my/view-file--remove-files)
            (add-to-list 'my/view-file--remove-files dirname-html)))
        (setq my/view-file--open-file filename-html)))

    ;; open file
    (cond
     ((or system
          (string-match-p "\\.midi?$" my/view-file--open-file)
          (= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
          (= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0))
      (let ((process-connection-type nil))
        (call-process-shell-command (format "xdg-open %s" (shell-quote-argument my/view-file--open-file)))
        (sleep-for 3)
        (funcall 'my/view-file--finalize-function)))
     ((or (= (call-process-shell-command (format "filetype-cli check --type playable %s" (shell-quote-argument my/view-file--open-file))) 0)
          (seq-some (lambda (suffix)
                      (string-suffix-p suffix my/view-file--open-file t))
                    '(".m3u" ".mts" ".m2ts")))
      (when-let ((mpv-proc (start-process-shell-command
                            "mpv" nil
                            (format "nohup mpv --force-window %s >/dev/null 2>&1" (shell-quote-argument my/view-file--open-file)))))
        (set-process-sentinel
         mpv-proc
         (lambda (process desc)
           (when (eq (process-status process) 'exit)
             (funcall 'my/view-file--finalize-function))))))
     ((= (call-process-shell-command
          (format "filetype-cli check --type html %s"
                  (shell-quote-argument my/view-file--open-file))) 0)
      (add-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
      (eww-open-file my/view-file--open-file))
     ((file-directory-p my/view-file--open-file)
      (dired my/view-file--open-file)
      (funcall 'my/view-file--finalize-function))
     (t
      (find-file my/view-file--open-file)
      (funcall 'my/view-file--finalize-function))))

  (defun my/view-file--finalize-function ()
    "Remove files and initialize variables."
    (mapc (lambda (file)
            (when (stringp file)
              (cond
               ((file-directory-p file)
                (delete-directory file t nil))
               ((file-exists-p file)
                (let ((delete-by-moving-to-trash t))
                  (delete-file file))))))
          my/view-file--remove-files)
    (setq my/view-file--open-file nil
          my/view-file--remove-files nil))

  (defun my/view-file--eww-finalize-function ()
    "Finalize function for `EWW'."
    (remove-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
    (funcall 'my/view-file--finalize-function))

  (defun my/view-file-filter-org-link-store-props (&rest plist-orig)
    "Filter PLIST-ORIG to original file name if value of `eww-current-url'
   is in `my/view-file--temp-dir'."
    (let ((plist-filtered (car plist-orig)))
      (if (plist-member plist-filtered :link)
          (plist-put plist-filtered
                     :link
                     (replace-regexp-in-string (format "%s\\(.*\\)/index.html"
                                                       (expand-file-name my/view-file--temp-dir))
                                               (format "%s\\1"
                                                       (expand-file-name "~"))
                                               (plist-get plist-filtered
                                                          :link))))
      (car plist-orig)))

  (advice-add #'org-link-store-props :filter-args
              #'my/view-file-filter-org-link-store-props)

  (provide 'my/view-file)
#+end_src

***** open-file
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/site-lisp/open-file.el")
:END:

This set of code (open-file) offers file opener functionality in my liking. With open-file, PDF and EPUB, which is either local or on the web, is viewed in EWW (text browser in Emacs) after the process of converted into html. Video and audio is played in MPV media player. Open-file is available in elisp commands for opening files (e.g. org-open-at-point for org links, browse-url and dired-open-file). With any command above, invoking with single prefix (C-u) inflict to open file in Emacs, and invoking with double prefix (C-u C-u) inflict to open files in default application.

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
  d <<share-dir()>>/emacs/open-file 0755 - - 14d
#+end_src

#+begin_src emacs-lisp
  ;; general functions

  (defvar my/open-file-dir
    (expand-file-name "open-file"
                      user-emacs-directory)
    "Directory where html file is converted into.")

  (defvar my/open-file-media-player "mpv"
    "Media player used to play media file in open-file.")

  (defvar my/open-file-media-extensions
    '("mpg" "mpeg" "mp3" "mp4" "m4v" "m4a"
      "avi" "wmv" "wav" "mov" "flv" "mkv" "webm"
      "ogv" "oga" "ogx" "ogg" "spx"
      "xbm" "pbm" "pgm" "ppm" "pnm" "png" "gif" "bmp" "tif" "jpeg" "jpg")
    "Extensions files which can play with media player must have.")

  (defvar my/open-file-compressed-media-extensions
    '("tar.gz" "tgz" "tar.xz" "txz" "zip" "7z")
    "Extensions compressed files which can play with media player must have.")

  (defvar my/open-file-yt-regexp
    (rx (? (or "https://" "http://" "//"))
        (? "www")
        (or "youtube.com" "youtu.be"))
    "Regexp for youtube url.")

  (defmacro my/open-file-as-html (file convert-cmd)
    `(let* ((cap-command (if (string-match-p url-handler-regexp ,file)
                             "curl"
                           (if (string-suffix-p ".gpg" ,file)
                               "gpg -d"
                             "cat")))
            (dir-name
             (seq-reduce (lambda (str rep)
                           (string-replace (car rep) (cdr rep) str))
                         '(("/" . "!")
                           ("~" . "`")
                           (" " . "_"))
                         ,file))
            (dirname-html
             (expand-file-name
              (file-name-sans-extension dir-name)
              my/open-file-dir))
            (filename-html
             (concat (file-name-as-directory dirname-html)
                     "index.html"))
            (command ,convert-cmd))
       (unless (file-exists-p filename-html)
         (make-directory dirname-html t)
         (call-process-shell-command command))
       (browse-url filename-html)))

  (defun my/open-pdf-as-html (pdf)
    "Open PDF in `eww' after the process of convertion into html."
    (my/open-file-as-html
     pdf
     (format "%1$s %2$s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %3$s"
             cap-command
             (shell-quote-argument pdf)
             (shell-quote-argument filename-html))))

  (defun my/open-epub-as-html (epub)
    "Open EPUB in `eww' after the process of convertion into html."
    (my/open-file-as-html
     epub
     (format "%1$s %2$s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%3$s - | strip_ruby > %4$s"
             cap-command
             (shell-quote-argument epub)
             (shell-quote-argument dirname-html)
             (shell-quote-argument filename-html))))

  (defun my/open-media (media &optional start-time)
    "Open MEDIA in `my/open-file-media-player' at the point of START-TIME."
    (let ((ask-file (when (or (file-directory-p media)
                              (string-match-p (eval `(rx (or ,@my/open-file-compressed-media-extensions)))
                                              media))
                      (file-name-nondirectory media))))
      (when (or (not ask-file)
                (and ask-file
                     (y-or-n-p (format "Play %s?: " ask-file))))
        (start-process-shell-command
         my/open-file-media-player nil
         (let ((cap-cmd (and (string-suffix-p ".gpg" media)
                             (format "gpg -d %s | " media))))
           (mapconcat #'identity
                      (list (or cap-cmd "")
                            "nohup" my/open-file-media-player
                            "--force-window"
                            (or (and start-time
                                     (format "--start=%s" start-time))
                                "")
                            (if cap-cmd
                                "-"
                              (shell-quote-argument media))
                            "2>&1" ">/dev/null")
                      " "))))))

  ;; ==============================================
  ;; browse-url handling

  (with-eval-after-load 'browse-url
    (let ((search-suffix "\\(?:::.*\\)?"))
      (customize-set-variable
       'browse-url-handlers
       `(((lambda (url)
            (equal current-prefix-arg '(16)))
          . my/browse-url-external)
         ((lambda (url)
            (equal current-prefix-arg '(4)))
          . my/browse-url-emacs)
         (,(format "\\.html%s\\'" search-suffix)
          . my/browse-url-html)
         (,(format "\\.pdf\\(\\.gpg\\)?%s\\'" search-suffix)
          . my/browse-url-pdf)
         (,(format "\\.epub%s\\'" search-suffix)
          . my/browse-url-epub)
         (,(eval `(concat (rx "." (or ,@my/open-file-media-extensions
                                      ,@my/open-file-compressed-media-extensions)
                              (opt ".gpg"))
                          search-suffix))
          . my/browse-url-media)
         (,(concat my/open-file-yt-regexp search-suffix)
          . my/browse-url-media)))
      (customize-set-variable
       'browse-url-browser-function 'eww-browse-url)))

  (defun my/browse-url-html (url &optional same-window)
    "A handler for `browse-url' responsible for html at URL."
    (cond
     ((file-exists-p url)
      (eww-open-file url))
     ((string-match-p url-handler-regexp url)
      (browse-web url))
     (t
      (eww url))))

  (defun my/browse-url-pdf (url &optional same-window)
    "A handler for `browse-url' responsible for a pdf file at URL."
    (let* ((query-list (my/browse-url-break-down url))
           (search-str (cadr query-list)))
      (my/open-pdf-as-html (car query-list))
      (and (stringp search-str)
           (org-link-search search-str))))

  (defun my/browse-url-epub (url &optional same-window)
    "A handler for `browse-url' responsible for an epub file at URL."
    (let* ((query-list (my/browse-url-break-down url))
           (search-str (cadr query-list)))
      (my/open-epub-as-html (car query-list))
      (and (stringp search-str)
           (org-link-search search-str))))

  (defun my/browse-url-media (url &optional same-window)
    "A handler for `browse-url' responsible for a media file at URL."
    (let* ((query-list (my/browse-url-break-down url))
           (search-str (cadr query-list)))
      (my/open-media (car query-list) search-str)))

  (defun my/browse-url-emacs (url &optional same-window)
    "A handler for `browse-url' invoked with `C-u' responsible for a file at URL."
    (browse-url-emacs (car (my/browse-url-break-down url))
                      same-window))

  (defun my/browse-url-external (url &optional same-window)
    "A handler for `browse-url' invoked with `C-u C-u' responsible for a file at URL."
    (browse-url-xdg-open (car (my/browse-url-break-down url))
                         same-window))

  (defun my/browse-url-break-down (query)
    (let* ((search-opt-regexp "::\\(.*\\)\\'")
           (matcher nil)
           (url-or-file
            (cond ((string-match-p url-handler-regexp query)
                   (setq matcher (format "\\(%s.*\\)%s"
                                         url-handler-regexp
                                         search-opt-regexp))
                   query)
                  (t
                   (setq matcher (format "\\(.*\\)%s"
                                         search-opt-regexp))
                   (expand-file-name
                    (and (not (string-match-p "^file://" query))
                         (replace-regexp-in-string "^\\(?:/\\)?file:" "" query)))))))
      (if (string-match matcher url-or-file)
          `(,(match-string 1 url-or-file) ,(match-string 2 url-or-file))
        `(,url-or-file nil))))

  ;; ==============================================
  ;; org-open handling

  (with-eval-after-load 'org
    (customize-set-variable
     `org-file-apps
     `(("\\.html\\'" . my/org-open-html)
       ("\\.pdf\\(\\.gpg\\)?\\'" . my/org-open-pdf)
       ("\\.epub\\'" . my/org-open-epub)
       (,(eval `(rx "." (or ,@my/open-file-media-extensions
                            ,@my/open-file-compressed-media-extensions)
                    (opt ".gpg") string-end))
        . my/org-open-media)
       (auto-mode . emacs)
       (directory . my/org-open-media)
       (system . browse-url-default-browser))))

  (defun my/org-open-html (file-path link-string)
    "Open a html file at FILE-PATH via org-open command."
    (browse-url file-path)
    (when-let ((search (my/org-link-search link-string)))
      (org-link-search search)))

  (defun my/org-open-pdf (file-path link-string)
    "Open a pdf file at FILE-PATH via org-open command."
    (my/open-pdf-as-html file-path)
    (when-let ((search (my/org-link-search link-string)))
      (org-link-search search)))

  (defun my/org-open-epub (file-path link-string)
    "Open an epub file at FILE-PATH via org-open command."
    (my/open-epub-as-html file-path)
    (when-let ((search (my/org-link-search link-string)))
      (org-link-search search)))

  (defun my/org-open-media (file-path link-string)
    "Open a media file at FILE-PATH via org-open command."
    (my/open-media file-path
                   (my/org-link-search link-string)))

  (defun my/org-link-search (link-string)
    (and (stringp link-string)
         (string-match "::\\(.*\\)\\'" link-string)
         (match-string 1 link-string)))

  (defun my/org-execute-file-search-line-number (s)
    "A search function responsible for line number inside of S."
    (and (string-match "^l=\\([-+[:digit:]]+\\)\\'" s)
         (goto-line (string-to-number (match-string 1 s)))))

  (add-hook 'org-execute-file-search-functions
            'my/org-execute-file-search-line-number)

  ;; ==============================================
  ;; dired-open handling

  (with-eval-after-load 'dired-open
    (customize-set-variable
     'dired-open-functions
     '(dired-open-call-function-by-extension
       dired-open-guess-shell-alist
       dired-open-by-extension
       dired-open-subdir))
    (customize-set-variable
     'dired-open-extensions-elisp
     `(("pdf" . my/open-pdf-as-html)
       ("pdf.gpg" . my/open-pdf-as-html)
       ("epub" . my/open-epub-as-html)
       ("jpg.gpg" . my/open-media)
       ,@(mapcar (lambda (ext)
                   (cons ext 'my/open-media))
                 my/open-file-media-extensions)))
    (customize-set-variable
     'dired-open-find-file-function 'my/dired-find-file))

  (defun my/dired-find-file ()
    "A function for `dired-open-find-file-function' dealing with
  a `dired-open-file' call with `C-u' or `C-u C-u'."
    (let ((file-for-visit (dired-get-file-for-visit)))
      (cond
       ((equal current-prefix-arg '(16))
        (browse-url-default-browser file-for-visit))
       ((equal current-prefix-arg '(4))
        (dired--find-possibly-alternative-file file-for-visit))
       ((or (file-directory-p file-for-visit)
            (string-match-p (eval `(rx (or ,@my/open-file-compressed-media-extensions)))
                            file-for-visit))
        (my/open-media file-for-visit)))))
#+end_src

***** lfile (org-link type for files on the machine)

lfile is a custom org link type inspired by [[https://karl-voit.at/2022/02/10/lfile/][Kerl Voit's implementation]].

#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name ".emacs.d/site-lisp/lfile.el")
  (defcustom my/lfile-root "~/" "docstring")

  (defmacro my/expand-lfile (file body exclude-search)
    "Evaluate BODY with resolving a path from FILE.

  In BODY, caller could refer a resolved file path as `file-resolved'.
  If exclude-search is non-nil, search specifier after \"::\" will be removed in `file-resolved'."
    `(let* ((paths (my/lfile--locate ,file ,exclude-search))
            (file-resolved (car paths)))
       (cond
        ((= 0 (length paths))
         (message "Sorry, no results found for query: %s" file))
        ((<= 1 (length paths))
         ,body
         ))))

  (defun my/lfile-follow-link (file _)
    "Open FILE given in lfile org link type."
    (my/expand-lfile file
                     (org-link-open-as-file file-resolved current-prefix-arg)
                     nil))

  (defun my/lfile-follow-link--emacs (file _)
    "Open FILE in Emacs given in lfile+emacs org link type."
    (my/expand-lfile file
                     (org-open-file file-resolved t)
                     t))

  (defun my/lfile-follow-link--sys (file _)
    "Open FILE out of Emacs given in lfile+sys org link type."
    (my/expand-lfile file
                     (org-open-file file-resolved 'system)
                     t))

  (defun my/lfile-store-link ()
    "Store a link to the file.

  Prefix argument does matter in this function call.
  If `C-u' prefix is given, file link is stored instead of lfile link."
    (when (and (derived-mode-p 'dired-mode)
               (string-match-p
                (format "^%s" (expand-file-name my/lfile-root))
                (dired-current-directory nil)))
      (let ((path (dired-get-filename nil t)))
        (if (equal current-prefix-arg '(4))
            (org-link-store-props
             :type "file"
             :link (concat "file:" (abbreviate-file-name
                                    (expand-file-name path))))
          (org-link-store-props
           :type "lfile"
           :link (concat "lfile:" (file-name-nondirectory path)))))))

  (defun my/lfile-completing-read (&optional arg)
    "Create a lfile link using completion."
    (let* ((paths (my/lfile--locate nil))
           (files (mapcar #'file-name-nondirectory paths))
           (file (completing-read "Local file: " files nil 'confirm)))
      (concat "lfile:" file)))

  (defun my/lfile-export (link description format)
    "Return an exported string from lfile link for format FORMAT.
  A link consists of LINK and DESCRIPTION."
    (when-let* ((paths (my/lfile--locate link))
                (path (org-export-file-uri (expand-file-name (car paths))))
                (desc (or description link)))
      (when (stringp path)
        (cond
         ((eq format 'html) (format "<a href=\"%s\">%s</a>" path desc))
         ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
         ((eq format 'ascii) (format "%s (%s)" desc path))
         (t path)))))

  (defun my/lfile-from-file-link ()
    "Replace file link type with lfile link type only if hte path in my/lfile-root."
    (interactive)
    (let* ((context (org-element-lineage
                     (org-element-context)
                     '(link desc)
                     t))
           (type (org-element-property :type context))
           (path (org-element-property :path context))
           (app (org-element-property :application context))
           (search-option (org-element-property :search-option context))
           (desc-begin (org-element-property :contents-begin context))
           (desc-end (org-element-property :contents-end context))
           (desc (and (and (integerp desc-begin) (integerp desc-begin))
                      (substring-no-properties (buffer-substring desc-begin desc-end)))))
      (when (and (string= type "file")
                 (string-match-p
                  (format "^%s" (expand-file-name my/lfile-root))
                  (expand-file-name path)))
        (delete-region (org-element-property :begin context)
                       (org-element-property :end context))
        (insert (org-link-make-string (concat "lfile" (and app (concat "+" app)) ":"
                                              (file-name-nondirectory path)
                                              (and search-option (concat "::" search-option)))
                                      desc)))))

  (defun my/lfile--locate (pattern &optional exclude-search)
    "Determine an absolute path from given FILE name using `locate' program."
    (if pattern
        (save-match-data
          (let ((match-idx (string-match "\\(.+\\)\\(::.+\\)\\'"
                                         pattern))
                (data (match-data)))
            (mapcar (lambda (resolved-path)
                      (set-match-data data)
                      (concat resolved-path
                              (when (and match-idx
                                         (not exclude-search))
                                (match-string 2 pattern))
                              ))
                    (split-string
                     (shell-command-to-string
                      (format "plocate -d <<plocate-db()>> -ie \"%s\""
                              (or (and match-idx
                                       (match-string 1 pattern))
                                  pattern)
                              ))
                     "\n" t))))
      ""))

  (with-eval-after-load 'org
    (org-link-set-parameters "lfile"
                             :follow #'my/lfile-follow-link
                             :store #'my/lfile-store-link
                             :complete #'my/lfile-completing-read
                             :export #'my/lfile-export)
    (org-link-set-parameters "lfile+emacs"
                             :follow #'my/lfile-follow-link--emacs)
    (org-link-set-parameters "lfile+sys"
                             :follow #'my/lfile-follow-link--sys))
#+end_src

**** org workflows
:PROPERTIES:
:header-args+: :tangle (expand-file-name ".emacs.d/site-lisp/workflows.el")
:END:

***** notification count down timer finished

#+begin_src emacs-lisp
  (require 'org-timer)

  (defun my/notify-timer-completed ()
    "docstring"
    (when (and (org-clocking-p)
               org-clock-marker)
      (let ((alert (org-entry-get org-clock-marker
                                  "ALERT")))
        (if (and (stringp alert)
                 (string= alert "alarm"))
            (alert "Timer Done!" :style 'alarm)
          (alert "Timer Done!" :style 'fringe :mode 'org-mode :buffer (org-clocking-buffer) :severity 'trivial)))))

  (add-hook 'org-timer-done-hook
            'my/notify-timer-completed)

  (require 'alert)

  (defvar alarm-sound (expand-file-name "~/data/media/music/levelup.mp3"))
  (alert-define-style 'alarm
                      :title "alarm"
                      :notifier
                      (lambda (info)
                        (let ((message (plist-get info :message))
                              (severity (plist-get info :severity))
                              (title (plist-get info :title))
                              (icon (plist-get info :icon))
                              (category (plist-get info :category))
                              (buffer (plist-get info :buffer))
                              (mode (plist-get info :mode))
                              (data (plist-get info :data))
                              (style (plist-get info :style))
                              (persistent (plist-get info :persistent))
                              (id (plist-get info :id))
                              (system-volume (string-trim (shell-command-to-string "volget"))))
                          (if (string= system-volume "0")
                              (alert message :severity severity :title title :icon icon :category category :buffer buffer :mode mode :data data :style 'fringe :persistent persistent :id id)
                            (start-process-shell-command "system-alarm" nil
                                                         (mapconcat #'shell-quote-argument
                                                                    (list "mpg321" alarm-sound)
                                                                    " "))))))
#+end_src

***** clock in/out trigger invocation

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-clock)
    (add-hook 'org-clock-in-prepare-hook #'my/org-clock-in-set-timer)
    (add-hook 'org-clock-out-hook #'my/org-clock-out-have-a-break)
    (add-hook 'org-clock-cancel-hook #'my/org-clock-out-have-a-break))

  (defun my/org-clock-in-set-timer ()
    "Start count down timer for a clocked in entry.

  If the entry has ATTENTION_SPAN property, use it for `org-timer-default-timer'.
  Otherwise count down time is Effort property value.
  In neither case, count down time is 25 min which is suggested in the Pomodoro-technique."
    (let ((todo (org-get-todo-state))
          (attention-span (org-entry-get (point) "ATTENTION_SPAN" 'selective))
          (effort (org-entry-get (point) "Effort" 'selective)))
      (when org-clock-clocking-in
        (org-clock-out))
      (cond
       ((stringp attention-span)
        (let ((org-timer-default-timer attention-span))
          (org-timer-set-timer '(64))))
       ((and (stringp effort)
             (ts< (ts-parse effort) (ts-parse "01:40")))
        (org-timer-set-timer '(16)))
       (todo
        (let ((org-timer-default-timer "25"))
          (org-timer-set-timer '(64)))))))

  ;;;###autoload
  (defun my/org-clock-out-have-a-break ()
    "Clock in the 'Break' task if the previous task has clocked out."
    ;; remove old clock entries if the entry is neither habit nor have any todo keywords
    (when (or (org-is-habit-p)
              (not (org-get-todo-state)))
      (my/org-clock-remove-old-clock-entries 4 5))
    (and org-timer-countdown-timer
         (org-timer-stop))
    (save-excursion
      (let ((break-entry-id "d49d97de-58ec-4e41-b58c-491a9e216e1c"))
        (when (and (not org-clock-clocking-in)
                   (not (string= (or (org-id-get) "")
                                 break-entry-id)))
          (org-id-goto break-entry-id)
          (org-clock-in)))))
#+end_src

***** jotting down (memo)

Memo file (memo.org) is useful for jotting down fragmented pieces of text, code and more.

#+begin_src emacs-lisp
  (require 'org-capture)

  (add-to-list 'org-capture-templates
               '("m" "Memo"
                 entry (file "~/org/sandbox/memo.org")
                 "* %U\n#+begin_src %^{Lnaguage|text}\n%(my-org-capture-filter-memo \"%i\")\n#+end_src"
                 :jump-to-captured t
                 :immediate-finish t)
               t)

  (defun my-org-capture-filter-memo (&optional str)
    "Replace semantic representation in `org-mode' with plain string in STR."
    (cond
     ((stringp str)
      (replace-regexp-in-string "^\\(*+ \\)" ",\\1" str))
     (t "")))
#+end_src

***** list someday/pending tasks
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 22:06]
:END:

#+begin_src emacs-lisp
  (with-eval-after-load 'org-ql-view
    (push `("Someday tasks"
            :buffers-files
            ,(append
              (org-agenda-files)
              (list (file-name-concat org-directory "archive" "suspended.org")))
            :query (todo ,org-todo-keyword-4)
            :super-groups ((:auto-property "ARCHIVE_OLPATH"))
            :sort (scheduled priority date))
          org-ql-views)
    (push `("Pending tasks"
            :buffers-files
            ,(append
              (org-agenda-files)
              (list (file-name-concat org-directory "archive" "suspended.org")))
            :query (todo ,org-done-keyword-2)
            :super-groups ((:auto-property "ARCHIVE_OLPATH"))
            :sort (scheduled priority date))
          org-ql-views)  )
#+end_src

***** learning english words/phrases

1. Capture an word to study by invoking my/org-english-capture
2. Review words periodically with my/org-english-drill-test-display or its variants

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/org-english.el")
  (defvar my/org-english-file (file-name-concat org-directory "lists" "english.org")
    "A file where all english words to learn locate.")

  (defun my/org-english-capture (word)
    "Capture an english WORD as a `org-mode' entry suitable for org-drill.

  Capture URL or file currently visiting as well as a sentence at point."
    (interactive (list (if (use-region-p)
                           (buffer-substring (region-beginning) (region-end))
                         (read-string "Phrase: "))))
    (let* ((sentence-end-double-space nil)
           (org-english-word (downcase word))
           (match-entry (org-ql-select
                          `(,my/org-english-file)
                          `(and (heading-regexp
                                 ,(eval `(rx word-start
                                             ,org-english-word
                                             word-end)))
                                (tags "drill"))
                          :action 'element-with-markers))
           (sentence (replace-regexp-in-string word
                                               (my/cloze-deletion word)
                                               (sentence-at-point))))
      (kill-new (if (stringp sentence) sentence ""))
      (cond
       (match-entry (org-capture nil "!1"))
       (t (org-capture nil "!0")))))

  (defun my/cloze-deletion (word)
    "Build cloze deletion string from WORD."
    (seq-reduce (lambda (string chunk)
                  (replace-regexp-in-string chunk (format "[%s||%c]" chunk (string-to-char chunk))
                                            string))
                (split-string word "[ -]+")
                word))

  (defun my/cloze-deletion-replace (word start end)
    "Convert WORD into cloze deletion.
  OWRD can be determined a string between START and END.

  When called Interactively, WORD is either a word at point or a string in region."
    (interactive (cond
                  ((region-active-p)
                   `(,(buffer-substring (region-beginning) (region-end))
                     ,(region-beginning)
                     ,(region-end)))
                  (t
                   (let ((bounds (bounds-of-thing-at-point 'word)))
                     `(,(thing-at-point 'word)
                       ,(car bounds)
                       ,(cdr bounds))))))
    (replace-string word
                    (my/cloze-deletion word)
                    nil
                    start
                    end))

  (with-eval-after-load 'org-ql-view
    (push `("English words to learn"
            :buffers-files ,(list my/org-english-file)
            :query (and (tags "drill")
                        (tags "fd_en"))
            :sort (scheduled date))
          org-ql-views))

  (with-eval-after-load 'org-capture
    (add-to-list 'org-capture-templates
                 '("!0" "drill entry for english word"
                   entry (id "de0983a7-9d1a-4ef8-b882-148c401e862d")
                   "* %i :drill:fd_en:
  [%(my/org-english-insert-japanese-translation) %(my/org-english-insert-japanese-pronunciation org-english-word)]
  %(my/org-english-insert-english-translation)
  - %a
    %c"))
    (add-to-list 'org-capture-templates
                 '("!1" "drill entry for english word"
                   item (function my/org-english-goto-match)
                   "- %a
    %c")))

  (defun my/org-english-goto-match ()
    "Goto function for org-capture-template designed to insert an edditional example
  to existing english word entry."
    (org-goto-marker-or-bmk
     (plist-get (cadar match-entry) :org-marker)))

  (defun my/org-english-insert-english-translation ()
    "Insert English translation into org capture entry."
    (let* ((url (format "http://wordnik.com/words/%s" (downcase org-english-word)))
           (buffer (url-retrieve-synchronously url t t))
           (vertico-sort-function nil))
      (with-temp-buffer
        (url-insert-buffer-contents buffer url)
        (completing-read "match" (split-string (funcall 'my/define-word--parse-wordnik) "\n")))))

  (advice-add #'my/org-english-insert-english-translation :around #'my/define-word--fix-31)

  (defun my/org-english-insert-japanese-translation ()
    "Insert Japanese translation into org capture entry."
    (let* ((url (format "https://ejje.weblio.jp/content/%s" (downcase org-english-word)))
           (buffer (url-retrieve-synchronously url t t)))
      (with-temp-buffer
        (url-insert-buffer-contents buffer url)
        (funcall 'my/define-word--parse-weblio))))

  (defun my/org-english-insert-japanese-pronunciation (w)
    "Return and add to the kill ring (if interactive) Japanese pronunciation info for word `W'."
    (interactive `(,(or (when (region-active-p)
                          (buffer-substring (region-beginning) (region-end)))
                        (read-string "Word: "))))
    (let (pron)
      (request
        (concat "https://eow.alc.co.jp/search?q=" (string-replace " " "+" (downcase w)))
        :sync t
        :parser
        (lambda ()
          (let ((str (buffer-string)))
            (with-temp-buffer
              (insert str)
              (shr-render-region (point-min) (point-max))
              (let ((str (buffer-substring-no-properties (point-min) (point-max))))
                (if (string-match
                     (rx (seq (opt "【レベル】" (** 1 2 digit) "、")
                              "【発音" (opt "！") "】"
                              (+ (or (category combining-diacritic)
                                     (category latin)
                                     (category japanese-katakana-two-byte)
                                     (category korean)
                                     (category greek)))
                              "、"
                              (? (or (seq "【＠】" (opt "[US]")
                                          (+ (or (category japanese-katakana-two-byte)
                                                 "（" "）"))
                                          (? "、"))
                                     (seq (+ any) "*")))))
                     str)
                    (match-string 0 str)
                  "")))))
        :success
        (cl-function
         (lambda (&key data &allow-other-keys)
           (setq pron (replace-regexp-in-string
                       "\\[\\(.\\{2\\}\\)\\]" "【\\1】"
                       (string-trim-right (substring-no-properties data)
                                          "、"))))))
      (when (interactive-p)
        (kill-new (princ pron)))
      pron))

  (defmacro with-org-drill-english-config (&rest body)
    "Evaluate BODY with config for Org-Drill for english words review."
    `(progn
       (org-id-goto "de0983a7-9d1a-4ef8-b882-148c401e862d")
       (let ((org-drill-scope 'tree)
             (org-drill-question-tag "drill")
             (org-drill-maximum-items-per-session 25)
             (org-drill-hide-item-headings-p t)
             (org-startup-indented nil))
         (org-indent-mode -1)
         (visual-line-mode 1)
         ,@body)
       (save-buffer)
       (org-indent-mode 1)
       (visual-line-mode -1)))

  (defun my/org-english-drill ()
    "Invoke Org-Drill for English word review."
    (interactive)
    (with-org-drill-english-config (org-drill)))

  (defun my/org-english-drill-resume ()
    "Resume Org-Drill session for english word review."
    (interactive)
    (with-org-drill-english-config (org-drill-resume)))

  (defun my/org-english-drill-nontrivial ()
    ""
    (interactive)
    (let ((org-drill-match "-trivial"))
      (with-org-drill-english-config (org-drill))))

  (defun my/org-english-drill-new ()
    ""
    (interactive)
    (let ((org-drill-match "-DRILL_TOTAL_REPEATS>0"))
      (with-org-drill-english-config (org-drill))))

  (defun my/org-english-lookup (word)
    "Look up WORD in my archive files using `org-ql-search'."
    (interactive (list (if (use-region-p)
                           (buffer-substring (region-beginning) (region-end))
                         (read-string "Word: "))))
    (org-ql-search
      my/org-english-file
      `(heading-regexp ,(eval `(rx word-start
                                   ,(downcase word)
                                   word-end)))))

  (defun my/org-english-level (word)
    "Return difficulty level of `WORD' in number."
    (cl-labels ((parse-level (text)
                             (if (string-match
                                  (rx (seq "【レベル】"
                                           (group-n 1 (repeat 1 2 digit))))
                                  text)
                                 (match-string 1 text)
                               nil)))
      (let ((local-str (with-current-buffer (find-file-noselect my/org-english-file)
                         (let ((headline (org-ql-select
                                           `(,my/org-english-file)
                                           `(and (heading ,word)
                                                 (tags "drill"))
                                           :action 'element-with-markers)))
                           (org-with-point-at (plist-get (cadar headline) :org-marker)
                             (org-get-entry))))))
        (string-to-number (or (and local-str
                                   (parse-level local-str))
                              ;; CAVEAT: getting level from web costs a lot
                              ;; (when-let ((remote-str (my/org-english-insert-japanese-pronunciation word)))
                              ;;   (parse-level remote-str))
                              "99")))))

  (defun my/org-ql--english-level< (a b)
    "Return non-nil if A's difficulty level is higher than B's.
  A and B are Org headline elements."
    (cl-macrolet ((level (item)
                         `(my/org-english-level
                           (org-element-property :raw-value ,item))))
      (let ((a-level (level a))
            (b-level (level b)))
        (cond ((and (numberp a-level) (numberp b-level))
               (< a-level b-level))
              (a-level t)
              (b-level nil)))))

  (provide 'my/org-english)
#+end_src

test code
#+begin_src emacs-lisp
  (require 'ert)

  (ert-deftest test-org-english-pron ()
    "Tests the output string of `my/org-english-insert-japanese-pronunciation'."
    (should (string= (my/org-english-insert-japanese-pronunciation "rife")
                     "【レベル】11、【発音】ráif、【＠】ライフ"))
    (should (string= (my/org-english-insert-japanese-pronunciation "congregate")
                     "【レベル】12、【発音！】【US】《動》kɑ́ngrəgèit 《形》kɑ́ŋgrəgit ｜ 【UK】《動》kɔ́ŋgrigèit 《形》kɔ́ŋgrigit"))
    (should (string= (my/org-english-insert-japanese-pronunciation "unleash")
                     "【レベル】9、【発音】ʌ̀nlíːʃ、【＠】アンリーシュ"))
    (should (string= (my/org-english-insert-japanese-pronunciation "homage")
                     "【レベル】11、【発音】【US】 hɑ́midʒ ｜ 【UK】 hɔ́midʒ、【＠】【US】ハミジ、【UK】ホミジ"))
    (should (string= (my/org-english-insert-japanese-pronunciation "interstitial")
                     "【発音】ìntərstíʃəl、【＠】インタ（ー）スティシャル"))
    (should (string= (my/org-english-insert-japanese-pronunciation "veterinarian")
                     "【レベル】12、【発音】vètərənέəriən、【＠】ヴェトラネアリアン"))
    (should (string= (my/org-english-insert-japanese-pronunciation "warehouse")
                     "【レベル】8、【発音！】《動》wέərhàuz 《名》wέərhàus、【＠】ウェアハウス、ウエアハウス"))
    (should (string= (my/org-english-insert-japanese-pronunciation "lambaste")
                     ""))
    (should (string= (my/org-english-insert-japanese-pronunciation "in a nutshell")
                     ""))
    (should (string= (my/org-english-insert-japanese-pronunciation "traverse")
                     "【レベル】8、【発音！】《名・形》trǽvəːrs 《動》trəvʌ́rs、【＠】トゥラヴァース、トラバース")))
#+end_src

**** additional emacs lisp code

This section mainly for elisp code associated with some other programs.

#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name ".emacs.d/site-lisp/additional.el")
  <<additional-elisp>>
#+end_src

** Findutils

[[https://www.gnu.org/software/findutils/][GNU Findutils]] offers following commands
- find
- locate
- updatedb
- xargs

'locate' is GNU implementation of mlocate. I prefer '[[id:c56e19dd-d3b1-4595-be74-0ff7c6558bc8][plocate]]', which is fast than mlocate, for indexed file searching,

#+begin_src scheme :noweb-ref base-pkgs
  "findutils"
#+end_src

** plocate
:PROPERTIES:
:CREATED:  [2022-10-11 Tue 16:52]
:ID:       c56e19dd-d3b1-4595-be74-0ff7c6558bc8
:END:

#+begin_src scheme :noweb-ref base-pkgs
  "plocate"
#+end_src

#+name: plocate-db
#+begin_src emacs-lisp :noweb yes
  (file-name-concat "<<share-dir()>>" "plocate/plocate.db")
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
  export LOCATE_PATH=<<plocate-db()>>
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/updatedb-home") :tangle-mode (identity #o755)
  #!/usr/bin/env bash

  [[ -d $(dirname <<plocate-db()>>) ]] \
   || mkdir -p $(dirnmae <<plocate-db()>>) \
     && which -a updatedb | grep sbin | xargs -I{} sh -c '{} -l 0 -U '<<home-dir()>>' -o <<plocate-db()>>'
#+end_src

#+begin_src conf :noweb yes :noweb-ref cronjob-pc
  30 4 * * * /bin/bash -ci "updatedb-home >> $LOG_DIR/updatedb-home.log 2>&1"
#+end_src

** OpenSSH

[[https://www.openssh.com/][OpenSSH]] is client and server side of ssh implementation.

#+begin_src scheme :noweb-ref base-pkgs
  "openssh"
#+end_src

#+begin_src conf  :tangle (expand-file-name ".ssh/config")
  Include config.d/*
#+end_src

** Git

#+begin_src scheme :noweb-ref base-pkgs
  "git"
#+end_src

- git ignore
  #+BEGIN_SRC conf :tangle (expand-file-name ".config/git/info/ignore")
    #
    # ~/.gitignote
    #
    ## Compiled object files ##
    ,*.slo
    ,*.lo
    ,*.o
    ,*.obj

    ## Compiled Dynamic libraries ##
    ,*.so
    ,*.dylib
    ,*.dll

    ## Compiled Static libraries ##
    ,*.lai
    ,*.la
    ,*.a
    ,*.lib

    ## Executables ##
    ,*.out
    ,*.app

    ## Windows ##
    Thumbs.db
    ehthumbs.db
    Desktop.ini
    $RECYCLE.BIN/
    ,*.cab
    ,*.msm
    ,*.msp

    ## Mac ##
    .DS_Store
    .AppleDouble
    .LSOverride
    .Spotlight-V100
    .Trashes
    ._*

    ## Linux ##
    locate.db

    ## version control system ##
    .git/
    .hg/
    .svn/

    ## backup,log ##
    ,*~
    ~*
    ,*.swp
    .swp.*
    ,*.tmp
    ,*.bak
    ,*.old
    ,*.log
    .cache/
    ,*.autosave

    ## Emacs ##
    ,*.elc

    ## Vim ##
    ,*.un~
    Session.vim
    .netrwhist

    ## GNU GLOBAL ##
    GPATH
    GRTAGS
    GTAGS

    ## netbeans ##
    nbproject/
    ## intellij idea ##
    .idea/
    ## eclipse ##
    .settings/
    .project
    .classpath
    .buildpath
    ## XCode ##
    ,*.xcodeproj/*

    ## Build dir ##
    build/
  #+END_SRC
- git config

  [[https://magit.vc/manual/magit/How-to-show-diffs-for-gpg_002dencrypted-files_003f.html][This page]] show you how to get diffs of gpg files in Magit.

  #+BEGIN_SRC gitconfig :noweb tangle :tangle (expand-file-name ".config/git/config")
    [core]
            excludesfile = <<home-dir()>>/.config/git/info/ignore
            attributesfile = <<home-dir()>>/.config/git/info/attributes
            editor = emacs
            symlinks = true
            # Unicode
            precomposeunicode = true
            quotepath = true
            autocrlf = false
    [push]
            # simple,matching,upstream,current
            default = simple
    [color]
            ui = auto
            status = auto
            diff = auto
            branch = auto
            interactive = auto
            grep = auto
    [diff]
            patience = true
    [diff "gpg"]
            textconv = gpg --no-tty --decrypt
    [help]
            autocorrect = 0
    [alias]
            co = checkout
            ca = commit -a -v
            ce = commit -v --amend
            st = status --branch --short
            si = status --ignored --short
            branches = branch -a
            remotes = remote -v
            tags = tag -l
            lg = log --graph --all --decorate --abbrev-commit --branches --date=short --pretty=format:\"%C(red)%h%C(reset) %C(green)[%ad]%C(reset) %s %C(cyan)@%an%C(reset) %C(yellow)%d%C(reset)\"
            fp = fetch --prune
            di = diff
            dh = diff --histogram
            dw = diff --word-diff
            dc = diff --cached
            wc = whatchanged
    [user]
            email = 6841207+p-snow@users.noreply.github.com
            name = p-snow
    [credential]
            helper = <<home-dir()>>/.guix-extra-profiles/base/base/bin/pass-git-helper -m <<home-dir()>>/.config/pass-git-helper/git-pass-mapping.ini
    <<git-config>>
  #+END_SRC
- git attributes
  #+BEGIN_SRC gitattributes :tangle (expand-file-name ".config/git/info/attributes")
    ,*.c diff=cpp
    ,*.h diff=cpp
    ,*.cpp diff=cpp
    ,*.hpp diff=cpp
    ,*.cs diff=csharp
    ,*.m diff=objc
    ,*.java diff=java
    ,*.html diff=html
    ,*.xml diff=html
    ,*.pl diff=perl
    ,*.pm diff=perl
    ,*.t diff=perl
    ,*.php diff=php
    ,*.ptml diff=php
    ,*.py diff=python
    ,*.rb diff=ruby
    ,*.js diff=java
    ,*.csv encoding=cp932
    ,*.json diff=json
    ,*.gpg filter=gpg diff=gpg
  #+END_SRC

*** git-annex

[[https://git-annex.branchable.com/git-annex/][git-annex]] aims to manage large files based on git system. It is alse designed to manage copies of binary in distributed repositories. [[https://git-annex.branchable.com/walkthrough/][walkthrough]] offers handy instruction.

[[https://git-lfs.github.com/][Git-LFS]] is alse designed to manage large files. [[https://lwn.net/Articles/774125/][This article]] compares Git-LFS and git-annex precisely.

#+begin_src scheme :noweb-ref base-pkgs
  "git-annex"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://git-annex.branchable.com/news/index.rss" soft_update)
  ("https://git-annex.branchable.com/devblog/index.rss" soft_update)
#+end_src

#+begin_src gitconfig :noweb-ref git-config
  [annex]
          youtube-dl-command = yt-dlp
  [annex.security]
          allowed-ip-addresses = all
  [safe]
          directory = /mnt/ns01/doc
#+end_src

** ghq

[[https://github.com/x-motemen/ghq][ghq]] is management system for remote git repositories.

#+begin_src scheme :noweb-ref base-pkgs
  "ghq"
#+end_src

#+begin_src gitconfig :noweb-ref git-config
  [ghq]
          root = ~/ghq
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/ghq")
  [github.com*]
  username_extractor=specific_line
  line_username=2
  target=github.com
  # username_extractor=entry_name
#+end_src

** Pass

[[https://www.passwordstore.org/][Pass]] is a simple password manager.

#+begin_src scheme :noweb-ref base-pkgs
  "password-store"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/pass-git-helper/git-pass-mapping.ini")
  [github.com*]
  username_extractor=specific_line
  line_username=2
  target=github.com
  # username_extractor=entry_name
#+end_src

- additional environment variables
  #+BEGIN_SRC shell :noweb-ref bashrc
    export PASSWORD_STORE_CLIP_TIME=25
  #+END_SRC
** mpv

#+begin_src scheme :noweb-ref desktop-pkgs
  "mpv"
#+end_src

- mpv.conf
  #+begin_src conf :tangle (expand-file-name ".config/mpv/mpv.conf")
    ##################
    # video settings #
    ##################

    # Start in fullscreen mode by default.
    fs=yes


    ###########
    # General #
    ###########

    save-position-on-quit
    no-border                               # no window title bar
    msg-module                              # prepend module name to log messages
    msg-color                               # color log messages on terminal
    term-osd-bar                            # display a progress bar on the terminal
    use-filedir-conf                        # look for additional config files in the directory of the opened file
    pause                                   # no autoplay
    force-window=immediate
    keep-open                               # keep the player open when a file's end is reached
    autofit-larger=100%x95%                 # resize window in case it's larger than W%xH% of the screen
    cursor-autohide-fs-only                 # don't autohide the cursor in window mode, only fullscreen
    # input-media-keys=no                     # enable/disable OSX media keys
    cursor-autohide=1000                    # autohide the curser after 1s

    screenshot-format=png
    screenshot-png-compression=8
    screenshot-template='~/Desktop/%F (%P) %n'

    hls-bitrate=max                         # use max quality for HLS streams


    #########
    # Cache #
    #########

    cache=yes
    cache-secs=10                           # how many seconds of audio/video to prefetch if the cache is active


    #############
    # OSD / OSC #
    #############

    osd-level=1                             # enable osd and display --osd-status-msg on interaction
    osd-duration=2500                       # hide the osd after x ms
    osd-status-msg='${time-pos} / ${duration}${?percent-pos: (${percent-pos}%)}${?frame-drop-count:${!frame-drop-count==0: Dropped: ${frame-drop-count}}}\n${?chapter:Chapter: ${chapter}}'
    # osd-status-msg='${=time-pos}'         # show raw position

    osd-font='Source Sans Pro'
    osd-font-size=64
    osd-color='#CCFFFFFF'                   # ARGB format
    osd-border-color='#DD322640'            # ARGB format
    #osd-shadow-offset=1                    # pixel width for osd text and progress bar
    osd-bar-align-y=0                       # progress bar y alignment (-1 top, 0 centered, 1 bottom)
    osd-border-size=2                       # size for osd text and progress bar
    osd-bar-h=2                             # height of osd bar as a fractional percentage of your screen height
    osd-bar-w=60                            # width of " " "


    #############
    # Subtitles #
    #############

    sub-use-margins
    sub-ass-force-margins

    demuxer-mkv-subtitle-preroll            # try to correctly show embedded subs when seeking
    sub-auto=fuzzy                          # external subs don't have to match the file name exactly to autoload
    embeddedfonts=yes                       # use embedded fonts for SSA/ASS subs
    sub-fix-timing=no                       # do not try to fix gaps (which might make it worse in some cases)
    sub-ass-force-style=Kerning=yes         # allows you to override style parameters of ASS scripts

    # the following options only apply to subtitles without own styling (i.e. not ASS but e.g. SRT)
    sub-font="Source Sans Pro Semibold"
    sub-font-size=36
    sub-color="#FFFFFFFF"
    sub-border-color="#FF262626"
    sub-border-size=3.2
    sub-shadow-offset=1
    sub-shadow-color="#33000000"
    sub-spacing=0.5


    #############
    # Languages #
    #############

    slang=enm,en,eng,de,deu,ger             # automatically select these subtitles (decreasing priority)
    alang=ja,jp,jpn,en,eng,de,deu,ger       # automatically select these audio tracks (decreasing priority)

    #########
    # Image #
    #########

    image-display-duration=4

    #########
    # Audio #
    #########

    audio-file-auto=fuzzy                   # external audio doesn't has to match the file name exactly to autoload
    audio-pitch-correction=yes              # automatically insert scaletempo when playing with higher speed
    volume-max=200                          # maximum volume in %, everything above 100 results in amplification
    volume=100                              # default volume, 100 = unchanged


    ################
    # Video Output #
    ################

    # Active VOs (and some other options) are set conditionally
    # See here for more information: https://github.com/wm4/mpv-scripts/blob/master/auto-profiles.lua
    # The script was modified to import functions from scripts/auto-profiles-functions.lua

    # Defaults for all profiles
    tscale=catmull_rom                      # sharp: oversample <-> linear (triangle) <-> catmull_rom <-> mitchell <-> gaussian <-> bicubic : smooth
    opengl-early-flush=no
    opengl-pbo=yes


    [high-quality]
    profile-desc=cond:is_desktop() and get('width', math.huge) < 3840
    scale=ewa_lanczossharp
    cscale=ewa_lanczossoft
    dscale=mitchell
    scale-antiring=0.7
    cscale-antiring=0.7
    dither-depth=auto
    correct-downscaling=yes
    sigmoid-upscaling=yes
    deband=yes
    hwdec=no

    [mid-quality]
    profile-desc=cond:(is_laptop() and not on_battery() and get('width', math.huge) < 1920) or (is_desktop() and get('width', math.huge) >= 3840)
    scale=spline36
    cscale=bilinear
    dscale=mitchell
    scale-antiring=1.0
    cscale-antiring=1.0
    dither-depth=auto
    correct-downscaling=yes
    sigmoid-upscaling=yes
    deband=yes
    hwdec=no

    [low-quality]
    profile-desc=cond:is_laptop() and (on_battery() or get('width', math.huge) >= 1920)
    scale=bilinear
    cscale=bilinear
    dscale=bilinear
    scale-antiring=0.0
    cscale-antiring=0.0
    dither-depth=no
    correct-downscaling=no
    sigmoid-upscaling=no
    deband=no
    hwdec=auto

    [60FPS]
    profile-desc=cond:is_laptop() and get('container-fps', 0) >= 59
    scale=bilinear
    cscale=bilinear

    [4K]
    profile-desc=cond:get('width', -math.huge) >= 3840
    vd-lavc-threads=32

    [4K-inverted]
    profile-desc=cond:get('width', -math.huge) < 3840
    vd-lavc-threads=0


    [default]


    ###################################
    # Protocol Specific Configuration #
    ###################################

    [protocol.https]
    #cache=yes
    #cache-default=500000                    # size in KB
    #cache-backbuffer=250000                 # size in KB
    cache-secs=100                          # how many seconds of audio/video to prefetch
    user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

    [protocol.http]
    #cache=yes
    #cache-default=500000                    # size in KB
    #cache-backbuffer=250000                 # size in KB
    cache-secs=100                          # how many seconds of audio/video to prefetch
    user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

    [extension.gif]
    cache=no
    no-pause
    loop-file=yes

    [extension.webm]
    #cache=no
    #no-pause
    #loop-file=yes
  #+end_src
- input.conf
  #+begin_src conf :tangle (expand-file-name ".config/mpv/input.conf")
    # mpv keybindings
    #
    # Location of user-defined bindings: ~/.config/mpv/input.conf
    #
    # Lines starting with # are comments. Use SHARP to assign the # key.
    # Copy this file and uncomment and edit the bindings you want to change.
    #
    # List of commands and further details: DOCS/man/input.rst
    # List of special keys: --input-keylist
    # Keybindings testing mode: mpv --input-test --force-window --idle
    #
    # Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
    #
    # Strings need to be quoted and escaped:
    #   KEY show-text "This is a single backslash: \\ and a quote: \" !"
    #
    # You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
    # the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
    #
    # The default keybindings are hardcoded into the mpv binary.
    # You can disable them completely with: --no-input-default-bindings

    # Developer note:
    # On compilation, this file is baked into the mpv binary, and all lines are
    # uncommented (unless '#' is followed by a space) - thus this file defines the
    # default key bindings.

    # If this is enabled, treat all the following bindings as default.
    #default-bindings start

    #MOUSE_BTN0 ignore                      # don't do anything
    #MOUSE_BTN0_DBL cycle fullscreen        # toggle fullscreen on/off
    #MOUSE_BTN2 cycle pause                 # toggle pause on/off
    #MOUSE_BTN3 seek 10
    #MOUSE_BTN4 seek -10
    #MOUSE_BTN5 add volume -2
    #MOUSE_BTN6 add volume 2

    # Mouse wheels, touchpad or other input devices that have axes
    # if the input devices supports precise scrolling it will also scale the
    # numeric value accordingly
    #AXIS_UP    seek 10
    #AXIS_DOWN  seek -10
    #AXIS_LEFT  seek 5
    #AXIS_RIGHT seek -5

    ## Seek units are in seconds, but note that these are limited by keyframes
    #RIGHT seek  5
    #LEFT  seek -5
    #UP    seek  60
    #DOWN  seek -60
    RIGHT  seek  5
    LEFT   seek -5
    UP     seek -60
    DOWN   seek  60
    Ctrl+f seek  3
    Ctrl+b seek -3
    Ctrl+p seek -60
    Ctrl+n seek  60
    # Do smaller, always exact (non-keyframe-limited), seeks with shift.
    # Don't show them on the OSD (no-osd).
    #Shift+RIGHT no-osd seek  1 exact
    #Shift+LEFT  no-osd seek -1 exact
    #Shift+UP    no-osd seek  5 exact
    #Shift+DOWN  no-osd seek -5 exact
    # Skip to previous/next subtitle (subject to some restrictions; see manpage)
    #Ctrl+LEFT   no-osd sub-seek -1
    #Ctrl+RIGHT  no-osd sub-seek  1
    #PGUP add chapter 1                     # skip to next chapter
    #PGDWN add chapter -1                   # skip to previous chapter
    PGUP add chapter -1                     # skip to next chapter
    PGDWN add chapter 1                     # skip to previous chapter
    #Shift+PGUP seek 600
    #Shift+PGDWN seek -600
    #[ multiply speed 0.9091                # scale playback speed
    #] multiply speed 1.1
    #{ multiply speed 0.5
    #} multiply speed 2.0
    #BS set speed 1.0                       # reset speed to normal
    #q quit
    #Q quit-watch-later
    #q {encode} quit 4
    #ESC set fullscreen no
    #ESC {encode} quit 4
    #p cycle pause                          # toggle pause/playback mode
    #. frame-step                           # advance one frame and pause
    #, frame-back-step                      # go back by one frame and pause
    #SPACE cycle pause
    ? playlist-shuffle                      # skip to random file
    #> playlist-next                        # skip to next file
    ENTER playlist-next                     # skip to next file
    #< playlist-prev                        # skip to previous file
    Shift+ENTER playlist-prev               # skip to next file
    #O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
    #o show-progress
    #P show-progress
    #I show-text "${filename}"              # display filename in osd
    #z add sub-delay -0.1                   # subtract 100 ms delay from subs
    #x add sub-delay +0.1                   # add
    #ctrl++ add audio-delay 0.100           # this changes audio/video sync
    #ctrl+- add audio-delay -0.100
    #9 add volume -2
    #/ add volume -2
    #0 add volume 2
    #* add volume 2
    #m cycle mute
    #1 add contrast -1
    #2 add contrast 1
    #3 add brightness -1
    #4 add brightness 1
    #5 add gamma -1
    #6 add gamma 1
    #7 add saturation -1
    #8 add saturation 1
    #Alt+0 set window-scale 0.5
    #Alt+1 set window-scale 1.0
    #Alt+2 set window-scale 2.0
    # toggle deinterlacer (automatically inserts or removes required filter)
    #d cycle deinterlace
    #r add sub-pos -1                       # move subtitles up
    #t add sub-pos +1                       #                down
    #v cycle sub-visibility
    # stretch SSA/ASS subtitles with anamorphic videos to match historical
    #V cycle sub-ass-vsfilter-aspect-compat
    # switch between applying no style overrides to SSA/ASS subtitles, and
    # overriding them almost completely with the normal subtitle style
    #u cycle-values sub-ass-style-override "force" "no"
    #j cycle sub                            # cycle through subtitles
    #J cycle sub down                       # ...backwards
    #SHARP cycle audio                      # switch audio streams
    #_ cycle video
    #T cycle ontop                          # toggle video window ontop of other windows
    #f cycle fullscreen                     # toggle fullscreen
    #s async screenshot                     # take a screenshot
    #S async screenshot video               # ...without subtitles
    #Ctrl+s async screenshot window         # ...with subtitles and OSD, and scaled
    #Alt+s screenshot each-frame            # automatically screenshot every frame
    #w add panscan -0.1                     # zoom out with -panscan 0 -fs
    #e add panscan +0.1                     #      in
    # cycle video aspect ratios; "-1" is the container aspect
    #A cycle-values video-aspect "16:9" "4:3" "2.35:1" "-1"
    #POWER quit
    #PLAY cycle pause
    #PAUSE cycle pause
    #PLAYPAUSE cycle pause
    #STOP quit
    #FORWARD seek 60
    #REWIND seek -60
    #NEXT playlist-next
    #PREV playlist-prev
    #VOLUME_UP add volume 2
    #VOLUME_DOWN add volume -2
    #MUTE cycle mute
    #CLOSE_WIN quit
    #CLOSE_WIN {encode} quit 4
    #E cycle edition                        # next edition
    #l ab-loop                              # Set/clear A-B loop points
    #L cycle-values loop-file "inf" "no"    # toggle infinite looping
    #ctrl+c quit 4

    # Apple Remote section
    #AR_PLAY cycle pause
    #AR_PLAY_HOLD quit
    #AR_CENTER cycle pause
    #AR_CENTER_HOLD quit
    #AR_NEXT seek 10
    #AR_NEXT_HOLD seek 120
    #AR_PREV seek -10
    #AR_PREV_HOLD seek -120
    #AR_MENU show-progress
    #AR_MENU_HOLD cycle mute
    #AR_VUP add volume 2
    #AR_VUP_HOLD add chapter 1
    #AR_VDOWN add volume -2
    #AR_VDOWN_HOLD add chapter -1

    # For tv://
    #h cycle tv-channel -1                  # previous channel
    #k cycle tv-channel +1                  # next channel

    # For dvb://
    #H cycle dvb-channel-name -1            # previous channel
    #K cycle dvb-channel-name +1            # next channel

    #
    # Legacy bindings (may or may not be removed in the future)
    #
    #! add chapter -1                       # skip to previous chapter
    #@ add chapter 1                        #         next

    #
    # Not assigned by default
    # (not an exhaustive list of unbound commands)
    #

    # ? add sub-scale +0.1                  # increase subtitle font size
    # ? add sub-scale -0.1                  # decrease subtitle font size
    # ? sub-step -1                         # immediately display next subtitle
    # ? sub-step +1                         #                     previous
    # ? cycle angle                         # switch DVD/Bluray angle
    # ? add balance -0.1                    # adjust audio balance in favor of left
    Z add balance -0.1                    # adjust audio balance in favor of left
    # ? add balance 0.1                     #                                  right
    X add balance 0.1                     #                                  right
    # ? cycle sub-forced-only               # toggle DVD forced subs
    # ? cycle program                       # cycle transport stream programs
    # ? stop                                # stop playback (quit or enter idle mode)
  #+end_src
- scripts
  #+begin_src lua :tangle (expand-file-name ".config/mpv/scripts/delete_file.lua")
    local utils = require "mp.utils"

    del_list = {}

    function contains_item(l, i)
       for k, v in pairs(l) do
          if v == i then
             mp.osd_message("undeleting current file")
             l[k] = nil
             return true
          end
       end
       mp.osd_message("deleting current file")
       return false
    end

    function mark_delete()
       local work_dir = mp.get_property_native("working-directory")
       local file_path = mp.get_property_native("path")
       local s = file_path:find(work_dir, 0, true)
       local final_path
       if s and s == 0 then
          final_path = file_path
       else
          final_path = utils.join_path(work_dir, file_path)
       end
       if not contains_item(del_list, final_path) then
          table.insert(del_list, final_path)
       end
    end

    function delete(e)
       if e.reason == "quit" then
          for i, v in pairs(del_list) do
             print("deleting: "..v)
             os.remove(v)
          end
       end
    end

    mp.add_key_binding("ctrl+DEL", "delete_file", mark_delete)
    mp.register_event("end-file", delete)
  #+end_src

** unison
- music directory syncing
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".unison/music.prf")
    # Roots of the synchronization
    root = <<home-dir()>>/mnt/ruizu/Music
    root = <<home-dir()>>/Audio

    # Paths to synchronize
    path = .

    # Ruizu's file system is FAT
    fat = true

    # Overwrite by newer file on confliction
    prefer = newer

    # Show nothing
    silent = true
    confirmbigdel = false

    # Do fast checking
    fastcheck = true

    # Log settings
    log = true
    logfile = <<home-dir()>>/.local/state/log/log/unison/music.log

  #+end_src
- doc directory backup
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".unison/doc.prf")
    # Roots of the synchronization
    root = <<home-dir()>>/mnt/ns01
    root = <<home-dir()>>

    # Paths to synchronize
    path = doc

    # Overwrite by newer file on confliction
    prefer = newer

    # Use this command for displaying diffs
    diff = diff -y -W 79 --suppress-common-lines

    # Write down synchronization activity on log file rather than show in stdout
    auto = true
    confirmbigdel = false
    silent = true
    log = true
    logfile = <<home-dir()>>/.local/state/log/unison/doc.log

    # Use inode number to verify identity rather than ckeck whole byte sequence
    fastcheck = true

    # Abort if device is not mounted
    mountpoint = doc
  #+end_src
** Aspell
aspell - interactive spell checker
#+begin_src conf :tangle (expand-file-name ".aspell.conf")
  lang en_US
#+end_src
** textlint
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 14:53]
:ID:       decef153-596d-4821-996e-53cfafe83c8f
:END:

#+begin_src conf :noweb-ref ubuntu-setup :tangle no
  install-textlint
#+end_src

#+begin_src shell :shebang #!/bin/sh :tangle (expand-file-name ".local/bin/install-textlint") :tangle-mode (identity #o755)
  npm install -g \
    textlint \
    @textlint/ast-node-types \
    textlint-rule-preset-ja-spacing \
    textlint-rule-preset-ja-technical-writing \
    textlint-rule-spellcheck-tech-word \
    textlint-rule-ginger \
    textlint-rule-write-good \
    textlint-rule-prh \
    textlint-filter-rule-node-types \
    textlint-plugin-org \
    traverse
#+end_src

- config for English
  #+begin_src json :tangle (expand-file-name ".textlintrc")
    {
      "rules": {
        "ginger": true,
        "write-good": true,
      }
    }
  #+end_src

- config for Japanese
  #+begin_src json :tangle (expand-file-name ".config/textlint/textlintrc_ja")
    {
        "rules": {
            "preset-ja-technical-writing": {
                "no-exclamation-question-mark": false,
                "sentence-length": {
                    "max": 200
                }
            },
            "spellcheck-tech-word": true,
            "textlint-rule-ginger": {
                "skipPatterns": [
                    "`(.*)`"
                ]
            },
            "textlint-rule-write-good": true,
            "preset-ja-spacing": true
        }
    }
  #+end_src

** xkeysnail

#+begin_src scheme :noweb-ref desktop-pkgs
  "xkeysnail"
#+end_src

- config.py
  #+begin_src python :tangle (expand-file-name ".config/xkeysnail/config.py")
  # -*- coding: utf-8 -*-

  import re
  from xkeysnail.transform import *

  define_multipurpose_modmap({
      # SandS
      Key.SPACE: [Key.SPACE, Key.LEFT_SHIFT],

      # Enter is enter when pressed and released. Control when held down.
      Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL],

      Key.LEFT_SHIFT: [Key.EQUAL, Key.LEFT_SHIFT],
      Key.RIGHT_SHIFT: [Key.MINUS, Key.RIGHT_SHIFT],
  })

  define_modmap({
      Key.LEFT_CTRL: Key.CAPSLOCK,
      Key.CAPSLOCK: Key.LEFT_CTRL,
      Key.SYSRQ: Key.RIGHT_META,
  })

  define_keymap(None, {
      K("C-Shift-a"): K("KEY_1"),
      K("C-Shift-s"): K("KEY_2"),
      K("C-Shift-d"): K("KEY_3"),
      K("C-Shift-f"): K("KEY_4"),
      K("C-Shift-g"): K("KEY_5"),
      K("C-Shift-h"): K("KEY_6"),
      K("C-Shift-j"): K("KEY_7"),
      K("C-Shift-k"): K("KEY_8"),
      K("C-Shift-l"): K("KEY_9"),
      K("C-Shift-semicolon"): K("KEY_0"),
  })


  # # [Conditional modmap] Change modifier keys in certain applications
  # define_conditional_modmap(re.compile(r'Emacs'), {
  #     Key.RIGHT_CTRL: Key.ESC,
  # })

  # # [Multipurpose modmap] Give a key two meanings. A normal key when pressed and
  # # released, and a modifier key when held down with another key. See Xcape,
  # # Carabiner and caps2esc for ideas and concept.
  # define_multipurpose_modmap(
  #     # Enter is enter when pressed and released. Control when held down.
  #     {Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL]}

  #     # Capslock is escape when pressed and released. Control when held down.
  #     # {Key.CAPSLOCK: [Key.ESC, Key.LEFT_CTRL]
  #     # To use this example, you can't remap capslock with define_modmap.
  # )


  # # Keybindings for Firefox/Chrome
  # define_keymap(re.compile("Firefox|Google-chrome"), {
  #     # Ctrl+Alt+j/k to switch next/previous tab
  #     K("C-M-j"): K("C-TAB"),
  #     K("C-M-k"): K("C-Shift-TAB"),
  #     # Type C-j to focus to the content
  #     K("C-j"): K("C-f6"),
  #     # very naive "Edit in editor" feature (just an example)
  #     K("C-o"): [K("C-a"), K("C-c"), launch(["gedit"]), sleep(0.5), K("C-v")]
  # }, "Firefox and Chrome")

  # # Keybindings for Zeal https://github.com/zealdocs/zeal/
  # define_keymap(re.compile("Zeal"), {
  #     # Ctrl+s to focus search area
  #     K("C-s"): K("C-k"),
  # }, "Zeal")

  # # Emacs-like keybindings in non-Emacs applications
  # define_keymap(lambda wm_class: wm_class not in ("Emacs", "URxvt"), {
  #     # Cursor
  #     K("C-b"): with_mark(K("left")),
  #     K("C-f"): with_mark(K("right")),
  #     K("C-p"): with_mark(K("up")),
  #     K("C-n"): with_mark(K("down")),
  #     K("C-h"): with_mark(K("backspace")),
  #     # Forward/Backward word
  #     K("M-b"): with_mark(K("C-left")),
  #     K("M-f"): with_mark(K("C-right")),
  #     # Beginning/End of line
  #     K("C-a"): with_mark(K("home")),
  #     K("C-e"): with_mark(K("end")),
  #     # Page up/down
  #     K("M-v"): with_mark(K("page_up")),
  #     K("C-v"): with_mark(K("page_down")),
  #     # Beginning/End of file
  #     K("M-Shift-comma"): with_mark(K("C-home")),
  #     K("M-Shift-dot"): with_mark(K("C-end")),
  #     # Newline
  #     K("C-m"): K("enter"),
  #     K("C-j"): K("enter"),
  #     K("C-o"): [K("enter"), K("left")],
  #     # Copy
  #     K("C-w"): [K("C-x"), set_mark(False)],
  #     K("M-w"): [K("C-c"), set_mark(False)],
  #     K("C-y"): [K("C-v"), set_mark(False)],
  #     # Delete
  #     K("C-d"): [K("delete"), set_mark(False)],
  #     K("M-d"): [K("C-delete"), set_mark(False)],
  #     # Kill line
  #     K("C-k"): [K("Shift-end"), K("C-x"), set_mark(False)],
  #     # Undo
  #     K("C-slash"): [K("C-z"), set_mark(False)],
  #     K("C-Shift-ro"): K("C-z"),
  #     # Mark
  #     K("C-space"): set_mark(True),
  #     K("C-M-space"): with_or_set_mark(K("C-right")),
  #     # Search
  #     K("C-s"): K("F3"),
  #     K("C-r"): K("Shift-F3"),
  #     K("M-Shift-key_5"): K("C-h"),
  #     # Cancel
  #     K("C-g"): [K("esc"), set_mark(False)],
  #     # Escape
  #     K("C-q"): escape_next_key,
  #     # C-x YYY
  #     K("C-x"): {
  #         # C-x h (select all)
  #         K("h"): [K("C-home"), K("C-a"), set_mark(True)],
  #         # C-x C-f (open)
  #         K("C-f"): K("C-o"),
  #         # C-x C-s (save)
  #         K("C-s"): K("C-s"),
  #         # C-x k (kill tab)
  #         K("k"): K("C-f4"),
  #         # C-x C-c (exit)
  #         K("C-c"): K("C-q"),
  #         # cancel
  #         K("C-g"): pass_through_key,
  #         # C-x u (undo)
  #         K("u"): [K("C-z"), set_mark(False)],
  #     }
  # }, "Emacs-like keys")
  #+end_src
- xkeysnail.service

  #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
    systemctl --user enable xkeysnail
    systemctl --user start xkeysnail
  #+end_src

  #+begin_src conf :tangle (expand-file-name ".config/systemd/user/xkeysnail.service")
    [Unit]
    Description=xkeysnail

    [Service]
    KillMode=process
    ExecStart=/bin/bash -ic 'pwsudo xkeysnail --watch --quiet %h/.config/xkeysnail/config.py'
    Type=simple
    Restart=always
    # Update DISPLAY to be the same as `echo $DISPLAY` on your graphical terminal.
    Environment=DISPLAY=:0

    [Install]
    WantedBy=default.target
  #+end_src

** SKK

SKK is Simple Kana to Kanji conversion program, an input method of Japanese.

- TODO: following programs have no guix package.
  It is better to write my own one for my reproducible system.
  + [ ] [[https://github.com/skk-dev/skktools][skktools]]
  + [ ] ibus-skk

*** derive unique entries in user-jisyo

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/skkdic_uniq.sh") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
  tmp_euc=$(mktemp)
  tmp_utf8=$(mktemp)
  skk_dir=<<share-dir()>>/skk
  skk_get_dir=${skk_dir}/get-jisyo
  dic_orig=${skk_dir}/jisyo
  dic_uniq=${skk_dir}/jisyo.uniq

  skkdic-expr2 ${skk_get_dir}/SKK-JISYO.* > ${tmp_euc}
  nkf -w -Lu ${tmp_euc} > ${tmp_utf8}
  skkdic-expr2 ${dic_orig} - ${tmp_utf8} > ${dic_uniq}

  rm -f ${tmp_euc}
  rm -f ${tmp_utf8}

  echo ${dic_uniq}
#+end_src
** Festival
:PROPERTIES:
:ID:       379230e4-dec0-4f96-becf-7d62159ff598
:END:

[[http://festvox.org/festival/][Festival]] is a framework for building and manipulating speech synthesis engine.

#+begin_src scheme :noweb-ref emacs-pkgs
  "festival"
#+end_src

- configuration
  #+begin_src scheme :noweb tangle :tangle (expand-file-name ".festivalrc")
    ;; -*- mode:scheme; -*-
    (Parameter.set 'Audio_Required_Format 'aiff)
    (Parameter.set 'Audio_Method 'Audio_Command)
    (Parameter.set 'Audio_Command "paplay $FILE --client-name=Festival --stream-name=Speech")

    ;; add SLT voice and use it as a default one
    (voice-location 'cmu_us_slt_cg
                    (path-as-directory "<<home-dir()>>/.local/share/festival/lib/voices/us/cmu_us_slt_cg")
                    "English American Female")
    (set! voice_default voice_cmu_us_slt_cg)
  #+end_src
- a script to download voices

  #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
    download-festival-voices
  #+end_src

  #+begin_src shell :tangle (expand-file-name ".local/bin/download-festival-voices") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
    work_dir=~/.local/share/festival
    voices=(
      cmu_us_aew_cg
      cmu_us_rxr_cg
      cmu_us_slt_cg
    )

    if [ ! -d "${work_dir}" ]; then
      mkdir -p "${work_dir}"
    fi

    cd "${work_dir}"
    for voice in "${voices[@]}"; do
      voice_pack_file=festvox_${voice}.tar.gz
      if [ ! -e ${voice_pack_file} ]; then
        wget -c http://festvox.org/packed/festival/2.5/voices/${voice_pack_file}
        tar zxf "${voice_pack_file}" -C ../../share
      fi
    done

    echo "${work_dir}"
  #+end_src
- festival.el

  #+begin_src emacs-lisp :noweb-ref additional-elisp
    (use-package festival
      :config
      (say-minor-mode 1)
      (setq festival-tmp-file (make-temp-file "festival-")))
  #+end_src
** Open JTalk
:PROPERTIES:
:ID:       ce99b0cf-dd07-4b9e-86b3-b492a8cfb354
:END:

#+name: hts-voice-dir
#+begin_src emacs-lisp :noweb yes
  (expand-file-name "~/.local/share/hts-voice")
#+end_src

- install on Ubuntu
  #+begin_src shell :noweb-ref apt-pkgs :noweb-sep " \\\n" :tangle no
    open-jtalk open-jtalk-mecab-naist-jdic hts-voice-nitech-jp-atr503-m001
  #+end_src
- download hts voices

  #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
    download-hts-voices
  #+end_src

  #+begin_src bash :noweb tangle :tangle (expand-file-name ".local/bin/download-hts-voices") :tangle-mode (identity #o755)
    data_dir=<<hts-voice-dir()>>
    hts_workdir=/tmp
    hts_fname=MMDAgent_Example-1.8.zip

    if [ ! -d "${data_dir}" ]; then
      mkdir -p "${data_dir}"
    fi

    cd "${hts_workdir}" \
      && curl -sLO http://sourceforge.net/projects/mmdagent/files/MMDAgent_Example/${hts_fname%.zip}/${hts_fname} \
      && unzip -o -d ${data_dir} ${hts_fname} \
      && ln -sfv ${data_dir}/${hts_fname%.zip}/Voice ${data_dir}/
  #+end_src

** Jack

#+begin_src scheme :noweb-ref desktop-pkgs
  "qjackctl"
  "qsynth"
  "jack-keyboard"
#+end_src

#+begin_src conf :tangle (expand-file-name ".jackdrc")
  /usr/bin/jackd -dalsa -dhw:0 -r44100 -p1024 -n3 -Xseq
#+end_src

** XRandR

XRandR is a command line utility for changing display options without restarting X server.

[[https://wiki.archlinux.org/title/xrandr][xrandr - ArchWiki]]

- show avaulable modes for all displays
  #+begin_src shell :results verbatim
    xrandr
  #+end_src

- change mode (resolution) to 1920x1080 for a display identified as "HDMI-2"
  #+begin_src shell
    xrandr --output HDMI-2 --mode 1920x1080
  #+end_src

- change mode back to preferred (maximum)
  #+begin_src shell
    xrandr --output HDMI-2 --auto
  #+end_src

#+begin_src scheme :noweb-ref desktop-pkgs
  "xrandr"
#+end_src
** C/Migemo
:PROPERTIES:
:ID:       9ac77d59-90bd-4054-89c9-dcab29bd7462
:END:

[[https://github.com/koron/cmigemo][C/Migemo]] allows me to search Japanese with incremental ASCII charactor input.

#+begin_src shell :noweb-ref apt-pkgs :noweb-sep " \\\n" :tangle no
  cmigemo
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/koron/cmigemo/releases.atom" soft_update)
#+end_src

If you are AZIK lover, replace /usr/share/cmigemo/utf-8/roma2hira.dat with the content below to activate AZIK key assign in migemo.

#+begin_src shell :noweb-ref ubuntu-setup :tangle no
  MIGEMO_DAT_SYSTEM_DIR=/usr/share/cmigemo/utf-8
  MIGEMO_DAT_LOCAL_DIR=~/.local/share/cmigemo/utf-8
  ROMA_2_HIRA=roma2hira.dat

  if [ -f "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
    (
      cd "${MIGEMO_DAT_SYSTEM_DIR}" \
         && sudo mv ${ROMA_2_HIRA} ${ROMA_2_HIRA}.orig
    )
  fi
  if [ -h "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
    sudo unlink "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}"
  fi
  sudo ln -s "${MIGEMO_DAT_LOCAL_DIR}/${ROMA_2_HIRA}" ${MIGEMO_DAT_SYSTEM_DIR}
#+end_src

#+begin_src text :tangle (expand-file-name ".local/share/cmigemo/utf-8/roma2hira.dat")
  # vi:set ts=8 sts=8 sw=8 tw=0:
  #
  # roma2hira.dat - ローマ字→平仮名変換表
  #
  # Last Change: 18-Oct-2003.
  # Written By:  Muraoka Taro  <koron@tka.att.ne.jp>

  # こいつをカスタマイズすることでローマ字の入力方式が変わります。
  # 現在はMS-IME2000を参考に決定しています。
  # 漢字コードの違いを吸収する役割も果たします。
  # xnとxtuには「ん」と「っ」を指定する役割があります。
  # {from} {to}の形式です。
  # 現在は{from}は最大7バイトまで{to}は6バイトまでとなっています。
  # {from}と{to}の間は空白文字(isspace())で区切ります。

  # http://asiamoth.com/mt/archives/2006-08/05_2313.php

  -	ー
  ~	〜
  ,	、
  .	。
  :	ー
  [	「
  ]	」
  ;	っ
  a	あ
  ba	ば
  bd	べん
  be	べ
  bh	ぶう
  bi	び
  bj	ぶん
  bk	びん
  bl	ぼん
  bn	ばん
  bo	ぼ
  bp	ぼう
  bq	ばい
  bt	びと
  bu	ぶ
  bv	びゅう
  bw	べい
  bx	びょう
  bya	びゃ
  byj	びゅん
  byo	びょ
  byp	びょう
  byu	びゅ
  bz	ばん
  ca	ちゃ
  cd	ちぇん
  ce	ちぇ
  cf	ちぇ
  ch	ちゅう
  ci	ち
  cj	ちゅん
  ck	ちん
  cl	ちょん
  cn	ちゃん
  co	ちょ
  cp	ちょう
  cq	ちゃい
  cu	ちゅ
  cz	ちゃん
  da	だ
  dch	どぅー
  dci	でぃ
  dcj	どぅん
  dck	でぃん
  dcu	どぅ
  dd	でん
  de	で
  df	で
  dga	ぢゃ
  dge	ぢぇ
  dgj	ぢゅん
  dgl	ぢょん
  dgo	ぢょ
  dgq	ぢゃい
  dgu	ぢゅ
  dgz	ぢゃん
  dh	づう
  di	ぢ
  dj	づん
  dk	ぢん
  dl	どん
  dm	でも
  dn	だん
  do	ど
  dp	どう
  dq	だい
  dr	である
  ds	です
  dt	だち
  du	づ
  dv	ぢゅう
  dw	でい
  dx	ぢょう
  dya	でゃ
  dyh	でゅー
  dyj	でゅん
  dyq	でゃい
  dyu	でゅ
  dyz	でゃん
  dz	だん
  e	え
  fa	ふぁ
  fd	ふぇん
  fe	ふぇ
  fh	ふう
  fi	ふぃ
  fj	ふん
  fk	ふぃん
  fl	ふぉん
  fn	ふぁん
  fo	ふぉ
  fq	ふぁい
  fu	ふ
  fv	ふゅー
  fw	ふぇい
  fyh	ふゅー
  fyj	ふゅん
  fyu	ふゅ
  fz	ふぁん
  ga	が
  gd	げん
  ge	げ
  gh	ぐう
  gi	ぎ
  gj	ぐん
  gk	ぎん
  gl	ごん
  gn	がん
  go	ご
  gp	ごう
  gq	がい
  gr	がら
  gt	ごと
  gu	ぐ
  gv	ぎゅう
  gw	げい
  gx	ぎょう
  gya	ぎゃ
  gyh	ぎゅう
  gyj	ぎゅん
  gyl	ぎょん
  gyo	ぎょ
  gyp	ぎょう
  gyq	ぎゃい
  gyu	ぎゅ
  gyz	ぎゃん
  gz	がん
  ha	は
  hd	へん
  he	へ
  hf	ふ
  hga	ひゃ
  hgd	ひぇん
  hge	ひぇ
  hgh	ひゅう
  hgj	ひゅん
  hgl	ひょん
  hgn	ひゃん
  hgo	ひょ
  hgp	ひょう
  hgq	ひゃい
  hgu	ひゅ
  hgz	ひゃん
  hh	ふう
  hi	ひ
  hj	ふん
  hk	ひん
  hl	ほん
  ho	ほ
  hp	ほう
  hq	はい
  ht	ひと
  hu	ふ
  hv	ひゅう
  hw	へい
  hx	ひょう
  hya	ひゃ
  hyd	ひぇん
  hye	ひぇ
  hyh	ひゅう
  hyj	ひゅん
  hyl	ひょん
  hyo	ひょ
  hyp	ひょう
  hyq	ひゃい
  hyu	ひゅ
  hyz	ひゃん
  hz	はん
  i	い
  ja	じゃ
  jd	じぇん
  je	じぇ
  jf	じゅ
  jh	じゅう
  ji	じ
  jj	じゅん
  jk	じん
  jl	じょん
  jo	じょ
  jp	じょう
  jq	じゃい
  ju	じゅ
  jw	じぇい
  jz	じゃん
  ka	か
  kd	けん
  ke	け
  kf	き
  kga	きゃ
  kgh	きゅう
  kgj	きゅん
  kgl	きょん
  kgn	きゃん
  kgo	きょ
  kgp	きょう
  kgq	きゃい
  kgu	きゅ
  kgz	きゃん
  kh	くう
  ki	き
  kj	くん
  kk	きん
  kl	こん
  km	かも
  kn	かん
  ko	こ
  kp	こう
  kq	かい
  kr	から
  kt	こと
  ku	く
  kv	きゅう
  kw	けい
  kx	きょう
  kya	きゃ
  kyh	きゅう
  kyj	きゅん
  kyl	きょん
  kyo	きょ
  kyp	きょう
  kyq	きゃい
  kyu	きゅ
  kyz	きゃん
  kz	かん
  la	ぁ
  le	ぇ
  li	ぃ
  lo	ぉ
  ltsu	っ
  ltu	っ
  lu	ぅ
  lwa	ゎ
  lya	ゃ
  lye	ぇ
  lyi	ぃ
  lyo	ょ
  lyu	ゅ
  ma	ま
  md	めん
  me	め
  mf	む
  mgn	みゃん
  mh	むう
  mi	み
  mj	むん
  mk	みん
  ml	もん
  mn	もの
  mo	も
  mp	もう
  mq	まい
  ms	ます
  mt	また
  mu	む
  mv	みゅう
  mw	めい
  mx	みょう
  mya	みゃ
  myh	みゅう
  myj	みゅん
  myl	みょん
  myo	みょ
  myp	みょう
  myq	みゃい
  myu	みゅ
  myz	みゃん
  mz	まん
  na	な
  nb	ねば
  nd	ねん
  ne	ね
  nf	ぬ
  nga	にゃ
  ngh	にゅう
  ngj	にゅん
  ngl	にょん
  ngn	にゃん
  ngo	にょ
  ngp	にょう
  ngq	にゃい
  ngu	にゅ
  ngz	にゃん
  nh	ぬう
  ni	に
  nj	ぬん
  nk	にん
  nl	のん
  nn	ん
  no	の
  np	のう
  nq	ない
  nr	なる
  nt	にち
  nu	ぬ
  nv	にゅう
  nw	ねい
  nx	にょう
  nya	にゃ
  nyh	にゅう
  nyj	にゅん
  nyl	にょん
  nyo	にょ
  nyp	にょう
  nyq	にゃい
  nyu	にゅ
  nyz	にゃん
  nz	なん
  o	お
  pa	ぱ
  pd	ぺん
  pe	ぺ
  pf	ぽん
  pga	ぴゃ
  pgh	ぴゅう
  pgj	ぴゅん
  pgl	ぴょん
  pgn	ぴゃん
  pgo	ぴょ
  pgp	ぴょう
  pgq	ぴゃい
  pgu	ぴゅ
  pgz	ぴゃん
  ph	ぷう
  pi	ぴ
  pj	ぷん
  pk	ぴん
  pl	ぽん
  po	ぽ
  pp	ぽう
  pq	ぱい
  pu	ぷ
  pv	ぴゅう
  pw	ぺい
  px	ぴょう
  pya	ぴゃ
  pyh	ぴゅう
  pyj	ぴゅん
  pyl	ぴょん
  pyo	ぴょ
  pyp	ぴょう
  pyq	ぴゃい
  pyu	ぴゅ
  pz	ぱん
  q	ん
  ra	ら
  rd	れん
  re	れ
  rh	るう
  ri	り
  rj	るん
  rk	りん
  rl	ろん
  rn	らん
  ro	ろ
  rp	ろう
  rq	らい
  rr	られ
  ru	る
  rv	りゅう
  rw	れい
  rx	りょう
  rya	りゃ
  ryh	りゅう
  ryj	りゅん
  ryl	りょん
  ryo	りょ
  ryp	りょう
  ryq	りゃい
  ryu	りゅ
  ryz	りゃん
  rz	らん
  sa	さ
  sd	せん
  se	せ
  sf	さい
  sh	すう
  si	し
  sj	すん
  sk	しん
  sl	そん
  sn	さん
  so	そ
  sp	そう
  sq	さい
  sr	する
  ss	せい
  st	した
  su	す
  sv	しゅう
  sw	せい
  sx	しょう
  syi	すぃ
  syk	すぃん
  sz	さん
  ta	た
  tb	たび
  td	てん
  te	て
  tgh	とぅー
  tgi	てぃ
  tgj	とぅん
  tgk	てぃん
  tgu	とぅ
  th	つう
  ti	ち
  tj	つん
  tk	ちん
  tl	とん
  tm	ため
  tn	たん
  to	と
  tp	とう
  tq	たい
  tr	たら
  tsa	つぁ
  tsd	つぇん
  tse	つぇ
  tsh	つう
  tsi	つぃ
  tsj	つん
  tsk	つぃん
  tsl	つぉん
  tso	つぉ
  tsq	つぁい
  tst	として
  tsu	つ
  tsz	つぁん
  tt	たち
  tu	つ
  tw	てい
  tya	てゃ
  tyh	てゅー
  tyj	てゅん
  tyq	てゃい
  tyu	てゅ
  tyz	てゃん
  tz	たん
  u	う
  va	う゛ぁ
  vd	う゛ぇん
  ve	う゛ぇ
  vh	う゛ー
  vi	う゛ぃ
  vj	う゛ん
  vk	う゛ぃん
  vl	う゛ぉん
  vn	う゛ぁん
  vo	う゛ぉ
  vp	う゛ぉう
  vq	う゛ぁい
  vu	う゛
  vv	う゛ゅー
  vw	う゛ぇい
  vyh	う゛ゅー
  vyj	う゛ゅん
  vyu	う゛ゅ
  vz	う゛ぁん
  wa	わ
  wd	うぇん
  we	うぇ
  wi	うぃ
  wk	うぃん
  wl	うぉん
  wn	わん
  wo	を
  wp	うぉー
  wq	わい
  wr	われ
  wse	ゑ
  wsi	ゐ
  wso	うぉ
  wt	わた
  ww	うぇい
  wz	わん
  xa	しゃ
  xd	しぇん
  xe	しぇ
  xh	しゅう
  xi	し
  xj	しゅん
  xk	しん
  xl	しょん
  xn	しゃん
  xo	しょ
  xp	しょう
  xq	しゃい
  xu	しゅ
  xw	しぇい
  xz	しゃん
  ya	や
  yd	いぇん
  ye	いぇ
  yf	ゆ
  yh	ゆう
  yj	ゆん
  yl	よん
  yo	よ
  yp	よう
  yq	やい
  yr	よる
  yu	ゆ
  yw	いぇい
  yz	やん
  za	ざ
  zc	ざ
  zd	ぜん
  ze	ぜ
  zh	ずう
  zi	じ
  zj	ずん
  zk	じん
  zl	ぞん
  zn	ざん
  zo	ぞ
  zp	ぞう
  zq	ざい
  zr	ざる
  zu	ず
  zv	ざい
  zw	ぜい
  zx	ぜい
  zyi	ずぃ
  zz	ざん
#+end_src
** LilyPond

[[https://lilypond.org/unix.html][LilyPond]] elisp package is included in source tarball available at [[https://lilypond.org/download/source][here]],
you are required to locate that package where emacs can search.

#+begin_src scheme :noweb-ref emacs-pkgs
  "lilypond"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
  ("https://github.com/lilypond/lilypond/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb-ref additional-elisp
  (use-package lilypond-mode
    :delight (LilyPond-mode " LP")
    :mode ("\\.ly$" . LilyPond-mode)
    :custom
    (LilyPond-pdf-command "firefox")
    (LilyPond-midi-command "fluidsynth -a alsa -m alsa_seq -l"))
#+end_src

** Graphviz
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 13:36]
:END:

Documentation is available at [[https://graphviz.org/documentation/][here]] and [[https://graphviz.org/gallery/][gallery]] is also useful.

#+begin_src scheme :tangle no :noweb-ref emacs-pkgs
  "graphviz"
  "emacs-graphviz-dot-mode"
#+end_src

#+begin_src emacs-lisp :noweb-ref additional-elisp
  (use-package graphviz-dot-mode
    :mode ("\\.\\(?:dot\\|gz\\)$" . graphviz-dot-mode))
#+end_src

** Rsync

#+begin_src scheme :noweb-ref base-pkgs
  "rsync"
#+end_src

*** sync server data

#+begin_src conf :noweb yes :noweb-ref cronjob-pc
  12 1 * * * /bin/bash -ci "sync_sv04 >> $LOG_DIR/sync_sv04.log 2>&1"
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/sync_sv04") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
  ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit 0" \
    && rsync -arhv sv04:~/var/backup <<share-dir()>>/sv04
#+end_src

*** backup script                             :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/back_rsync.sh")
  #!/usr/bin/env bash

  OPT="-aPh"
  LINK="--link-dest=../last/"
  DEST="ns01:~/data/share/backups"
  DATETIME=`date "+%Y%m%d-%H%M"`

  ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/data/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

  # take a snapshot for pc01
  # if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
  #   rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
  #   ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
  # else
  #   rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
  #   ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
  # fi

  # take a snapshot for sv04
  if mountpoint /mnt/sv04 >/dev/null 2>&1; then
    if ssh ns01 "[ -h ~/data/share/backups/sv04/last ]"; then
      rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
      ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
    else
      rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
      ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
    fi
  fi
 #+end_src

+ rsync exclude file for pc01
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
    + var
    + var/log
    + var/log/**
    - var/lib/dash
    + var/lib
    + var/lib/**
    + work
    + work/**
    + git
    + git/**
    - *
  #+end_src
+ rsync exclude file for sv04
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
    + var
    + var/backup
    + var/backup/**
    - *
  #+end_src
** libvirt

#+begin_src scheme :noweb-ref desktop-pkgs
  "libvirt"
  "virt-manager"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/libvirt/libvirt.conf")
  uri_default = "qemu:///system"
#+end_src

- how to set up local storage pool (named 'local')
  : $ virsh pool-define ~/.config/libvirt/pool.xml
  : $ virsh pool-autostart local
  : $ virsh pool-start local

  #+begin_src xml :noweb tangle :tangle (expand-file-name ".config/libvirt/pool.xml")
    <pool type='dir'>
      <name>local</name>
      <source>
      </source>
      <target>
        <path><<home-dir()>>/media/libvirt/images</path>
        <permissions>
          <mode>0711</mode>
          <owner>0</owner>
          <group>0</group>
        </permissions>
      </target>
    </pool>
#+end_src
** Calibre

[[https://calibre-ebook.com/download_linux][Calibre for linux]] is a e-book reader. I use it in the mood of reading epub in GUI app.

#+begin_src scheme :noweb-ref desktop-pkgs
  "calibre"
#+end_src

** yt-dlp
:PROPERTIES:
:CREATED:  [2022-08-19 Fri 08:06]
:END:

#+begin_src scheme :noweb-ref desktop-pkgs
  "yt-dlp"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/yt-dlp/config")
  -o %(title)s.%(ext)s
  --trim-filenames 80
#+end_src

** rTorrent
:PROPERTIES:
:CREATED:  [2022-10-05 Wed 15:26]
:ID:       bdc987ad-419b-4f36-922d-de75207d85c0
:END:

[[https://github.com/rakshasa/rtorrent/wiki][rTorrent]] is a bittorrent client using ncurses.

As of now, rTorrent on guix does not support for XMLRPC. You need to install from another source, if you want rTorrent with RPC capability.

# #+begin_src scheme :noweb-ref base-pkgs
#   "rtorrent"
# #+end_src

#+name: rtorrent-sock
#+begin_src emacs-lisp :eval no-export
  (expand-file-name "~/.local/share/rtorrent-rpc.socket")
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".rtorrent.rc")
  network.scgi.open_local = <<rtorrent-sock()>>
  execute.nothrow = chmod,770,<<rtorrent-sock()>>
  encoding.add = utf8
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
  systemctl --user enable rtorrent.service
  systemctl --user start rtorrent.service
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/user/rtorrent.service")
  [Unit]
  Description=rTorrent
  After=network.target

  [Service]
  Type=simple
  WorkingDirectory=<<home-dir()>>/data/media/torrent
  ExecStart=/bin/bash -ic 'rtorrent -o system.daemon.set=true'
  Restart=on-failure
  RestartSec=3

  [Install]
  WantedBy=default.target
#+end_src

** Ledger
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 20:55]
:END:

[[https://www.ledger-cli.org/3.0/doc/ledger-mode.html][Ledger]] is double-entry accounting cli tool. [[https://hledger.org/][hledger]] is feature rich reimplementation of ledger in Haskell. User data in ledger is interoperable for hledger and vice versa.

#+begin_src scheme :noweb-ref base-pkgs
  "ledger"
  "hledger"
#+end_src

** ripgrep-all
:PROPERTIES:
:CREATED:  [2022-10-26 Wed 10:39]
:END:

[[https://github.com/phiresky/ripgrep-all][ripgrep-all]] or rga command enables to search media files such as pdf documents or epub files in grep-like way.

#+begin_src shell :noweb yes :noweb-ref ubuntu-setup :tangle no
  rga_url=https://github.com/phiresky/ripgrep-all/releases/download/v0.9.6
  rga_fname=ripgrep_all-v0.9.6-x86_64-unknown-linux-musl.tar.gz
  rga_workdir=/tmp
  rga_lbinpath=<<home-dir()>>/.local/bin

  curl -sL "${rga_url}/${rga_fname}" | tar zxf - -C ${rga_workdir} \
    && cp -fv ${rga_workdir}/${rga_fname%.tar.gz}/{rga,rga-preproc} ${rga_lbinpath}
#+end_src

* Development Infrastructures
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:55]
:END:

** Python

#+begin_src scheme :noweb-ref base-pkgs
  "python"
  "python-sphinx"
  "python-lxml"
  "python-jedi"
  "python-send2trash"
  "python-matplotlib"
#+end_src

** Ruby

#+begin_src scheme :noweb-ref base-pkgs
  "ruby"
  "ruby-pry"
  "ruby-rubocop"
  "ruby-thor"
#+end_src

#+begin_src shell :noweb-ref bashrc
  export RUBYLIB=${HOME}/.local/lib

  # set path for ruby gems in local
  if which ruby >/dev/null && which gem >/dev/null; then
    PATH="$(ruby -r rubygems -e 'puts Gem.user_dir')/bin:$PATH"
  fi
#+end_src

** Node.js
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 13:52]
:END:

#+name: npm-prefix
#+begin_src shell :eval no-export
  echo ${HOME}/.npm-global
#+end_src

#+begin_src scheme :noweb-ref base-pkgs
  "node"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
  NODE_PATH="<<npm-prefix()>>/lib/node_modules:${NODE_PATH}"
  PATH="<<npm-prefix()>>/bin:${PATH}"
  MANPATH="<<npm-prefix()>>/share/man:${MANPATH}"
#+end_src

#+begin_src shell :noweb yes :tangle (expand-file-name ".npmrc")
  prefix=<<npm-prefix()>>
#+end_src

- make a directory for global npm packages
  #+begin_src shell :tangle no :noweb yes
    mkdir -pv <<npm-prefix()>>
  #+end_src

** asdf-vm                                     :ARCHIVE:
Extendable version manager
- call for init script in bashrc
  #+begin_src shell
    . $HOME/.asdf/asdf.sh
    . $HOME/.asdf/completions/asdf.bash

    export RUBYLIB=${RUBYLIB}:${HOME}/.local/lib
  #+end_src
- define versions
  #+begin_src conf :comments noweb :tangle (expand-file-name ".tool-versions")
    ruby 2.6.8
    python 3.8.5
  #+end_src

  steps to install tools for specific versions
  1. install plugins
     : $ asdf plugin add ruby
     : $ asdf plugin add python

  2. install tools
     : $ cd ~ && asdf install

*** asdf-ruby
#+begin_src conf :comments noweb :tangle (expand-file-name ".default-gems")
  thor 1.2.1
  pry 0.14.1
  rubocop 1.26
  exifr 1.2.6
  streamio-ffmpeg
#+end_src
*** asdf-python
#+begin_src python :tangle (expand-file-name ".default-python-packages")
  lxml
  jedi
  ical2orgpy
  Send2Trash
#+end_src
** Tree Sitter
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:55]
:END:

#+begin_src scheme :noweb-ref devel-pkgs
  "tree-sitter"
#+end_src

** Language Servers

*** Bash Language Server
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:49]
:END:

[[https://github.com/bash-lsp/bash-language-server][Bash Language Server]]

- how to install
  : $ npm install -g bash-language-server

*** Solargraph
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:16]
:END:

[[https://github.com/castwide/solargraph][Solargraph]] is Ruby Language Server.

#+begin_src scheme :noweb-ref devel-pkgs
  "ruby-solargraph"
#+end_src

* Utility Scripts
:PROPERTIES:
:header-args+: :tangle-mode (identity #o755)
:END:

** Declutters                                  :ARCHIVE:

These scripts (declutter_xxx) keep things decluttered.

- trash
  #+begin_src conf
    0 2 * * * /bin/bash -ci "declutter_trash >> $LOG_DIR/declutter_trash.log 2>&1"
  #+end_src

  #+begin_src python :noweb yes :tangle no
    #!/usr/bin/env python3

    import os
    import time
    import datetime
    import shutil
    import glob
    from send2trash import send2trash

    TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
    TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                       list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                       + glob.glob(os.path.join(os.environ['HOME'], 'tmp/*')))

    MAX_STAY_DAYS_IN_TRASH = 7
    MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    def humansize(nbytes):
        i = 0
        while nbytes >= 1024 and i < len(suffixes)-1:
            nbytes /= 1024.
            i += 1
        f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
        return '%s %s' % (f, suffixes[i])

    def get_size(start_path = '.'):
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(start_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                # skip if it is symbolic link
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)

        return total_size

    print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                       datetime.datetime.now()))

    NOW = time.time()

    print('--{0} starts to move files neglected more than {1} days to trash box.\n'
          .format(os.path.basename(__file__),
                  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

    tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
    for a_file in [item for sublist in tidyup_lists for item in sublist]:
        atime = os.lstat(a_file).st_atime
        delta_atime = datetime.timedelta(seconds=(NOW - atime))
        if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
            try:
                send2trash(a_file)
            except OSError as error:
                print(error)
            else:
                print('moveed to trash: {}'.format(a_file))

    print('--{0} starts to remove files staying more than {1} days in trash box.'
          .format(os.path.basename(__file__),
                  MAX_STAY_DAYS_IN_TRASH))

    rbytes_total = 0
    for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
        lstat = os.lstat(trash_file)
        delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
        if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
            method = 'removed'
            fname = os.path.basename(trash_file)
            if os.path.islink(trash_file):
                method = 'unlinked'
                fsize = 'N/A'
                os.unlink(trash_file)
            elif os.path.isfile(trash_file):
                rbytes = os.path.getsize(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                os.remove(trash_file)
            elif os.path.isdir(trash_file):
                rbytes = get_size(trash_file)
                rbytes_total += rbytes
                fsize = humansize(rbytes)
                fname += '/'
                shutil.rmtree(trash_file)
            print('{}: [{:>9}] {}'.format(method, fsize, fname))

    print('--{0} removes [{1}] in total.\n'
          .format(os.path.basename(__file__),
                  humansize(rbytes_total)))

    print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))
#+end_src
- home directory (ruby implementation)
  #+begin_src ruby :tangle no
    #!/usr/bin/env ruby
    # coding: utf-8

    TRASHES = ["*~", "#*#", ".#*#", "._*", ".DS_Store"]

    class Sweep
      def self.sweep(base_dir)
        puts base_dir
        TRASHES.each do |trash|
          tfiles = File.join("%s/**" % base_dir, trash)
          Dir.glob(tfiles).each do |f|
            if File.delete(f) > 0
              puts "Removed: " + f
            else
              puts "CANNOT Removed: " + f
            end
          end
        end
      end
    end

    ARGV.each do |arg|
      if Dir.exist?(arg) then
        Sweep.sweep(arg)
      end
    end
  #+end_src
- home directory (python implementation)
  #+begin_src python :tangle no
    #!/usr/bin/env python3

    import sys
    import os
    import glob
    import argparse

    TRASH_REGEXPS = ["*~", "#*", ".#*", "._*", ".DS_Store", "*.dvi", "*.aux", "*.bbl"]

    class Sweepy:
        @classmethod
        def sweep_with_regexp(self, base_dir, recursive=False):
            for trash_regexp in TRASH_REGEXPS:
                files = glob.glob("%s/**/" % base_dir + trash_regexp, recursive=recursive)
                for file in files:
                    if os.path.isfile(file):
                        os.remove(file)
                        print("Removed: " + file)
        @classmethod
        def sweep_broken_symlink(self, base_dir, recursive=False):
            files = glob.glob("%s/*" % base_dir, recursive=recursive)
            dotfiles = glob.glob("%s/.*" % base_dir, recursive=recursive)
            for file in (files + dotfiles):
                if os.path.islink(file):
                    if not os.path.exists(os.readlink(file)):
                        os.unlink(file)
                        print("Unlinked: " + file)

    parser = argparse.ArgumentParser(description='Removes all desired files')
    parser.add_argument('dir', metavar='dir', nargs='?', action='store',
                        help='base directory to search')
    parser.add_argument('-r', dest='recursive', action="store_true", default=False)
    args = parser.parse_args()
    if args.recursive:
        Sweepy.sweep_with_regexp(args.dir, recursive=True)
        Sweepy.sweep_broken_symlink(args.dir, recursive=True)
    else:
        Sweepy.sweep_with_regexp(args.dir, recursive=False)
        Sweepy.sweep_broken_symlink(args.dir, recursive=False)
  #+end_src

** Database back-up scripts
- PostgreSQL
  #+begin_src bash :tangle (expand-file-name ".local/bin/postgres_backup")
    #!/usr/bin/env bash

    # Usage: $ postgres_backup <db_name> <backup_dir>

    POSTGRES_DBNAME=$1
    BACKUP_DIR=$2
    DATE="$(date +%Y%m%d_%H%M)"

    pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

    exit 0
  #+end_src

- MySQL
  #+begin_src shell :tangle (expand-file-name ".local/bin/mysql_backup")
    #!/usr/bin/env bash

    BACKUP_DIR=~/data/share/backups/mysql
    RAW_SQL="$(date +%Y%m%d_%H%M)_backup.sql"
    TAR_SQL="${RAW_SQL}.txz"

    (
      cd "${BACKUP_DIR}" || exit 1
      mysqldump --opt --all-databases --events --default-character-set=binary -u root > "${RAW_SQL}"
      tar cfJ "${TAR_SQL}" "${RAW_SQL}"
      rm -f "${RAW_SQL}"
    ) || exit 1

    exit 0
  #+end_src

** filetype

This program determine type of the file.

#+begin_src ruby :tangle (expand-file-name ".local/lib/filetype.rb")
  #!/usr/bin/env ruby

  require 'pathname'
  require 'uri'
  require 'shellwords'

  class FileType
    ZIP_PREFIXES = ['Zip archive data']

    def self.type(filename, file_cmd_opt = "")
      if  File.exists?(filename)
        local_opt = ""
        if File.symlink?(filename)
          local_opt += "--dereference"
        end
        `file --brief #{file_cmd_opt} #{local_opt} #{Shellwords.shellescape(filename)}`.strip
      elsif filename =~ /https?:\/\/www\.youtube\.com.*/
        `yt-dlp -f worst -q #{Shellwords.shellescape(filename)} -o - 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      elsif filename =~ URI::DEFAULT_PARSER.make_regexp
        `curl --location --range 0-9999 #{Shellwords.shellescape(filename)} 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
      else
        ''
      end
    end

    def self.mime_type(filename)
      type(filename, "--mime-type")
    end

    def self.block_device?(file)
      type(file).start_with?('block special') &&
        mime_type(file) == 'inode/blockdevice'
    end

    def self.iso9660?(file)
      mime_type(file) == 'application/x-iso9660-image'
    end

    def self.video_dvd_image?(file)
      iso9660?(file) && type(file).start_with?('UDF filesystem data')
    end

    def self.html?(file)
      type(file).start_with?("HTML document")
    end

    def self.pdf?(file)
      type(file).start_with?("PDF document")
    end

    def self.epub?(file)
      type(file) == "EPUB document"
    end

    def self.mobi?(file)
      type(file).start_with?("Mobipocket E-book")
    end

    def self.pgp?(file)
      type(file).start_with?("PGP")
    end

    def self.tarpgp?(file)
      pgp?(file) && file.end_with?('.tar.gpg')
    end

    def self.zip?(file)
      type(file).start_with?(*ZIP_PREFIXES)
    end

    def self.video?(file)
      mime_type(file).start_with?("video/")
    end

    def self.audio?(file)
      mime_type(file).start_with?('audio/')
    end

    def self.image?(file)
      mime_type(file).start_with?("image/")
    end

    def self.playable?(file)
      if File.directory?(file)
        Dir.foreach(file) do |fname|
          next if [".", ".."].include?(fname)
          return false unless playable?("#{file}/#{fname}")
        end
        true
      elsif file =~ /https?:\/\/www\.youtube\.com.*/
        true
      else
        type(file).start_with?("ISO Media", "Audio file") ||
          mime_type(file).start_with?("video", "audio", "image")
      end
    end

    def self.dvd_dir?(file)
      false unless mime_type(file) == 'inode/directory'
      File.exist?(Pathname.new(file).join("VIDEO_TS")) ||
        File.exist?(Pathname.new(file).join("video_ts"))
    end
  end
#+end_src
** mediautil

Utility ruby program for manipulating image, audio and video file.

#+begin_src scheme :noweb-ref desktop-pkgs
  "dvd+rw-tools"
#+end_src

#+begin_src ruby :tangle (expand-file-name ".local/bin/mediautil")
  #!/usr/bin/env ruby

  require 'thor'
  require 'open3'
  require 'fileutils'
  require 'tempfile'
  require 'tmpdir'

  require 'filetype'

  class MediaUtil < Thor
    OUTFILE_SUFFIX = "_out"
    DEFAULT_VIDEO_EXT = ".mkv"

    class Names < Struct.new(:in_f, :out_f)
      def in_file()
        in_f
      end
      def out_file(extension = nil)
        if out_f
          out_f
        else
          bn = File.basename(in_f, ".*").gsub(/ /, '_')
          ext = ((extension) ? extension : File.extname(in_file))
          default_out = bn + ext
          if File.file?(default_out)
            10.times do |i|
              try_name = bn + "_" + (i+1).to_s + ext
              unless File.file?(try_name)
                return try_name
              end
            end
          end
          default_out
        end
      end
      def title()
        File.basename(out_file, ".*")
      end
    end
    class Commander < Struct.new(:log, :dry)
      def execute(command)
        if dry
          puts command
        else
          log_str, s_code = Open3.capture2e(command)
          if log
            user_cmd = caller.first.scan(/`(.*)'/).flatten.first.to_s
            log_fname = Time.now.strftime("%Y%m%d_%H%M%S_") + user_cmd + ".log"
            File.open(log_fname, "w") do |f|
              f.puts(log_str)
            end
          else
            puts log_str
          end
          exit false unless s_code.success?
          # exit false
        end
      end
    end

    class_option :log, aliases: "L", :type => :boolean,
                 :desc => "log stdout and stderr instead they reveal in terminal"
    class_option :dryrun, aliases: "D", :type => :boolean

    desc "info <file>", "show information about the video file or DVD directory"
    option :short, aliases: "s", :type => :boolean
    def info(target)
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(target) || FileType.audio?(target)
        commander.execute("ffprobe \"#{target}\" -hide_banner -show_entries format")
      elsif FileType.image?(target)
        if options[:short]
          commander.execute("identify #{target}")
        else
          commander.execute("identify -verbose #{target}")
        end
      elsif FileType.block_device?(target) ||
            FileType.video_dvd_image?(target) ||
            FileType.dvd_dir?(target)
        commander.execute("HandBrakeCLI -i \"#{target}\" --title 0")
      else
        STDERR.puts "Unknown Media Format"
        exit false
      end
    end

    default_command :encode
    desc "encode", "encode video file"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :vencoder, aliases: "e", :type => :string,
           :banner => "libx265|libx264",
           :desc => "video encoder"
    option :vquality, aliases: "q", :type => :string,
           :banner => "24.0",
           :desc => "video encoding quality"
    option :vbitrate, aliases: "b", :type => :string,
           :banner => "1000",
           :desc => "video encoding bitrate in kbps"
    option :aencoder, aliases: "E", :type => :string,
           :banner => "fdk_aac",
           :desc => "audio encoder"
    option :aquality, aliases: "Q", :type => :string,
           :banner => "100.0",
           :desc => "audio encoding quality"
    option :abitrate, aliases: "B", :type => :string,
           :banner => "128",
           :desc => "audio encoding bitrate in kbps"
    option :display, aliases: "d", :type => :string,
           :banner => "1920:1080",
           :desc => 'display (width:height) in which encoded video fit'
    option :fps, aliases: "f", :type => :string,
           :banner => "30",
           :desc => 'max frame rate'
    option :ffmpeg, :type => :string
    def encode()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      vconf = aconf = pconf = nil
      if options[:vencoder] || options[:vquality]
        vconf = VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
      end
      if options[:aencoder] || options[:aquality]
        aconf = AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
      end
      if options[:display] || options[:fps]
        pconf = PictureConfig.new
        pconf.fit_size(options[:display]) if options[:display]
        pconf.decrease_framerate(options[:fps]) if options[:fps]
      end

      if FileType.video?(equip.in_file) then
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                         [FFMPEGOptSet.new(equip.out_file, [vconf, aconf, pconf, "-map_metadata 0", options[:ffmpeg]])]))
      elsif FileType.audio?(equip.in_file) then
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                         [FFMPEGOptSet.new(equip.out_file, [aconf])]))
      elsif FileType.image?(equip.in_file) then
        pconf = ImageConfig.new
        commander.execute(ImageMagick.command(equip.in_file,
                                              equip.out_file,
                                              pconf))
      else
        STDERR.puts "Unknown Media Format"
        exit false
      end
    end

    desc 'cdencode', 'rip and encode CD contents'
    option :device, aliases: 'd', :type => :string,
           :desc => 'Device file'
    option :format, aliases: 'f', :type => :string,
           :banner => 'flac,ogg,m4a', :default => 'flac:-8',
           :desc => 'formats with additinal argument like compression level'
    def cdencode()
      commander = Commander.new(options[:log], options[:dryrun])

      abcde_args = []
      abcde_args << "-d #{options[:device]}" if options[:device]
      abcde_args << '-a default'
      if options[:format] then
        abcde_args << "-o '#{options[:format]}'"
      end
      abcde_args << '-G' # getalbumart
      abcde_args << '-x' # Eject CD

      commander.execute("abcde #{abcde_args.join(' ')}")
    end

    desc 'dvdrip', 'rip(backup) DVD contents'
    option :device, aliases: 'd', :type => :string,
           :desc => 'DVD device file'
    option :out, aliases: 'o', :type => :string,
           :desc => 'output directory name'
    option :name, aliases: 'n', :type => :string,
           :desc => 'root directory name of backup data'
    def dvdrip()
      commander = Commander.new(options[:log], options[:dryrun])

      dvdbackup_opts = ['dvdbackup']
      dvdbackup_opts << '--input=%s' % options[:device] if options[:device]
      dvdbackup_opts << '--output=%s' % options[:out] if options[:out]
      dvdbackup_opts << '--name=%s' % options[:name] if options[:name]
      dvdbackup_opts << '--mirror'
      dvdbackup_opts << '--progress'
      dvdbackup_opts << '--verbose'

      commander.execute(dvdbackup_opts.join(' '))
    end

    desc 'dvdencode', 'encode DVD contents'
    option :in, aliases: 'i', :type => :string, :required => true,
           :desc => 'input source, DVD device file or backuped DVD file'
    option :out, aliases: 'o', :type => :string,
           :desc => 'output directory name'
    option :vencoder, aliases: "e", :type => :string,
           :banner => "x265|x264",
           :desc => "video encoder"
    option :vquality, aliases: "q", :type => :string,
           :banner => "24.0",
           :desc => "video encoding quality"
    option :vbitrate, aliases: "b", :type => :string,
           :banner => "1000",
           :desc => "video bitrate in kbps"
    option :aencoder, aliases: "E", :type => :string,
           :banner => "fdk_aac",
           :desc => "audio encoder"
    option :aquality, aliases: "Q", :type => :string,
           :banner => "100.0",
           :desc => "audio encoding quality"
    option :abitrate, aliases: "B", :type => :string,
           :banner => "128",
           :desc => "audio bitrate in kbps"
    option :title, aliases: 't', :type => :string,
           :banner => '1|2|3|...',
           :desc => 'title number'
    option :chapters, aliases: 'c', :type => :string,
           :banner => '1|1-3|1,3,5|...',
           :desc => 'chapter numbers'
    option :audio, aliases: 'a', :type => :string,
           :banner => '1,2,3',
           :desc => 'audio channel'
    option :subtitle, aliases: 's', :type => :string,
           :banner => '1,2',
           :desc => 'subtitle channel'
    option :handbrake, :type => :string,
           :banner => '--handbrake \"--mixdown 5point1,stereo\"',
           :desc => 'HandBrakeCLI options'
    def dvdencode()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.block_device?(equip.in_file) ||
         FileType.video_dvd_image?(equip.in_file) ||
         FileType.dvd_dir?(equip.in_file)
        configs = []
        configs << VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
        configs << AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
        dconf = DVDConfig.new
        dconf.title = options[:title] if options[:title]
        dconf.chapters = options[:chapters] if options[:chapters]
        dconf.audio = options[:audio] if options[:audio]
        dconf.subtitle = options[:subtitle] if options[:subtitle]
        configs << dconf
        commander.execute(HandBrakeCLI.command(equip.in_file,
                                               equip.out_file(DEFAULT_VIDEO_EXT),
                                               configs,
                                               options[:handbrake]))
      end
    end

    desc 'mount <dir>', 'Mount CD/DVD media to dir.'
    option :device, aliases: "d", :type => :string, :required => true,
           :desc => 'device or iso file to mount',
           :banner => '--mount /dev/dvd|image.iso'
    option :type, aliases: 't', :type => :string,
           :desc => 'mount DVD-Video',
           :banner => '--type data|video'
    def mount(dir)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['mount']
      if options[:type] == 'video' || FileType.video_dvd_image?(options[:device])
        cmd_opts << ['-t', 'iso9660', '-o', 'loop']
      end
      cmd_opts << options[:device]
      cmd_opts << dir

      Dir.mkdir(dir) if !Dir.exist?(dir) && !options[:dryrun]
      commander.execute("sudo #{cmd_opts.join(' ')}")
    end

    desc 'umount', 'unmount dir'
    option :remove, aliases: 'r', :type => :boolean,
           :desc => 'remove dir after unmounting'
    def umount(dir)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['umount']
      cmd_opts << dir

      commander.execute("sudo #{cmd_opts.join(' ')}")

      if options[:remove]
        FileUtils.rmdir(dir)
      end
    end

    desc 'mkiso', 'make ISO image file.'
    option :type, aliases: 't', :type => :string, :required => true,
           :desc => 'DVD image type. Data or Video DVD.',
           :banner => '--type data|video'
    option :volume, aliases: 'V', :type => :string,
           :desc => 'Volume Label'
    option :out, aliases: 'o', :type => :string,
           :desc => 'ISO image file name.',
           :banner => '--out movie.iso'
    def mkiso(file)
      names = Names.new(file, options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      mkisofs_opts = ['mkisofs']
      mkisofs_opts << ["-V", "\"#{options[:volume]}\""] if options[:volume]
      if options[:type] == "data"
        mkisofs_opts << ["-r", "-l", "-J"]
      elsif options[:type]
        mkisofs_opts << "-dvd-video"
      else
        exit 1
      end
      mkisofs_opts << ["-o", "\"#{names.out_file('.iso')}\""]
      mkisofs_opts << "\"#{file}\""

      commander.execute(mkisofs_opts.join(" "))
    end

    desc 'dvdburn <file>', 'Burn file to DVD.'
    option :iso, aliases: 'I', :type => :boolean,
           :desc => 'Set this option if <file> is ISO 9660 compliant.'
    option :volume, aliases: 'V', :type => :string, :default => 'DVD_VIDEO',
           :desc => 'Volume Label'
    option :video, aliases: 'v', :type => :boolean,
           :desc => 'Create DVD video image file to burn.'
    option :speed, aliases: 's', :type => :string, :default => '4',
           :desc => 'Burning Speed',
           :banner => 'n'
    option :device, aliases: 'd', :type => :string,
           :desc => 'Device file', :default => '/dev/sr0'
    def dvdburn(file)
      commander = Commander.new(options[:log], options[:dryrun])

      cmd_opts = ['growisofs']
      cmd_opts << '-dvd-compat'
      cmd_opts << '-speed=%s' % options[:speed]
      if FileType.iso9660?(file) || options[:iso]
        cmd_opts << '-Z %s=%s' % [options[:device], file]
      else
        cmd_opts << '-Z %s' % options[:device]
        mkisofs_opts = []
        mkisofs_opts << ['-V', "\"#{options[:volume]}\""] if options[:volume]
        if options[:video]
          mkisofs_opts << '-dvd-video'
        else # Data-DVD
          mkisofs_opts << ['-r', '-l', '-R']
        end
        mkisofs_opts << file
        cmd_opts << mkisofs_opts
      end

      commander.execute(cmd_opts.join(' '))
    end

    desc "cdburn", "burn files to CD device"
    option :in, aliases: "i", :type => :string, :required => true,
           :desc => "Root Directory for image file"
    option :volume, aliases: "v", :type => :string, :required => true,
           :desc => "Volume ID"
    option :device, aliases: "d", :type => :string,
           :desc => "Device file", :default => "/dev/sr0"
    def cdburn()
      commander = Commander.new(options[:log], options[:dryrun])

      commander.execute("mkisofs -V \"#{options[:volume]}\" -J -r #{options[:in]} | cdrecord -v dev=#{options[:device]} -waiti -")
    end

    desc "screenshot", "take a screenshot of a video at a time"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :time, aliases: "t", :type => :string,
           :desc => "ex. 00:10:22.300"
    def screenshot()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])
      if FileType.video?(equip.in_file) then
        args = ['ffmpeg']
        args << ('-ss %s' % options[:time]) if options[:time]
        args << '-i %s' % equip.in_file
        args << '-vframes 1'
        args << '-q:v 2'
        args << equip.out_file('.jpg')
        commander.execute(args.join(' '))
      end
    end

    desc "clip", "clip a video with specific time span"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :time_begin, aliases: "b", :type => :string,
           :desc => "ex. 00:10:22.300"
    option :time_end, aliases: "e", :type => :string
    def clip()
      equip = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(equip.in_file) then
        if options[:time_begin] or options[:time_end] then
          in_opts = []
          in_opts << "-ss #{options[:time_begin]}" if options[:time_begin]
          in_opts << "-to #{options[:time_end]}" if options[:time_end]
          out_opts = []
          out_opts << "-vcodec copy"
          out_opts << "-acodec copy"
          out_opts << "-map_metadata 0"
          commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, in_opts)],
                                           [FFMPEGOptSet.new(equip.out_file, out_opts)]))
        end
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "crop", "extract a specific rectangle of a image/video"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :width, aliases: "w", :type => :numeric, :required => true
    option :height, aliases: "h", :type => :numeric, :required => true
    option :xpos, aliases: "x", :type => :numeric,
           :desc => "x coordinate of an original image where cropped image of top-left corner overlaps"
    option :ypos, aliases: "y", :type => :numeric
    def crop()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      width = options[:width]
      height = options[:height]
      xpos = options[:xpos] ? options[:xpos] : 0
      ypos = options[:ypos] ? options[:ypos] : 0
      if FileType.image?(names.in_file) then
        opt = '-crop %dx%d+%dx%d' % [width, height, xpos, ypos]
        commander.execute("convert #{opt} #{names.in_file} #{names.out_file}")
      elsif FileType.video?(names.in_file) then
        args = ['ffmpeg']
        args << '-i %s' % names.in_file
        args << '-vf crop=%d:%d:%d:%d' % [width, height, xpos, ypos]
        args << "-map_metadata 0"
        args << names.out_file
        commander.execute(args.join(' '))
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "trim", "trim a image/video with automated detection"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :threshold, aliases: "t", :type => :string,
           :desc => "threshold where trimming begin and end"
    def trim()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.image?(names.in_file) then
        commander.execute("convert -trim #{names.in_file} #{names.out_file}")
      elsif FileType.audio?(names.in_file) then
        threshold = (options[:threshold]) ? options[:threshold] : "-40dB"
        commander.execute("ffmpeg -i #{names.in_file} -af \"silenceremove=start_periods=1:start_duration=0:start_threshold=#{threshold}:detection=peak\" #{names.out_file}")
      end
    end

    desc "resize", "resize the image"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    option :width, aliases: "w", :type => :string,
           :banner => "e.g. 300",
           :desc => "resized image width"
    option :height, aliases: "h", :type => :string,
           :banner => "e.g. 200",
           :desc => "resized image height"
    option :operation, aliases: "p", :type => :string,
           :banner => "enlarge|shrink",
           :desc => "permitted operation for resizing"
    def resize()
      names = Names.new(options[:in], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      if FileType.video?(names.in_file) then
        if options[:width] and options[:height]
          out_opts = []
          out_opts << format("-vf scale=%s:%s,setsar=1:1", options[:width], options[:height])
          commander.execute(FFMPEG.command([FFMPEGOptSet.new(names.in_file, [])],
                                           [FFMPEGOptSet.new(names.out_file, out_opts)]))
        end
      elsif FileType.image?(names.in_file) then
        return if options[:width] == nil && options[:height] == nil
        if options[:operation] == "enlarge"
          op = "<"
        elsif options[:operation] == "shrink"
          op = ">"
        else
          op = ""
        end
        geometry = format("%sx%s%s", options[:width], options[:height], op)
        commander.execute("convert -resize #{geometry} #{names.in_file} #{names.out_file}")
      end
    end

    desc "concat", "concat multiple files"
    option :in, aliases: "i", :type => :array, :required => true
    option :out, aliases: "o", :type => :string
    def concat()
      names = Names.new(options[:in][0], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      srcs = options[:in]
      output = names.out_file

      if srcs.all? { |src| FileType.video?(src) }
        src_list = ""
        src_file = Tempfile.open()
        chap_file = Tempfile.open()
        chap_file.write("### Create Chapterfile ###\n")
        files_to_remove = []
        time_accumulated = Time.new(0)
        srcs.each_with_index do |src, index|
          valid_src =
            if src =~ /^\p{Ascii}+$/
              src
            else
              Dir::Tmpname.create('base') do |src_dup|
                FileUtils.cp(src, src_dup)
                files_to_remove << src_dup
                src_dup
              end
            end
          src_file.write("file '#{File.expand_path(valid_src)}'\n")
          chap_file.write("CHAPTER#{index + 1}=#{time_accumulated.strftime('%H:%M:%S.%L')}\n")
          chap_file.write("CHAPTER#{index + 1}NAME=#{File.basename(src, File.extname(src))}\n")
          duration = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "#{src}"`.strip().to_f()
          time_accumulated += duration
        end
        src_file.flush
        commander.execute("ffmpeg -n -f concat -safe 0 -i #{src_file.path} -c:v copy -c:a copy -c:s copy -map 0:v -map 0:a -map 0:s? #{output}")
        src_file.close
        chap_file.flush
        commander.execute("MP4Box -chap #{chap_file.path} #{output}")
        chap_file.close
        src_file.unlink
        chap_file.unlink
        FileUtils.rm_f(files_to_remove)
      elsif srcs.all? { |src| FileType.image?(src) }
        commander.execute "convert #{srcs.join(' ')} #{output}"
      else
        STDERR.puts "This Media Format is not supported on this function"
        exit false
      end
    end

    desc "diff", "measure the difference by providing SSIM value"
    option :out, aliases: "o", :type => :string
    def diff(file1, file2)
      commander = Commander.new(options[:log], options[:dryrun])

      if ((FileType.video?(file1) and FileType.video?(file2)) or
          (FileType.image?(file1) and FileType.image?(file2))) then
        if options[:out] then
          commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim=#{options[:out]} -an -f null -")
        else
          commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim -an -f null -")
        end
      end
    end

    desc "mux", "mux to one file which has streams correspond with input files"
    option :video, aliases: "v", :type => :string, :required => true
    option :audio, aliases: "a", :type => :string, :required => true
    option :audio_delay, aliases: "d", :type => :string
    option :out, aliases: "o", :type => :string
    def mux()
      names = Names.new(options[:video], options[:out])
      commander = Commander.new(options[:log], options[:dryrun])

      in_optsets = []
      in_optsets << FFMPEGOptSet.new(options[:video], [])
      aconf = []
      aconf << "-itsoffset #{options[:audio_delay]}" if options[:audio_delay]
      in_optsets << FFMPEGOptSet.new(options[:audio], aconf)
      commander.execute(FFMPEG.command(in_optsets,
                                       [FFMPEGOptSet.new(names.out_file, [])]))
    end
  end

  class MainConfig
    attr_accessor :start, :end
  end

  class VideoConfig
    attr_accessor :encode, :quality, :bitrate, :preset, :tune, :profile, :level

    DEFAULT_ENCODE = 'vp9'
    DEFAULT_QUALITY = '26'
    DEFAULT_BITRATE = '1000'

    def initialize(encode, quality=nil, bitrate=nil)
      @encode = encode
      @quality = quality
      @bitrate = bitrate

      case @encode
      when "x265"
        @preset = "veryslow"
        @tune = "ssim"
        @profile = "main"
        @level = nil
      when "x264"
        @preset = "veryslow"
        @tune = "film"
        @profile = "main"
        @level = "4.1"
      end
    end
  end

  class PictureConfig
    # conversion options
    attr_accessor :vf_opts, :fps

    def initialize()
      @vf_opts = []
      @vf_opts << "format=yuv420p"
    end

    # down-size to fit to display (width:heigh) in keeping aspect ratio
    def fit_size(display_size)
      @vf_opts << "scale=#{display_size}:force_original_aspect_ratio=decrease"
      @vf_opts << "pad=((iw+1)/2)*2:((ih+1)/2)*2" # avoid width/height to odd
    end

    def decrease_framerate(fps)
      @fps = fps
    end
  end

  class AudioConfig
    attr_accessor :encode, :quality, :bitrate

    DEFAULT_ENCODE = 'opus'
    DEFAULT_QUALITY = '100'
    DEFAULT_BITRATE = '128'

    def initialize(encode, quality=nil, bitrate=nil)
      # @encode = (encode ? encode : DEFAULT_ENCODE)
      @encode = encode
      @quality = quality
      @bitrate = bitrate
    end

    def quality
      case @encode
      when 'opus'
      else
        @quality
      end
    end

    def bitrate
      case @encode
      when 'opus'
        (@bitrate ? @bitrate : DEFAULT_BITRATE)
      else
        @bitrate
      end
    end
  end

  class DVDConfig
    attr_accessor :title, :chapters, :audio, :subtitle, :options
    attr_accessor :chapter_marker

    def initialize
      @chapter_marker = true
    end
  end

  class ImageConfig
    attr_reader :quality # 1~100
  end

  class FFMPEGOptSet < Struct.new(:fname, :optset)
  end

  class FFMPEG
    def self.command(in_optsets, out_optsets)
      opts = ["ffmpeg"]

      infilep = proc do |fname, optset|
        opt_arr = []
        optset.each do |opt|
          if opt.instance_of?(String)
            opt_arr << opt
          end
        end
        opt_arr << ["-i", "\"#{fname}\""]
        next opt_arr
      end
      in_optsets.each do |in_optset|
        opts << infilep.call(in_optset.fname, in_optset.optset)
      end

      outfilep = proc do |fname, optset|
        oopts = []
        optset.each do |opt|
          if opt.instance_of?(VideoConfig)
            case opt.encode
            when 'av1'
              oopts << format("-c:v librav1e")
              if opt.bitrate
                oopts << format("-b:v %sk", opt.bitrate)
              end
            when 'vp9'
              oopts << format("-c:v libvpx-vp9")
              if opt.quality
                oopts << format("-crf %s", opt.quality)
                oopts << format("-b:v 0")
              elsif opt.bitrate
                oopts << format("-b:v %s", opt.bitrate)
              end
            when 'h265'
              oopts << format("-c:v libx265")
              oopts << format("-crf %s", opt.quality)
              oopts << format("-preset %s", opt.preset) if opt.preset
              oopts << format("-tune %s", opt.tune) if opt.tune
              # Currently, ffmpeg ​does not support setting profiles on x265
              oopts << format("-profile:v %s", opt.profile) if opt.profile && opt.encoder == 'x264'
              oopts << format("-level %s", opt.level) if opt.level
            else
              oopts << format("-c:v copy")
            end
          elsif opt.instance_of?(AudioConfig)
            case opt.encode
            when 'opus'
              oopts << format("-c:a lib%s", opt.encode)
              oopts << format("-b:a %sk", opt.bitrate) if opt.bitrate
            when 'aac'
              oopts << format("-c:a libfdk_aac")
              if opt.quality
                oopts << format("-aq %s", opt.quality)
                oopts << format("-b:a 0")
              elsif opt.bitrate
                oopts << format("-b:a %s", opt.bitrate)
              end
            else
              oopts << format("-c:a copy")
            end
          elsif opt.instance_of?(PictureConfig)
            oopts << format("-vf \"%s\"", opt.vf_opts.join(",")) if opt.vf_opts && opt.vf_opts.any?
            oopts << format("-r %s", opt.fps) if opt.fps
          elsif opt.instance_of?(String)
            oopts << opt
          end
        end
        oopts << "\"#{fname}\""
        next oopts
      end
      out_optsets.each do |out_optset|
        opts << outfilep.call(out_optset.fname, out_optset.optset)
      end

      opts.join(" ")
    end
  end

  class HandBrakeCLI
    def self.command(input, output, configs, raw_option)
      cmd_opts = ["HandBrakeCLI"]
      cmd_opts << format("--input \"%s\"", input)
      cmd_opts << format("--output \"%s\"", output)
      configs.each do |config|
        if config.instance_of?(VideoConfig)
          case config.encode
          when 'vp9'
            cmd_opts << format("--encoder VP9")
            if config.quality
              cmd_opts << format("--quality %s", config.quality)
              cmd_opts << format("--vb 0")
            elsif config.bitrate
              cmd_opts << format("--vb %s", config.bitrate)
            end
            cmd_opts << format("--encoder-preset veryslow")
          when 'h265' || 'hevc'
            cmd_opts << format("--encoder x265")
            if config.quality
              cmd_opts << format("--quality %s", config.quality)
              cmd_opts << format("--vb 0")
            elsif config.bitrate
              cmd_opts << format("--vb %s", config.bitrate)
            end
            cmd_opts << format("--encoder-preset %s", config.preset) if config.preset
            cmd_opts << format("--encoder-tune %s", config.tune) if config.tune
            cmd_opts << format("--encoder-profile %s", config.profile) if config.profile
            cmd_opts << format("--encoder-level %s", config.level) if config.level
          else
            cmd_opts << format("--encoder %s", config.encode) if config.encode
            cmd_opts << format("--quality %s", config.quality) if config.quality
            cmd_opts << format("--vb %s", config.bitrate) if config.bitrate
          end
        elsif config.instance_of?(AudioConfig)
          case config.encode
          when 'opus'
            cmd_opts << format("--aencoder %s", config.encode)
            cmd_opts << format("--aq %s", config.quality) if config.quality
            cmd_opts << format("--ab %s", config.bitrate) if config.bitrate
          when 'aac'
            cmd_opts << format("--aencoder ca_haac")
            if config.quality
              cmd_opts << format("--aq %s", config.quality)
              cmd_opts << format("--ab 0")
            elsif config.bitrate
              cmd_opts << format("--ab %s", config.bitrate)
            end
          else
            cmd_opts << format("--aencoder copy")
          end
        elsif config.instance_of?(DVDConfig)
          cmd_opts << (config.title ? format("--title %s", config.title) : "--main-feature")
          cmd_opts << format("--chapters %s", config.chapters) if config.chapters
          cmd_opts << "--markers" if config.chapter_marker
          cmd_opts << (config.audio ? format("--audio %s", config.audio) : "--all-audio" )
          cmd_opts << (config.subtitle ? format("--subtitle %s", config.subtitle) : "--all-subtitles" )
        end
      end

      cmd_opts << raw_option if raw_option

      cmd_opts.join(" ")
    end
  end

  class ImageMagick
    COMMAND = "convert %s %s %s %s "

    def self.command(input, output, pconfig, raw_option="")
      input_opt = ""
      output_opt = ""
      if pconfig.instance_of?(ImageConfig) then
        input_opt += "-quality %s" % pconfig.quality if pconfig.quality
        s = COMMAND % [input, input_opt, output, output_opt]
        s
      end
    end
  end

  MediaUtil.start(ARGV)
#+end_src
** genalbum

Personal script for encoding family pictures and movies.

#+begin_src ruby :tangle (expand-file-name ".local/bin/genalbum")
  #!/usr/bin/env ruby

  require 'fileutils'
  require 'time'
  require 'exifr'
  require 'streamio-ffmpeg'
  require 'pathname'
  require 'thor'

  PICTURE_FILE_EXTS = [".jpg"]
  MOVIE_FILE_EXTS = [".mp4"]
  ALBUM_DIR_NAME = "album/"
  RENAME_DIR_NAME = "rename/"
  WEB_DIR_NAME = "album_web/"
  IMG_PREFIX = "img_"

  class GenAlbum < Thor
    default_command :album
    desc "[album] -i <img_dir>", "generate album"
    option :in, aliases: "i", :type => :string, :required => true
    def album
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = ALBUM_DIR_NAME

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      Dir.glob(src_path + "/*").each do |img_file|
        basename = File::basename(img_file)
        src_file = src_path + "/" + basename
        dest_file = dest_path + "/" + basename
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          system("convert -resize \"4096x>\" -quality 92 #{src_file} #{dest_file}")
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          system("mediautil encode -i #{src_file} -o #{dest_file} -q 22.0 -Q 100.0")
        end
      end
    end

    desc "web -i <img_dir>", "generate lightweight album for web"
    option :in, aliases: "i", :type => :string, :required => true
    def web
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = WEB_DIR_NAME

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      Dir.glob(src_path + "/*").each do |img_file|
        basename = File::basename(img_file)
        src_file = src_path + "/" + basename
        dest_file = dest_path + "/" + basename
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          system("convert -resize \"1024x>\" -quality 80 #{src_file} #{dest_file}")
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          system("mediautil encode -i #{src_file} -o #{dest_file} -q 26.0 -Q 100.0")
        end
      end
    end

    desc "renmae -i <img_dir>", "rename image files in chlonological order"
    option :in, aliases: "i", :type => :string, :required => true
    option :out, aliases: "o", :type => :string
    def rename
      src_path = File.expand_path(options[:in], Dir.pwd)
      dest_path = ((options[:out]) ? options[:out] : RENAME_DIR_NAME)

      FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

      img_time = {}
      Dir.glob(src_path + "/*").each do |img_file|
        ext = File.extname(img_file)
        if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
          pic = EXIFR::JPEG.new(img_file)
          if pic.exif? && pic.date_time_original then
            img_time[img_file] = pic.date_time_original
          else
            img_time[img_file] = Time.now
          end
        elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
          movie = FFMPEG::Movie.new(img_file)
          time = movie.creation_time
          if time then
            img_time[img_file] = time
          else
            img_time[img_file] = Time.now
          end
        end
      end
      img_time = img_time.sort_by{ |_, v| v }

      digit = img_time.length.to_s.length
      digit = 2 if digit < 2
      img_time.each_with_index do |(img, time), i|
        ext = File.extname(img).downcase
        base = IMG_PREFIX + "%0#{digit}d" % (i + 1) + ext
        src_file = img
        dest_file = dest_path + "/" + base
        system("cp #{src_file} #{dest_file}")
      end
    end
  end

  GenAlbum.start(ARGV)
#+end_src

** nhp                                         :ARCHIVE:
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-file-name ".local/bin/nhp")
  #!/usr/bin/env bash

  readonly MAIL_FROM="<<email()>>"
  readonly MAIL_TO="<<email()>>"

  function usage() {
    cat <<_EOT_
  Usage:
    $(basename "$0") [options] command|exefile

  Description:
    $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

  Options:
    -l <logfile>  log file name
    -p <pidfile>  process id file name
    -h            help

  _EOT_
    exit 1
  }

  if [ "${OPTIND}" = 1 ]; then
    while getopts l:p:h OPT
    do
      case ${OPT} in
      l)
        opt_logfile=${OPTARG}
        ;;
      p)
        opt_pidfile=${OPTARG}
        ;;
      h)
        usage
        ;;
      \?)
        echo "Try to enter the h option." 1>&2
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi

  shift $((OPTIND - 1))

  function mailtome() {
    local _command=$1
    local _whole_command=$2
    local _logfile_rel=$4

    if [ "$3" -eq 0 ]; then
      _result='success'
    else
      _result='failed'
    fi
    _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

    mailfrom=${MAIL_FROM}
    mailto=${MAIL_TO}
    subject="${_result}: ${_command} @ $(uname -n)"
    msg1="command line      : ${_whole_command}"
    msg2="exit status(nohup): $3"
    msg3="execution time    : $5"
    msg4="pwd               : $(pwd)"
    msg5="Log data (stdout/stderr) is stored in following file:"
    msg6="${_logfile}"

    {
      echo "${msg1}"
      echo "${msg2}"
      echo "${msg3}"
      echo "${msg4}"
      echo "${msg5}"
      echo "${msg6}"
    } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
  }
  export -f mailtome

  if [ $# -eq 1 ] && [ -x "$1" ]; then
    utility="$1"
  elif [ $# -gt 0 ] && type "$1" >/dev/null; then
    utility="$*"
  else
    exit 1
  fi

  LOG_DIR=${HOME}/.local/state/log/$(basename "$0")
  fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

  if [ ! -d "${LOG_DIR}" ]; then
    mkdir -p "${LOG_DIR}"
  fi

  if [ -v "opt_logfile" ]; then
    logfile=${opt_logfile}
  else
    logfile="${LOG_DIR}/${fname_default}.log"
  fi

  if [ -v "opt_pidfile" ]; then
    pidfile=${opt_pidfile}
  else
    pidfile="${LOG_DIR}/${fname_default}.pid"
  fi

  (
    start_time=$(date +%s)
    nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
    PID=$!
    echo $PID >"${pidfile}"
    wait $PID
    EXIT_STATUS=$?
    end_time=$(date +%s)
    exec_time=$((end_time-start_time))
    ((h=exec_time/3600))
    ((m=(exec_time%3600)/60))
    ((s=exec_time%60))
    exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
    mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
  )
  echo "$1 has finished successfully"

  exit 0
#+end_src

** sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-file-name ".local/bin/sendmail.py")
  #!/usr/bin/env python3

  import sys
  import argparse
  import subprocess
  import smtplib
  import ssl
  from email.mime.text import MIMEText
  from email.utils import formatdate

  def sendmail(mail_to, mail_from, subject, message):
      smtp_host = 'smtp.<<my-network()>>'
      smtp_port = '465'
      smtp_user = '<<email()>>'.split(sep='@')[0]
      smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

      mime_msg = MIMEText(message)
      mime_msg['Subject'] = subject
      mime_msg['From'] = mail_from
      mime_msg['To'] = mail_to
      mime_msg["Date"] = formatdate(None, True)

      if smtp_port == '465':
          context = ssl.create_default_context()
          smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

      if smtp is not None:
          smtp.login(smtp_user, smtp_pass)
          smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
          smtp.quit()


  DESC = 'sendmail.py sends mail'
  parser = argparse.ArgumentParser(description=DESC)
  parser.add_argument('-s', '--subject')
  parser.add_argument('-f', '--mailfrom')
  parser.add_argument('to')
  args = parser.parse_args()

  message = sys.stdin.read()
  sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

** pwsudo

A script which executes command with elevating privilege using password from pass command.

#+begin_src bash :noweb tangle :tangle (expand-file-name ".local/bin/pwsudo")
  _userid=$(whoami)
  _hostname=$(hostname)

  if pass show "${_hostname}/${_userid}" >/dev/null 2>&1; then
    pass show "${_hostname}/${_userid}" | head -1 | sudo -sES -p "" "PATH=$PATH" "$@"
  else
    sudo -sE "PATH=$PATH" "$@"
  fi
#+end_src

** gitsync                                     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-09-29 Thu 16:42]
:END:

- gitsync-local
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-local")
    #!/usr/bin/env bash

    function usage() {
      cat <<_EOT_
    Usage:
      $0 <prj_root>

    Description:
      $0 adds file changes in git projects under root_dir to the repository

    Options:
      prj_root:  a root directory that has git projects as children

    _EOT_
      exit 1
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo} || continue

          # skip if this is not git repo
          git rev-parse || continue

          echo "repository: ${repo}"

          cd `git rev-parse --show-toplevel`
          sync_mode=`git config sync.mode`
          case "${sync_mode}" in
          "auto" )
            # Remove deleted files
            git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
            # Add new files
            git add . >/dev/null 2>&1
            git commit -m "$(date)";;
          "manual" )
            git add -u >/dev/null 2>&1
            git commit -m "$(date)";;
          "none" )
          ;;
          esac
        done
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi
  #+end_src

- gitsync-remote
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-remote")
    #!/usr/bin/env bash

    # Local bare repository name
    syncrepo=origin

    # Display repository name only once
    log_repo() {
      [ "x$lastrepo" == "x$repo" ] || {
        printf "\nREPO: ${repo}\n"
        lastrepo="$repo"
      }
    }

    # Log a message for a repository
    log_msg() {
      log_repo
      printf "  $1\n"
    }

    # fast-forward reference $1 to $syncrepo/$1
    fast_forward_ref() {
      log_msg "fast-forwarding ref $1"
      current_ref=$(cat .git/HEAD)
      if [ "x$current_ref" = "xref: refs/heads/$1" ]
      then
        # Check for dirty index
        files=$(git diff-index --name-only HEAD --)
        git merge refs/remotes/$syncrepo/$1
      else
        git branch -f $1 refs/remotes/$syncrepo/$1
      fi
    }

    # Push reference $1 to $syncrepo
    push_ref() {
      log_msg "Pushing ref $1"
      if ! git push --tags --quiet $syncrepo $1
      then
        exit 1
      fi
    }

    # Check if a ref can be moved
    #   - fast-forwards if behind the sync repo and is fast-forwardable
    #   - Does nothing if ref is up to date
    #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
    #   - Fails if ref and $syncrop/ref have diverged
    check_ref() {
      revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
      revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
      if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
      then
        # Ref $1 is up to date.
        :
      elif [ "x$revlist1" = "x" ]
      then
        # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
        fast_forward_ref $1 || exit 1
      elif [ "x$revlist2" = "x" ]
      then
        # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
        push_ref $1 || exit 1
      else
        log_msg "Ref $1 and $syncrepo/$1 have diverged."
        exit 1
      fi
    }

    # Check all local refs with matching refs in the $syncrepo
    check_refs () {
      git for-each-ref refs/heads/* | while read sha1 commit ref
      do
        ref=${ref/refs\/heads\//}
        git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
        do
          if [ "x$sha1" != "x" -a "x$sha2" != "x" ]
          then
            check_ref $ref || exit 1
          fi
        done
      done
    }

    # parameter check
    if [ $# -ne 1 ]; then
      usage
      exit 1
    fi
    root_dir=$1

    # For all repositories under $reporoot
    #   Check all refs matching $syncrepo and fast-forward, or push as necessary
    #   to synchronize the ref with $syncrepo
    #   Bail out if ref is not fastforwardable so user can fix and rerun
    retval=0
    if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
        while read repo
        do
          cd ${repo}

          # continue if this is not git repo
          git rev-parse 2> /dev/null || continue

          upd=$(git remote update $syncrepo 2>&1 || retval=1)
          [ "x$upd" = "xFetching $syncrepo" ] || {
            log_repo
            printf "$upd\n"
          }
          check_refs || retval=1
        done
        exit $retval
      }
    then
      printf "\nAll done.\n"
    else
      printf "\nFix and redo.\n"
    fi

    exit $retval
#+end_src

** filetype-cli                                :ARCHIVE:
Wrapper script for [[* filetype][filetype.rb]].

#+begin_src ruby :tangle (expand-file-name ".local/bin/filetype-cli") :tangle-mode (identity #o755)
  #!/usr/bin/env ruby

  require 'thor'
  require 'filetype'

  class FileTypeCLI < Thor
    default_command :check
    desc "check", "check whether the file is the speicfied type."
    option :type, aliases: "t", :type => :string, :required => true,
           :bannar => '--type image'
    def check(file)
      unless FileType.respond_to?("#{options[:type]}?")
        $stderr.print("file type '#{options[:type]}' is not valid.")
        exit 1
      end

      status = FileType.send("#{options[:type]}?", file)
      unless status
        $stderr.print("#{file} is not of #{options[:type]}?")
        exit 1
      end

      exit 0
    end
  end

  FileTypeCLI.start(ARGV)
#+end_src
** strip ruby
A program strips all ruby tags in a HTML stream. All HTML contents are expected to be from STDIN and go out as STDOUT. This procedure is mainly for html files converted from pdf and epub files.
Stripping rules are:
- <ruby> tag will be stripped
- <rt> tree for furigana tree will be removed
- <rp> tree contains parenthes for non-ruby-support brouwser will be removed
- <rb> tag for delimiter will be stripped
- <rtc> tree for semantic word will be removed

#+begin_src python :tangle (expand-file-name ".local/bin/strip_ruby") :tangle-mode (identity #o755)
  #!/usr/bin/env python3

  import sys
  import lxml.html as html

  INPUT_STR = sys.stdin.read()
  ROOT = html.fromstring(INPUT_STR).getroottree()

  for ruby in ROOT.xpath('//ruby'):
      for rt in ruby.xpath('//rt'):
          rt.drop_tree()
      for rp in ruby.xpath('//rp'):
          rp.drop_tree()
      for rb in ruby.xpath('//rb'):
          rb.drop_tag()
      for rtc in ruby.xpath('//rtc'):
          rtc.drop_tree()
      ruby.drop_tag()

  CONTENT = html.tostring(ROOT, encoding="utf-8", method='html', pretty_print=True)
  print(CONTENT.decode())
#+end_src
* Workflows

** Transcode Video Files
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 14:44]
:END:

Transcoding my local video files with open codec, like VP9 and AV1, is effective for disc space usage.

#+begin_src shell :noweb-ref transc-shared
  #!/usr/bin/env bash
  set -euo pipefail

  CRF=28
  KBITRATE_AUDIO=128

  function usage() {
    cat <<_EOT_
  Usage:
    $(basename $0) [OPTIONS] <video_in> [<video_out>]

  Description:
    $(basename $0) encodes <video_in> to <video_out> in specified codec.

  Options:
    -c <CRF>      CRF value instead of ${CRF} (DEFAULT)
    -B <AUDIO_BR> Audio Bitrate in kbps

  _EOT_
  }

  if [ "${OPTIND}" = 1 ]; then
    while getopts c:B:h OPT
    do
      case ${OPT} in
      c)
        CRF=${OPTARG}
        ;;
      B)
        CRF=${OPTARG}
        ;;
      h)
        usage
        ;;
      \?)
        echo "Try to enter the h option." 1>&2
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi

  shift $((OPTIND - 1))

  if [ $# -lt 1 ] || [ $# -gt 2 ]; then
    usage
    exit -1
  fi

  INPUT_VIDEO=$1
  if [ ! -e "${INPUT_VIDEO}" ]; then
    echo "${INPUT_VIDEO} does not exist." 1>&2
    exit -1
  fi

  if [[ $# -eq 2 ]]; then
    output_cand=$2
  else
    output_cand=$(basename "${INPUT_VIDEO}").webm
  fi
  if [ -e ${output_cand} ]; then
    OUTPUT_VIDEO=${output_cand%.*}_$(date +%Y%m%d_%H%M).webm
  else
    OUTPUT_VIDEO="${output_cand}"
  fi

  WORK_DIR="${INPUT_VIDEO%.*}"
#+end_src

*** vp9 transcoding

- transcode video to vp9
  : $ vp9transc -c 32 video_orig.mkv video_vp9.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/vp9transc") :tangle-mode (identity #o555)
  <<transc-shared>>

  vp9_opts_pass1="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 1 -an -f null"
  vp9_opts_pass2="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 2 -map_metadata 0"
  opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

  mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
    && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass1} /dev/null \
    && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src
*** av1 transcoding

- transcode video to av1
  : $ av1transc video_orig.mkv video_av1.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/av1transc") :tangle-mode (identity #o555)
  <<transc-shared>>

  av1_opts_common="-c:v libaom-av1 -cpu-used 2 -row-mt 1 -threads $(nproc) -b:v 0 -crf ${CRF}"
  av1_opts_pass1="${av1_opts_common} -pass 1 -an -f null"
  av1_opts_pass2="${av1_opts_common} -pass 2 -map_metadata 0"
  opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

  mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
    && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass1} /dev/null \
    && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src

** Transcode Audio Files

- usage
  + encode bulk podcast files for 64kb/s (in Dired)
    : $ nohup parallel opusencode "{}" "{.}".oga ::: *

#+begin_src shell :tangle (expand-file-name ".local/bin/opusencode") :tangle-mode (identity #o555)
  #!/usr/bin/env bash
  set -euo pipefail

  if [[ $# -ge 1 ]]; then
    INPUT_VIDEO=$1
    if [[ $# -eq 2 ]]; then
      OUTPUT_VIDEO=$2
    else
      OUTPUT_VIDEO=$(basename "${INPUT_VIDEO}").oga
    fi
  fi

  opus_opts="-c:a libopus -b:a 64k -ac 2"

  ffmpeg -i "${INPUT_VIDEO}" ${opus_opts} "${OUTPUT_VIDEO}"
#+end_src

** DVD Packing

#+begin_src scheme :noweb-ref desktop-pkgs
  "handbrake"
  "dvdbackup"
  "libdvdnav"
  "libdvdcss"
#+end_src

#+begin_src shell :tangle (expand-file-name ".local/bin/dvdpack") :tangle-mode (identity #o555)
  #!/usr/bin/env bash
  set -euo pipefail

  if [ "${OPTIND}" = 1 ]; then
    while getopts t: OPT
    do
      case ${OPT} in
      t)
        TITLE=${OPTARG}
        ;;
      esac
    done
  else
    echo "No installed getopts-command." 1>&2
    exit 1
  fi
  shift $((OPTIND - 1))

  if [[ $# -ge 1 ]]; then
    DVD_DIR=$1
    if [[ $# -eq 2 ]]; then
      DVD_PACK_VIDEO=$2
    else
      DVD_PACK_VIDEO=$(basename "${DVD_DIR}").mkv
    fi
  fi

  if [ -v TITLE ]; then
    title_opt="--title ${TITLE}"
  else
    title_opt='--main-feature'
  fi

  hb_opts="--x264-preset veryslow --quality 18 --aencoder copy ${title_opt} --markers --all-audio --all-subtitles"

  HandBrakeCLI --input "${DVD_DIR}" --output "${DVD_PACK_VIDEO}" ${hb_opts}
#+end_src
** CD Ripping

#+begin_src scheme :noweb-ref desktop-pkgs
  "abcde"
  "cdrtools"
  "easytag"
#+end_src

- abcde
  #+BEGIN_SRC conf :tangle (expand-file-name ".abcde.conf")
    FDKAACENCOPTS='--bitrate 256k'

    OUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${TRACKNUM}.${TRACKFILE}'
  #+END_SRC
** Tutorial Video Creation
:PROPERTIES:
:CREATED:  [2022-08-15 Mon 20:13]
:END:

[[https://www.thregr.org/~wavexx/software/screenkey/][Screencast your keys.]]

: $ screenkey -p fixed -g 1090x248+1470+348

#+begin_src scheme :noweb-ref creative-pkgs
  "python-screenkey"
  "slop"
  "gimp"
  "obs"
  "kdenlive"
  "audacity"
#+end_src

#+begin_src json :tangle no  :tangle (expand-file-name ".config/screenkey.json")  :tangle-mode (identity #o644)
  {"no_systray": false, "timeout": 0.5, "recent_thr": 0.1, "compr_cnt": 3, "ignore": [], "position": "bottom", "persist": false, "font_desc": "Sans Bold", "font_size": "medium", "font_color": "white", "bg_color": "black", "opacity": 0.9, "key_mode": "composed", "bak_mode": "baked", "mods_mode": "emacs", "mods_only": false, "multiline": false, "vis_shift": true, "vis_space": true, "geometry": null, "screen": 0, "start_disabled": false, "mouse": false, "button_hide_duration": 2.0}
#+end_src
** Sync Git Repos Automatically
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 16:43]
:END:

#+begin_src conf :noweb-ref cronjob-pc
  0 */2 * * * /bin/bash -ci "ghq-sync >> $LOG_DIR/ghq-sync.log 2>&1"
#+end_src

#+begin_src shell :tangle (expand-file-name ".local/bin/ghq-sync") :shebang #!/usr/bin/env bash :tangle-mode (identity #o500)
  ghq_repos=$(ghq list --full-path)
  for repo_path in ${ghq_repos[@]}; do
    cd ${repo_path} && \
      (
        git-sync check && git-sync
      )
  done
#+end_src

*** git-sync
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 15:14]
:END:

[[https://github.com/simonthum/git-sync][git-sync]] enables to sync (stage, commit and pull/push) git repositories. I use it for my org-file repo in daily basis.

#+begin_src gitconfig :noweb-ref git-config
  [branch "main"]
          syncCommitMsg = "on $(LC_TIME=en_GB.UTF-8 date) from $(uname -n)"
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/git-sync") :tangle-mode (identity #o755)
  #!/usr/bin/env bash
  #
  # git-sync
  #
  # synchronize tracking repositories
  #
  # 2012-20 by Simon Thum and contributors
  # Licensed as: CC0
  #
  # This script intends to sync via git near-automatically
  # in "tracking" repositories where a nice history is not
  # crucial, but having one at all is.
  #
  # Unlike the myriad of scripts to do just that already available,
  # it follows the KISS principle: It is small, requires nothing but
  # git and bash, but does not even try to shield you from git.
  #
  # Mode sync (default)
  #
  # Sync will likely get from you from a dull normal git repo with trivial
  # changes to an updated dull normal git repo equal to origin. No more,
  # no less. The intent is to do everything that's needed to sync
  # automatically, and resort to manual intervention as soon
  # as something non-trivial occurs. It is designed to be safe
  # in that it will likely refuse to do anything not known to
  # be safe.
  #
  # Mode check
  #
  # Check only performs the basic checks to make sure the repository
  # is in an orderly state to continue syncing, i.e. committing
  # changes, pull etc. without losing any data. When check returns
  # 0, sync can start immediately. This does not, however, indicate
  # that syncing is at all likely to succeed.

  # command used to auto-commit file modifications
  DEFAULT_AUTOCOMMIT_CMD="git add -u ; git commit -m \"%message\";"

  # command used to auto-commit all changes
  ALL_AUTOCOMMIT_CMD="git add -A ; git commit -m \"%message\";"

  # default commit message substituted into autocommit commands
  DEFAULT_AUTOCOMMIT_MSG="changes from $(uname -n) on $(date)"


  # AUTOCOMMIT_CMD="echo \"Please commit or stash pending changes\"; exit 1;"
  # TODO mode for stash push & pop

  print_usage() {
      cat << EOF
  usage: $0 [-h] [-n] [-s] [MODE]

  Synchronize the current branch to a remote backup
  MODE may be either "sync" (the default) or "check", to verify that the branch is ready to sync

  OPTIONS:
     -h      Show this message
     -n      Commit new files even if branch.\$branch_name.syncNewFiles isn't set
     -s      Sync the branch even if branch.\$branch_name.sync isn't set
  EOF
  }
  sync_new_files_anyway="false"
  sync_anyway="false"

  while getopts "hns" opt ; do
      case $opt in
          h )
              print_usage
              exit 0
              ;;
          n )
              sync_new_files_anyway="true"
              ;;
          s )
              sync_anyway="true"
              ;;
      esac
  done
  shift $((OPTIND-1))

  #
  #    utility functions, some adapted from git bash completion
  #

  __log_msg()
  {
      echo git-sync: $1
  }

  # echo the git dir
  __gitdir()
  {
          if [ "true" = "$(git rev-parse --is-inside-work-tree "$PWD" | head -1)" ]; then
                  git rev-parse --git-dir "$PWD" 2>/dev/null
          fi
  }

  # echos repo state
  git_repo_state ()
  {
          local g="$(__gitdir)"
          if [ -n "$g" ]; then
                  if [ -f "$g/rebase-merge/interactive" ]; then
                          echo "REBASE-i"
                  elif [ -d "$g/rebase-merge" ]; then
                          echo "REBASE-m"
                  else
                          if [ -d "$g/rebase-apply" ]; then
                                  echo "AM/REBASE"
                          elif [ -f "$g/MERGE_HEAD" ]; then
                                  echo "MERGING"
                          elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
                                  echo "CHERRY-PICKING"
                          elif [ -f "$g/BISECT_LOG" ]; then
                                  echo "BISECTING"
                          fi
                  fi
                  if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
                          if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                                  echo "|BARE"
                          else
                                  echo "|GIT_DIR"
                          fi
                  elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
                          git diff --no-ext-diff --quiet --exit-code || echo "|DIRTY"
  #			if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
  #			        git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
  #			fi
  #
  #			if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
  #			   if [ -n "$(git ls-files --others --exclude-standard)" ]; then
  #			      u="%"
  #			   fi
  #			fi
  #
  #			if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
  #				__git_ps1_show_upstream
  #			fi
                  fi
          else
              echo "NOGIT"
          fi
  }

  # check if we only have untouched, modified or (if configured) new files
  check_initial_file_state()
  {
      local syncNew="$(git config --get --bool branch.$branch_name.syncNewFiles)"
      if [[ "true" == "$syncNew" || "true" == "$sync_new_files_anyway" ]]; then
          # allow for new files
          if [ ! -z "$(git status --porcelain | grep -E '^[^ \?][^M\?] *')" ]; then
              echo "NonNewOrModified"
          fi
      else
          # also bail on new files
          if [ ! -z "$(git status --porcelain | grep -E '^[^ ][^M] *')" ]; then
              echo "NotOnlyModified"
          fi
      fi
  }

  # look for local changes
  # used to decide if autocommit should be invoked
  local_changes()
  {
      if [ ! -z "$(git status --porcelain | grep -E '^(\?\?|[MARC] |[ MARC][MD])*')" ]; then
          echo "LocalChanges"
      fi
  }

  # determine sync state of repository, i.e. how the remote relates to our HEAD
  sync_state()
  {
      local count="$(git rev-list --count --left-right $remote_name/$branch_name...HEAD)"

      case "$count" in
          "") # no upstream
              echo "noUpstream"
              false
              ;;
          "0	0")
              echo "equal"
              true
              ;;
          "0	"*)
              echo "ahead"
              true
              ;;
          ,*"	0")
              echo "behind"
              true
              ;;
          ,*)
              echo "diverged"
              true
              ;;
      esac
  }

  # exit, issue warning if not in sync
  exit_assuming_sync() {
      if [ "equal" == "$(sync_state)" ] ; then
          __log_msg "In sync, all fine."
          exit 0;
      else
          __log_msg "Synchronization FAILED! You should definitely check your repository carefully!"
          __log_msg "(Possibly a transient network problem? Please try again in that case.)"
          exit 3
      fi
  }

  #
  #        Here git-sync actually starts
  #

  # first some sanity checks
  rstate="$(git_repo_state)"
  if [[ -z "$rstate" || "|DIRTY" = "$rstate" ]]; then
      __log_msg "Preparing. Repo in $(__gitdir)"
  elif [[ "NOGIT" = "$rstate" ]] ; then
      __log_msg "No git repository detected. Exiting."
      exit 128 # matches git's error code
  else
      __log_msg "Git repo state considered unsafe for sync: $(git_repo_state)"
      exit 2
  fi

  # determine the current branch (thanks to stackoverflow)
  branch_name=$(git symbolic-ref -q HEAD)
  branch_name=${branch_name##refs/heads/}

  if [ -z "$branch_name" ] ; then
      __log_msg "Syncing is only possible on a branch."
      git status
      exit 2
  fi

  # while at it, determine the remote to operate on
  remote_name=$(git config --get branch.$branch_name.pushRemote)
  if [ -z "$remote_name" ] ; then
      remote_name=$(git config --get remote.pushDefault)
  fi
  if [ -z "$remote_name" ] ; then
      remote_name=$(git config --get branch.$branch_name.remote)
  fi

  if [ -z "$remote_name" ] ; then
      __log_msg "the current branch does not have a configured remote."
      echo
      __log_msg "Please use"
      echo
      __log_msg "  git branch --set-upstream-to=[remote_name]/$branch_name"
      echo
      __log_msg "replacing [remote_name] with the name of your remote, i.e. - origin"
      __log_msg "to set the remote tracking branch for git-sync to work"
      exit 2
  fi

  # check if current branch is configured for sync
  if [[ "true" != "$(git config --get --bool branch.$branch_name.sync)" && "true" != "$sync_anyway" ]] ; then
      echo
      __log_msg "Please use"
      echo
      __log_msg "  git config --bool branch.$branch_name.sync true"
      echo
      __log_msg "to enlist branch $branch_name for synchronization."
      __log_msg "Branch $branch_name has to have a same-named remote branch"
      __log_msg "for git-sync to work."
      echo
      __log_msg "(If you don't know what this means, you should change that"
      __log_msg "before relying on this script. You have been warned.)"
      echo
      exit 1
  fi

  # determine mode
  if [[ -z "$1" || "$1" == "sync" ]]; then
      mode="sync"
  elif [[ "check" == "$1" ]]; then
      mode="check"
  else
      __log_msg "Mode $1 not recognized"
      exit 100
  fi

  __log_msg "Mode $mode"

  __log_msg "Using $remote_name/$branch_name"

  # check for intentionally unhandled file states
  if [ ! -z "$(check_initial_file_state)" ] ; then
      __log_msg "There are changed files you should probably handle manually."
      git status
      exit 1
  fi

  # if in check mode, this is all we need to know
  if [ $mode == "check" ] ; then
      __log_msg "check OK; sync may start."
      exit 0
  fi

  # check if we have to commit local changes, if yes, do so
  if [ ! -z "$(local_changes)" ]; then
      autocommit_cmd=""
      config_autocommit_cmd="$(git config --get branch.$branch_name.autocommitscript)"

      # discern the three ways to auto-commit
      if [ ! -z "$config_autocommit_cmd" ]; then
          autocommit_cmd="$config_autocommit_cmd"
      elif [[ "true" == "$(git config --get --bool branch.$branch_name.syncNewFiles)" || "true" == "$sync_new_files_anyway" ]]; then
          autocommit_cmd=${ALL_AUTOCOMMIT_CMD}
      else
          autocommit_cmd=${DEFAULT_AUTOCOMMIT_CMD}
      fi

      commit_msg="$(git config --get branch.$branch_name.syncCommitMsg)"
      if [ "" == "$commit_msg" ]; then
        commit_msg=${DEFAULT_AUTOCOMMIT_MSG}
      fi
      autocommit_cmd=$(echo "$autocommit_cmd" | sed "s/%message/$commit_msg/")

      __log_msg "Committing local changes using ${autocommit_cmd}"
      eval $autocommit_cmd

      # after autocommit, we should be clean
      rstate="$(git_repo_state)"
      if [[ ! -z "$rstate" ]]; then
          __log_msg "Auto-commit left uncommitted changes. Please add or remove them as desired and retry."
          exit 1
      fi
  fi

  # fetch remote to get to the current sync state
  # TODO make fetching/pushing optional
  __log_msg "Fetching from $remote_name/$branch_name"
  git fetch $remote_name $branch_name
  if [ $? != 0 ] ; then
      __log_msg "git fetch $remote_name returned non-zero. Likely a network problem; exiting."
      exit 3
  fi

  case "$(sync_state)" in
  "noUpstream")
          __log_msg "Strange state, you're on your own. Good luck."
          exit 2
          ;;
  "equal")
          exit_assuming_sync
          ;;
  "ahead")
          __log_msg "Pushing changes..."
          git push $remote_name $branch_name:$branch_name
          if [ $? == 0 ]; then
              exit_assuming_sync
          else
              __log_msg "git push returned non-zero. Likely a connection failure."
              exit 3
          fi
          ;;
  "behind")
          __log_msg "We are behind, fast-forwarding..."
          git merge --ff --ff-only $remote_name/$branch_name
          if [ $? == 0 ]; then
              exit_assuming_sync
          else
              __log_msg "git merge --ff --ff-only returned non-zero ($?). Exiting."
              exit 2
          fi
          ;;
  "diverged")
          __log_msg "We have diverged. Trying to rebase..."
          git rebase $remote_name/$branch_name
          if [[ $? == 0 && -z "$(git_repo_state)" && "ahead" == "$(sync_state)" ]] ; then
              __log_msg "Rebasing went fine, pushing..."
              git push $remote_name $branch_name:$branch_name
              exit_assuming_sync
          else
              __log_msg "Rebasing failed, likely there are conflicting changes. Resolve them and finish the rebase before repeating git-sync."
              exit 1
          fi
          # TODO: save master, if rebasing fails, make a branch of old master
          ;;
  esac
#+end_src
