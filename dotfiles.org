#+TITLE: Dotfiles
#+STARTUP: overview

#+OPTIONS: toc:t
#+SETUPFILE: theme-readtheorg.setup

* Personal Information
** Local Directories
*** home directory

#+name: home-dir
#+begin_src shell :eval no-export
echo -n '~'
#+end_src
*** config directory

#+name: conf-dir
#+begin_src shell :eval no-export
echo '~/.config'
#+end_src
*** document directory
:PROPERTIES:
:CREATED:  [2025-01-31 Fri 14:43]
:END:

A directory that contains all my documents, including both text and binary files.

#+NAME: doc-dir
#+begin_src emacs-lisp
"/mnt/pt-shared/doc-%%HOSTNAME%%"
#+end_src

*** share directory

My share directory is where my variable data stay.

#+name: share-dir
#+begin_src shell :eval no-export
echo -n '~/.local/share'
#+end_src

*** media directory

#+begin_src shell :noweb yes :noweb-ref make-dir :tangle no
<<media-dir()>>
#+end_src

#+name: media-dir
#+begin_src sh :noweb yes :eval no-export
echo -n '~/.local/share/video'
#+end_src

*** trash directory
:PROPERTIES:
:CREATED:  [2023-04-10 Mon 21:57]
:END:

#+name: trash-dir
#+begin_src emacs-lisp :eval no-export :var full-path=0
(funcall (if (= full-path 0) #'identity #'expand-file-name)
         "~/.local/share/Trash")
#+end_src

delete file which lives longer than 1 week in trash directory.

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<trash-dir(full-path=1)>>/files - - - 1w
#+end_src

*** log file directory
:PROPERTIES:
:CREATED:  [2023-11-03 Fri 08:56]
:END:

#+name: log-dir
#+begin_src shell :eval no-export
echo -n '~/.local/state/log'
#+end_src

#+begin_src shell :noweb yes :noweb-ref make-dir
<<log-dir()>>
#+end_src

** Email Settings
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:57]
:END:

*** Smtp Server Host                            :crypt:
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 12:01]
:END:

-----BEGIN PGP MESSAGE-----

hQEMA9uWvE5LJ2ejAQgAgdgJUS0v+ASUy6B5/RsqDdm/3ll8VK3bq+GlNPdPUIca
hO2qmuJfgiwXWmNZtr4wSFLYOEU6l9PjM8lCS+U1dcv18XcX0v3cjIZKb/0EiABl
PLnxdI0Nnkk3RBrWICP1+DLE48rCuJQvdHLzZ8wsVw1Wh4/BizIvY+t7+TxSDKLy
4UissNE9C+lftBL7caIaSUOyeppoQCKUaM4TaRiJU/Yv0QpCZvp6x03dSoTkr10h
l73EhhlkhbwvAUAg8Sb2hX7bAFwR8qp6BC8XkbtZM5u2uqrYUAmXGIYmHWOYSvQZ
hsxj9jzPkt8Y+xIZ//+oXxhN0UFigwGHn5IbIlB2TNJ+AYMlUGxMiv13YoI19N09
aGTmms93QHI7c86kfJNi4bI20kDLOwZThFK3gXEpzVFFT0rD1LOVga3Dqw1VsO0N
EEcaZWs9POlc4rdeF3kn3ZSB0P3J77vidiaIFOh5lNpU/9k7nEmT9QE0K++fpTxs
obm9ZjahsnwNP10Vn2pQ
=rUbc
-----END PGP MESSAGE-----

*** Dummy Smtp Server Host

This is a dummy SMTP server definition that serves as a fallback when the genuine definition (encrypted above) is absent.

#+name: smtp-host
#+begin_src text
  smtp.dummy.com
#+end_src

*** Full Name                                   :crypt:

-----BEGIN PGP MESSAGE-----

hQEMA9uWvE5LJ2ejAQf/fpFgrhLTsuuXLWW4RU3WzAee1B+bBReCkH3mBbS/YWhO
8Cdle+MnLNbZ9WMOxZuSA8Zrb+6GM9rijC5UEwkT172KlmikttltCUyn4If6M/R3
zGyWy0Y0CAYL5QT7v/IMnBgwjo5nPvfjXQASbuvf/PhNZvl1Gi3Zcz+VAQGtFkhU
JK6h+HRb//NyzkwqY9WhXPxQePRxF2xQcFJnWLSg+viV5fid6ANRMBVPZAUhj1pg
Ew/uj4a4jGK14L2zrlhbtzYygpo3TrOiJRPJ2g8nmr9g6CBb7qAFo+27kqTPHk2P
qsZENoKtr3yzbLLL9SOOO0OD6A+bzH775hRySkt2ONJ/Ae8d3Fl+tke/QjaLpjC1
I17sR6dQ3Qz24BdNkg4rC5DvOftdqppf2vxJXN5Th7izSAmZHly6KGauoMi+qdnH
foMOc7y5cb5uQiPYIfNQICKo4Ut9yWjfnI79b94LUZopRTJpcVc7uCbcZ0E2iHTG
Kk2NxYDwNZELB7iqDq9mbQ==
=O5aZ
-----END PGP MESSAGE-----

*** Dummy Full Name

This is a dummy full name that serves as a fallback when the genuine (encrypted above) is absent or not available.

#+name: full-name
#+begin_src text :eval no
taro.yamada
#+end_src

*** My Private Email Address                    :crypt:
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 19:41]
:END:

-----BEGIN PGP MESSAGE-----

hQEMA9uWvE5LJ2ejAQgAtC7Jd2eChH/yaCKEx5ecJFRpmv0JJlymqJU7Jf2ShbgF
FQeDPbqQaBAyp/vV9RVxeiYV5EsOofTJYhlLvvdiv4zq4NiaaEDjrUblOGWxaEHp
KBMdKLqqLADM9RfvPv2vrofI7FtxAG7PF+wRFeW1vXyKakjhnPA/ydJpDdOIgjzh
HCPmcZnYObSz9pwKPM05Rhfd7eLtOtaWBCxmTLGHhVd9xU0dXJ3eQwO0OeqYns7l
QWq4lQ9Q825aZ7h+hKkamleVuKy8kjrBxnfdsyHGMaPUQlQcTTnNmS50+EmiHh4Z
0I9N+vIhAM6yuz5Y/C4pndMgggFjKYCpmVAnIJLLjdKBASx2bGgpUfmRqdHeOwY5
/3zipNj2QRjif9iZuSNdgthn2Yz0wtZuzwzc+CGib/fqtY+N5Nt36mhydgbac36v
y3bLp9UlGFAAUsqmvw1EP0nmtONIX+9SZDL3B08OV6OdtmmINKNAR/8rkDZN8o0d
5F/lEfK8uU00O1Cwjl6O8YK/
=qchL
-----END PGP MESSAGE-----

*** Dummy Private Email Address

This is a dummy email address that serves as a fallback when the genuine (encrypted above) is absent or not available.

#+name: email
#+begin_src text :eval no
  user@dummy.com
#+end_src

*** My Public Email Address
:PROPERTIES:
:CREATED:  [2025-02-07 Fri 22:21]
:END:

#+name: email-pub
#+begin_src text :eval no
public@p-snow.org
#+end_src

*** My Login Name

#+name: login-name
#+begin_src emacs-lisp :eval no-export
user-login-name
#+end_src

*** My Domain Name

#+name: my-domain
#+begin_src shell :eval no-export
echo -n "${EMAIL}" | cut -d'@' -f2
#+end_src

* Linux Distributions
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 14:59]
:END:
** Ubuntu
:PROPERTIES:
:CREATED:  [2022-10-06 Thu 15:32]
:END:

initialization script for a ubuntu account

#+begin_src bash :noweb yes :noweb-sep "\n\n" :tangle (expand-file-name "setup-ubuntu-desktop" tangle/local-bin-dir)
mkdir -p <<make-dir>>

apt-install
npm-install
start-systemd-services

<<ubuntu-setup>>
#+end_src

*** Apt Package Manager
:PROPERTIES:
:CREATED:  [2023-11-01 Wed 12:11]
:END:

- apt-managed packages
  #+begin_src shell :noweb tangle :tangle (expand-file-name "apt-install" tangle/local-bin-dir)
  sudo apt-get install -y \
       <<apt-pkg>>
  #+end_src
- update apt packages every weekend
  #+begin_src sh :eval no :tangle no :noweb-ref midnight-batch
  pwsudo apt update && pwsudo apt upgrade --yes
  #+end_src

** Linux Mint (Cinnamon DE)
:PROPERTIES:
:CREATED:  [2022-09-03 Sat 15:00]
:ID:       f3cd9a3b-9ff5-4cc8-807e-846f3f04c97a
:END:

- Back-up Cinnamon Desktop Configuration
  #+begin_src shell :eval no :noweb yes :tangle no :noweb-ref midnight-batch
  dconf dump /org/cinnamon/ > <<home-dir()>>/.local/state/cinnamon/desktop.conf
  #+end_src

- Commands/Applications that need to use LinuxMint comfortably
  #+begin_src scheme :noweb-ref guix-base
  "xclip"
  #+end_src

** GNU Guix

Below is Elisp code defining Guix templates for TempEL.

#+header: :shebang "eshell-mode minibuffer-mode"
#+begin_src emacs-lisp :tangle no :tangle (expand-file-name "guix.eld" tangle/dedicated-template-dir)
(guix-search "guix search " (p (my/region-string-trans-buffer)))
(activate-profiles "activate-profiles "
                   (completing-read "profiles: "
                                    (mapcar (lambda (elt)
                                              (string-join elt " "))
                                            (my/combinations
                                             '("base" "desktop" "emacs")))))
#+end_src

*** Channels

Guix channels of my choice, providing package definitions.

#+begin_src scheme :tangle (expand-file-name ".config/guix/base-channels.scm")
(list (channel
       (name 'nonguix)
       (url "https://gitlab.com/nonguix/nonguix"))
      (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git"))
      (channel
       (name 'guix-jp)
       (url "https://gitlab.com/guix-jp/channel")
       (branch "main"))
      (channel
       (name 'guix-science)
       (url "https://codeberg.org/guix-science/guix-science.git")
       (branch "master")
       (introduction
        (make-channel-introduction
         "b1fe5aaff3ab48e798a4cce02f0212bc91f423dc"
         (openpgp-fingerprint
          "CA4F 8CF4 37D7 478F DA05  5FD4 4213 7701 1A37 8446"))))
      (channel
       (name 'p-snow)
       (url "https://github.com/p-snow/guix-channel")
       (introduction
        (make-channel-introduction
         "3a10227fbc2d5e9744aced43f820a0d3bf64add5"
         (openpgp-fingerprint
          "CF56 FC53 3AD6 6A67 6FDC  1D73 0D2B AF0E 8AEF 0306")))))
#+end_src

A script for updating channels

This script makes it easy to update all channels to the latest commit based on an original channel file.

: update-channels

#+NAME: guix/update-channels
#+begin_src shell :tangle (expand-file-name "update-channels" tangle/local-bin-dir)
guix pull --channels=$HOME/.config/guix/base-channels.scm \
  && guix describe --format=channels > ~/.config/guix/channels.scm
#+end_src

*** Profiles

Below is an initialization code for Guix profiles in Bash.

#+NAME: guix/ex-prof
#+begin_src sh
echo -n '~/.guix-extra-profiles'
#+end_src

#+NAME: guix/bashrc
#+begin_src sh :noweb yes :noweb-ref bashrc
export GUIX_EXTRA_PROFILES=<<guix/ex-prof()>>

# fill in a variable below like a comment line
# if you'd like to acticate specific profiles under GUIX_EXTRA_PROFILES
ACTIVE_PROFILE_NAMES=()
# ACTIVE_PROFILE_NAMES=(base emacs)

profiles=()
if [ ${#ACTIVE_PROFILE_NAMES[@]} -eq 0 ]; then
  profiles="${GUIX_EXTRA_PROFILES}/*"
else
  for name in ${ACTIVE_PROFILE_NAMES[@]}; do
    profiles+=("${GUIX_EXTRA_PROFILES}/${name}")
  done
fi

for profile in ${profiles[@]}; do
  GUIX_PROFILE="${profile}/$(basename ${profile})"
  if [ -f ${GUIX_PROFILE}/etc/profile ]; then
    . "${GUIX_PROFILE}"/etc/profile
  fi
  if [ -d ${GUIX_PROFILE}/share ]; then
    export XDG_DATA_DIRS=${GUIX_PROFILE}/share${XDG_DATA_DIRS:+:}$XDG_DATA_DIRS
  fi
  if [ -d ${GUIX_PROFILE}/share/man ]; then
    export MANPATH=${GUIX_PROFILE}/share/man${MANPATH:+:}$MANPATH
  fi
done

# export GUIX_PROFILE="$HOME/.guix-profile"
# . "$GUIX_PROFILE/etc/profile"

export GUIX_PROFILE="$HOME/.config/guix/current"
. "$GUIX_PROFILE/etc/profile"


if [ -v GUIX_ENVIRONMENT ]; then
  if [[ $PS1 =~ (.*)"\\$" ]]; then
    PS1="${BASH_REMATCH[1]} [env]\\\$ "
  fi
fi
#+end_src

activate-profiles is a script that accepts space-separated profile names, whose packages will be fetched:

: activate-profiles base emacs

#+NAME: guix/activate-profile
#+begin_src shell :tangle (expand-file-name "activate-profiles" tangle/local-bin-dir)
GREEN='\033[1;32m'
RED='\033[1;30m'
NC='\033[0m'
GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

profiles=$*
if [ $# -eq 0 ]; then
  profiles="$HOME/.config/guix/manifests/*.scm";
fi

for profile in $profiles; do
  # Remove the path and file extension, if any
  profileName=$(basename $profile)
  profileName="${profileName%.*}"
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  manifestPath=$HOME/.config/guix/manifests/$profileName.scm

  if [ -f $manifestPath ]; then
    echo
    echo -e "${GREEN}Activating profile:" $manifestPath "${NC}"
    echo

    mkdir -p $profilePath
    guix package --manifest=$manifestPath --profile="$profilePath/$profileName"

    # Source the new profile
    GUIX_PROFILE="$profilePath/$profileName"
    if [ -f $GUIX_PROFILE/etc/profile ]; then
      . "$GUIX_PROFILE"/etc/profile
    else
      echo -e "${RED}Couldn't find profile:" $GUIX_PROFILE/etc/profile "${NC}"
    fi
  else
    echo "No profile found at path" $profilePath
  fi
done
#+end_src

- Automating Script
  Update packages in base profile at morning
  #+begin_src shell :eval no :tangle no :noweb-ref midnight-batch
  pwsudo -i guix pull && pwsudo systemctl restart guix-daemon.service
  update-channels && activate-profiles base emacs desktop && guix gc -d 1m -F 30G
  #+end_src

**** guix base profile

#+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/base.scm")
(specifications->manifest
 '("coreutils"
   "diffutils"
   "parallel"
   "gawk"
   "sed"
   "tar"
   "zip"
   "unzip"
   "zstd"
   "p7zip"
   "unrar"
   "shadow"
   "sshfs"
   "grep"
   "ripgrep"
   "man-db"
   "less"
   "pwgen"
   "file"
   "nkf"
   "lsof"
   "tree"
   "poppler"
   "stow"
   "pandoc"
   "nss-certs"
   "openssl"
   "glibc"
   "procps"
   "time"
   "htop"
   "net-tools"
   "curl"
   "wget"
   "httrack"
   "ghc-tldr"
   "network-manager"
   "wakelan"
   "speedtest-cli"
   "parted"
   "fdisk"
   "gptfdisk"
   "cryptsetup"
   "smartmontools"
   "ddrescue"
   "sqlite"
   "libarchive"
   "graphicsmagick"
   "pngquant"
   "ffmpeg@6.1.1" ; mpv requires version 6 of FFMPEG
   "dav1d"
   "jq"
   "pup"
   "htmlq"
   "util-linux"
   "binutils"
   "make"
   "llvm"
   "cmake"
   "libtool"
   "pkgconf"
   "yasm"
   "texinfo"
   "shellcheck"
   "global"
   "perl"
   "pfetch"
   "neofetch"
   "gcc-toolchain@13.3.0"
   "nasm"
   "libdrm"
   <<guix-base>>))
#+end_src

**** guix desktop profile

#+begin_src scheme :noweb yes :tangle (expand-file-name ".config/guix/manifests/desktop.scm")
(specifications->manifest
 '("gparted"
   "gcompris-qt"
   "gnome-disk-utility"
   "kdeconnect"
   "dia"
   "shotwell"
   "vlc"
   "ungoogled-chromium"
   "mullvadbrowser"
   "syncthing"
   <<guix-desktop>>))
#+end_src

**** guix creative profile                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-10-14 Sat 13:39]
:END:

#+begin_src shell :noweb yes
export XDG_DATA_DIRS=${GUIX_EXTRA_PROFILES}/creative/creative/share:${XDG_DATA_DIRS}
#+end_src

#+begin_src scheme :noweb yes :tangle no
(specifications->manifest
 '(<<guix-creative>>))
#+end_src

**** guix emacs profile

#+begin_src scheme :noweb yes :noweb-prefix no :tangle (expand-file-name ".config/guix/manifests/emacs.scm")
(specifications->manifest
 '(<<guix-emacs>>
   "sicp"
   "isync"
   "stunnel"
   "wordnet"
   "emacs-transient"
   "emacs-mocker"
   "emacs-compat"))
#+end_src

*** Home Configuration
:PROPERTIES:
:ID:       d882f2f6-c4cf-4d17-87e8-3fc5bbd3cc6b
:END:

#+begin_src scheme :noweb tangle :noweb-prefix no :tangle (expand-file-name "guix/home/home-config.scm" tangle/config-dir)
;; This "home-environment" file can be passed to 'guix home reconfigure'
;; to reproduce the content of your profile.  This is "symbolic": it only
;; specifies package names.  To reproduce the exact same profile, you also
;; need to capture the channels being used, as returned by "guix describe".
;; See the "Replicating Guix" section in the manual.

(use-modules (gnu home)
             (gnu home services)
             (gnu home services shells)
             (gnu home services ssh)
             (gnu home services dotfiles)
             (gnu packages)
             (gnu packages base)
             (gnu packages fonts)
             (gnu packages fontutils)
             (gnu packages gnupg)
             (gnu services)
             (guix gexp))

(home-environment
 ;; Below is the list of packages that will show up in your
 ;; Home profile, under ~/.guix-home/profile.
 (packages (list glibc-locales fontconfig which
                 font-iosevka font-ipa font-ipa-ex font-google-noto font-inconsolata
                 font-adobe-source-han-sans))

 ;; Below is the list of Home services.  To search for available
 ;; services, run 'guix home search KEYWORD' in a terminal.
 (services
  (list
   (simple-service 'basic-env-vars-service
                   home-environment-variables-service-type
                   `(("EMAIL" . "<<email>>")
                     ("VIEWER" . "less")
                     ("EDITOR" . "emacsclient -c -a emacs")))
   (service home-bash-service-type
            (home-bash-configuration
             (guix-defaults? #t)
             (aliases '(<<print-aliases(lang="scheme")>>))
             (bashrc (list (local-file "./.bashrc" "bashrc")))))
   (service home-openssh-service-type
            (home-openssh-configuration
             (hosts
              (list (openssh-host (name "pc-t480s")
                                  (host-name "192.168.100.126"))
                    (openssh-host (name "pc-k8p")
                                  (host-name "192.168.100.130"))
                    (openssh-host (name "pc-vmint01")
                                  (host-name "192.168.122.136"))))))
   (service home-dotfiles-service-type
            (home-dotfiles-configuration
             (layout 'plain)
             (source-directory
              (let ((path "~/dotfiles"))
                (if (string-prefix? "~" path)
                    (string-append (getenv "HOME") (substring path 1))
                    path)))
             (directories '("source")))))))
#+end_src

A script for activating home configuration

#+header: :shebang "eshell-mode minibuffer-mode"
#+begin_src emacs-lisp :tangle no :tangle (expand-file-name "activate-home.eld" tangle/dedicated-template-dir)
(activate-home "cd ~/dotfiles && make")
#+end_src

* Home Environment
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:14]
:END:
** Fontconfig                                 :ARCHIVE:

Fontconfig settings moved to Guix dissolved into [[id:d882f2f6-c4cf-4d17-87e8-3fc5bbd3cc6b][Home Configuration]].

# #+begin_src scheme :noweb-ref guix-base
# "fontconfig"
# #+end_src

# #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
#   fonts-ipafont-mincho fonts-ipafont-gothic
# #+end_src

fontconfig/fonts.conf
#+begin_src xml :noweb tangle :tangle no
<?xml version='1.0'?>
<!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
<fontconfig>
  <dir><<home-dir()>>/.guix-extra-profiles/base/base/share/fonts</dir>
</fontconfig>
#+end_src

install available fonts by rescanning font directories
#+begin_src conf :noweb yes :tangle no
fc-cache -rvf
#+end_src

** Bash

*** bashrc

#+BEGIN_SRC bash :noweb yes :tangle (expand-file-name "guix/home/.bashrc" tangle/config-dir) :comments no :shebang ""
export PATH="${HOME}/bin:${HOME}/.local/bin:${HOME}/.cargo/bin:$PATH"
export PS1="[\u@$(uname -n):\\W]\n\$ "

<<bashrc>>
#+END_SRC

*** bash functions                            :ARCHIVE:

#+begin_src sh :tangle (expand-file-name ".bash_functions")
  function cl() {
    DIR="$*";
    # if no DIR given, go home
    if [ $# -lt 1 ]; then
      DIR=$HOME;
    fi;

    builtin cd "${DIR}" && \
      # use your preferred ls command
      ls -F --color=auto
  }

  function cpuinfo {
    cores=$(nproc)
    frequency=$(grep MHz /proc/cpuinfo | head -1 | awk -F ' ' '{print $4" MHz"}')
    model=$(grep "model name" /proc/cpuinfo | head -1 | sed -r 's/^.{13}//')
    echo "CPU Model: $model"
    echo "CPU Cores: $cores"
    echo "Frequency: $frequency"
  }

  function dual() {
    if [ $# -eq 0 ]; then
      du_arg="./* ./.[^.]*"
    else
      du_arg=""
      for v in "$@"
      do
        if [ -f ${v} ]; then
          du_arg="${du_arg} ${v}"
        elif [ -d ${v} ]; then
          du_arg="${du_arg} ${v}/* ${v}/.[^.]*"
        fi
      done
    fi

    ionice -c2 -n7 nice -n19 du -scD ${du_arg} 2>/dev/null
  }
  export -f dual

  function mkcdir() {
    mkdir -p -- "$1" && cd -P -- "$1"
  }

  function rms() {
    read -p 'shred all files - are you sure (y/n) ? ' ans
    test x$ans == xy && (
      for file in "$@"; do
        if [ -f "${file}" ]; then
          shred -uzv "${file}"
        elif [ -d "${file}" ]; then
          find "${file}" -type f -exec shred -uzv {} \;
          rm -rf "${file}"
        fi
      done
    )
  }

  # A simple script to check on system resources
  function chksys() {
    clear

    echo "Memory Usage:"
    /usr/bin/free -h

    echo $'\n'$"Disk Usage:"
    /bin/df -h /dev/sd[a-z][1-9] 2>/dev/null

    echo $'\n'$"Uptime:"
    /usr/bin/uptime
  }
#+end_src

*** Shell Command Aliases

#+NAME: shell-aliases
| ..     | cd ../                            |    |
| e      | exit                              |    |
| l      | ls -F                             | $* |
| ll     | ls -lh                            | $* |
| lld    | l -ld                             | $* |
| la     | l -a                              | $* |
| lal    | l -alh                            | $* |
| cp     | cp -i                             | $* |
| mv     | mv -i                             | $* |
| rm     | rm -i                             | $* |
| rmf    | rm -rf                            | $* |
| mkdir  | mkdir -pv                         | $* |
| rmdir  | rmdir -v                          | $* |
| ipad   | hostname -I \vert cut -f1 -d' '       |    |
| kem    | pkill -kill emacs                 |    |

#+NAME: print-aliases
#+header: :var lang="plain"
#+begin_src emacs-lisp :results output :var aliases=shell-aliases
(seq-do-indexed (lambda (alias index)
                  (let ((ali (car alias))
                        (def (replace-regexp-in-string "\\\\vert" "|" (cadr alias)))
                        (param (caddr alias)))
                    (pcase lang
                      ('"plain"
                       (princ (funcall 'string-join `(,ali ,def ,param) " "))
                       (when (< index (1- (length aliases))) (princ "\n")))
                      ('"scheme"
                       (prin1 (funcall 'cons ali def))
                       (princ "\n")))))
                aliases)
#+end_src

** Systemd

#+begin_src shell :noweb tangle :tangle (expand-file-name "start-systemd-services" tangle/local-bin-dir)
<<systemd-service>>
#+end_src

*** systemd-tmpfiles
:PROPERTIES:
:ID:       44d6dd73-d34e-43f7-9026-e6439a05203e
:END:

[[https://www.freedesktop.org/software/systemd/man/systemd-tmpfiles-setup.service.html][systemd-tmpfiles]] manages file creation and deletion. I mainly use systemd-tmpfiles to delete obsolete files in specific directories by running the following command.

: $ systemd-tmpfiles --user --clean

or set up timer shown below.

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl --user enable systemd-tmpfiles-clean.timer
#+end_src

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name "user-tmpfiles.d/cleanup.conf" tangle/config-dir)
d /home/<<login-name()>>/tmp - - - 5d
d /home/<<login-name()>>/Downloads - - - 4w
<<tmpfiles-cleanup>>
#+end_src

** Vixie Cron

A script to reinitialize a set of cron jobs
#+begin_src bash :eval no :comments no :noweb tangle :tangle (expand-file-name "cron-reinit.sh" tangle/local-bin-dir)
crontab <<home-dir()>>/.config/crontab/<<login-name()>>
#+end_src

#+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
cron-reinit.sh
#+end_src

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name user-login-name ".config/crontab") :tangle-mode o444
MAILTO="<<email-pub>>"

BIN_DIR="<<home-dir()>>/bin"
LOG_DIR="<<log-dir()>>"

<<cronjob-user>>
#+end_src

** Btrfs

Btrfs is a CoW (Copy on Write) file system supports snapshot and send/recv mechanism.

#+begin_src scheme :noweb-ref guix-base
"btrfs-progs"
#+end_src

*** btrbk

[[https://digint.ch/btrbk/doc/btrbk.1.html][Btrbk]] supports for taking snapshots and backups

#+begin_src scheme :noweb-ref guix-base
"btrbk"
#+end_src

[[https://digint.ch/btrbk/doc/btrbk.conf.5.html][btrbk.conf documentation]]

- snapshot/backup cron job
  #+begin_src conf :noweb yes :noweb-ref cronjob-user
  ,*/15 * * * * /usr/bin/bash -ci "which btrbk | xargs -I _ pwsudo _ --config /etc/btrbk/btrbk.conf run"
  #+end_src

*** snapshots management                      :ARCHIVE:

A structure described below is expected under all devices.

/mountpoint/
├── backups
├── incumbents
└── snapshots

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_snap") :tangle-mode (identity #o755)
#!/usr/bin/env bash
set -euo pipefail

DATETIME=`date "+%Y%m%d-%H%M"`
BTRFS_MNTS=("/mnt/ssd01"
            "/mnt/nvme01")

# back up server data beforehand
ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit" \
  && rsync -arhv sv04:~/var/backup ~/share/sv04

# take snapshots for all btrfs subvolumes
for btrfs_mnt in ${BTRFS_MNTS[@]}; do
  if mountpoint ${btrfs_mnt} >/dev/null 2>&1; then
    for subv in ${btrfs_mnt}/incumbents/*; do
      subv_base=$(basename ${subv})
      if [ ! -d "${btrfs_mnt}/snapshots/${subv_base}" ]; then
        mkdir -p "${btrfs_mnt}/snapshots/${subv_base}"
      fi
      btrfs subvolume snapshot "${subv}" "${btrfs_mnt}/snapshots/${subv_base}/${DATETIME}"
    done
  fi
done
#+end_src

*** backup to another device                  :ARCHIVE:

: $ btrfs_back

#+begin_src shell :tangle (expand-file-name ".local/bin/btrfs_back") :tangle-mode (identity #o755)
#!/usr/bin/env bash
set -euo pipefail

MNT_SSD=/mnt/ssd01
MNT_HDD=/mnt/hdd01

function backup_subvol() {
  local _src_snap_dir=$1
  local _src_back_dir=$2
  local _dst_back_dir=$3

  echo "Name: $(basename ${_src_back_dir})"

  mkdir -pv "${_src_back_dir}"
  mkdir -pv "${_dst_back_dir}"

  src_back_last=$((ls -d "${_src_back_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename) || echo -n "")
  snap_last=$(ls -d "${_src_snap_dir}"/* 2>/dev/null | sort | tail -1 | xargs basename || echo -n "")

  # create readonly clone of last snapshot
  if [[ "${src_back_last}" < "${snap_last}" ]]; then
    echo btrfs subv snap -r "${_src_snap_dir}/${snap_last}" "${_src_back_dir}/${src_back_last}"
  fi

  exit;

  # determine parent btrfs subvolume
  parent=
  dst_backs=$(ls -d "${_dst_back_dir}"/* 2>/dev/null | sort || echo -n "")
  if [ ${#dst_backs} -ne 0 ]; then
    for dst_back in "${dst_backs[@]}"; do
      test=$(basename ${dst_back})
      if [ -d "${_src_back_dir}/${test}" ]; then
        parent=${test}
      fi
    done
  fi

  # determine subvolume to send in source device
  subvol=
  if [ ${#src_back_last} -ne 0 ]; then
    if [[ "${parent}" < "${src_back_last}" ]] && [ ! -d "${_dst_back_dir}/${src_back_last}" ]; then
      subvol=${src_back_last}
    fi
  fi

  echo "Parent: ${parent}"
  echo "Subvol: ${subvol}"

  if [ -n "${parent}" ] && [ -n "${subvol}" ]; then
    echo "Invoke incremental backup"
    sudo btrfs send -p "${_src_back_dir}/${parent}" "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
  elif [ -z "${parent}" ] && [ -n "${subvol}" ]; then
    echo "Invoke full backup"
    sudo btrfs send "${_src_back_dir}/${subvol}" | sudo btrfs receive "${_dst_back_dir}"
  fi

  echo "--------"
}

backup_subvol "${MNT_SSD}"/snapshots/doc "${MNT_SSD}"/backups/doc "${MNT_HDD}"/backups/doc
# backup_subvol "${MNT_SSD}"/snapshots/share "${MNT_SSD}"/backups/share "${MNT_HDD}"/backups/share
#+end_src
** XDG

#+begin_src scheme :noweb-ref guix-base
"xdg-utils"
#+end_src

*** xdg-mime
- ask default application for text/plain
  : $ xdg-mime query default text/plain

#+begin_src conf :tangle (expand-file-name ".config/mimeapps.list") :tangle-mode (identity #o644)
[Added Associations]
inode/directory=io.github.celluloid_player.Celluloid.desktop;nemo.desktop;

[Default Applications]
inode/directory=nemo.desktop
#+end_src

** GnuPG (gpg)
[[https://wiki.archlinux.org/title/GnuPG][
GnuPG - ArchWiki]]

I've chosen to use gpg/gpg-agent and pass on Ubuntu system since pass (password-store) spouts a warning saying there's gpg version mismatch persistently.
#+begin_src scheme :noweb-ref guix-base
;; "gnupg"
#+end_src

- gpg config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg.conf")
  with-keygrip
  #+end_src
- gpg-agent config
  #+begin_src conf :noweb tangle :tangle (expand-file-name ".gnupg/gpg-agent.conf")
  pinentry-program /usr/bin/pinentry-curses
  allow-emacs-pinentry
  allow-loopback-pinentry
  enable-ssh-support
  max-cache-ttl <<hours-in-sec(h=700)>>
  default-cache-ttl <<hours-in-sec(h=700)>>
  default-cache-ttl-ssh <<hours-in-sec(h=48)>>
  #+end_src
- mandatory config to use pinentry-curses for gpg-agent

  #+begin_src shell :noweb-ref bashrc
  export GPG_TTY=$(tty)

  # Refresh gpg-agent tty in case user switches into an X session
  gpg-connect-agent updatestartuptty /bye >/dev/null
  #+end_src

** Key Remappers
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:44]
:END:

*** Xremap                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:45]
:END:

[[https://github.com/k0kubun/xremap][Xremap]] is a key remapper for Wayland/X11. It's astoundingly fast, customizable and easy-to-use.

#+begin_src scheme :tangle no
"xremap-x11"
#+end_src

**** xremap config
:PROPERTIES:
:CREATED:  [2024-03-29 Fri 20:51]
:END:

#+NAME: config/xremap-main
#+begin_src yaml :tangle (expand-file-name ".config/xremap/config.yml") :comments no
modmap:
  - name: CapsCtrlSwap
    remap:
      CapsLock: Ctrl_L
      Ctrl_L: CapsLock
      Ctrl_R: Super_R
  - name: Enter as RCtrl
    remap:
      KEY_ENTER:
        held: Ctrl_R
        alone: KEY_ENTER
        alone_timeout_millis: 500
  - name: Quote as Hyper
    remap:
      KEY_APOSTROPHE:
        held: Super_L
        alone: KEY_APOSTROPHE
        alone_timeout_millis: 300
  - name: SandS
    remap:
      Space:
        held: Shift_L
        alone: Space
        alone_timeout_millis: 500
  - name: Left/Right Shift to Equal/Minus
    remap:
      Shift_L:
        held: Shift_L
        alone: KEY_EQUAL
        alone_timeout_millis: 300
      Shift_R:
        held: Shift_R
        alone: KEY_MINUS
        alone_timeout_millis: 300
keymap:
  - name: M-u/H-u to C-u
    exact_match: true
    remap:
      M-KEY_U: Ctrl-KEY_U
      Super-KEY_U: Ctrl-KEY_U
  - name: asdf1234
    exact_match: true
    remap:
      C-Super-a: KEY_1
      C-Super-s: KEY_2
      C-Super-d: KEY_3
      C-Super-f: KEY_4
      C-Super-g: KEY_5
      C-Super-h: KEY_6
      C-Super-j: KEY_7
      C-Super-k: KEY_8
      C-Super-l: KEY_9
      C-Super-semicolon: KEY_0
#+end_src

As of [2024-03-29 Fri], the following configuration to propagate Emacs key bindings for all applications except Emacs does not seem to work correctly.

#+NAME: config/xremap-emacs
#+begin_src yaml :tangle (expand-file-name ".config/xremap/emacs.yml") :comments no
# keymap:
#   - name: Emacs
#     application:
#       not: [emacs.Emacs]
#     remap:
#       # Cursor
#       C-b: { with_mark: left }
#       C-f: { with_mark: right }
#       C-p: { with_mark: up }
#       C-n: { with_mark: down }
#       # Forward/Backward word
#       M-b: { with_mark: C-left }
#       M-f: { with_mark: C-right }
#       # Beginning/End of line
#       C-a: { with_mark: home }
#       C-e: { with_mark: end }
#       # Page up/down
#       M-v: { with_mark: pageup }
#       C-v: { with_mark: pagedown }
#       # Beginning/End of file
#       M-Shift-comma: { with_mark: C-home }
#       M-Shift-dot: { with_mark: C-end }
#       # Newline
#       C-m: enter
#       C-j: enter
#       C-o: [enter, left]
#       # Copy
#       C-w: [C-x, { set_mark: false }]
#       M-w: [C-c, { set_mark: false }]
#       C-y: [C-v, { set_mark: false }]
#       # Delete
#       C-d: [delete, { set_mark: false }]
#       M-d: [C-delete, { set_mark: false }]
#       # Kill line
#       C-k: [Shift-end, C-x, { set_mark: false }]
#       # Kill word backward
#       Alt-backspace: [C-backspace, {set_mark: false}]
#       # set mark next word continuously.
#       C-M-space: [C-Shift-right, {set_mark: true}]
#       # Undo
#       C-slash: [C-z, { set_mark: false }]
#       C-Shift-ro: C-z
#       # Mark
#       C-space: { set_mark: true }
#       # Search
#       C-s: C-f
#       C-r: Shift-F3
#       M-Shift-5: C-h
#       # Cancel
#       C-g: [esc, { set_mark: false }]
#       # C-x YYY
#       # C-x:
#       #   remap:
#       #     # C-x h (select all)
#       #     h: [C-home, C-a, { set_mark: true }]
#       #     # C-x C-f (open)
#       #     C-f: C-o
#       #     # C-x C-s (save)
#       #     C-s: C-s
#       #     # C-x k (kill tab)
#       #     k: C-f4
#       #     # C-x C-c (exit)
#       #     C-c: C-q
#       #     # C-x u (undo)
#       #     u: [C-z, { set_mark: false }]
#+end_src

**** xremap systemd service
:PROPERTIES:
:CREATED:  [2023-02-23 Thu 17:49]
:END:

#+begin_src conf :noweb yes :tangle no
sudo systemctl enable xremap
sudo systemctl start xremap
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name "etc/systemd/system/xremap.service" tangle/system)
[Unit]
Description=xremap daemon

[Service]
ExecStart=<<which(filename="xremap")>> --watch=device,config <<conf-dir()>>/xremap/config.yml <<conf-dir()>>/xremap/emacs.yml
Restart=always
Type=simple

[Install]
WantedBy=multi-user.target
#+end_src

*** XKB                                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-19 Sun 15:32]
:END:

#+begin_src scheme :noweb-ref no
"xkeyboard-config"
"setxkbmap"
"xkbcomp"
#+end_src

- 通常の'setxkbmap -print'の出力からシンボルctrl(swapcaps)を加えたもの (CtrlとCapsLockの入替)
  #+begin_src conf :tangle (expand-file-name ".config/xkb/keymap/keymap.xkb")
  xkb_keymap {
  xkb_keycodes  { include "evdev+aliases(qwerty)"	};
  xkb_types     { include "complete"	};
  xkb_compat    { include "complete"	};
  xkb_symbols   { include "pc+us+inet(evdev)+group(win_space_toggle)+ctrl(swapcaps)+terminate(ctrl_alt_bksp)"	};
  xkb_geometry  { include "pc(pc105)"	};
  };
  #+end_src

**** xkb user systemd service
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 18:45]
:END:

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/start-xkb") :shebang #!/bin/bash :tangle-mode (identity #o755)
<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY 2>/dev/null
#+end_src

# #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
#+begin_src conf :tangle no
systemctl --user enable xkb
systemctl --user start xkb
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/user/xkb.service")
[Unit]
Description=xkb
# Wants=systemd-udev-settle.service
# After=systemd-udev-settle.service

[Service]
ExecStart=<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY

[Install]
# WantedBy=default.target
WantedBy=basic.target
# WantedBy=graphical-session.target

# [Unit]
# Description=Custom xkb layout service

# [Service]
# # ExecStart=/usr/bin/setxkbmap -layout us -variant altgr-intl -option grp:ctrl_shift_toggle
# ExecStart=<<which(filename="xkbcomp")>> -I<<conf-dir()>>/xkb/ <<conf-dir()>>/xkb/keymap/user.xkb $DISPLAY
# Restart=always

# [Install]
# WantedBy=multi-user.target
#+end_src

*** Interception Tools                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:02]
:END:

[[https://gitlab.com/interception/linux/tools][Interception Tools]] offers a set of programs to change key event by intervening evdev which is low layer key event managing program.

#+begin_src scheme :noweb-ref no
"interception-dual-function-keys"
"interception-tools"
#+end_src

**** udevmon
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:10]
:END:

#+begin_src yaml :noweb tangle :tangle (expand-file-name ".config/interception/udevmon.yaml")
- JOB: "<<which(filename="intercept")>> -g $DEVNODE | <<which(filename="dual-function-keys")>> -c <<home-dir()>>/.config/interception/dual-function-keys.yaml | <<which(filename="uinput")>> -d $DEVNODE"
DEVICE:
EVENTS:
EV_KEY: [KEY_ENTER]
LINK: .*_Realforce_103-event-kbd
#+end_src

***** udevmon systemd service

# #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
#   sudo systemctl enable udevmon
#   sudo systemctl start udevmon
# #+end_src

# #+begin_src conf :noweb tangle :tangle (expand-file-name ".config/systemd/system/udevmon.service")
#+begin_src conf :noweb tangle :tangle no
[Unit]
Description=udevmon
Wants=systemd-udev-settle.service
After=systemd-udev-settle.service

[Service]
ExecStart=<<which(filename="pwsudo")>> <<which(filename="nice")>> -n -20 <<which(filename="udevmon")>> -c <<home-dir()>>/.config/interception/udevmon.yaml

[Install]
WantedBy=multi-user.target
#+end_src

**** dual function keys
:PROPERTIES:
:CREATED:  [2023-02-22 Wed 13:09]
:END:

[[https://man.archlinux.org/man/community/interception-dual-function-keys/dual-function-keys.1.en][dual-function-keys]] is constituent of Interception Tools. It allows users to add a function to the key resulting to impart two capability for one key exerted at tapped and held.

#+begin_src yaml :tangle (expand-file-name ".config/interception/dual-function-keys.yaml")
TIMING:
TAP_MILLISEC: 400
DOUBLE_TAP_MILLISEC: 150

MAPPINGS:
- KEY: KEY_ENTER
TAP: KEY_ENTER
HOLD: KEY_RIGHTCTRL
# space for shift on hold
- KEY: KEY_SPACE
TAP: KEY_SPACE
HOLD: KEY_LEFTSHIFT
- KEY: KEY_LEFTSHIFT
TAP: KEY_MINUS
HOLD: KEY_LEFTSHIFT
- KEY: KEY_RIGHTSHIFT
TAP: KEY_EQUAL
HOLD: KEY_RIGHTSHIFT
#+end_src

*** keyd
:PROPERTIES:
:CREATED:  [2024-10-23 Wed 13:24]
:END:

[[https://github.com/rvaiya/keyd][keyd]] is a key remapping daemon for Linux. It is fast with concise configuration introducing layer mechanism.

#+begin_src conf :tangle no :noweb yes :noweb-ref systemd-service
sudo systemctl enable keyd
sudo systemctl start keyd
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name "common/etc/keyd/default.conf" tangle/system)
[ids]

,*

[global]

oneshot_timeout = 1000

[main]

capslock = oneshot(control)
; leftcontrol = oneshot(capslock)
tab = overload(numpad_layer, tab)
rightcontrol = oneshot(app_layer)
space = overload(shift, space)
' = lettermod(apostrophe_layer, ', 50, 180)
` = lettermod(app_layer, `, 50, 180)
leftcontrol = overload(app_layer, capslock)

leftshift = overload(shift, =)
rightshift = overload(shift, -)

[apostrophe_layer:M]

u = C-u

[numpad_layer:C-M]

m = 1
, = 2
. = 3
j = 4
k = 5
l = 6
u = 7
i = 8
o = 9
space = 0
; = -
/ = .

[app_layer:C-A-M]
#+end_src

* Application Configurations

#+name: user-bin-dir
#+begin_src emacs-lisp :noweb yes
(expand-file-name "~/.local/bin")
#+end_src

** GNU Emacs
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:22]
:CUSTOM_ID: gnu-emacs
:header-args:emacs-lisp+: :tangle-mode (identity #o644)
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
;; "emacs"
"emacs-next"
#+end_src

#+NAME: emacs-var-dir
#+begin_src emacs-lisp :tangle no
no-littering-var-directory
#+end_src

*** Basic Configuration
:PROPERTIES:
:header-args:emacs-lisp+: :tangle (expand-file-name "base-config.el" tangle/emacs-config-dir)
:CREATED:  [2023-01-20 Fri 10:22]
:END:

**** early-init.el
:PROPERTIES:
:header-args:emacs-lisp+: :tangle (expand-file-name "early-init.el" tangle/user-emacs-directory)
:END:

Early init file defines fundamental variables used from both normal Emacs session and batch mode.

***** Paths for tangling
:PROPERTIES:
:ID:       e69ebc68-c604-4f37-b61b-59f4fb5440b0
:END:

Variables that start with "tangle/" and are used during the tangling process are also required for the main Emacs session.

#+begin_src emacs-lisp :noweb tangle
<<tangle-def()>>
#+end_src

#+NAME: tangle-def
#+begin_src emacs-lisp :tangle no
(let ((syms (string)))
  (obarray-map (lambda (sym)
                 (when (string-prefix-p "tangle/" (symbol-name sym))
                   (setq syms
                         (concat syms
                                 (format "(setq %s \"%s\")\n"
                                         sym (symbol-value sym))))))
               obarray)
  syms)
#+end_src

***** package.el

#+begin_src emacs-lisp
(require 'package)

(setopt package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("nongnu" . "https://elpa.nongnu.org/nongnu/")
          ("melpa" . "https://melpa.org/packages/")
          ("p-snow" . "https://p-snow.org/packages/")))
(setopt package-archive-priorities
        '(("gnu" . 3)
          ("melpa" . 2)
          ("nongnu" . 1)))
(setopt package-enable-at-startup t)

(require 'package-vc)

(package-initialize)
#+end_src

***** load cl-lib

Use 'cl-lib' rather than 'cl' package since it is [[https://www.gnu.org/savannah-checkouts/gnu/emacs/news/NEWS.27.1][officially deprecated]].

#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src

***** use-package

[[https://jwiegley.github.io/use-package/][Official manual]] is handy especially when you look up [[https://jwiegley.github.io/use-package/keywords/][Keywords]].

#+begin_src emacs-lisp
(require 'use-package)
(require 'use-package-ensure)

(setopt use-package-compute-statistics t
        use-package-verbose nil)
(with-eval-after-load 'my-launch-app
  (keymap-set my/launch-app-map (kbd "u")
              #'use-package-report))
#+end_src

use-package depends on following packages internally

****** diminish

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-diminish"
#+end_src

****** delight

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-delight"
#+end_src

***** straight.el                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 20:17]
:END:

#+begin_src emacs-lisp :tangle no
(customize-set-variable 'straight-recipes-gnu-elpa-use-mirror t)
(customize-set-variable 'straight-base-dir user-emacs-directory)
(customize-set-variable 'straight-vc-git-default-clone-depth 1)

(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(with-eval-after-load 'hydra
  (defhydra hydra-straight (global-map "C-x -"
                                       :color blue)
    "Straight"
    ("c" straight-check-package)
    ("C" straight-check-all)
    ("r" straight-rebuild-package)
    ("R" straight-rebuild-all)
    ("f" straight-fetch-package)
    ("F" straight-fetch-all)
    ("p" straight-pull-package-and-deps)
    ("P" straight-pull-all)
    ("m" straight-merge-package)
    ("M" straight-merge-all)
    ("n" straight-normalize-package)
    ("N" straight-normalize-all)
    ("u" straight-push-package)
    ("U" straight-push-all)
    ("v" straight-freeze-versions)
    ("V" straight-thaw-versions)
    ("w" straight-watcher-start)
    ("W" straight-watcher-quit)
    ("g" straight-get-recipe)
    ("e" straight-prune-build)
    ("q" nil)))
#+end_src

***** safe local eval forms
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 10:19]
:END:

Following hook statements are likely written in .dir-locals.el at the top level of git repositories.

#+begin_src emacs-lisp
(add-to-list 'safe-local-eval-forms
             '(add-hook 'find-file-hook
                        (lambda () (setq-local buffer-save-without-query t))))

(add-to-list 'safe-local-eval-forms
             '(remove-hook 'find-file-hook
                           (lambda () (setq-local buffer-save-without-query t))))
#+end_src

***** no-littering
:PROPERTIES:
:CREATED:  [2024-02-04 Sun 16:29]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-no-littering"
#+end_src

#+NAME: config/emacs-no-littering
#+begin_src emacs-lisp :noweb tangle
(setq no-littering-var-directory
      (abbreviate-file-name (file-name-concat user-emacs-directory "var")))

(require 'no-littering)
#+end_src

**** loading sequence

***** custom file
:PROPERTIES:
:CREATED:  [2023-01-10 Tue 18:48]
:END:

#+begin_src emacs-lisp
(setopt custom-file
        (expand-file-name "custom.el" user-emacs-directory))

(when (file-readable-p custom-file)
  (load custom-file))
#+end_src

***** init.el
:PROPERTIES:
:CREATED:  [2022-12-24 Sat 14:56]
:END:

init.el devote itself to call for remaining config files.

#+begin_src emacs-lisp :tangle (expand-file-name "init.el" tangle/user-emacs-directory)
(push (file-name-concat user-emacs-directory "lisp") load-path)
(push (file-name-concat user-emacs-directory "site-lisp") load-path)

(let ((load-match "\\.el$"))
  (mapc #'load-file
        (append (directory-files (file-name-concat user-emacs-directory "lisp") t load-match)
                (directory-files (file-name-concat user-emacs-directory "lisp/dedicated") t load-match))))
#+end_src

**** Themes

The theme of my choice at present

#+begin_src emacs-lisp
(with-eval-after-load 'ef-themes
  (load-theme 'ef-bio :no-confirm))
#+end_src

***** modus-themes

I love modus-theme which [[https://protesilaos.com/codelog/2019-08-07-emacs-modus-themes/][conforms to WCAG AAA]]. [[https://protesilaos.com/codelog/2022-04-21-modus-themes-colour-theory/][This blog post]] explains how this package determines colors theoretically and perceptually.

Following configuration is for version 4 of modus-themes which takes breaking change from previous major version.

#+begin_src emacs-lisp
(use-package modus-themes
  :disabled t
  :custom
  (modus-themes-to-toggle '(modus-vivendi
                            modus-vivendi-tinted
                            modus-vivendi-deuteranopia))
  (modus-themes-org-blocks 'tinted-background)
  (modus-themes-bold-constructs t)
  :config
  (customize-set-variable 'modus-themes-common-palette-overrides
                          modus-themes-preset-overrides-faint)
  (bind-keys ("<f6>" . modus-themes-toggle)))
#+end_src

***** ef-themes
:PROPERTIES:
:CREATED:  [2023-05-15 Mon 15:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ef-themes"
#+end_src

#+begin_src emacs-lisp
(use-package ef-themes
  :init
  (setq ef-bio-palette-overrides
        '((cursor "#ffffff")))
  :custom
  (ef-themes-to-toggle ef-themes-dark-themes)
  :config
  (bind-keys ("<f9>" . ef-themes-toggle)))
#+end_src

**** Basic Preferences

Settings in this section are influenced a great deal by my personal preference. Please be meticulous when you borrow.

***** Modifier Keys

#+begin_src emacs-lisp
(cond
 ((string= window-system "x")
  (setf x-meta-keysym 'meta
        x-alt-keysym 'meta
        x-super-keysym 'hyper))
 ((string= window-system "ns")
  ;; IME inline patch
  (setf mac-use-input-method-on-system nil)
  (setf mac-control-modifier       'control
        mac-command-modifier       'meta
        mac-option-modifier        'super
        mac-right-option-modifier  'alt
        mac-right-control-modifier 'super
        mac-function-modifier      'hyper)))
#+end_src

***** Basic Key Bindings

#+begin_src emacs-lisp
(keymap-global-set "M-F" #'forward-to-word)
(keymap-global-set "M-B" #'backward-to-word)
(keymap-global-set "C-x M-F" #'forward-paragraph)
(keymap-global-set "C-x M-B" #'backward-paragraph)
(keymap-global-set "C-c d" #'duplicate-dwim)
(keymap-global-set "C-c j" #'join-line)
(keymap-global-set "C-c M-d" #'copy-from-above-command)
(keymap-global-set "M-z" #'zap-up-to-char)
(keymap-global-set "C-z" #'repeat)
(keymap-global-set "C-x M-t" #'transpose-sentences)
(keymap-global-set "M-T" #'transpose-paragraphs)

(keymap-global-set "C-;" #'backward-delete-char)
(keymap-global-set "C-:" #'backward-kill-word)

(keymap-global-set "C-c k" #'kill-current-buffer)
(keymap-global-set "C-x M-r" #'rename-visited-file)
(keymap-global-set "C-M-<delete>" #'restart-emacs)
(keymap-global-set "C-M-S-<delete>" #'save-buffers-kill-emacs)

(substitute-key-definition 'upcase-region
                           'upcase-dwim
                           global-map)
(substitute-key-definition 'downcase-region
                           'downcase-dwim
                           global-map)
(keymap-global-set "C-x C-c" #'capitalize-dwim)
#+end_src

- Bind for C-x C-b, use [[help:ibuffer][ibuffer]] which has more features than [[help:list-buffers][list-buffers]] based on [[https://irreal.org/blog/?p=10329][this advice]].
  #+begin_src emacs-lisp
  (substitute-key-definition 'list-buffers
                             'ibuffer
                             global-map)
  #+end_src

- bind find-functions and finder commands
  #+begin_src emacs-lisp
  (find-function-setup-keys)

  (keymap-set ctl-x-map "C" 'finder-commentary)
  #+end_src

***** Unleash Disabled Commands
:PROPERTIES:
:CREATED:  [2023-07-01 Sat 13:59]
:END:

#+begin_src emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'set-goal-column 'disabled nil)
(put 'buffer-save-without-query 'disabled nil)
(put 'scroll-left 'disabled nil)
(put 'scroll-right 'disabled nil)
#+end_src

***** Language
:PROPERTIES:
:CUSTOM_ID: emacs-language
:END:

[[info:emacs#Language Environments][emacs#Language Environments]]

#+begin_src emacs-lisp
;; language and locale
(set-language-environment "Japanese")
(setq system-time-locale "C")

;; coding system
(set-default-coding-systems 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
(set-selection-coding-system 'utf-8-unix)

;; prefer-coding-system take effect equally to follows
(set-buffer-file-coding-system 'utf-8-unix)
(set-file-name-coding-system 'utf-8-unix)
(set-terminal-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8-unix)
(setq locale-coding-system 'utf-8-unix)
#+end_src

***** Fontsets
:PROPERTIES:
:CUSTOM_ID: emacs-fontset
:END:

#+begin_src emacs-lisp
(create-fontset-from-ascii-font "IPAGothic" nil "default")

(create-fontset-from-ascii-font "IPAexMincho" nil "exmincho")
(set-fontset-font "fontset-exmincho" 'japanese-jisx0208 "IPAexMincho")

(create-fontset-from-ascii-font "IPAexGothic" nil "exgothic")
(set-fontset-font "fontset-exgothic" 'japanese-jisx0208 "IPAexGothic")

(create-fontset-from-ascii-font "IPAMincho" nil "mincho")
(set-fontset-font "fontset-mincho" 'japanese-jisx0208 "IPAMincho")
(set-fontset-font "fontset-mincho" 'symbol "IPAMincho")

(create-fontset-from-ascii-font "Iosevka" nil "code")
(set-fontset-font "fontset-code" 'latin (font-spec :family "Iosevka" :weight 'Light :width 'Normal))

;; foreign fonts for all fontsets
(set-fontset-font t 'emoji "Noto Color Emoji")
(set-fontset-font t 'symbol "Noto Sans CJK JP" nil 'append)
(set-fontset-font t 'symbol "Noto Sans Symbols" nil 'append)
(set-fontset-font t 'symbol "Noto Sans Symbols2" nil 'append)
#+end_src

***** Faces
:PROPERTIES:
:CREATED:  [2022-09-11 Sun 16:55]
:ID:       9edc9c6a-607c-4a06-8f75-c04de9a32abb
:CUSTOM_ID: emacs-face
:END:

Caveat: [[https://en.wikipedia.org/wiki/Leber%27s_hereditary_optic_neuropathy][I am visually impaired]], so the font size for the default face is extraordinarily large.

| face name           | font        |
|---------------------+-------------|
| default             | IPAGothic   |
| fixed-pitch         | IPAMincho   |
| fixed-pitch-serif   | Iosevka     |
| variable-pitch      | IPAExMincho |
| variable-pitch-text | IPAExGothic |

#+NAME: config/emacs-face
#+begin_src emacs-lisp
(defvar my/default-pixel-width 2560 "Default display width in pixel.")
(defmacro my/normalized-font-size (original-size)
  "This macro culculates normalized font size for display resolution at runtime.
It tries to proportionate ORIGINAL-SIZE in `my/default-pixel-width' in the display at runtime."
  `(truncate (* ,original-size (/ (float (x-display-pixel-width))
                                  ,my/default-pixel-width))))

(set-face-attribute 'default
                    nil
                    :font "fontset-default"
                    :height (my/normalized-font-size 620))
(set-face-attribute 'fixed-pitch
                    nil
                    :font "fontset-mincho")
(set-face-attribute 'fixed-pitch-serif
                    nil
                    :font "fontset-code")
(set-face-attribute 'variable-pitch
                    nil
                    :font "fontset-exmincho")
(set-face-attribute 'variable-pitch-text
                    nil
                    :font "fontset-exgothic")

(use-package face
  :no-require t
  :hook
  ((eww-mode mastodon-mode nov-mode mu4e-view-mode elfeed-show-mode)
   . (lambda ()
       (buffer-face-set (check-face 'variable-pitch-text))
       (text-scale-set 5.0)))
  ((Info-mode help-mode helpful-mode woman-mode devdocs-mode)
   . (lambda ()
       (buffer-face-set (check-face 'default))
       (text-scale-set 1.3)))
  ((org-mode text-mode mu4e-compose-mode)
   . (lambda ()
       (buffer-face-set (check-face 'default))))
  ((prog-mode shell-mode term-mode vterm-mode eshell-mode calendar-mode)
   . (lambda ()
       (buffer-face-set (check-face 'fixed-pitch-serif))
       (text-scale-set -1.2)))
  ((dired-mode mu4e-headers-mode elfeed-search-update)
   . (lambda ()
       (buffer-face-set (check-face 'fixed-pitch)))))
#+end_src

***** Performance Tuning
:PROPERTIES:
:CREATED:  [2022-09-16 Fri 12:08]
:END:

#+begin_src emacs-lisp
(setq auto-window-vscroll nil)
(setq-default bidi-display-reordering nil)
(setq bidi-inhibit-bpa t)
#+end_src

**** Custom Variables
:PROPERTIES:
:ID:       587bc395-6321-4f59-97e6-6f0b62518b20
:END:

Entries in this section represnets [[info:emacs#Customization Groups][Customization Groups]] hierarchy.

***** Files
:PROPERTIES:
:ID:       1a73e0cf-f851-4f48-9a22-1ec37fdcf960
:END:

#+begin_src emacs-lisp
(setopt create-lockfiles nil
        remote-file-name-inhibit-locks t)
#+end_src

****** Auto Revert

[[info:emacs#Auto Revert][Auto Revert]]: Keeping buffers automatically up-to-date.

#+begin_src emacs-lisp
(use-package autorevert
  :diminish (global-auto-revert-mode auto-revert-mode)
  :custom
  (auto-revert-verbose nil)
  (global-auto-revert-non-file-buffers t)
  (auto-revert-interval 3)
  (auto-revert-check-vc-info t)
  (global-auto-revert-mode t))
#+end_src

****** Auto Save

[[info:emacs#Auto Save][Auto Save mode]] saves the file you are editing periodically, whereas [[help:auto-save-visited-mode][auto-save-visited-mode]] saves all  open buffers in Emacs session.

#+begin_src emacs-lisp :noweb tangle
(setopt auto-save-default t
        auto-save-interval 200
        auto-save-timeout 25
        auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/files") t))
        delete-auto-save-files t
        kill-buffer-delete-auto-save-files t
        auto-save-no-message t)

(setopt auto-save-visited-mode t
        auto-save-visited-interval 10)
(put 'auto-save-visited-mode 'disabled nil)

(setopt delete-by-moving-to-trash t)
(setopt save-some-buffers-default-predicate 'save-some-buffers-root)
#+end_src

****** Uniquify

[[info:emacs#Uniquify][Uniquify]] shows buffer name easy to distinguish.

#+begin_src emacs-lisp
(use-package uniquify
  :custom
  (uniquify-buffer-name-style 'post-forward))
#+end_src

****** Recentf

[[info:emacs#File Conveniences][emacs#File Conveniences]]

#+begin_src emacs-lisp
(use-package recentf
  :bind ("H-r" . recentf)
  :hook (after-init . recentf-mode)
  :custom
  (recentf-exclude '(".gz" ".xz" ".zip" ".gpg"))
  (recentf-max-saved-items 1000)
  ;; clean-up when idle time reaches 7 minutes
  (recentf-auto-cleanup (* 7 60)))
#+end_src

****** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer t
  :custom
  (tramp-default-method "ssh")
  :config
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  (add-to-list 'tramp-remote-path "~/bin"))
#+end_src

****** Find File

#+begin_src emacs-lisp
(setopt large-file-warning-threshold 300000000)
(setopt revert-buffer-quick-short-answers t)
#+end_src

****** Backup
:PROPERTIES:
:CREATED:  [2023-10-13 Fri 09:53]
:END:

I no longer use backup functionality. Even if I reinstate it, backing up by copying must be rational.

#+begin_src emacs-lisp
(setopt make-backup-files nil
        backup-by-copying t
        backup-directory-alist
        `(("." . ,(no-littering-expand-var-file-name "backup"))))
#+end_src

***** Environment

****** Initialization
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:24]
:END:

#+begin_src emacs-lisp
(setopt initial-scratch-message "")
(setopt inhibit-startup-screen t)
#+end_src

****** Frames

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

******* Fringe
:PROPERTIES:
:CREATED:  [2023-09-15 Fri 08:53]
:END:

#+begin_src emacs-lisp
(set-fringe-mode 15)
(setq-default indicate-buffer-boundaries 'left)
#+end_src

******* Two Column
:PROPERTIES:
:CREATED:  [2023-09-07 Thu 10:45]
:END:

#+begin_src emacs-lisp
(use-package two-column
  :commands (2C-two-columns 2C-split 2C-associate-buffer)
  :custom
  (2C-window-width 25))
#+end_src

******* Desktop
:PROPERTIES:
:CREATED:  [2022-12-20 Tue 16:06]
:END:

[[info:emacs#Saving Emacs Sessions][Info manual for Saving Emacs Sessions]] describes how to set up desktop-save-mode.
'--no-desktop' option for emacs command will disable forcibly desktop-save-mode .

#+begin_src emacs-lisp
(use-package desktop
  :commands (desktop-save)
  :custom
  (desktop-restore-frames t)
  (desktop-restore-eager 1)
  (desktop-lazy-idle-delay 5)
  :config
  (desktop-change-dir (expand-file-name "desktop" user-emacs-directory))
  (desktop-save-mode 1))
#+end_src

******* Cursor

#+begin_src emacs-lisp
(setopt blink-cursor-blinks 15
        blink-cursor-delay 0.7
        blink-cursor-interval 0.35
        blink-cursor-mode t)
#+end_src

******* Scrolling
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 00:14]
:END:

#+begin_src emacs-lisp
(setopt fast-but-imprecise-scrolling t)
#+end_src

****** Display

#+begin_src emacs-lisp
;; do not use visual bell
(setopt visible-bell nil)

(setopt text-scale-mode-step 1.0625
        highlight-nonselected-windows t
        truncate-lines t
        x-underline-at-descent-line nil)
;; avoid to break at whitespace in Japanese
(setopt word-wrap-by-category t)
;; suppress curved quotes in docstring (for emacs25)
(setopt text-quoting-style 'straight)
;; resize frame size responding to font size
(setopt global-text-scale-adjust-resizes-frames t)
#+end_src

****** Windows

[[https://www.masteringemacs.org/article/demystifying-emacs-window-manager?utm_source=newsletter&utm_medium=email&utm_campaign=rss][This blog post]] is must-read when you tweak display-buffer facilities or something related to display settings.

#+begin_src emacs-lisp
(setopt scroll-step 1
        scroll-conservatively 101
        next-screen-context-lines 2
        scroll-preserve-screen-position t)
;; display buffer
(setopt display-buffer-base-action
        '((display-buffer-same-window
           display-buffer-reuse-window
           display-buffer-reuse-mode-window
           display-buffer-in-previous-window)))

(bind-keys :map other-window-repeat-map
           ("0" . delete-window)
           ("1" . delete-other-windows))
#+end_src

******* Winner

Triple Escape (M-ESC ESC) has got to reset window layout by tweaking buffer-quit-function.

#+begin_src emacs-lisp
(use-package winner
  :bind (("H-z" . winner-undo)
         ("H-M-z" . winner-redo))
  :custom
  (winner-mode t)
  :config
  (setq buffer-quit-function 'winner-undo))
#+end_src

******* Windmove

You can now switch windows with your shift key by pressing S-<left>, S-<right>, S-<up>, S-<down>.

#+begin_src emacs-lisp
(use-package windmove
  :bind (("C-x C-<left>"    . windmove-left)
         ("C-x C-<right>"   . windmove-right)
         ("C-x C-<up>"      . windmove-up)
         ("C-x C-<down>"    . windmove-down)
         ("C-x C-S-<left>"  . windmove-swap-states-left)
         ("C-x C-S-<right>" . windmove-swap-states-right)
         ("C-x C-S-<up>"    . windmove-swap-states-up)
         ("C-x C-S-<down>"  . windmove-swap-states-down)
         ("C-x C-M-<left>"  . windmove-delete-left)
         ("C-x C-M-<right>" . windmove-delete-right)
         ("C-x C-M-<up>"    . windmove-delete-up)
         ("C-x C-M-<down>"  . windmove-delete-down))
  :custom
  (windmove-mode t)
  (windmove-wrap-around t)
  :config
  (defvar-keymap my/windmove-repeat-map
    :doc "Keymap to repeat windmove commands."
    :repeat (:enter (windmove-left
                     windmove-right
                     windmove-up
                     windmove-down
                     windmove-swap-states-left
                     windmove-swap-states-right
                     windmove-swap-states-up
                     windmove-swap-states-down
                     windmove-delete-left
                     windmove-delete-right
                     windmove-delete-up
                     windmove-delete-down))
    "<left>"  #'windmove-left
    "<right>" #'windmove-right
    "<up>"    #'windmove-up
    "<down>"  #'windmove-down
    "S-<left>"  #'windmove-swap-states-left
    "S-<right>" #'windmove-swap-states-right
    "S-<up>"    #'windmove-swap-states-up
    "S-<down>"  #'windmove-swap-states-down
    "M-<left>"  #'windmove-delete-left
    "M-<right>" #'windmove-delete-right
    "M-<up>"    #'windmove-delete-up
    "M-<down>"  #'windmove-delete-down))
#+end_src

****** Minibuffer
:PROPERTIES:
:CUSTOM_ID: emacs-minibuffer
:END:

#+begin_src emacs-lisp
(setopt history-length 3000
        history-delete-duplicates t
        enable-recursive-minibuffers t
        minibuffer-depth-indicate-mode t
        read-file-name-completion-ignore-case t
        read-minibuffer-restore-windows t
        minibuffer-default-prompt-format " [%s]"
        completion-cycle-threshold 1
        completions-detailed t)

(add-hook 'minibuffer-setup-hook 'my/minibuffer-setup-function)
(defun my/minibuffer-setup-function ()
  ;; disable input method in mini buffer
  (when current-input-method
    (deactivate-input-method))
  ;; decrease font size to 90% in minibuffer
  (setq-local face-remapping-alist '((default :height 0.9))))
#+end_src

Formerly, I used to bind C-h to =backward-delete-char= and M-h to =backward-kill-word=, which was very comfortable. However, I realized that C-h should be a help key, as many Emacs packages are developed with the assumption that "C-h is a help key." That said, in the minibuffer where a help key does not necessarily play a significant role, I decided to bind C-h to =backward-delete-char=.

#+begin_src emacs-lisp
(keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete)
#+end_src

******* Savehist

[[help:savehist-mode][savehist-mode]] saves minibuffer history and additionals.

#+begin_src emacs-lisp
(use-package savehist
  :custom
  (savehist-save-minibuffer-history t)
  (savehist-additional-variables '((kill-ring . 1000)
                                   (compile-command . 1000)))
  (savehist-autosave-interval 180)
  :hook
  (after-init . savehist-mode))
#+end_src

******* Icomplete                         :ARCHIVE:
:PROPERTIES:
:CREATED:  [2025-01-02 Thu 18:05]
:END:

Icomplete is nice, but Vertico takes a more supple approach, so I would use Vertico for a while.

#+begin_src emacs-lisp
(use-package icomplete
  :custom
  (fido-vertical-mode t)
  (icomplete-prospects-height 11))
#+end_src

****** Menu

[[https://christiantietze.de/posts/2022/12/use-file-open-dialog-for-file-actions/][This blog post]] demonstrates for emacsers who have disabled file pickers and dialog boxes to adversely use them temporalily.

#+begin_src emacs-lisp
(setopt use-short-answers t)
(setopt use-file-dialog nil)
#+end_src

****** Mode Line

#+begin_src emacs-lisp
(defvar my/mode-line-buffer-name-length-max 15
  "Fixed length for displaying buffer name in mode line.")

(setopt line-number-mode nil
        column-number-mode nil
        mode-line-compact t)
(setopt mode-line-format
        '("%e"
          (:eval (my/tab-bar-mode-line-string))
          mode-line-front-space
          (:eval
           (let ((mode-line-buffer-name
                  (replace-regexp-in-string " %\\([[:ascii:]]\\)" " %%\\1"
                                            (truncate-string-to-width
                                             (buffer-name) my/mode-line-buffer-name-length-max nil ? t))))
             (cond
              (buffer-read-only
               (propertize mode-line-buffer-name 'face 'underline))
              ((buffer-modified-p)
               (propertize mode-line-buffer-name 'face 'warning))
              (mode-line-buffer-name))))
          (:eval
           (cond
            ((and line-number-mode
                  column-number-mode)
             mode-line-position-column-line-format)
            (line-number-mode mode-line-position-line-format)
            (column-number-mode mode-line-position-column-format)))
          " "
          global-mode-string))
#+end_src

******* Display Time

#+begin_src emacs-lisp
(setopt
 display-time-string-forms
 '((propertize (format-time-string "%H:%M" now) 'face 'mode-line-highlight)))
(setopt display-time-mode t)
#+end_src

****** Mouse

Mouse needs to be unobtrusive in my Emacs experience.

#+begin_src emacs-lisp
(use-package mouse
  :custom
  (mouse-1-click-follows-link nil)
  (mouse-highlight nil)
  (mouse-wheel-mode nil))

(use-package pixel-scroll
  :custom
  (pixel-scroll-precision-mode t))
#+end_src

******* Tool Tips
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:14]
:END:

#+begin_src emacs-lisp
(tooltip-mode -1)
(setq x-gtk-use-system-tooltips nil)
#+end_src

****** Hardware
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:00]
:END:

******* Battery
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:01]
:END:

#+begin_src emacs-lisp
(use-package battery
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("b" . battery)))
#+end_src

****** Installation
:PROPERTIES:
:CREATED:  [2024-02-11 Sun 16:10]
:END:

#+begin_src emacs-lisp
(use-package tutorial
  :commands help-with-tutorial
  :preface
  (defun my/tutorial--saved-dir ()
    (locate-user-emacs-file
     (no-littering-expand-var-file-name "tutorial/")
     (expand-file-name "tutorial/" user-emacs-directory)))
  :config
  (advice-add #'tutorial--saved-dir :override
              #'my/tutorial--saved-dir))
#+end_src

***** Convenience

subword-mode enables to recognize 'RSS' and 'Feed' are separate words in 'RSSFeed'

#+begin_src emacs-lisp
(repeat-mode 1)
(global-subword-mode 1)
#+end_src

****** Abbreviations

#+begin_src emacs-lisp
(use-package abbrev
  :diminish abbrev-mode
  :custom
  (save-abbrevs t))
#+end_src

****** Hippie Expand

[[https://www.masteringemacs.org/article/text-expansion-hippie-expand][As this blog post mentions]], Hippie Expansion is superior to dabbrev, skeleton and company in the field of auto typing.

#+begin_src emacs-lisp
(use-package hippie-exp
  :bind ([remap dabbrev-expand] . hippie-expand))
#+end_src

****** Hl Line

#+begin_src emacs-lisp
(use-package hl-line
  :hook (vterm-mode . (lambda () (hl-line-mode -1)))
  :config
  (hl-line-mode 1))
#+end_src

****** Visual Line

#+begin_src emacs-lisp
(use-package visual-line
  :no-require t
  :after adaptive-wrap
  :hook
  ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode
                   mu4e-view-mode nov-mode devdocs-mode)
   . visual-line-mode)
  ((feed-show-mode eww-after-render help-mode helpful-mode Info-mode woman-mode
                   mu4e-view-mode nov-mode devdocs-mode)
   . adaptive-wrap-prefix-mode)
  :custom
  (global-visual-line-mode nil))
#+end_src

****** Whitespace

[[info:emacs#Useless Whitespace][emacs#Useless Whitespace]]

#+begin_src emacs-lisp
(use-package whitespace
  :diminish ((global-whitespace-mode . "Ws")
             (whitespace-mode . "ws"))
  :hook
  ((org-mode prog-mode dired-mode) . whitespace-mode)
  (eww-mode . whitespace-turn-off)
  (before-save . delete-trailing-whitespace)
  :custom
  (whitespace-style
   '(face trailing tabs tab-mark spaces space-mark empty missing-newline-at-eof))
  (whitespace-action '(cleanup auto-cleanup))
  (whitespace-space-regexp "\\(\x3000+\\)")
  (whitespace-trailing-regexp "\\([ \t\u00A0]+\\)$")
  (whitespace-display-mappings
   '((space-mark ?\x3000 [?\u2423])
     (tab-mark   ?\t   [?\u00BB ?\t])))
  (global-whitespace-mode nil))
#+end_src

****** So Long
:PROPERTIES:
:ID:       9b051905-c21b-492b-ba0b-4468f53cb975
:END:

#+begin_src emacs-lisp
(setopt global-so-long-mode t)
#+end_src

****** Tab Bar

#+begin_src emacs-lisp
(use-package tab-bar
  :custom
  (tab-bar-show 8)
  (tab-bar-history-mode t)
  (tab-bar-tab-hints t)
  (tab-bar-tab-name-function (apply-partially #'my/project-root-path t))
  :preface
  (defun my/tab-bar-mode-line-string ()
    "Return the name for the current tab."
    (format "%s)"
            (assoc-default 'name
                           (assoc-default 'current-tab
                                          (funcall tab-bar-tabs-function)))))
  (defun my/project-root-path (&optional base-name)
    "Return an absolute path for `project-current' or base name if BASE-NAME is non-nil."
    (if-let (project (project-current))
        (funcall (if base-name #'file-name-nondirectory #'identity)
                 (directory-file-name (project-root project)))
      (buffer-name)))
  :config
  (with-eval-after-load 'consult
    (bind-keys :map tab-prefix-map
               ("B" . consult-buffer-other-tab))))

(keymap-global-set "H-t" tab-prefix-map)
(keymap-set tab-prefix-map "s" #'tab-switcher)
#+end_src

****** Ffap

#+begin_src emacs-lisp
(require 'ffap)

(ffap-bindings)
#+end_src

****** Kmacro

The power of keyboard macro is more than repeating editing commands. [[https://masteringemacs.org/article/keyboard-macros-are-misunderstood][This post explains fluently]].

#+begin_src emacs-lisp
(require 'kmacro)

(defalias 'kmacro-insert-macro 'insert-kbd-macro)
(keymap-set kmacro-keymap "I" #'kmacro-insert-macro)
#+end_src

****** Register
:PROPERTIES:
:CREATED:  [2024-04-06 Sat 16:24]
:CUSTOM_ID: emacs-register
:END:

#+begin_src emacs-lisp
(use-package register
  :custom
  (register-preview-delay nil)
  :config
  (with-eval-after-load 'savehist
    (add-to-list 'savehist-additional-variables
                 'register-alist)))
#+end_src

***** Editing

#+begin_src emacs-lisp
;; the point will be at the beginning of duplicated lines
(setopt duplicate-line-final-position 1)
#+end_src

****** Indent

See also [[id:4a58219c-74dd-4135-b56d-876b0db2cd83][aggressive-indent-mode]]

#+begin_src emacs-lisp
(setopt tab-always-indent 'complete
        indent-tabs-mode nil
        tab-first-completion 'word-or-paren-or-punct)
#+end_src

****** Electricity

#+begin_src emacs-lisp
(setopt electric-indent-mode nil)
#+end_src

****** Fill

#+begin_src emacs-lisp
(setopt fill-column 80
        sentence-end-double-space nil)
#+end_src

****** Killing

The =save-interprogram-paste-before-kill= variable controls whether clipboard text is moved to the kill-ring when some text is killed in Emacs. This is something I've been longing for!

#+begin_src emacs-lisp
(setopt yank-pop-change-selection t)
(setopt delete-active-region 'kill)
(setopt kill-do-not-save-duplicates nil)
(setopt kill-whole-line nil)
(setopt save-interprogram-paste-before-kill (expt 2 16))
#+end_src

****** Undo

The older undo step which exceeds [[help:undo-limit][undo-limit]] in byte is eliminated at garbage collection.
The oldest undo step, if undo info exceeds [[help:undo-strong-limit][undo-strong-limit]] in total, is removed instantaneously.
No more new undo step than [[help:undo-outer-limit][undo-outer-limit]] could not be registered.

#+begin_src emacs-lisp
(setopt undo-limit 320000
        undo-strong-limit 480000
        undo-outer-limit 48000000
        undo-no-redo nil)
#+end_src

****** Matching
******* Isearch

#+begin_src emacs-lisp
(use-package isearch
  :custom
  (isearch-allow-motion t)
  (isearch-lazy-count t)
  (isearch-lax-whitespace t)
  (isearch-regexp-lax-whitespace t)
  (search-whitespace-regexp ".*")
  :config
  (bind-keys :map isearch-mode-map
             ("C-j" . isearch-exit)))
#+end_src

******* Bookmark
:PROPERTIES:
:CUSTOM_ID: emacs-bookmark
:END:

#+begin_src emacs-lisp
(use-package bookmark
  :bind (("H-b" . bookmark-jump)
         ("C-x 5 B" . bookmark-jump-other-frame))
  :custom
  (bookmark-save-flag 1)
  (bookmark-menu-confirm-deletion t)
  (bookmark-watch-bookmark-file 'silent))
#+end_src

****** Paragraph
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 00:23]
:END:

#+begin_src emacs-lisp
(setopt bidi-paragraph-direction 'left-to-right)
#+end_src

***** Multimedia

****** Image

[[https://xenodium.com/emacs-viewing-webp-images/][This post]] teaches me how to enable converting external formats (i.e. webp) to internal ones.

#+begin_src emacs-lisp
(use-package image
  :custom
  (image-use-external-converter t))
#+end_src

****** Image Dired
:PROPERTIES:
:CREATED:  [2025-01-10 Fri 14:02]
:END:

#+begin_src emacs-lisp
(use-package image-dired
  :after dired
  :custom
  (image-dired-thumb-size 256))
#+end_src

***** Programming
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

****** Tools
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

******* Xref
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 12:43]
:END:

#+begin_src emacs-lisp
(use-package xref
  :custom
  (xref-show-definitions-function 'xref-show-definitions-completing-read)
  (xref-search-program (cond
                        ((or (executable-find "ripgrep")
                             (executable-find "rg"))
                         'ripgrep)
                        ((executable-find "ugrep")
                         'ugrep)
                        (t
                         'grep))))
#+end_src

******* Ediff
:PROPERTIES:
:CREATED:  [2023-11-19 Sun 06:17]
:END:

******** Ediff Window
:PROPERTIES:
:CREATED:  [2023-11-19 Sun 06:17]
:END:

#+begin_src emacs-lisp
(use-package ediff
  :commands ediff-files
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally))
#+end_src

***** Development

****** Internal
******* Storage Allocation
:PROPERTIES:
:ID:       ff1cc31b-756f-4442-acef-907ebeb872f6
:END:

If GC time at Emacs initialization is problematic, checking [[help:gcs-done][gcs-done]] or [[help:gc-elapsed][gc-elapsed]] may help you as well as setting garbage-collection-messages to t. Increasing gc-cons-* variables would minimize Emacs init time, but this also cause each GC time which may noticeable as freeze.
[[https://emacsconf.org/2023/talks/gc/][
This presentation]] advise to increase gc-cons-threshold to 20-80Mb if you have Emacs with slow startup, and to increase gc-cons-percentage to 0.2-1.0 if you have slow and frequent GC.

The Emacs package [[help:Package][emacs-gc-stats]] is useful for collecting statistical data on garbage collection (GC) to send to developers in order to inquire about the cause of GC issues.

#+begin_src emacs-lisp :tangle (expand-file-name "early-init.el" tangle/user-emacs-directory)
(setq gc-cons-threshold (* 30 gc-cons-threshold)
      gc-cons-percentage 0.3)
#+end_src

****** Lisp
******* Shortdoc

#+begin_src emacs-lisp
(use-package shortdoc
  :bind ("<help> D" . shortdoc-display-group))
#+end_src

******* Re Builder

#+begin_src emacs-lisp
(use-package re-builder
  :custom
  (reb-re-syntax 'string))
#+end_src

******* Comp

For [[info:elisp#Native Compilation][native compilation feature]] introduced at Emacs 28.1.

#+begin_src emacs-lisp
(use-package comp
  :init
  ;; enable asynchronous native compilation
  (setq native-comp-jit-compilation t)
  :custom
  (native-comp-async-report-warnings-errors 'silent)
  (native-comp-async-query-on-exit t)
  (native-comp-verbose 1))
#+end_src

******* Eldoc

#+begin_src emacs-lisp
(use-package eldoc
  :preface
  (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
  :custom
  (eldoc-echo-area-prefer-doc-buffer 'maybe)
  :config
  (eldoc-add-command-completions "paredit-"))
#+end_src

****** Debug

#+begin_src emacs-lisp
(setopt message-log-max 10000)
#+end_src

****** Development
:PROPERTIES:
:CREATED:  [2024-01-28 Sun 19:30]
:END:

******* Extensions
:PROPERTIES:
:CREATED:  [2024-01-28 Sun 19:30]
:END:

******** Transient
:PROPERTIES:
:CREATED:  [2024-01-28 Sun 19:31]
:END:

#+NAME: config/emacs-transient
#+begin_src emacs-lisp
(use-package transient
  :custom
  (transient-save-history t)
  (transient-force-single-column t))
#+end_src

***** Help
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 23:04]
:END:

#+begin_src emacs-lisp
(setopt help-enable-variable-value-editing t
        help-enable-symbol-autoload t
        describe-bindings-outline t
        help-window-select 'other)
#+end_src

***** Data

****** Save Place

File-related tweaks including [[info:emacs#Customize Save][Customizing Saving of Files]].

#+begin_src emacs-lisp
(require 'saveplace)

(setopt save-place-abbreviate-file-names t
        save-place-version-control t
        save-place-mode t)
#+end_src

****** Compression

- Jka Compr (auto compression mode)
  #+begin_src emacs-lisp
  (setopt auto-compression-mode t)
  #+end_src

****** Tar

#+begin_src emacs-lisp
(require 'tar-mode)
#+end_src

****** Archive

#+begin_src emacs-lisp
(require 'archive-mode)
#+end_src

***** Editing Basics

#+begin_src emacs-lisp
(setopt set-mark-command-repeat-pop t
        mark-ring-max 64
        next-line-add-newlines nil
        cycle-spacing-actions '(delete-all-space just-one-space restore))

;; delsel
;;; inserting Replacing the string in the region with the typed character
;;; instead of simply inserting it.
(setopt delete-selection-mode t)

;; files
(setopt mode-require-final-newline 'visit-save
        enable-remote-dir-locals t)
(setq delete-auto-save-files t)
#+end_src

***** External

****** EasyPG

#+begin_src emacs-lisp
(use-package epg
  :defer t
  :custom
  (epg-pinentry-mode 'loopback))
#+end_src

******* Epa (EasyPG Assistant)
:PROPERTIES:
:CREATED:  [2023-01-01 Sun 15:03]
:END:

[[info:epa#Top][EasyPG Assistant (epa)]] enables users to manage their GnuPG keys and exert encryption/sign with them.

#+begin_src emacs-lisp :noweb tangle
(use-package epa
  :bind (("C-x : l" . epa-list-keys)
         ("C-x : L" . epa-list-secret-keys)
         :map dired-mode-map
         (": E" . my/epa-dired-do-encrypt-armor))
  :preface
  (defun my/epa-dired-do-encrypt-armor ()
    "Encrypt mark files in ASCII armored format."
    (interactive)
    (let ((epa-armor t))
      (epa-dired-do-encrypt)))
  :config
  (setq epa-file-encrypt-to "<<email>>"))
#+end_src

****** Server

#+begin_src emacs-lisp :noweb tangle
(use-package server
  :hook (after-init . (lambda () (unless (server-running-p)
                               (server-start))))
  :custom
  (server-name "server-<<hash-string(seed="server", len=6)>>")
  (server-client-instructions t))
#+end_src

****** Processes
******* Proced

[[https://www.masteringemacs.org/article/displaying-interacting-processes-proced][This blog post]] explains how to use proced, process monitoring package for emacs.

#+begin_src emacs-lisp
(use-package proced
  :commands proced
  :custom
  (proced-auto-update-flag t)
  (proced-auto-update-interval 3)
  (proced-show-remote-processes t)
  :config
  (bind-keys :map proced-mode-map
             ("a" . proced-toggle-auto-update)))
#+end_src

******* Shell
:PROPERTIES:
:CREATED:  [2024-04-13 Sat 16:14]
:END:

#+begin_src emacs-lisp
(setopt shell-command-prompt-show-cwd t)
#+end_src

****** Browse Url

#+begin_src emacs-lisp
(use-package browse-url
  :init
  (keymap-global-set "C-c C-o" #'browse-url-at-point)
  :custom
  (browse-url-new-window-flag t)
  (browse-url-browser-function 'eww-browse-url)
  (browse-url-secondary-browser-function 'browse-url-firefox))
#+end_src

******* Webjump
:PROPERTIES:
:CREATED:  [2023-10-10 Tue 19:01]
:END:

#+begin_src emacs-lisp
(use-package webjump
  :commands webjump
  :custom
  (webjump-use-internal-browser t))
#+end_src

****** locate

#+begin_src emacs-lisp :noweb yes
(use-package locate
  :commands locate
  :custom
  (locate-command "plocate")
  (locate-make-command-line #'my/plocate-make-command-line)
  (locate-fcodes-file (expand-file-name "<<locate-db-home()>>"))
  (locate-update-path (expand-file-name "~/")))

(defun my/plocate-make-command-line (search-string)
  (list locate-command "-d" (expand-file-name "<<locate-db-home()>>") "--ignore-case" "--existing" "--regexp" search-string))
#+end_src

****** With Editor
:PROPERTIES:
:CREATED:  [2024-04-13 Sat 16:11]
:END:

#+begin_src emacs-lisp
(use-package with-editor
  :custom
  (shell-command-with-editor-mode t))
#+end_src

***** Applications

****** Mail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:54]
:END:

******* Smtpmail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 11:54]
:END:

#+begin_src emacs-lisp :noweb tangle
(use-package smtpmail
  :after mu4e
  :init
  (setq smtpmail-default-smtp-server "<<smtp-host>>")
  :custom
  (smtpmail-smtp-service 465)
  (smtpmail-smtp-user user-mail-address)
  (smtpmail-stream-type 'ssl)
  (smtpmail-mail-address user-mail-address))
#+end_src

******* Message
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:23]
:END:

******** Message Mail
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:24]
:END:

#+begin_src emacs-lisp
(use-package message
  :after (dired mu4e)
  :custom
  (message-send-mail-function 'smtpmail-send-it))
#+end_src

******* Mime Security
:PROPERTIES:
:CREATED:  [2023-10-28 Sat 17:50]
:END:

#+begin_src emacs-lisp
(use-package mm-encode
  :after mu4e
  :custom
  (mm-sign-option nil))

(use-package mml-sec
  :after (mu4e dired)
  :custom
  (mml-secure-openpgp-sign-with-sender t)
  (mml-default-sign-method 'pgpmime))
#+end_src

****** Ispell/FlySpell
:PROPERTIES:
:CREATED:  [2023-10-07 Sat 10:40]
:END:

#+begin_src emacs-lisp
(use-package ispell
  :if (executable-find "aspell")
  :custom
  (ispell-program-name "aspell")
  :config
  ;; avoid checking for Japanese characters
  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
  (setq-default ispell-extra-args '("--sug-mode=ultra"
                                    "--lang=en_US"))
  (let ((arg "--camel-case"))
    (and (string-match-p arg
                         (shell-command-to-string (concat ispell-program-name " --help")))
         (push arg ispell-extra-args))))

(use-package flyspell
  :after ispell
  :hook ((text-mode . (lambda ()
                        (unless (derived-mode-p 'org-mode)
                          (flyspell-mode 1))))
         (prog-mode . flyspell-prog-mode))
  :preface (setq flyspell-mode-map nil)
  :bind (:map flyspell-mode-map
              :prefix "C-$"
              :prefix-map my/flyspell-mode-map
              :prefix-docstring "Keymap for Flyspell"
              ("n" . flyspell-goto-next-error)
              ("C-$" . flyspell-auto-correct-word)
              ("C-" . flyspell-auto-correct-previous-word)
              ("$" . flyspell-correct-word-before-point))
  :custom
  (flyspell-issue-message-flag nil))
#+end_src

****** News

******* Gnus

******** Auth Source

#+begin_src emacs-lisp
(use-package auth-source
  :custom
  (auth-source-gpg-encrypt-to `(,user-mail-address))
  ;; Empty auth-sources to set password-store as the only source
  (auth-sources nil))

(use-package auth-source-pass
  :config
  (auth-source-pass-enable))
#+end_src

****** Calc (The GNU Emacs Calculator)

#+begin_src emacs-lisp
(use-package calc
  :bind (("<f7>" . calc)
         ("<f8>" . quick-calc))
  :commands (calc quick-calc))
#+end_src

****** Calendar

#+begin_src emacs-lisp
(use-package calendar
  :commands (calendar)
  :hook
  (calendar-today-visible . calendar-mark-today)
  :custom
  (calendar-left-margin 0)
  (calendar-right-margin 0)
  (calendar-intermonth-spacing 1)
  (calendar-mark-holidays-flag t)
  ;; Below is lat/lon for Japna used in sunrise-sunset command
  (calendar-latitude 36.2)
  (calendar-longitude 138.3)
  :custom-face
  (holiday ((t (:foreground "dark orange" :box t)))))
#+end_src

******* Midnight
:PROPERTIES:
:CREATED:  [2023-06-08 Thu 18:20]
:END:

#+NAME: config/emacs-midnight
#+begin_src emacs-lisp :noweb tangle
(use-package midnight
  :defer t
  :custom
  (midnight-mode t)
  (midnight-delay "4:00"))
#+end_src

******* Appt
:PROPERTIES:
:CREATED:  [2024-10-29 Tue 15:32]
:END:

#+begin_src emacs-lisp
(use-package appt
  :custom
  (appt-message-warning-time 60)
  (appt-display-interval 5)
  :config
  (appt-activate 1)
  (with-eval-after-load 'org-agenda
    (org-agenda-to-appt)))
#+end_src

****** Package

#+begin_src emacs-lisp
(use-package package
  :custom
  (package-native-compile t)
  (package-install-upgrade-built-in t)
  (package-quickstart t)
  :config
  (with-eval-after-load 'my-launch-app
    (keymap-set my/launch-app-map (kbd "l")
                #'list-packages)))
#+end_src

****** Eglot
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:32]
:END:

[[https://github.com/joaotavora/eglot][Eglot]]

#+begin_src emacs-lisp
(use-package eglot
  :disabled t
  :hook ((sh-mode ruby-mode python-mode graphviz-dot-mode) . eglot-ensure)
  :custom
  (eglot-extend-to-xref t))
#+end_src

****** Games
:PROPERTIES:
:CREATED:  [2025-01-26 Sun 16:08]
:END:

******* Tetris
:PROPERTIES:
:CREATED:  [2025-01-26 Sun 16:08]
:END:

#+begin_src emacs-lisp
(use-package tetris
  :commands (tetris)
  :config
  (bind-keys :map tetris-mode-map
             ("j" . tetris-rotate-next)
             ("i" . tetris-rotate-prev)
             ("e" . tetris-move-left)
             ("f" . tetris-move-right)
             ("SPC" . tetris-move-bottom)))
#+end_src

***** Text

****** View

#+begin_src emacs-lisp
(use-package view
  :defer t)
#+end_src

***** Hypermedia
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 16:59]
:END:
****** Dictionary
:PROPERTIES:
:CREATED:  [2022-10-20 Thu 17:01]
:END:

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
dictd dict \
      dict-gcide dict-wn \
      dict-jargon dict-foldoc dict-vera \
      dict-freedict-eng-jpn dict-freedict-jpn-eng
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
sudo systemctl start dictd
#+end_src

#+begin_src emacs-lisp

(use-package dictionary
  :commands (dictionary-search dictionary-lookup-definition)
  :custom
  (dictionary-use-single-buffer t)
  (dictionary-server nil)
  :config
  (setq switch-to-buffer-obey-display-actions t)
  (add-to-list 'display-buffer-alist
               '("^\\*Dictionary\\*"
                 display-buffer-in-tab)))
#+end_src

***** Communication
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 12:58]
:END:

****** Net Utils
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 12:58]
:END:

#+begin_src emacs-lisp
(use-package net-utils
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("n d" . run-dig)
              ("n i" . ifconfig)
              ("n w" . iwconfig)
              ("n p" . ping)))
#+end_src

**** Input Methods

***** ddskk

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ddskk"
#+end_src

#+NAME: config/emacs-ddskk
#+begin_src emacs-lisp :noweb tangle
(defvar skk-dir (expand-file-name "skk" "<<share-dir()>>"))

(use-package skk
  :defer t
  :init
  (setopt default-input-method "japanese-skk")
  (defface skk-candidate `((t . (:font "fontset-default"
                                       :height ,(my/normalized-font-size 860))))
    "Default face for ddskk candidates."
    :group 'skk-dcomp)
  (setq skk-get-jisyo-directory "<<skk-jisyo-path()>>")
  :custom
  (skk-user-directory (no-littering-expand-etc-file-name "ddskk"))
  (skk-init-file (expand-file-name "ddskk-init.el" skk-user-directory))
  (skk-byte-compile-init-file t)
  ;; cursor color
  (skk-use-color-cursor t)
  (skk-cursor-hiragana-color "orange")
  (skk-cursor-katakana-color "OrangeRed3")
  (skk-cursor-latin-color "DodgerBlue3")
  (skk-cursor-jisx0201-color "purple3")
  ;; mode line string
  (skk-latin-mode-string "A")
  (skk-hiragana-mode-string "あ")
  (skk-katakana-mode-string "ア")
  (skk-jisx0201-mode-string "ｱ")
  (skk-jisx0208-latin-mode-string "Ａ")
  ;; AZIK
  (skk-use-azik t)
  (skk-azik-keyboard-type 'us101)
  ;; conversion
  (skk-egg-like-newline t)
  (skk-henkan-strict-okuri-precedence t)
  (skk-check-okurigana-on-touroku t)
  ;; annotation
  (skk-show-annotation t)
  (skk-annotation-delay 0.3)
  ;; how candidates behave
  (skk-show-candidates-always-pop-to-buffer t)
  (skk-henkan-number-to-display-candidates 10)
  (skk-show-candidates-nth-henkan-char 3)
  (skk-henkan-show-candidates-keys
   '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0))
  ;; set face for candidates list
  (skk-treat-candidate-appearance-function
   (lambda (candidate listing-p)
     (cond
      ((string-match ";" candidate)
       (put-text-property 0 (match-beginning 0)
                          'face 'skk-candidate
                          candidate)
       (put-text-property (match-beginning 0)
                          (length candidate) 'face 'shadow candidate))
      (t
       (put-text-property 0 (length candidate)
                          'face 'skk-candidate
                          candidate)))
     candidate))
  ;; bind C-q for hankaku-kana input mode
  (skk-use-jisx0201-input-method t)
  ;; dynamic conversion
  (skk-dcomp-activate nil)
  (skk-dcomp-multiple-activate nil)
  ;; config file
  (skk-record-file (expand-file-name "record" skk-dir))
  (skk-emacs-id-file (expand-file-name "emacs-id" skk-dir))
  ;; jisyo
  (skk-share-private-jisyo t)
  (skk-compare-jisyo-size-when-saving t)
  (skk-save-jisyo-instantly t)
  ;; jisyo file/directory
  (skk-jisyo `(,(no-littering-expand-var-file-name "ddskk/jisyo.txt") . utf-8))
  (skk-backup-jisyo (expand-file-name "jisyo.bak" skk-dir))
  (skk-large-jisyo (expand-file-name "SKK-JISYO.L" skk-get-jisyo-directory))
  (skk-itaiji-jisyo (expand-file-name "SKK-JISYO.itaiji" skk-get-jisyo-directory))
  (skk-extra-jisyo-file-list
   (seq-remove (lambda (dic)
                 (seq-some (lambda (suffix)
                             (string-suffix-p (symbol-name suffix) dic))
                           '(L itaiji tar)))
               (append (file-expand-wildcards (expand-file-name "SKK-JISYO.*" skk-get-jisyo-directory))
                       (file-expand-wildcards (expand-file-name "open-jisyo/SKK-JISYO.*" skk-dir)))))
  ;; jisyo server
  ;; (skk-server-host "localhost")
  ;; (skk-server-portnum 1178)
  ;; (skk-server-inhibit-startup-server t)
  ;; study
  (skk-study-file (expand-file-name "study" skk-dir))
  (skk-study-backup-file (expand-file-name "study.bak" skk-dir))
  :config
  ;; ward off activating skk-auto-fill-mode inadvertently
  (bind-keys ("C-x j" . skk-mode)))
#+end_src

- ddskk init file
#+begin_src emacs-lisp :tangle (expand-file-name "ddskk/ddskk-init.el" tangle/emacs-etc-dir)
;; -*- mode:emacs-lisp; -*-
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("!" nil skk-purge-from-jisyo)
                ("xka" nil ("ヵ" . "ヵ"))
                ("xke" nil ("ヶ" . "ヶ"))
                ("n" nil nil)
                ("nn" nil ("ナノ" . "なの"))
                ("nm" nil ("ノミ" . "のみ"))
                ("ks" nil ("コソ" . "こそ"))
                ("kna" nil ("カナ" . "かな"))
                ("kno" nil ("コノ" . "この"))
                ("ym" nil ("ヤマ" . "やま"))
                ("yk" nil ("ユキ" . "ゆき"))
                ("tga" nil ("タガ" . "たが"))
                ("vj" nil ("ヴン" . "ぶん"))
                ("hm" nil ("ハマ" . "はま"))
                ;; followings are for preventing from changing to zenkaku eisu mode by pressing 'L'
                ("bL" nil ("ボン" . "ぼん"))
                ("byL" nil ("ビョン" . "びょん"))
                ("cL" nil ("チョン" . "ちょん"))
                ("dL" nil ("ドン" . "どん"))
                ("fL" nil ("フォン" . "ふぉん"))
                ("gL" nil ("ゴン" . "ごん"))
                ("gyL" nil ("ギョン" . "ぎょん"))
                ("hL" nil ("ホン" . "ほん"))
                ("hgL" nil ("ヒョン" . "ひょん"))
                ("hyL" nil ("ヒョン" . "ひょん"))
                ("jL" nil ("ジョン" . "じょん"))
                ("kL" nil ("コン" . "こん"))
                ("kgL" nil ("キョン" . "きょん"))
                ("kyL" nil ("キョン" . "きょん"))
                ("mL" nil ("モン" . "もん"))
                ("mgL" nil ("ミョン" . "みょん"))
                ("myL" nil ("ミョン" . "みょん"))
                ("nL" nil ("ノン" . "のん"))
                ("ngL" nil ("ニョン" . "にょん"))
                ("nyL" nil ("ニョン" . "にょん"))
                ("pL" nil ("ポン" . "ぽん"))
                ("pgL" nil ("ピョン" . "ぴょん"))
                ("pyL" nil ("ピョン" . "ぴょん"))
                ("rL" nil ("ロン" . "ろん"))
                ("ryL" nil ("リョン" . "りょん"))
                ("sL" nil ("ソン" . "そん"))
                ("syL" nil ("ション" . "しょん"))
                ("tL" nil ("トン" . "とん"))
                ("tyL" nil ("チョン" . "ちょん"))
                ("vL" nil ("ヴォン" . "う゛ぉん"))
                ("wL" nil ("ウォン" . "うぉん"))
                ("xL" nil ("ション" . "しょん"))
                ("xxL" nil ("→" . "→"))
                ("yL" nil ("ヨン" . "よん"))
                ("zL" nil ("ゾン" . "ぞん"))
                ("zyL" nil ("ジョン" . "じょん")))))

(add-hook 'skk-azik-load-hook
          (lambda ()
            (dolist (key '("kA" "kE" "tU" "wA"))
              (setq skk-rom-kana-rule-list
                    (skk-del-alist key skk-rom-kana-rule-list)))))
#+end_src

**** Dired

#+begin_src emacs-lisp
(use-package dired
  :bind (:map global-map
              ("C-x d" . dired-jump)
              :map dired-mode-map
              ("C-j" . dired-find-file)
              ("^" . dired-up-directory)
              ("(" . dired-hide-details-mode)
              (")" . dired-hide-details-mode)
              ("E" . dired-create-empty-file)
              ("Y" . dired-do-relsymlink)
              ("e" . wdired-change-to-wdired-mode)
              ("RET" . dired-open-file)
              ("C-c C-o" . dired-open-file)
              ("C-c C-s" . my/dired-share))
  :hook (dired-mode . dired-hide-details-mode)
  :custom
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-do-revert-buffer t)
  (dired-auto-revert-buffer t)
  (dired-copy-dereference t)
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'top)
  (dired-listing-switches "-ahgG --time-style=long-iso --group-directories-first")
  (dired-dwim-target 'dired-dwim-target-next)
  (dired-hide-details-hide-information-lines t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-compress-file-default-suffix ".zst")
  (dired-compress-directory-default-suffix ".7z")
  (dired-isearch-filenames t)
  (dired-open-use-nohup t)
  (dired-open-query-before-exit nil)
  (completion-ignored-extensions nil)
  :config
  (with-eval-after-load 'open-file
    (setq dired-guess-shell-alist-user
          `((,(regexp-opt (append my/open-file-media-extensions
                                  my/open-file-compressed-media-extensions)
                          "\\.\\(")
             "mpv")
            (,(regexp-quote ".kdenlive") "kdenlive")
            (,(regexp-quote ".xcf") "gimp"))))
  (advice-add #'dired-do-delete :around #'my/advice-dired-control-deletion)
  (advice-add #'dired-do-flagged-delete :around #'my/advice-dired-control-deletion)
  (put 'dired-find-alternate-file 'disabled nil))

(use-package dired-x
  :after dired
  :config
  (lambda-key dired-mode-map "."
              (lambda ()
                "Toggle hiding dotfiles whose name starts with '.'"
                (interactive)
                (let ((dired-omit-files (rx (seq string-start
                                                 (or "." ".."
                                                     (seq "." (+? graph)))
                                                 string-end))))
                  (call-interactively #'dired-omit-mode)))))

(use-package dired-aux
  :after dired
  :custom
  ;; Renaming files in Dired reflects their name in VCSs
  (dired-vc-rename-file t)
  :config
  (setq dired-compress-files-alist
        (append dired-compress-files-alist
                '(("\\.tar\\.7z\\'" . "tar cf - %i | 7z a -si %o")
                  ("\\.7z\\'" . "7z a %o %i"))))
  (add-to-list 'dired-compress-file-suffixes
               '("\\.tar\\.7z\\'" "" "7z x -so %i | tar xf -"))
  ;; submit "M-s f" to consult-find
  (bind-keys :map dired-mode-map
             ("M-s f" . nil)))

(defun my/advice-dired-control-deletion (oldfun &rest r)
  "Enable file deleting functions to control deleting procedure
whether files are going to be in trash box."
  (let ((delete-by-moving-to-trash
         (if (equal current-prefix-arg '(4))
             nil t)))
    (apply oldfun (cdr r))))

(defun my/dired-share ()
  "Share file with remote device via KDE Connect."
  (interactive)
  (let ((files (dired-get-marked-files nil nil)))
    (mapc (lambda (file)
            (shell-command
             (mapconcat 'identity
                        (list "kdeconnect-cli" "-d" "a30587ededf4c2d2"
                              "--share" (shell-quote-argument
                                         file)) " ")))
          files)))
#+end_src
***** dired-rsync

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dired-rsync"
#+end_src

#+begin_src emacs-lisp
(use-package dired-rsync
  :after dired
  :bind (:map dired-mode-map
              ("C-c C-r" . dired-rsync))
  :custom
  (dired-rsync-options "-auz --info=progress2"))
#+end_src

***** dired-single                          :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/crocket/dired-single/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package dired-single
  :disabled t
  :after dired
  :bind (:map dired-mode-map
              ("C-j" . dired-single-buffer)
              ("^" . dired-single-up-directory)))
#+end_src

***** dired-hacks

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dired-hacks"
#+end_src

#+begin_src emacs-lisp
(require 'dired-open)

(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("TAB" . dired-subtree-cycle)))

(use-package dired-narrow
  :after dired
  :bind
  (:map dired-mode-map
        ("z" . dired-narrow))
  (:map dired-narrow-map
        ("C-j" . exit-minibuffer)))
#+end_src

***** dired-hide-dotfiles                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-05-24 Wed 21:44]
:END:

dired-omit-mode took over [[https://github.com/mattiasb/dired-hide-dotfiles#start-of-content][dired-hide-dotfiles]].

#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("," . dired-clean-directory)
              ("." . dired-hide-dotfiles-mode))
  :config
  (dired-hide-dotfiles-mode -1))
#+end_src

***** find-dired

#+begin_src emacs-lisp
(use-package find-dired
  :bind (:prefix "M-s d"
                 :prefix-map my/find-dired-map
                 :prefix-docstring "Keymap for FInd Dired"
                 ("f" . find-dired)
                 ("F" . find-lisp-find-dired)
                 ("g" . find-grep-dired)
                 ("n" . find-name-dired)
                 ("d" . find-lisp-find-dired-subdirectories)
                 ("!" . find-dired-with-command))
  :custom
  (find-grep-options "-n -H --no-heading -q")
  (find-ls-option '("-print0 | xargs -0 ls -ldN" . "-ldN")))
#+end_src

**** EWW

#+NAME: eww-org-dir
#+begin_src emacs-lisp :var full-path=0
(funcall (if (= full-path 0) #'identity #'expand-file-name)
         (file-name-concat no-littering-var-directory "eww/org"))
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<eww-org-dir(full-path=1)>> - - - 3d
#+end_src

#+begin_src emacs-lisp
(with-eval-after-load 'shr
  (setopt shr-width 10000)
  (setopt shr-use-fonts nil)
  (setopt shr-image-animate t)
  (setopt shr-use-colors nil)
  (setopt shr-max-image-proportion 0.4)
  ;; never use cookies
  (setopt shr-cookie-policy nil))
#+end_src

The EWW bookmark functionality is an original implementation, separate from the emacs bookmark facility. Although [[https://lists.gnu.org/archive/html/emacs-devel/2020-10/msg01651.html][adoption of the facility has been considered]], a possible solution to count EWW bookmarks in the source of consult-buffer is showcased at [[https://github.com/minad/consult/issues/347][here]].

#+NAME: config-eww
#+begin_src emacs-lisp :noweb tangle
(use-package eww
  :commands eww
  :after my-launch-app
  :custom
  ;; set enough large column number to prevent from inserting line break
  (eww-header-line-format nil)
  (eww-browse-url-new-window-is-tab nil)
  (eww-auto-rename-buffer 'title)
  (eww-buffer-name-length 20)
  :config
  (bind-keys :map eww-mode-map
             ("C" . eww-set-character-encoding)
             ("C-j" . eww-follow-link)
             ("T" . eww-goto-title-heading)
             ("L" . my/eww-goto-heading)
             :map eww-bookmark-mode-map
             ("C-j" . eww-bookmark-browse))
  (with-eval-after-load 'consult
    (defvar consult--source-eww
      (list :name     "Eww"
            :narrow   ?w
            :action   (lambda (bm)
                        (eww-browse-url (get-text-property 0 'url bm)))
            :items    (lambda ()
                        (eww-read-bookmarks)
                        (mapcar (lambda (bm)
                                  (propertize
                                   (format "%s (%s)"
                                           (plist-get bm :url)
                                           (plist-get bm :title))
                                   'url (plist-get bm :url)))
                                eww-bookmarks))))
    (add-to-list 'consult-buffer-sources 'consult--source-eww 'append)))

(defun eww-headings-dom ()
  "Return heading list as a dom from xml."
  (let ((source (plist-get eww-data :source))
        (dom nil))
    (with-temp-buffer
      (let ((source-file (make-temp-file "source-"))
            (coding-system-for-write 'utf-8-unix))
        (insert source)
        (write-region (point-min) (point-max) source-file nil)
        (erase-buffer)
        (call-process "extract_headings" source-file t)
        (delete-file source-file)
        (libxml-parse-xml-region (point-min) (point-max))))))

(defun eww-goto-title-heading ()
  "Set point to a line which contaings the possible heading."
  (interactive)
  (when-let* ((headings-dom (eww-headings-dom))
              (possible-heading (cl-reduce (lambda (node-a node-b)
                                             (if (not (bound-and-true-p node-a))
                                                 (if (not (bound-and-true-p node-b))
                                                     nil
                                                   node-b)
                                               (if (>= (string-to-number (dom-attr node-a 'proximity))
                                                       (string-to-number (dom-attr node-b 'proximity)))
                                                   node-a node-b)))
                                           (dom-children headings-dom)
                                           :initial-value nil))
              (possible-text (dom-text possible-heading))
              (match-pos (or (re-search-forward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1)
                             (re-search-backward (format "^*?[[:blank:]]*%s[[:blank:]]*$" (regexp-quote possible-text)) nil t 1))))
    (beginning-of-line)
    (recenter-top-bottom 0)))

(defun my/eww-goto-heading ()
  "Go to selected heading line."
  (interactive)
  (setq lexical-binding t)
  (when-let* ((headings-root (eww-headings-dom))
              (cur-buf (current-buffer))
              (heading (completing-read
                        "Heading : "
                        (mapcar (lambda (heading-node)
                                  (when-let* ((heading (dom-text heading-node))
                                              (tag (symbol-name (dom-tag heading-node)))
                                              (match-pos (string-match "h\\([1-6]\\{1\\}\\)" tag))
                                              (indent (- (string-to-number (match-string 1 tag)) 1)))
                                    (format "%s%s"
                                            (apply 'concat (make-list indent "  "))
                                            heading)))
                                (dom-children headings-root))))
              (match (string-match "\\(?:  \\)*\\(.*\\)" heading))
              (heading (match-string 1 heading))
              (match-pos (or (re-search-forward (build-regex heading) nil t 1)
                             (re-search-backward (build-regex heading) nil t 1))))
    (with-current-buffer cur-buf
      (switch-to-buffer cur-buf)
      (beginning-of-line)
      (recenter-top-bottom 0))))

(defmacro build-regex (str)
  "Return a regexp representation for `STR'."
  `(format "^[[:blank:]SVG Image]*%s[[:blank:]]*$"
           ,str))
#+end_src

***** extract_headings

#+begin_src python :tangle (expand-file-name "extract_headings" tangle/local-bin-dir) :tangle-mode o755
import sys
import lxml.html as html
from lxml import etree
import difflib

if len(sys.argv) == 1:
    INPUT_STR = sys.stdin.read()
    ROOT = html.fromstring(INPUT_STR).getroottree()
else:
    sys.exit(1)

OUT_ROOT = etree.Element("headings")

# extract title text
title = ''
title_text_arr = ROOT.xpath('//title[1]//text()')
if len(title_text_arr):
    title = title_text_arr[0]
    OUT_ROOT.set("title", title.strip())

htag_text_arr = ROOT.xpath('//*[self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6]')
for i in range(len(htag_text_arr)):
    text = ''
    texts = htag_text_arr[i].xpath('.//text()')
    if len(texts) == 1:
        text = texts[0].strip()
    elif len(texts) > 1:
        text = ''.join(map(str.strip, texts))
    else:
        continue
    proximity = difflib.SequenceMatcher(None, title, text).ratio()
    heading = etree.Element(htag_text_arr[i].tag)
    heading.text = text
    heading.set('proximity', str(proximity))
    OUT_ROOT.append(heading)

out_root_str = etree.tostring(OUT_ROOT, encoding='utf-8', method='xml', pretty_print=True)
if type(out_root_str) is bytes:
    out_root_str = out_root_str.decode()
    print(out_root_str)
#+end_src

**** Info

#+begin_src emacs-lisp
(use-package info
  :custom
  (Info-use-header-line nil)
  :config
  (bind-keys :map Info-mode-map ("a" . info-apropos)))
#+end_src

**** Magit

[[https://github.com/magit/magit][Magit]] is git front end for emacs which is outstandingly powerful.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-magit"
#+end_src

#+begin_src emacs-lisp
(use-package magit
  :commands (magit magit-status magit-dispatch)
  :config
  (bind-keys :map magit-status-mode-map
             ("/" . magit-file-checkout)
             (";" . magit-list-repositories)))
#+end_src

***** Magit Essentials
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:07]
:END:

#+begin_src emacs-lisp
(use-package magit-repos
  :after magit
  :custom
  (magit-repository-directories '(("~/git" . 1))))
#+end_src

***** Magit Revision
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:13]
:END:

#+begin_src emacs-lisp
(use-package magit-diff
  :after magit
  :custom
  ;; %GG denotes signature key info botained by --show-signature option in git log command
  (magit-revision-headers-format
   (mapconcat #'identity
              (list "Author:     %aN <%aE>"
                    "AuthorDate: %ad"
                    "Commit:     %cN <%cE>"
                    "CommitDate: %cd"
                    "%GG")
              "\n")))
#+end_src

***** Magit Log
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 14:15]
:END:

#+begin_src emacs-lisp
(use-package magit-log
  :after magit
  :custom
  (magit-log-show-refname-after-summary t))
#+end_src

***** Magit Wip
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 13:59]
:END:

The following excerpt is important when trying finer control for git-wip-*-mode.
- [[help:magit-wip-mode][magit-wip-mode]]
  #+begin_quote
  For historic reasons this mode is implemented on top of four
  other 'magit-wip-*' modes, which can also be used individually,
  if you want finer control over when the wip refs are updated;
  but that is discouraged.
  #+end_quote

#+begin_src emacs-lisp
(use-package magit-wip
  :after magit
  :custom
  (magit-wip-merge-branch t)
  :config
  (magit-wip-after-save-mode 1))
#+end_src

***** forge
:PROPERTIES:
:CREATED:  [2024-04-24 Wed 19:38]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-forge"
#+end_src

#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

**** Mu4e

You might need to [[https://www.djcbsoftware.nl/code/mu/mu4e/Initializing-the-message-store.html][issue 'mu init' command]] before initial usage or after upgrading. The command would presumably looks like the following:
: mu init --maildir=~/data/share/mail --muhome=~/data/share/mu --my-address=jim@example.com --my-address=bob@example.com

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"mu"
#+end_src

#+begin_src emacs-lisp
(use-package mu4e
  :commands (mu4e)
  :hook (emacs-startup . (lambda () (mu4e t)))
  :delight
  (mu4e-main-mode    " MU")
  (mu4e-headers-mode " MU")
  (mu4e-view-mode    " MU")
  (mu4e-compose-mode " MU")
  :custom
  (mail-user-agent 'mu4e-user-agent)
  (mu4e-hide-index-messages t)
  (mu4e-context-policy 'pick-first)
  (mu4e-compose-context-policy 'ask)
  (mu4e-update-interval 300)
  (mu4e-split-view 'single-window)
  (mu4e-headers-date-format "%y%m%d")
  (mu4e-headers-time-format " %R")
  (mu4e-headers-fields
   '((:human-date . 6)
     (:flags      . 3)
     (:from       . 16)
     (:subject)))
  (mu4e-search-results-limit 2000)
  (mu4e-headers-advance-after-mark t)
  (mu4e-change-filenames-when-moving t)
  (mu4e-view-show-images t)
  (mu4e-html2text-command (lambda (msg)
                            (plist-put msg :body-html
                                       (with-temp-buffer
                                         (insert (or (mu4e-message-field msg :body-html) ""))
                                         (shell-command-on-region (point-min) (point-max) "nkf -w -Lu" (current-buffer) t)
                                         (or (buffer-string) "")))
                            (mu4e-shr2text msg)))
  :config
  (bind-keys :map mu4e-headers-mode-map
             ("C-j" . mu4e-headers-view-message)
             :map mu4e-view-mode-map
             ("C-j" . push-button)
             ("C-c C-a" . mu4e-view-attachment-action)
             :map mu4e-compose-mode-map
             ("C-x C-o" . org-mu4e-compose-org-mode))
  (add-to-list 'mu4e-view-actions
               '("external browser" . mu4e-action-view-in-browser) t)
  (add-to-list 'mu4e-view-actions
               '("XWidget View" . mu4e-action-view-with-xwidget) t)
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types)))
#+end_src

***** mu4e-alert                            :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-04-28 Fri 11:42]
:END:

#+begin_src scheme :tangle no
"emacs-mu4e-alert"
#+end_src

#+begin_src emacs-lisp
(use-package mu4e-alert
  :commands mu4e-alert-view-unread-mails
  :custom
  (mu4e-alert-modeline-formatter
   (lambda (count)
     (if (> count 0)
         (format " M:%d" count)
       "")))
  :config
  (mu4e-alert-set-default-style 'fringe)
  (mu4e-alert-enable-notifications)
  (mu4e-alert-enable-mode-line-display))
#+end_src

***** additional tweaks

- file attachment in dired ([[https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html][source]])
  : gnus-dired-attach (C-c RET C-a)

  #+begin_src emacs-lisp
  (use-package gnus-dired
    :after mu4e-compose
    :hook
    (dired-mode . turn-on-gnus-dired-mode)
    :custom
    (gnus-dired-mail-mode 'mu4e-user-agent))
  #+end_src

- use contact info from org-contacts

  #+begin_src emacs-lisp
  (with-eval-after-load 'mu4e
    (add-to-list 'mu4e-headers-actions
                 '("Contact to add" . mu4e-action-add-org-contact) t)
    (add-to-list 'mu4e-view-actions
                 '("Contact to add" . mu4e-action-add-org-contact) t)
    (with-eval-after-load 'org-contacts
      (setq mu4e-org-contacts-file (car org-contacts-files))))
  #+end_src

**** Elfeed

[[https://github.com/skeeto/elfeed][Elfeed]] is a powerful RSS feed reader with tag capability that is one of core software in my input workflow.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed"
#+end_src

#+NAME: config/emacs-elfeed
#+begin_src emacs-lisp
(use-package elfeed
  :delight
  (elfeed-show-mode   " EF")
  (elfeed-search-mode " EF")
  :commands elfeed
  :init
  (defface elfeed-search-unchecked-title-face
    nil
    "Face used in search mode for unchecked entry titles."
    :group 'elfeed)
  (defface elfeed-search-checked-title-face
    nil
    "Face used in search mode for checked entry titles."
    :group 'elfeed)
  :custom-face
  (elfeed-search-title-face ((t (:foreground "#4D4D4D"))))
  (elfeed-search-unchecked-title-face ((t (:foreground "cornflowerblue"))))
  (elfeed-search-checked-title-face ((t (:foreground "darkblue"))))
  :custom
  (elfeed-use-curl t)
  (elfeed-search-date-format '("%Y%m%d" 8 :left))
  (elfeed-search-title-min-width 100)
  (elfeed-search-title-max-width 120)
  (elfeed-search-trailing-width 160)
  (elfeed-sort-order 'ascending)
  (elfeed-enclosure-default-dir "~/Downloads/")
  (elfeed-save-multiple-enclosures-without-asking t)
  :config
  (defalias 'elfeed-search-tag-all-unchecked
    (elfeed-expose #'elfeed-search-tag-all 'unchecked)
    "Add the `unchecked' tag to all selected entries.")
  (defalias 'elfeed-search-untag-all-unchecked
    (elfeed-expose #'elfeed-search-untag-all 'unchecked)
    "Remove the `unchecked' tag from all selected entries.")
  (defalias 'elfeed-search-tag-all-checked
    (elfeed-expose #'elfeed-search-tag-all 'checked)
    "Add the `checked' tag to all selected entries.")
  (defalias 'elfeed-search-untag-all-checked
    (elfeed-expose #'elfeed-search-untag-all 'checked)
    "Remove the `checked' tag from all selected entries.")
  (bind-keys :map elfeed-search-mode-map
             ("C-j" . elfeed-search-show-entry)
             ("M-RET" . elfeed-search-open-url)
             ("C-c C-o" . elfeed-search-open-url)
             ("f" . scroll-up-line)
             ("e" . scroll-down-line)
             ("q" . elfeed-kill-buffer)
             ("Q" . quit-window)
             ("x" . elfeed-search-update--force)
             ("c" . (lambda () (interactive)
                      (elfeed-search-untag-all-unread)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all-unchecked)))
             ("C" . elfeed-search-untag-all-unchecked)
             ("r" . (lambda () (interactive)
                      (elfeed-search-untag-all-unread)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-untag-all-unchecked)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all-checked)
                      (unless (use-region-p) (forward-line -1))
                      (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))))
             ("R" . elfeed-search-untag-all-checked)
             ("d" . elfeed-search-untag-all-unread)
             ("Y" . elfeed-search-download-media)
             ("_" . elfeed-search-show-media-duration))
  (add-to-list 'elfeed-search-face-alist '(unchecked elfeed-search-unchecked-title-face))
  (add-to-list 'elfeed-search-face-alist '(checked elfeed-search-checked-title-face)))

(defun elfeed-search-open-url ()
  "Visit the current entry in your browser using 'eww-browse-url'."
  (interactive)
  (elfeed-search-untag-all-unchecked)
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-tag-all-checked)
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-tag-all (intern (format-time-string "%Y%m%d")))
  (unless (use-region-p) (forward-line -1))
  (elfeed-search-browse-url))

(defun elfeed-search-download-media ()
  "Downlaod video file."
  (interactive)
  (let ((entries (elfeed-search-selected)))
    (cl-loop for entry in entries
             when (or (caar (elfeed-entry-enclosures entry))
                      (elfeed-entry-link entry))
             do (let ((title (elfeed-entry-title entry)))
                  (my/yt-dlp-command it title)
                  (my/tsc-execute-macro)))
    (mapc #'elfeed-search-update-entry entries)
    (unless (or elfeed-search-remain-on-entry (use-region-p))
      (forward-line))))

(defun elfeed-search-show-media-duration ()
  "Show duration of media attached to current entry."
  (interactive)
  (let* ((entry (elfeed-search-selected :single))
         (url (or (caar (elfeed-entry-enclosures entry))
                  (elfeed-entry-link entry))))
    (let ((dispatch-dwim--default-method
           (lambda (comm) (princ
                       (string-trim
                        (shell-command-to-string comm))))))
      (let ((my/tsc-execute-function
             (lambda (command)
               ;; Quirk: The message does not echo in the minibuffer.
               (princ (format "Duration: %s"
                              (string-trim (shell-command-to-string command)))))))
        (my/yt-dlp-command url nil t)
        (my/tsc-execute-macro)))))
#+end_src

***** elfeed-score
:PROPERTIES:
:CREATED:  [2023-07-20 Thu 09:26]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed-score"
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-score
  :after elfeed
  :custom
  (elfeed-score-score-format '("%d " 3 :right))
  (elfeed-score-rule-stats-file
   (no-littering-expand-var-file-name "elfeed/score/stats.el"))
  :config
  (elfeed-score-enable)
  (setq elfeed-search-sort-function #'my/elfeed-score-sort-descending)
  (setq elfeed-search-print-entry-function #'my/elfeed-score-search-print-entry)
  (keymap-set elfeed-search-mode-map "=" #'elfeed-score-map)
  :preface
  (defun my/elfeed-score-sort-descending (a b)
    "Return non-nil if A should sort after B."
    (let ((a-score (elfeed-score-scoring-get-score-from-entry a))
          (b-score (elfeed-score-scoring-get-score-from-entry b)))
      (if (< a-score b-score)
          t
        (let ((a-date (elfeed-entry-date a))
              (b-date (elfeed-entry-date b)))
          (and (eq a-score b-score) (< a-date b-date))))))
  (defun my/elfeed-score-search-print-entry (entry)
    "Print ENTRY to the buffer with my style."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (mapconcat
                      (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                      tags ","))
           (title-width (- (window-width) 10 elfeed-search-trailing-width))
           (title-column (elfeed-format-column
                          title (elfeed-clamp
                                 elfeed-search-title-min-width
                                 title-width
                                 elfeed-search-title-max-width)
                          :left))
           (score
            (elfeed-score-format-score
             (elfeed-score-scoring-get-score-from-entry entry))))
      (insert score)
      (when feed-title
        (insert (propertize (elfeed-format-column feed-title 6 :left)
                            'face 'elfeed-search-feed-face) " "))
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (when tags
        (insert "(" tags-str ")")))))
#+end_src

***** elfeed-org

[[https://github.com/remyhonig/elfeed-org][elfeed-org]] allow me to express feeds for elfeed in org file.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elfeed-org"
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-org
  :after (elfeed org)
  :init
  (with-eval-after-load 'denote
    (setq rmh-elfeed-org-files
          (list (denote-get-path-by-id "20230605T173315"))))
  :custom
  (rmh-elfeed-org-ignore-tag "ARCHIVE")
  (rmh-elfeed-org-auto-ignore-invalid-feeds nil)
  :config
  (elfeed-org))
#+end_src

Packages managed by other than guix (i.e. straight.el or apt) are encouraged to register feed since updating information channel is desirable to exist.

#+begin_src emacs-lisp :noweb yes
(advice-add #'rmh-elfeed-org-process
            :after #'my/elfeed-org-add-feeds)

(defun my/elfeed-org-add-feeds (rmh-elfeed-org-files rmh-elfeed-org-tree-id)
  "Add feeds in addition to feeds in `rmh-elfeed-org-files'.

This function needs to be invoked after `rmh-elfeed-org-process' which clear all feeds."
  (setf elfeed-feeds
        (append elfeed-feeds
                '(;; s-exps for feeds will be inserted here
                  <<elfeed-feeds>>))))
#+end_src

**** Terminal Emulators

***** shell

#+begin_src emacs-lisp
(use-package shell
  :delight " SM"
  :commands (shell)
  :custom
  (shell-has-auto-cd t)
  :config
  (bind-keys :map shell-mode-map
             ("C-j" . comint-send-input)))
#+end_src

***** term

#+begin_src emacs-lisp
(use-package term
  :disabled t
  :delight
  (term-mode " TR")
  :config
  (bind-keys :map term-mode-map
             ("C-j" . term-send-input)))
#+end_src

***** vterm

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-vterm"
"emacs-multi-vterm"
#+end_src

#+begin_src shell :tangle no :noweb-ref bashrc
# function/variable used in libvterm/emacs
vterm_printf(){
  if [ -n "$TMUX" ]; then
    # Tell tmux to pass the escape sequences through
    # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
    printf "\ePtmux;\e\e]%s\007\e\\" "$1"
  elif [ "${TERM%%-*}" = "screen" ]; then
    # GNU screen (screen, screen-256color, screen-256color-bce)
    printf "\eP\e]%s\007\e\\" "$1"
  else
    printf "\e]%s\e\\" "$1"
  fi
}

vterm_prompt_end(){
  vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}

PROMPT_COMMAND='echo -ne "\033]0;${HOSTNAME}:${PWD}\007"'
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :commands (vterm multi-vterm multi-vterm-next)
  :bind (:map vterm-mode-map
              ("C-c M-n" . multi-vterm-next)
              ("C-c M-p" . multi-vterm-prev))
  :delight " VT"
  :diminish ((vterm-copy-mode . "vc"))
  :custom
  (vterm-min-window-width 55)
  (vterm-buffer-name-string "vterm %s")
  :config
  (require 'multi-vterm)
  (bind-keys :map vterm-mode-map
             ("C-;" . vterm-send-backspace)
             ("C-:" . vterm-send-meta-backspace)
             ("C-y" . vterm-yank)
             ("M-y" . vterm-yank-pop)
             ("M-l" . nil)
             :map vterm-copy-mode-map
             ("C-j" . vterm-copy-mode-done))
  (advice-add 'consult-yank-from-kill-ring :around #'advice/vterm-yank-pop))

(defun my/multi-vterm (&optional arg)
  "Switch between existing vterm buffers.

Spawn a new vterm buffer if there's no available vterm buffer.
If command prefix ARG is simgle `C-u', spawn a vterm buffer forcibly regardless of condition."
  (interactive "P")
  (if (equal arg '(4))
      (multi-vterm)
    (multi-vterm-next)))

(defun advice/vterm-yank-pop (orig-fun &rest args)
  (if (eq major-mode 'vterm-mode)
      (let ((inhibit-read-only t)
            (yank-undo-function (lambda (_start _end) (vterm-undo))))
        (cl-letf (((symbol-function 'insert-for-yank)
                   (lambda (str) (vterm-send-string str t))))
          (apply orig-fun args)))
    (apply orig-fun args)))
#+end_src

***** Eshell

#+begin_src emacs-lisp
(use-package eshell
  :after my-launch-app
  :commands (eshell)
  :bind (:map my/launch-app-map
              ("e" . eshell))
  :hook
  (eshell-kill . eshell-command-alert)
  :custom
  (eshell-prompt-function
   #'(lambda ()
       (format "[%s]\n%s"
               (eshell/basename (eshell/pwd))
               (if (= (user-uid) 0) "# " "$ "))))
  (eshell-prompt-regexp "[#$] ")
  (eshell-visual-subcommands '(("git" "log" "diff" "show")))
  (eshell-scroll-to-bottom-on-input 'this)
  (eshell-history-size 2500)
  (eshell-hist-ignoredups t)
  :config
  (require 'em-prompt)
  (setq eshell-path-env (getenv "PATH"))
  (with-eval-after-load 'consult
    ;; narrow down eshell history using vertico
    (when (require 'em-hist nil t)
      (bind-keys :map eshell-hist-mode-map
                 ("C-M-n" . consult-history)))))

(defun eshell-command-alert (process status)
  "Send `alert' with severity based on STATUS when PROCESS finished."
  (let* ((cmd (process-command process))
         (buffer (process-buffer process))
         (msg (format "%s: %s" (mapconcat 'identity cmd " ")  status)))
    (if (string-prefix-p "finished" status)
        (alert msg :buffer buffer :severity  'normal)
      (alert msg :buffer buffer :severity 'urgent))))
#+end_src

****** Eshell Aliases

Aliases for Eshell are shared with Bash.

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name "eshell/aliases" tangle/emacs-etc-dir)
alias v view-file $1
alias vo view-file-other-window $1
alias <<print-aliases(lang="plain")>>
#+end_src

**** Org Mode
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:02]
:header-args:emacs-lisp+: :tangle (expand-file-name "org-config.el" tangle/emacs-config-dir)
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org"
"tree-sitter-org"
#+end_src

Basic settings for built-in Org features. Similar to [[id:587bc395-6321-4f59-97e6-6f0b62518b20][this section]], all entries obey customize group hierarchy for Org mode.

#+begin_src emacs-lisp
(use-package org
  :mode ("\\.org$" . org-mode)
  :init
  (setq org-directory "~/org"))

(defvar my/org-todo-keyword--urgent "UG"
  "TODO keyword acronym standing for 'UrGent'")
(put 'my/org-todo-keyword--urgent 'char ?u)
(defvar my/org-todo-keyword--todo "TD"
  "TODO keyword acronym standing for 'ToDo'")
(put 'my/org-todo-keyword--todo 'char ?t)
(defvar my/org-todo-keyword--next "NX"
  "TODO keyword acronym standing for 'NeXt")
(put 'my/org-todo-keyword--next 'char ?n)
(defvar my/org-todo-keyword--in-action "IP"
  "TODO keyword acronym standing for 'In Progress")
(put 'my/org-todo-keyword--in-action 'char ?i)
(defvar my/org-todo-keyword--someday "SD"
  "TODO keyword acronym standing for 'Someday'")
(put 'my/org-todo-keyword--someday 'char ?s)
(defvar my/org-done-keyword--done "DN"
  "DONE keyword acronym standing for 'DoNe'")
(put 'my/org-done-keyword--done 'char ?d)
(defvar my/org-done-keyword--cancel "CX"
  "DONE keyword acronym standing for 'Cancel'")
(put 'my/org-done-keyword--cancel 'char ?x)
(defvar my/org-done-keyword--pending "GU"
  "DONE keyword acronym standing for 'Given-Up'")
(put 'my/org-done-keyword--pending 'char ?g)

(defvar my/org-project-tag "project" "A tag for projects")
#+end_src

***** org mode keymap

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (let ((map org-mode-map))
    (keymap-set map "C-j" #'org-return)
    (keymap-set map "C-M-j" #'org-return-indent)
    (keymap-set map "M-j" #'org-meta-return)
    (keymap-set map "C-S-p" #'org-previous-item)
    (keymap-set map "C-S-n" #'org-next-item)
    (keymap-set map "C-S-u" #'org-up-element)
    (keymap-set map "C-S-d" #'org-down-element)
    (keymap-set map "C-x M-F" #'org-forward-paragraph)
    (keymap-set map "C-x M-B" #'org-backward-paragraph)
    (keymap-set map "C-<" #'org-previous-link)
    (keymap-set map "C->" #'org-next-link)
    (keymap-set map "C-c @" #'org-mark-element)
    (keymap-set map "C-c C-SPC" #'org-mark-subtree)
    (keymap-set map "C-c C-a" nil)
    (keymap-set map "C-," nil)
    (keymap-set map "M-h" nil)))
#+end_src

***** org core feature setup
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:14]
:END:

#+begin_src emacs-lisp
(with-eval-after-load "org-macs"
  (setopt org-sort-function 'org-sort-function-fallback))
#+end_src

****** Org Agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :after (org my-org-global-map)
  :bind (:map my/org-global-map
              ("a" . org-agenda))
  :hook
  (org-agenda-mode . (lambda ()
                       ;; TODO: this can be rewritten with `display-buffer'
                       (delete-other-windows)
                       (org-agenda-to-appt t '((category "appt")))))
  :custom
  (org-agenda-files
   `(,(file-name-as-directory
       (file-name-concat org-directory "agenda"))))
  (org-agenda-inhibit-startup t)
  (org-agenda-use-tag-inheritance nil)
  :config
  (bind-keys :map org-agenda-mode-map
             ("C-j" . org-agenda-switch-to)
             ("M" . org-agenda-month-view)))

(defun org-agenda-cmp-latest-clock-log (a b)
  "Compare two org entry A and B in terms of clock log.

This function can be used as `org-agenda-cmp-user-defined' in `org-agenda-sorting-strategy'."
  (let* ((marker-a (get-text-property 1 'org-marker a))
         (time-a (org-get-latest-clock-log-time marker-a))
         (marker-b (get-text-property 1 'org-marker b))
         (time-b (org-get-latest-clock-log-time marker-b)))
    (if (time-less-p time-a time-b) -1 +1)))

(defun org-clock-sum-all ()
  "Sum the times for all agenda files."
  (interactive)
  (save-excursion
    (mapc (lambda (file)
            (with-current-buffer (or (org-find-base-buffer-visiting file)
                                     (find-file-noselect file))
              (org-clock-sum)
              (org-clock-sum-today)))
          (org-agenda-files))))

(defun org-get-latest-clock-log-time (pom)
  "Get the latest clock log time stamp in org entry at POM as a time object.

If entry at POM has no clock log time stamp, this function returns 0."
  (org-with-point-at pom
    (save-excursion
      (setq end-of-subtree (org-end-of-subtree))
      (setq latest-time 0)
      (org-back-to-heading t)
      (org-show-all)
      (while (re-search-forward org-drawer-regexp end-of-subtree t)
        (when (string= (match-string 1) (org-clock-drawer-name))
          (while (progn
                   (forward-line 1)
                   (when (org-match-line (concat "^[ \t]*" org-clock-string "[ \t]*" org-tsr-regexp-both))
                     (setq match-ts
                           (if (match-string 3)
                               (match-string 3) (match-string 1)))
                     (when (time-less-p latest-time
                                        (apply 'encode-time (parse-time-string match-ts)))
                       (setq latest-time (apply 'encode-time (parse-time-string match-ts)))))
                   (not (org-match-line org-clock-drawer-end-re))))))))
  latest-time)
#+end_src

******* Org Agenda Custom Commands
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 11:05]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setopt org-stuck-projects `(,(concat "+" my/org-project-tag)
                               (,my/org-todo-keyword--todo ,my/org-todo-keyword--next ,my/org-todo-keyword--in-action)
                               nil ""))
  (setq org-agenda-custom-commands
        `(("a" "Week-agenda"
           agenda ""
           ((org-agenda-skip-function #'my/org-agenda-skip-someday-task)))
          ("l" "Log entries in a week"
           agenda ""
           ((org-agenda-skip-function #'my/org-agenda-skip-someday-task)
            (org-agenda-span (if (equal current-prefix-arg '(4))
                                 'day 'week))
            (org-agenda-start-with-log-mode t)
            (org-agenda-start-with-clockreport-mode t)
            (org-agenda-include-inactive-timestamps nil)
            (org-agenda-include-diary t)
            (org-agenda-sorting-strategy
             '(time-up
               deadline-up
               todo-state-up
               priority-down))))
          ("L" "Log entry timeline on today with default org-agenda-prefix-format"
           agenda ""
           ((org-agenda-skip-function #'my/org-agenda-skip-someday-task)
            (org-agenda-prefix-format (eval (car (get 'org-agenda-prefix-format 'standard-value))))
            (org-agenda-span (if (equal current-prefix-arg '(4))
                                 'day 'week))
            (org-agenda-start-with-clockreport-mode t)
            (org-agenda-start-with-log-mode t)
            (org-agenda-include-inactive-timestamps nil)
            (org-agenda-include-diary t)
            (org-agenda-sorting-strategy
             '(time-up
               deadline-up
               todo-state-up
               priority-down))))
          ;; KEEP IN MIND
          ;; invoking `org-clock-sum-all' is required before showing effort table
          ("e" . "Effort table")
          ("ei" "today"
           ((org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action)
                                      (and (clocked :on today)
                                           (or (todo) (done))
                                           (not (habit))
                                           (not (tags "web"))))
                                 ((org-ql-block-header "Today's task"))))
           ((org-agenda-overriding-header "Today's Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("eg" "this week"
           ((org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--next)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "This Week's task"))))
           ((org-agenda-overriding-header "This Week's Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM_T(Today){:} %CLOCKSUM(Total)")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("ed" "done task"
           ((org-ql-search-block `(or (todo ,my/org-done-keyword--done)
                                      (todo ,my/org-done-keyword--cancel)
                                      (todo ,my/org-done-keyword--pending))
                                 ((org-ql-block-header "Done task"))))
           ((org-agenda-overriding-header "Done Task")
            (org-overriding-columns-format "%26ITEM(Task) %Effort(Effort){:} %CLOCKSUM(Total){:}")
            (org-agenda-view-columns-initially t)
            (org-agenda-sorting-strategy '(todo-state-up priority-down deadline-up))))
          ("i" "Today's agenda"
           ((todo "Today's agenda"
                  ((org-agenda-sorting-strategy '(priority-up))))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "Today's task")))
            (org-ql-search-block `(and (planning :on today)
                                       (not (todo ,my/org-todo-keyword--in-action
                                                  ,my/org-done-keyword--done
                                                  ,my/org-done-keyword--cancel
                                                  ,my/org-done-keyword--pending))
                                       (not (tags "web"))
                                       (not (habit))
                                       (not (todo ,my/org-todo-keyword--someday)))
                                 ((org-ql-block-header "Scheduled/Deadlined on today")))
            (org-ql-search-block `(and (habit)
                                       (or (todo ,my/org-todo-keyword--todo)
                                           (todo ,my/org-todo-keyword--next))
                                       (scheduled :to today)
                                       (not (tags "bad_habit"))
                                       (not (tags-inherited "ARCHIVE")))
                                 ((org-ql-block-header "Habits to take")))
            (org-ql-search-block `(and (ts-active :on today)
                                       (not (or (todo ,my/org-todo-keyword--in-action)
                                                (habit) (done)))
                                       (not (todo ,my/org-todo-keyword--someday)))
                                 ((org-ql-block-header "Today's common event")))
            (org-ql-search-block '(and (done)
                                       (closed :on today))
                                 ((org-ql-block-header "Completed tasks on today")))
            (org-ql-search-block '(and (habit)
                                       (last-repeat 0))
                                 ((org-ql-block-header "Completed habits on today"))))
           ((org-agenda-sorting-strategy
             '(todo-state-up priority-down deadline-up))))
          ("n" "This Week's agenda"
           ((org-ql-search-block `(heading ,(format-time-string "%G-W%V"))
                                 ((org-agenda-files `(,(file-name-concat org-directory "archive" (format-time-string "archive_%Y.org"))))
                                  (org-ql-block-header "This week in datetree archive")))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--next))
                                 ((org-ql-block-header "This week's tasks")))
            (org-ql-search-block `(or (todo ,my/org-todo-keyword--urgent)
                                      (todo ,my/org-todo-keyword--in-action))
                                 ((org-ql-block-header "Today's tasks")))
            (org-ql-search-block `(and (planning :from 0 :to 6)
                                       (not (todo ,my/org-todo-keyword--in-action
                                                  ,my/org-done-keyword--done
                                                  ,my/org-done-keyword--cancel
                                                  ,my/org-done-keyword--pending))
                                       (not (tags "web"))
                                       (not (todo ,my/org-todo-keyword--someday))
                                       (not (habit)))
                                 ((org-ql-block-header "Scheduled/Deadlined this week")))
            (org-ql-search-block `(and (and (ts-active :from 0 :to 6)
                                            (not (deadline))
                                            (not (scheduled))
                                            (not (closed)))
                                       (not (or (todo ,my/org-todo-keyword--next
                                                      ,my/org-todo-keyword--in-action)
                                                (done))))
                                 ((org-ql-block-header "This week's common event"))))
           ((org-agenda-sorting-strategy
             '(todo-state-up priority-down deadline-up))))
          ("t" "All tasks"
           ((org-ql-search-block `(todo ,my/org-todo-keyword--urgent)
                                 ((org-ql-block-header "Urgent task")))
            (org-ql-search-block `(todo ,my/org-todo-keyword--in-action)
                                 ((org-ql-block-header "Today's task")))
            (org-ql-search-block `(todo ,my/org-todo-keyword--next)
                                 ((org-ql-block-header "This week's task")))
            (org-ql-search-block `(and (todo ,my/org-todo-keyword--todo)
                                       (not (habit)))
                                 ((org-ql-block-header "Remaining task")))))
          ("d" "Done tasks"
           ((org-ql-search-block `(and (or (done)
                                           (and (todo ,my/org-todo-keyword--someday)
                                                (not (olp "Someday Tasks"))))
                                       (not (tags "project")))
                                 ((org-ql-block-header "Done/Canceled/Pending task")))))
          ("p" "Projects" tags ,(concat "+" my/org-project-tag))
          ("h" "Habits in consistency graph"
           agenda ""
           ((org-agenda-span 'day)
            (org-agenda-use-time-grid nil)
            (org-agenda-prefix-format '((agenda . "")))
            (org-habit-show-all-today t)
            (org-agenda-sorting-strategy '(scheduled-up))
            ;; display habits only
            (org-agenda-skip-function
             (lambda ()
               (and (save-excursion
                      (not (org-is-habit-p)))
                    (progn (outline-next-heading) (point)))))))
          ("H" "show all habits"
           ((org-ql-search-block '(habit)
                                 ((org-ql-block-header "All Habits"))))
           ((org-agenda-sorting-strategy '(scheduled-up)))))))
#+end_src

******* Org Agenda Daily/Weekly
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 14:08]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setopt org-agenda-start-on-weekday 1)
  (setopt org-agenda-skip-deadline-if-done t)
  (setopt org-agenda-include-diary t)
  (setopt org-agenda-dim-blocked-tasks nil))
#+end_src

******* Org Agenda Line Format
:PROPERTIES:
:CREATED:  [2023-11-06 Mon 14:21]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (setq org-agenda-prefix-format '((agenda   . "%?-12t% s")
                                   (timeline . "  %s")
                                   (todo     . " ")
                                   (tags     . " ")
                                   (search   . " "))))
#+end_src

****** Org Capture

#+begin_src emacs-lisp
(use-package org-capture
  :after (org my-org-global-map)
  :bind (:map my/org-global-map
              ("c" . org-capture))
  :hook
  (org-capture-mode . delete-other-windows)
  :custom
  (org-reverse-note-order nil)
  (org-capture-bookmark nil)
  (org-capture-templates
   `(("e" "Entry"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      ,(concat "* [heading]\n%a\n"
               "%(and (length> \"%i\" 0)
(format \"#+begin_\%1$s\n\%2$s#+end_%1$s\n\"
\"text\"
(replace-regexp-in-string \"^*\" \",*\" \"%i\")))"))
     ("t" "Task"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      ,(format "* %s %%?\n"
               my/org-todo-keyword--todo))
     ("p" "Project"
      entry (id "58e12e3e-da50-4089-9d22-565986637121")
      "* %? [/] :project:\n"
      :jump-to-captured t)
     ("M" "Append memo to clocking task"
      item (clock)
      "- %i%?"))))
#+end_src

****** Org Startup

#+begin_src emacs-lisp
(setopt org-startup-folded 'fold
        org-startup-truncated t
        org-startup-with-inline-images t
        org-cycle-hide-drawer-startup t)

;; allow _{}/^{} format for sub/super script
(setopt org-use-sub-superscripts '{})
#+end_src

****** Org TODO

#+begin_src emacs-lisp
(setopt org-enforce-todo-dependencies t)
(setopt org-todo-keywords
        `((sequence ,(format "%s(%c)" my/org-todo-keyword--todo
                             (get 'my/org-todo-keyword--todo 'char))
                    ,(format "%s(%c)" my/org-todo-keyword--urgent
                             (get 'my/org-todo-keyword--urgent 'char))
                    ,(format "%s(%c)" my/org-todo-keyword--next
                             (get 'my/org-todo-keyword--next 'char))
                    ,(format "%s(%c)" my/org-todo-keyword--in-action
                             (get 'my/org-todo-keyword--in-action 'char))
                    ,(format "%s(%c!/!)" my/org-todo-keyword--someday
                             (get 'my/org-todo-keyword--someday 'char))
                    "|"
                    ,(format "%s(%c!/@)" my/org-done-keyword--done
                             (get 'my/org-done-keyword--done 'char))
                    ,(format "%s(%c!/@)" my/org-done-keyword--cancel
                             (get 'my/org-done-keyword--cancel 'char))
                    ,(format "%s(%c!/@)" my/org-done-keyword--pending
                             (get 'my/org-done-keyword--pending 'char)))))
(setopt org-todo-keyword-faces
        `((,my/org-todo-keyword--urgent    . "red1")
          (,my/org-todo-keyword--todo      . "DeepPink1")
          (,my/org-todo-keyword--next      . "green1")
          (,my/org-todo-keyword--in-action . "DodgerBlue1")
          (,my/org-todo-keyword--someday   . "SpringGreen")
          (,my/org-done-keyword--done      . "gray30")
          (,my/org-done-keyword--cancel    . "dark gray")
          (,my/org-done-keyword--pending   . "sea green")))
(setopt org-log-into-drawer t
        org-log-states-order-reversed t
        org-log-note-clock-out nil
        org-log-done 'time
        org-log-refile 'time
        org-log-reschedule nil
        org-log-redeadline 'time
        org-closed-keep-when-no-todo nil)
#+end_src

****** Org Structure

#+begin_src emacs-lisp
(use-package org-indent
  :after org
  :bind (:map org-mode-map
              ("C-c C-M-i" . org-indent-mode))
  :hook (org-mode . org-indent-mode)
  :custom
  (org-startup-indented t)
  (org-bookmark-names-plist nil)
  (org-insert-heading-respect-content t)
  (org-M-RET-may-split-line '((default . nil))))

(use-package org-keys
  :after org
  :custom
  (org-use-speed-commands
   (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))
  :config
  (cl-labels ((os-set (key command)
                (assoc-delete-all key org-speed-commands)
                (add-to-list 'org-speed-commands
                             (cons key command)
                             t)))
    (add-to-list 'org-speed-commands '("Additional") t)
    (os-set "P" #'org-set-property)
    (os-set "C" #'org-clone-subtree-with-time-shift)
    (os-set "s" #'org-schedule)
    (os-set "d" #'org-deadline)
    (os-set "N" #'org-toggle-narrow-to-subtree)
    (os-set "$" #'org-archive-subtree)
    (os-set "'" #'ignore)))
#+end_src

******* Org Edit Structure

#+begin_src emacs-lisp
(use-package org-src
  :after org
  :hook (org-src-mode . (lambda ()
                          (setq-local auto-save-visited-mode nil)
                          (setq-local buffer-save-without-query t)
                          (when (eq major-mode 'text-mode)
                            (visual-line-mode 1))))
  :custom
  (org-special-ctrl-a/e t)
  (org-src-window-setup 'current-window)
  (org-edit-src-content-indentation 0)
  (org-edit-src-turn-on-auto-save nil)
  (org-edit-src-auto-save-idle-delay 30)
  (org-edit-src-persistent-message nil)
  (org-src-ask-before-returning-to-edit-buffer nil)
  (org-special-ctrl-k t)
  (org-ctrl-k-protect-subtree t)
  (org-src-lang-modes
   (mapc (lambda (override-src-lang)
           (add-to-list 'org-src-lang-modes override-src-lang))
         '(("bash"   . bash-ts)
           ("C"      . c)
           ("ruby"   . ruby)
           ("python" . python-ts)
           ("java"   . java)
           ("rust"   . rust)
           ("lua"    . lua)
           ("css"    . css-ts)
           ("json"   . json-ts)
           ("dot"    . graphviz-dot)
           ("yaml"   . yaml-ts))))
  :config
  (mapc (lambda (temp-cons)
          (if-let ((place (assoc (car temp-cons) org-structure-template-alist)))
              (setf (cdr (assoc (car temp-cons) org-structure-template-alist)) (cdr temp-cons))
            (add-to-list 'org-structure-template-alist temp-cons t)))
        '(("sh" . "src shell")
          ("tx" . "src text")
          ("el" . "src emacs-lisp")
          ("py" . "src python")))
  (advice-add #'org-edit-src-save
              :before
              (lambda (&rest _)
                (delete-trailing-whitespace))))
#+end_src

******* Org Plain lists

#+begin_src emacs-lisp
(setopt org-list-demote-modify-bullet
        '(("-" . "+") ("+" . "-") ("*" . "-")
          ("1." . "1)") ("1)" . "1.") ("*" . "1."))
        org-cycle-include-plain-lists 'integrate
        org-list-use-circular-motion t
        org-list-allow-alphabetical t)
#+end_src

******* Org Archive

#+begin_src emacs-lisp
(use-package org-archive
  :defer t
  :custom
  (org-archive-default-command 'org-toggle-archive-tag))

(setopt org-cycle-open-archived-trees t)
#+end_src

******* Org Inline Tasks

#+begin_src emacs-lisp
(use-package org-inlinetask
  :commands (org-inlinetask-insert-task
             org-inlinetask-promote
             org-inlinetask-demote)
  :custom
  (org-inlinetask-default-state my/org-todo-keyword--todo)
  (org-inlinetask-min-level 10))
#+end_src

****** Org Goto
:PROPERTIES:
:CREATED:  [2025-01-21 Tue 08:34]
:END:

#+begin_src emacs-lisp
(use-package org-goto
  :after org
  :custom
  (org-goto-interface 'outline-path-completion)
  (org-goto-max-level 7))
#+end_src

****** Org Tags

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (setopt org-use-tag-inheritance org-archive-tag
          org-tags-column -57
          org-tags-sort-function #'org-string-collate-greaterp))
#+end_src

****** Org Properties

#+begin_src emacs-lisp
(setopt org-use-property-inheritance "TIMELIMIT.*"
        org-highest-priority ?A
        org-lowest-priority ?Z
        org-default-priority ?E
        org-global-properties
        '(("Effort_ALL". "0 0:10 0:20 0:30 1:00 1:30 2:00 3:00 4:00 6:00 8:00")))
#+end_src

****** Org Refile

#+begin_src emacs-lisp
(use-package org-refile
  :after (org denote)
  :commands (org-refile)
  :custom
  (org-outline-path-complete-in-steps nil)
  (org-refile-targets
   `((org-agenda-files :tag . ,my/org-project-tag)
     (org-agenda-files :tag . "refile")
     (,(cl-remove-if-not (lambda (f)
                           (member "refile"
                                   (denote-extract-keywords-from-path f)))
                         (denote-directory-files))
      :tag . "refile"))))
#+end_src

****** Org Time

#+begin_src emacs-lisp
(setopt org-time-stamp-custom-formats
        '("<%m-%d %a>" . "<%H:%M>"))
#+end_src

******* Org Progress

******** Org Habit
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 12:58]
:END:

#+begin_src emacs-lisp
(use-package org-habit
  :after org
  :custom
  (org-habit-graph-column 32)
  (org-habit-preceding-days 21)
  (org-habit-following-days 14)
  (org-habit-show-habits-only-for-today t))
#+end_src

******** Org Clock

#+begin_src emacs-lisp
(use-package org-clock
  :after (org my-org-global-map)
  :custom
  (org-clock-into-drawer "CLOCK")
  (org-clock-out-when-done t)
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-persist t)
  (org-clock-persist-query-resume nil)
  (org-clock-string-limit 20)
  (org-clock-continuously t)
  (org-clock-ask-before-exiting nil)
  :config
  (org-clock-persistence-insinuate)
  (bind-keys :map my/org-global-map
             ("j" . org-clock-goto)
             ("I" . org-clock-in)
             ("O" . org-clock-out)
             ("X" . org-clock-cancel))
  (with-eval-after-load 'org-keys
    (dolist (elt '(("Clock Commands")
                   ("I" . org-clock-in)
                   ("O" . org-clock-out)
                   ("x" . nil)
                   ("X" . org-clock-cancel)))
      (add-to-list 'org-speed-commands elt t))))
#+end_src

****** Org Appearance

#+begin_src emacs-lisp
(setopt org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-image-actual-width 100
        org-display-remote-inline-images 'cache)
#+end_src

****** Babel

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"plantuml"
#+end_src

#+NAME: config/emacs-ob-core
#+begin_src emacs-lisp :noweb tangle
(use-package ob-core
  :after org
  :hook (org-babel-after-execute . org-display-inline-images)
  :init
  (cond
   ((string= system-type "gnu/linux")
    (setq org-plantuml-jar-path (expand-file-name "plantuml.jar" "~/.guix-profile/share/java")))
   ((string= system-type "darwin")
    (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/8041/plantuml.8041.jar")))
  :custom
  (org-babel-load-languages '((emacs-lisp . t)
                              (lisp       . t)
                              (C          . t)
                              (java       . t)
                              (R          . t)
                              (shell      . t)
                              (ruby       . t)
                              (python     . t)
                              (scheme     . t)
                              (lua        . t)
                              (ledger     . t)
                              (gnuplot    . t)
                              (dot        . t)
                              (plantuml   . t)
                              (lilypond   . t))))
#+end_src

******* Org Babel Tangle
:PROPERTIES:
:CREATED:  [2023-10-29 Sun 11:23]
:END:

org-babel-tangle-default-file-mode does not seems to be in effect. I set org-babel-default-header-args:<lang> instead as a wordaround.

#+begin_src emacs-lisp
(use-package ob-tangle
  :after ob-core
  :custom
  (org-babel-tangle-default-file-mode (identity #o444))
  (org-babel-tangle-use-relative-file-links nil))
#+end_src

****** Org ID

#+begin_src emacs-lisp
(use-package org-id
  :after org
  :bind (:map org-mode-map
              ("C-c i" . org-id-copy))
  :custom
  (org-id-track-globally t)
  (org-id-link-to-org-use-id 'create-if-interactive))
#+end_src

****** Org Crypt

#+begin_src emacs-lisp
(use-package org-crypt
  :after org
  :custom
  (org-crypt-key user-mail-address)
  :config
  (bind-keys :map org-mode-map
             ("C-c M-: e" . org-encrypt-entry)
             ("C-c M-: E" . org-encrypt-entries)
             ("C-c M-: d" . org-decrypt-entry)
             ("C-c M-: D" . org-decrypt-entries))
  (org-crypt-use-before-save-magic)
  (add-to-list 'org-tags-exclude-from-inheritance
               org-crypt-tag-matcher))
#+end_src

****** Org Attach                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-03-23 Sat 18:22]
:END:

#+begin_src emacs-lisp
(setopt org-attach-preferred-new-method nil)
#+end_src

****** Org Link

#+begin_src emacs-lisp
(use-package ol
  :after my-org-global-map
  :bind (:map my/org-global-map
              ("s" . org-store-link))
  :config
  (org-link-set-parameters "src" :follow #'org-babel-ref-resolve))
#+end_src

******* Org Follow Link

#+begin_src emacs-lisp
(with-eval-after-load 'ol
  (setf (alist-get 'file org-link-frame-setup) 'find-file)
  (setopt org-link-elisp-confirm-function nil))

(with-eval-after-load 'org-keys
  (setopt org-return-follows-link t))
#+end_src

****** Org Export

******* Org Export General

#+begin_src emacs-lisp
(use-package ox
  :commands org-export-dispatch
  :custom
  (org-export-with-smart-quotes t)
  (org-export-with-emphasize t)
  (org-export-with-special-strings t)
  (org-export-with-fixed-width t)
  (org-export-with-timestamps t)
  (org-export-preserve-breaks nil)
  (org-export-with-sub-superscripts nil)
  (org-export-with-archived-trees 'headline)
  (org-export-with-author nil)
  (org-export-with-broken-links 'mark)
  (org-export-with-clocks nil)
  (org-export-with-creator nil)
  (org-export-with-drawers '(not "LOGBOOK"))
  (org-export-with-date nil)
  (org-export-with-entities t)
  (org-export-with-email nil)
  (org-export-with-footnotes t)
  (org-export-headline-levels 5)
  (org-export-with-inlinetasks t)
  (org-export-with-section-numbers nil)
  (org-export-with-planning nil)
  (org-export-with-priority nil)
  (org-export-with-properties nil)
  (org-export-with-statistics-cookies t)
  (org-export-with-tags nil)
  (org-export-with-tasks t)
  (org-export-with-latex t)
  (org-export-time-stamp-file nil)
  (org-export-with-title t)
  (org-export-with-toc nil)
  (org-export-with-todo-keywords nil)
  (org-export-with-tables t)
  (org-export-default-language "ja")
  (org-export-dispatch-use-expert-ui nil))
#+end_src

******* Org Export HTML

#+begin_src emacs-lisp
(use-package ox-html
  :commands (org-html-export-as-html
             org-html-export-to-html)
  :custom
  (org-html-preamble t)
  (org-html-postamble 'auto)
  (org-html-with-latex t)
  (org-html-container-element "div")
  (org-html-doctype "xhtml-strict"))
#+end_src

******* Org Export LaTeX

#+begin_src emacs-lisp
(use-package ox-latex
  :commands (org-latex-export-as-latex
             org-latex-export-to-latex
             org-latex-export-to-pdf)
  :custom
  (org-latex-pdf-process '("platex %f"
                           "platex %f"
                           "bibtex %b"
                           "platex %f"
                           "platex %f"
                           "dvipdfmx %b.dvi"))
  (org-latex-default-class "jsarticle")
  :config
  (add-to-list 'org-latex-classes
               '("jsarticle"
                 "\\documentclass[dvipdfmx,12pt]{jsarticle}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               `("beamer"
                 "\\documentclass[presentation,dvipdfmx,18pt]{beamer}\n"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

******* Org Export Texinfo
:PROPERTIES:
:CREATED:  [2024-04-16 Tue 22:05]
:END:

#+begin_src emacs-lisp
(use-package ox-texinfo
  :after ox)
#+end_src

***** org external packages
:PROPERTIES:
:CREATED:  [2023-01-24 Tue 16:07]
:END:
****** org-ai                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-23 Fri 17:40]
:END:

#+begin_src emacs-lisp :noweb no
(use-package org-ai
  :disabled t
  :after org
  :hook (org-mode #'org-ai-mode)
  :custom
  (org-ai-chat-models '("gpt-3.5-turbo"))
  (org-ai-default-chat-model "gpt-3.5-turbo")
  (org-ai-default-max-tokens 150)
  (org-ai-image-directory (expand-file-name "org-ai-images"
                                            user-emacs-directory)))
#+end_src

****** org-modern
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 22:03]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-modern"
#+end_src

#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :commands org-modern-mode)
#+end_src

****** org-transclusion
:PROPERTIES:
:CREATED:  [2023-03-02 Thu 14:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-transclusion"
#+end_src

#+begin_src emacs-lisp
(use-package org-transclusion
  :after org
  :bind (:map my/org-global-map
              ("% a" . org-transclusion-add)
              ("% A" . org-transclusion-add-all)
              ("% n" . org-transclusion-make-from-link)
              ("% t" . org-transclusion-activate)))
#+end_src

****** org-edna
:PROPERTIES:
:CREATED:  [2022-10-24 Mon 15:28]
:END:

[[https://www.nongnu.org/org-edna-el/][Org Edna]] allows to org entries to be blockers and action triggers, which is very intresting feature especially for managing successive set of tasks or any correlated tasks.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-edna"
#+end_src

#+begin_src emacs-lisp
(use-package org-edna
  :after org
  :custom
  (org-edna-mode t))
#+end_src

****** org-drill

[[https://gitlab.com/phillord/org-drill][org-drill]] helps me to learn english words and phrases. [[https://youtu.be/SGzdFtN_NqE][This video]] introduces how I use org-drill.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-drill-head"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://gitlab.com/phillord/org-drill/-/tags?format=atom" soft_update)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package org-drill
  ;; :ensure t
  :after org
  :bind (:map org-mode-map
              ("C-c D" . org-drill-tree))
  :custom
  (org-drill-spaced-repetition-algorithm 'sm5)
  :config
  (copy-face 'highlight 'org-drill-hidden-cloze-face))
#+end_src

****** org-ql

[[https://github.com/alphapapa/org-ql][Org QL]] enables me to issue queries to search org entries with either SQL-like format or plain search strings.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-ql"
#+end_src

#+begin_src emacs-lisp
(use-package org-ql
  :after (org my-org-global-map)
  :bind (:map my/org-global-map
              ("q q" . org-ql-search)
              ("q v" . org-ql-view)
              ("q f f" . org-ql-find)
              ("q f F" . org-ql-find-in-org-directory)
              ("q f a" . org-ql-find-in-agenda)
              ("q f n" . my/org-ql-find-in-notes)
              ("q /" . org-ql-sparse-tree))
  :preface
  (defun my/org-ql-find-in-notes ()
    "Call 'org-ql-find' on 'denote-all-files'."
    (interactive)
    (when (require 'denote nil t)
      (org-ql-find (denote-directory-files))))
  :custom
  (org-ql-search-directories-files-regexp "\\.org\\(?:\\.gpg\\)?$")
  (org-ql-search-directories-files-recursive t)
  :preface
  (defconst org-last-repeat-time-regexp
    "\\(?::LAST_REPEAT: *\\[\\([^]]+\\)]\\)"
    "Matches the LAST_REPEAT property together with a time stamp.")
  :config
  (require 'org-ql-search)
  (org-ql-defpred last-repeat (&key from to _on)
    "Return non-nil if current entry was repeated in given period.
Without arguments, return non-nil if entry has LAST_REPEAT property."
    :normalizers ((`(,predicate-names ,(and num-days (pred numberp)))
                   (let* ((from-day (* -1 num-days))
                          (rest (list :from from-day)))
                     (org-ql--normalize-from-to-on
                       `(last-repeat :from ,from))))
                  (`(,predicate-names . ,rest)
                   (org-ql--normalize-from-to-on
                     `(last-repeat :from ,from :to ,to))))
    :preambles ((`(,predicate-names . ,_)
                 ;;  Predicate still needs testing.
                 (list :regexp org-last-repeat-time-regexp :query query)))
    :body
    (org-ql--predicate-ts :from from :to to :regexp org-last-repeat-time-regexp :match-group 1))
  (org-ql-defpred (tags-expanded expanded-tags tags-x xtags) (&rest tags)
    "Return non-nil if current heading has one or more of TAGS.
If TAGS contains a group tag, all tags in the group is used to match.
Both inherited and local tags is tested."
    :normalizers ((`(,predicate-names . ,tags)
                   `(tags-expanded ,@tags)))
    :body (apply #'org-ql--predicate-tags
                 (seq-uniq (--mapcat (org-tags-expand it t)
                                     tags))))
  (org-ql-defpred (category-inherited) (&rest categories)
    "Return non-nil if current heading has CATEGORY.
Ancestors are looked up If current heading has no CATEGORY."
    :body (when-let ((category (or (org-get-category (point))
                                   (org-entry-get (point) "CATEGORY" t))))
            (cl-typecase categories
              (null t)
              (otherwise (member category categories)))))
  (with-eval-after-load 'org-expiry
    (org-ql-defpred expired ()
      "Return non-nil if the entry is expired."
      :body (org-expiry-expired-p))))

(use-package org-ql-view
  :after (org-ql org-agenda)
  :config
  (push `("Tasks on Web/Book"
          :buffers-files org-agenda-files
          :query (and (or (tags "web")
                          (tags "book"))
                      (not (or (done) (todo ,my/org-todo-keyword--someday))))
          :super-groups ((:auto-tags))
          :sort (priority date))
        org-ql-views)
  (push `("Habits"
          :buffers-files org-agenda-files
          :query (habit)
          :sort (todo scheduled))
        org-ql-views))
#+end_src

****** org-contacts

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-contacts"
#+end_src

#+begin_src emacs-lisp
(use-package org-contacts
  :after org
  :commands (org-contacts-anniversaries)
  :config
  (when (require 'denote nil t)
    (setq org-contacts-files
          (list (denote-get-path-by-id "20230605T173003")))))
#+end_src

****** org-ml                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 20:02]
:END:

#+begin_src emacs-lisp :tangle no
(use-package org-ml
  :after org)
#+end_src

****** org-roam                            :ARCHIVE:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-org-roam"
#   "emacs-emacsql-sqlite3"
# #+end_src

#+begin_src emacs-lisp :tangle no
(use-package org-roam
  :disabled t
  :after org
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n S" . org-roam-db-sync))
  :custom
  (org-roam-directory org-directory)
  (org-roam-db-location (file-name-concat user-emacs-directory "org-roam.db"))
  (org-roam-database-connector 'sqlite3)
  (org-roam-db-update-on-save nil)
  (org-roam-db-extra-links-exclude-keys
   '((node-property "ROAM_REFS")
     (node-property "PARENT")
     (keyword "transclude")))
  :config
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-section
              #'org-roam-reflinks-section
              #'org-roam-unlinked-references-section)))
#+end_src
****** org-mime

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-mime"
#+end_src

#+begin_src emacs-lisp
(use-package org-mime
  :after org
  :commands (org-mime-org-subtree-htmlize)
  :bind (:map org-mode-map
              ("C-c M-M" . org-mime-org-subtree-htmlize))
  :custom
  (org-mime-use-property-inheritance t)
  (org-mime-export-ascii t))
#+end_src

****** org-web-tools

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-web-tools"
#+end_src

#+begin_src emacs-lisp
(use-package org-web-tools
  :bind (("C-c C-;" . org-web-tools-insert-link-for-url)))
#+end_src

****** org-volume                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 21:59]
:END:

[[https://github.com/akirak/org-volume][org-volume]] can be used to insert book information in dynamic block.

#+begin_src emacs-lisp :tangle no
(use-package org-volume
  :straight (org-volume
             :host github
             :repo "akirak/org-volume"
             :branch "master"))
#+end_src

****** org-clock-convenience

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/dfeich/org-clock-convenience/tags.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package org-clock-convenience
  :ensure t
  :after org-agenda
  :bind
  (:map org-agenda-mode-map
        ("@"   . org-clock-convenience-fill-gap)
        ("C-@" . org-clock-convenience-fill-gap-both)))
#+end_src

****** org-reveal

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-reveal"
#+end_src

****** org-expiry

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-contrib"
#+end_src

#+begin_src emacs-lisp
(use-package org-expiry
  :after org
  :custom
  (org-expiry-inactive-timestamps t)
  (org-expiry-handler-function 'org-expiry-archive-subtree)
  :config
  (with-eval-after-load 'org-capture
    (add-hook 'org-capture-prepare-finalize-hook
              #'org-expiry-insert-created))
  ;; Workaround for the malfunction of org-expiry-insinuate
  (unless (ignore-errors (org-expiry-insinuate))
    (add-hook 'org-insert-heading-hook 'org-expiry-insert-created)
    (add-hook 'org-after-todo-state-change-hook 'org-expiry-insert-created)
    (add-hook 'org-after-tags-change-hook 'org-expiry-insert-created)))
#+end_src

****** ob-async                            :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:31]
:END:

#+begin_src scheme :tangle no
"emacs-ob-async"
#+end_src

#+begin_src emacs-lisp
(use-package ob-async
  :after ob-core)
#+end_src

****** ob-lilypond                         :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:31]
:END:

#+begin_src emacs-lisp
(use-package ob-lilypond
  :after ob-core
  :custom
  ;; (org-babel-lilypond-commands '("lilypond" "firefox" "fluidsynth -a alsa -m alsa_seq -l"))
  (org-babel-lilypond-commands '("lilypond" "firefox" "xdg-open"))
  (org-babel-lilypond-arrange-mode t))
#+end_src

****** ox-hugo
:PROPERTIES:
:CREATED:  [2023-01-26 Thu 18:33]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ox-hugo"
#+end_src

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox)
#+end_src

****** org-web-track
:PROPERTIES:
:CREATED:  [2023-01-06 Fri 13:43]
:END:

[[help:my/org-web-track-update-all-and-notify][org-web-track-update-all-and-notify]] seems not to suit midnight-hook.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-web-track"
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "org-web-track-config.el" tangle/emacs-config-dir)
(use-package org-web-track
  ;; :ensure t
  ;; :load-path "~/.local/share/ghq/github.com/p-snow/org-web-track"
  :after my-org-global-map
  :bind (:map my/org-global-map
              ("T q" . my/org-web-track-ql-view)
              ("T c" . org-web-track-columns)
              ("T a" . org-web-track-agenda-columns)
              ("T n" . org-web-track-setup-entry)
              ("T u" . org-web-track-update-entry)
              ("T U" . org-web-track-update-files)
              ("T r" . org-web-track-report))
  :preface
  (defun my/org-web-track-ql-view ()
    "Open Org Agenda view with tracking items which hold TRACK_URL property."
    (interactive)
    (require 'org-web-track nil t)
    (with-current-buffer (get-buffer-create "Org Web Track")
      (org-agenda-mode)
      (setq-local org-overriding-columns-format (org-web-track-columns-format)
                  org-agenda-view-columns-initially t)
      (setq org-columns-modify-value-for-display-function
            'org-web-track-display-values)
      (when (require 'org-ql nil t)
        (org-ql-search org-web-track-files
          `(and (property ,org-web-track-url)
                (not (tags ,org-archive-tag)))
          :super-groups '((:tag "book") (:tag "food")
                          (:tag "tool") (:tag "supply"))
          :buffer (current-buffer)))))
  (defun my/org-web-track-update-all-and-notify ()
    "Update all web tracking items in `org-web-track-files'
 and send an email if any of them has changed its value."
    (let* ((org-log-into-drawer t)
           (message-kill-buffer-on-exit t)
           (mail-msg (mapconcat
                      (lambda (chg)
                        (org-with-point-at chg
                          (let ((org-trust-scanner-tags t))
                            (format "%s\n\t%s\n"
                                    (substring-no-properties
                                     (org-get-heading t t t t))
                                    (org-web-track-current-changes nil "%p => %c" " | ")))))
                      (org-web-track-update-files))))
      (unless (string-blank-p mail-msg)
        ;; you need to set SMTP info to smtpmail-xxx variables
        (message-mail user-mail-address "Web Tracking Notification")
        (message-goto-body)
        (insert mail-msg)
        (message-send-and-exit))))
  (defvar my/usd-exchange-rates nil)
  (defun my/usd-excange-rate (currency)
    "Return the exchange rate between CURRENCY and the US dollar.

This function also Update `my/usd-exchange-rates', a list of
exchange rate against US dollar."
    (or my/usd-exchange-rates
        (request (concat "https://openexchangerates.org/api/latest.json?app_id="
                         (my/credential-info "openexchangerates.org" "app id"))
          :sync t
          :success
          (cl-function
           (lambda (&key response &allow-other-keys)
             (let ((content (request-response-data response)))
               (setq my/usd-exchange-rates (json-parse-string content :object-type 'alist)))))
          :complete
          (cl-function
           (lambda (&key data &allow-other-keys)
             data))))
    (assoc-default currency
                   (assoc-default 'rates my/usd-exchange-rates)))
  (defun my/convert-currency (target-currency amount)
    "Convert AMOUNT into TARGET-CURRENCY."
    (let* ((currs '(("$" . USD) ("€" . EUR) ("£" . GBP) ("₹" . INR)
                    ("¥" . JPY) ("¥" . CNY) ("₩" . KRW) ("₽" . RUB)))
           (curr-re (rx-to-string `(seq (group-n 1 (or ,@(mapcar 'car currs)))
                                        (group-n 2 (1+ digit))))))
      (when (string-match curr-re amount)
        (let ((amt-in-usd (string-to-number (match-string 2 amount)))
              (to-usd-rate (my/usd-excange-rate
                            (assoc-default (match-string 1 amount) currs)))
              (from-usd-rate (my/usd-excange-rate target-currency)))
          (format "%s%.2f"
                  (car (rassq target-currency currs))
                  (/ (* amt-in-usd from-usd-rate) to-usd-rate))))))
  :custom
  (org-web-track-use-curl nil)
  (org-web-track-content-fetcher-alist
   `((,(regexp-quote "melpa.org/#/") .
      "fetch-dynamic-page %s")))
  (org-web-track-selectors-alist
   `((,(regexp-quote "melpa\.org/#/") .
      "htmlq --text dd | head -n 1 | cut -d ' ' -f 1")
     (,(regexp-quote "www.lenovo.com/jp/ja/p/laptops/thinkpad")
      (lambda (dom)
        (when-let ((price-node (car (dom-search dom (lambda (node) (string= "productpromotionprice"
                                                                        (dom-attr node 'name)))))))
          (assoc-default 'content (cadr price-node)))))
     (,(rx "www.amazon.co.jp" (+ anychar) "-ebook")
      ;; "pup 'span[id=\"priceblock_ourprice\"],span[id=\"kindle-price\"],span[class=\"a-text-price\"],span[class=\"a-offscreen\"] json{}' \| jq -re '.[0].text'"
      [.a-size-base.a-color-price.a-color-price])
     (,(regexp-quote "www.amazon.co.jp/product-reviews")
      [.a-size-base.a-color-secondary] ; num of stars
      [.a-size-medium.a-color-base])  ; rating
     (,(regexp-quote "www.amazon.co.jp")
      [.a-price.aok-align-center > .a-offscreen]
      [div:availability span]         ; availability
      )
     (,(regexp-quote "www.yodobashi.com/product")
      [:js_scl_unitPrice])
     (,(regexp-quote "kakaku.com/item")
      [.priceTxt])
     (,(regexp-quote "store.steampowered.com")
      (lambda (dom)
        (when-let ((products (dom-search dom (lambda (node) (string-prefix-p "game_area_purchase_game"
                                                                             (dom-attr node 'class))))))
          (seq-some (lambda (prod)
                      (let ((text (dom-text (or (dom-by-class prod "game_purchase_price")
                                                (dom-by-class prod "discount_final_price")))))
                        (if (length= text 0) nil text)))
                    products))))
     (,(regexp-quote "www.googleapis.com/youtube/v3/channels")
      (lambda (json)
        (assoc-default 'subscriberCount
                       (assoc-default 'statistics (aref (cdr (assoc 'items json))
                                                        0)))))
     (,(regexp-quote "www.googleapis.com/youtube/v3/videos")
      (lambda (json)
        (when (require 'dash nil t)
          (let ((stat (->> json
                           (assoc-default 'items)
                           (mapcar #'identity)
                           (nth 0)
                           (assoc-default 'statistics))))
            (list (assoc-default 'likeCount stat)
                  (assoc-default 'commentCount stat))))))
     (,(regexp-quote "openexchangerates.org/api/latest")
      (lambda (json)
        (format "%.3f"
                (assoc-default 'JPY
                               (assoc-default 'rates json)))))
     (,(regexp-quote "map.kaldi.co.jp/kaldi")
      "pup 'div[class=\"shop_bnr news\"] ul li text{}' | xargs echo -n")
     (,(regexp-quote "www.seijoishii.com")
      [.price > .total])
     ("localhost" identity)
     (,(regexp-quote "store.minisforum.jp/products")
      (lambda (dom)
        (when-let* ((prod-price (car (dom-by-class dom "product-info__price")))
                    (sale-price (car (dom-by-tag prod-price 'sale-price))))
          (dom-text sale-price))))
     (,(rx (seq "www.gmktec.com/" (or "products" "collections")))
      (lambda (dom)
        (when-let* ((price-w (car (dom-by-class dom "product-info__header_price-wrapper")))
                    (price (car (dom-by-class price-w "tw-text-save-color"))))
          (my/convert-currency 'JPY (dom-text price)))))
     (,(regexp-quote "api.github.com/repos") .
      ,(apply-partially 'assoc-default 'stargazers_count))))
  (org-agenda-bulk-custom-functions
   '((?U org-web-track-agenda-update)))
  (org-web-track-item-column-width 16)
  (org-web-track-update-column-width 30)
  (org-web-track-files
   (lambda ()
     (when (require 'denote nil t)
       (let ((denote-directory (expand-file-name "~/org/notes"))
             (org-agenda-files '("~/org/agenda/")))
         (append (org-agenda-files)
                 (cl-remove-if-not (lambda (f)
                                     (member "track"
                                             (denote-extract-keywords-from-path f)))
                                   (denote-directory-files))))))))
#+end_src

******* batch tracking
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 21:05]
:END:

#+begin_src shell :eval no :tangle no :noweb-ref morning-batch
export DISPLAY=:0 && \
  emacs -Q --batch \
        -l $XDG_CONFIG_HOME/emacs/early-init.el \
        -l $XDG_CONFIG_HOME/emacs/lisp/00-my-early-config.el \
        -l $XDG_CONFIG_HOME/emacs/lisp/ext-config.el \
        -l $XDG_CONFIG_HOME/emacs/lisp/org-web-track-config.el \
        -l $XDG_CONFIG_HOME/emacs/batch/org-web-track-mail.el \
        -f my/org-web-track-mail
#+end_src

#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name "batch/org-web-track-mail.el" tangle/user-emacs-directory)
(define-keymap :prefix 'my/org-global-map)
(provide 'my-org-global-map)

(setopt message-send-mail-function 'smtpmail-send-it
        smtpmail-smtp-server "<<smtp-host>>"
        smtpmail-smtp-service 465
        smtpmail-smtp-user user-mail-address
        smtpmail-stream-type 'ssl
        smtpmail-mail-address user-mail-address
        message-send-mail-function 'smtpmail-send-it
        network-security-level 'low
        make-backup-files nil)

(defun my/org-web-track-mail ()
  "Update `org-web-track' items along with sending email and immediate exit."
  (my/org-web-track-update-all-and-notify)
  (org-save-all-org-buffers)
  (save-buffers-kill-emacs t))
#+end_src

****** org-tidy
:PROPERTIES:
:CREATED:  [2024-06-14 Fri 10:32]
:END:

[[https://github.com/jxq0/org-tidy][org-tidy]] attentively conceals all org drawers. I use it in [[id:2bd0c5d2-faed-43d9-b054-3e1ad9b51a76][my English drill session]].

#+begin_src emacs-lisp
(use-package org-tidy
  :ensure t
  :after org
  :bind (:map org-mode-map
              ("C-c t" . org-tidy-mode)))
#+end_src

****** org-super-links                     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-06-17 Mon 18:52]
:END:

#+begin_src emacs-lisp
(use-package org-super-links
  :load-path "~/.local/share/ghq/github.com/toshism/org-super-links"
  :defer t)
#+end_src

****** org-appear
:PROPERTIES:
:CREATED:  [2024-09-07 Sat 23:58]
:END:

[[https://github.com/awth13/org-appear][org-appear]] attentively displays emphasis markers, such as / for italic and _ for underline, only when the cursor is positioned over the word in Org Mode.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-org-appear"
#+end_src

#+begin_src emacs-lisp
(use-package org-appear
  :after org
  :disabled t ;; tempprarily not working with Org 9.7
  :hook (org-mode . (org-appear-mode)))
#+end_src

**** Completion

***** vertico

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-vertico"
#+end_src

#+begin_src emacs-lisp
(use-package vertico
  :bind (:map vertico-map
              ("C-j" . exit-minibuffer)
              ("RET" . vertico-directory-enter)
              ("C-;" . vertico-directory-delete-char)
              ("C-:" . vertico-directory-delete-word)
              ("M-q" . vertico-quick-insert)
              ("C-q" . vertico-quick-exit))
  :hook
  ((minibuffer-setup . vertico-repeat-save)
   ;; enable to write "~/" or "/" whatever path being input in minibuffer
   (rfn-eshadow-update-overlay . vertico-directory-tidy))
  :custom
  (vertico-cycle t)
  (vertico-scroll-margin 0)
  (vertico-count 11)
  (vertico-resize 'grow-only)
  :config
  (bind-keys ("M-R" . vertico-repeat))
  (vertico-mode 1))

(use-package vertico-multiform
  :after vertico
  :bind (:map vertico-map
              ("M-G" . vertico-multiform-grid))
  :config
  (vertico-multiform-mode 1))
#+end_src

***** consult

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-consult"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package consult
  :after my-org-global-map
  :bind (("H-f" . consult-buffer)
         ("C-c m" . consult-mode-command)
         ("C-c h" . consult-outline)
         ("C-x M-:" . consult-complex-command)
         ("M-y" . consult-yank-pop)
         ("C-M-y" . consult-yank-from-kill-ring)
         ("M-g M-g" . consult-goto-line)
         ("M-g m" . consult-mark)
         ("M-g M" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("C-x r j" . consult-register)
         ("M-s e" . consult-isearch-history)
         ("M-s \\" . consult-locate)
         ("M-s f" . consult-find)
         ("M-s F" . consult-fd)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("H-s" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ("M-s i" . consult-info)
         ("C-x M-#" . consult-theme)
         :map my/org-global-map
         ("h" . consult-org-agenda)
         :map isearch-mode-map
         ("C-M-n" . consult-isearch-history)
         ("M-l" . consult-line)
         ("M-L" . consult-line-multi)
         :map minibuffer-local-map
         ("C-M-n" . consult-history)
         :map text-mode-map
         ("C-M-i" . completion-at-point)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :custom
  (consult-narrow-key "<")
  (consult-widen-key ">")
  (consult-line-start-from-top t)
  (consult-locate-args (format "plocate -d %s --ignore-case --existing --regexp"
                               (expand-file-name "<<locate-db-home()>>")))
  (consult-find-args "find . ")
  (consult-fd-args '((if (executable-find "fdfind" 'remote)
                         "fdfind" "fd")
                     "--hidden --full-path --color=never"))
  :init
  ;; use consult for completion unless Corfu is active
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))
  :config
  (with-eval-after-load 'org
    (bind-keys :map org-mode-map
               ("C-c H" . consult-org-heading)))
  (setq consult-ripgrep-args (concat (default-value 'consult-ripgrep-args) " --hidden")))
#+end_src

****** consult-dir
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 17:01]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-consult-dir"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package consult-dir
  :after consult-ghq
  :bind ("H-d" . consult-dir)
  :preface
  (defvar consult-dir--source-doc-repo
    `(:name "Document Directories"
            :narrow ?d
            :category file
            :face consult-file
            :history file-name-history
            :items ,(lambda ()
                      (let* ((project (project-current t "<<doc-dir()>>"))
                             (all-files (project-files project))
                             (completion-ignore-case read-file-name-completion-ignore-case))
                        (mapcar #'file-name-directory all-files))))
    "Directory source in my document folder for `consult-dir--pick'.")
  (defvar consult-dir--source-ghq
    `(:name "Projects in ghq"
            :narrow ?q
            :category file
            :face consult-file
            :history file-name-history
            :items ,(lambda () (consult-ghq--list-candidates)))
    "Directory source in my document folder for `consult-dir--pick'.")
  :custom
  (consult-dir-default-command 'dired)
  :config
  (add-to-list 'consult-dir-sources 'consult-dir--source-doc-repo)
  (add-to-list 'consult-dir-sources 'consult-dir--source-ghq))
#+end_src

****** affe
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 14:02]
:END:

#+begin_src emacs-lisp
(use-package affe
  :ensure t
  :bind (("M-s a f" . affe-find)
         ("M-s a g" . affe-grep)))
#+end_src

****** consult-ghq
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 15:56]
:END:

#+begin_src emacs-lisp
(use-package consult-ghq
  :ensure t
  :after consult
  :custom
  (consult-ghq-find-function 'dired))
#+end_src

***** embark

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-embark"
#+end_src

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-." . embark-act)
         ("M-." . embark-dwim)
         ("<help> B" . embark-bindings)
         :map embark-file-map
         ("b" . browse-url))
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :custom
  (embark-mixed-indicator-delay 3)
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  :config
  (require 'embark-consult)
  (require 'embark-org)
  (require 'avy-embark-collect)
  (push 'embark--allow-edit
        (alist-get 'shell-command-on-region embark-target-injection-hooks)))
#+end_src

***** marginalia
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 12:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-marginalia"
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :after vertico
  :config
  (marginalia-mode 1))
#+end_src

***** orderless
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 12:10]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-orderless"
#+end_src

#+begin_src emacs-lisp
(use-package orderless
  :custom (completion-styles '(orderless)))
#+end_src

****** support for migemo in orderless

#+begin_src emacs-lisp
(defun orderless-migemo (component)
  (let ((pattern (migemo-get-pattern component)))
    (condition-case nil
        (progn (string-match-p pattern "") pattern)
      (invalid-regexp nil))))

(orderless-define-completion-style orderless-default-style
  (orderless-matching-styles '(orderless-literal
                               orderless-regexp)))

(orderless-define-completion-style orderless-migemo-style
  (orderless-matching-styles '(orderless-literal
                               orderless-regexp
                               orderless-migemo)))

(setq orderless-matching-styles '(orderless-literal orderless-regexp orderless-migemo))

;; Uncomment this clause if you prefer to apply rules for completion categories selectively
;; (setq completion-category-overrides
;;       '((command (styles orderless-default-style))
;;         (file (styles orderless-migemo-style))
;;         (project-file (styles orderless-migemo-style))
;;         (buffer (styles orderless-migemo-style))
;;         (symbol (styles orderless-default-style))
;;         (multi-category (styles orderless-migemo-style))
;;         (org-heading (styles orderless-migemo-style))
;;         (consult-location (styles orderless-migemo-style))
;;         (org-roam-node (styles orderless-migemo-style))
;;         (unicode-name (styles orderless-migemo-style))
;;         (variable (styles orderless-default-style))))
#+end_src

***** corfu                                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:12]
:END:

Though I prefer vertico more for completion interface, [[https://github.com/minad/consult][consult manual]] says Vertico can't be used with Eglot or lsp-mode. So I decided to use Corfu only in prog-mode.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-corfu"
#+end_src

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode shell-mode eshell-mode) . corfu-mode)
  :custom
  (corfu-cycle t)
  (corfu-auto t)
  (corfu-preselect-first t))
#+end_src

***** cape
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:45]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-cape"
#+end_src

#+begin_src emacs-lisp
(use-package cape
  :bind (:map ctl-x-map
              :prefix "C-M-i"
              :prefix-map my/cape-map
              :prefix-docstring "Keymap for cape commands."
              ("C-M-i" . completion-at-point)
              ("d" . cape-dabbrev)
              ("h" . cape-history)
              ("f" . cape-file)
              ("k" . cape-keyword)
              ("a" . cape-abbrev)
              ("l" . cape-line)
              ("w" . cape-dict)
              ("\\" . cape-tex)
              ("_" . cape-tex)
              ("^" . cape-tex)
              ("&" . cape-sgml)
              ("r" . cape-rfc1345)
              ("8" . cape-emoji))
  :hook
  (text-mode
   . (lambda ()
       (setq-local completion-at-point-functions
                   (append '(cape-dabbrev
                             cape-file
                             cape-dict)
                           completion-at-point-functions))))
  (org-mode
   . (lambda ()
       (setq-local completion-at-point-functions
                   (append '(cape-elisp-block)
                           completion-at-point-functions))))
  (prog-mode
   . (lambda ()
       (setq-local completion-at-point-functions
                   (append '(cape-dabbrev
                             cape-file
                             cape-keyword)
                           completion-at-point-functions))))
  (emacs-lisp-mode
   . (lambda ()
       (setq-local completion-at-point-functions
                   (append '(cape-elisp-symbol)
                           completion-at-point-functions))))
  ((minibuffer-mode eshell-mode)
   . (lambda ()
       (setq-local completion-at-point-functions
                   (append '(cape-history
                             cape-dabbrev
                             cape-file
                             cape-dict)
                           completion-at-point-functions)))))
#+end_src

**** text-mode and its derivatives

***** nxml-mode

#+begin_src emacs-lisp
(use-package nxml-mode
  :delight (nxml-mode " XM")
  :mode (("\.xml$"   . nxml-mode)
         ("\.xsl$"   . nxml-mode)
         ("\.xhtml$" . nxml-mode)
         ("\.page$"  . nxml-mode)
         ("\.plist$" . nxml-mode))
  :hook (nxml-mode . my/prog-mode-hook-function)
  :custom
  (nxml-child-indent 2)
  (nxml-attribute-indent 2)
  (nxml-slash-auto-complete-flag t)
  :config
  (setq-local tab-width 2)
  ;; pattern in hideshow mode for nxml mode
  (add-to-list 'hs-special-modes-alist
               (list 'nxml-mode
                     "<!--\\|<[^/>]*[^/]>"
                     "-->\\|</[^/>]*[^/]>"
                     "<!--"
                     'nxml-forward-element
                     nil)))
#+end_src

***** toml-mode
:PROPERTIES:
:CREATED:  [2023-06-01 Thu 18:01]
:END:

language grammar for toml

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(toml "https://github.com/tree-sitter/tree-sitter-toml")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(toml-mode . toml-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package toml
  :mode "\\.toml$")
#+end_src

***** yaml-mode

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(yaml "https://github.com/ikatyang/tree-sitter-yaml")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(yaml-mode . yaml-ts-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref combobulate-hook
(yaml-ts-mode . combobulate-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package yaml
  :mode "\\.ya?ml$")
#+end_src

***** json-mode
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 15:07]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-json"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(json-mode . json-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package json
  :mode "\\.json$")
#+end_src

***** markdown-mode
:PROPERTIES:
:CREATED:  [2023-06-02 Fri 18:02]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"markdown"
"tree-sitter-markdown"
"emacs-markdown-mode"
#+end_src

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode "\\.md$")
#+end_src

***** tex-mode

#+begin_src emacs-lisp
(use-package tex-mode
  :mode ("\\.tex$" . latex-mode)
  :hook ((tex-mode . (lambda () (setq ispell-parser 'tex))))
  :config
  (my/add-dash-docsets-hook 'latex-mode-hook '("LaTeX")))
#+end_src

**** prog-mode and its derivatives

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook
          #'my/prog-mode-hook-function)

(defun my/prog-mode-hook-function ()
  (hl-line-mode -1)
  (hs-minor-mode -1)
  (display-fill-column-indicator-mode 1)
  (prettify-symbols-mode 1))
#+end_src

***** sh-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-bash"
#+end_src

#+begin_src emacs-lisp
(use-package sh-script
  :delight " SH"
  :commands sh-mode
  :mode ("\\.sh$" . sh-mode)
  :hook ((sh-mode)
         . (lambda ()
             (my/add-dash-docsets-hook 'sh-mode-hook '("Bash"))
             (setq-local devdocs-current-docs '("bash"))))
  :custom
  (sh-basic-offset 2)
  (sh-indent-after-if '+)
  (sh-indent-for-case-label 0)
  (sh-indent-for-case-alt '+))
#+end_src

***** bash-ts-mode
:PROPERTIES:
:CREATED:  [2024-04-30 Tue 00:08]
:END:

#+begin_src emacs-lisp
(use-package bash-ts-mode
  :interpreter "bash"
  :hook ((bash-ts-mode)
         . (lambda ()
             (setq-local devdocs-current-docs '("bash")))))
#+end_src

***** emacs-lisp-mode

I'm in the trial of pp-eval-last-sexp instead of eval-last-sexp adviced from [[https://karthinks.com/software/an-elisp-editing-tip/][this blog post]]

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(elisp "https://github.com/Wilfred/tree-sitter-elisp")
#+end_src

#+begin_src emacs-lisp
(use-package elisp-mode
  :mode ("\\.eld?$" . emacs-lisp-mode)
  :commands emacs-lisp-mode
  :hook (emacs-lisp-mode . (lambda ()
                             (setq-local devdocs-current-docs '("elisp"))
                             (push '("lambda" . ?λ) prettify-symbols-alist)
                             (setq-local tab-width 8)
                             (eldoc-mode 1)))
  :config
  (require 'eldoc)
  (substitute-key-definition 'eval-last-sexp
                             'pp-eval-last-sexp
                             global-map)
  (my/add-dash-docsets-hook 'emacs-lisp-mode-hook
                            '("Emacs Lisp")))

(defun my/elisp-mode-eval-buffer ()
  (interactive)
  (message "Evaluated buffer")
  (eval-buffer))

(keymap-set emacs-lisp-mode-map "C-c C-c" #'my/elisp-mode-eval-buffer)
(keymap-set lisp-interaction-mode-map "C-c C-c" #'my/elisp-mode-eval-buffer)
#+end_src

***** lisp-mode
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 16:53]
:END:

#+begin_src emacs-lisp
(use-package lisp-mode
  :mode "\\.lisp$"
  :config
  (my/add-dash-docsets-hook 'lisp-mode-hook
                            '("Common Lisp")))
#+end_src

****** sly
:PROPERTIES:
:CREATED:  [2023-12-18 Mon 14:53]
:END:

[[https://github.com/joaotavora/sly#start-of-content][Sly]], a fork of [[https://slime.common-lisp.dev/][Slime]].

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-sly"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package sly
  :custom
  (inferior-lisp-program "<<which(filename="sbcl")>>")
  (sly-auto-start 'ask)
  :config
  (with-eval-after-load 'ob-lisp
    (setopt org-babel-lisp-eval-fn 'sly-eval)))
#+end_src

***** scheme-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-scheme"
#+end_src

#+begin_src emacs-lisp
(use-package scheme
  :mode (("\\.guix-channel" . scheme-mode)
         ("\\.guix-authorizations" . scheme-mode)))
#+end_src

***** cc-mode

#+begin_src emacs-lisp
(use-package cc-mode
  :mode (("\\.c\\'"   . c-mode)
         ("\\.cpp\\'" . c++-mode))
  :hook (((c-mode c-ts-mode)
          . (lambda ()
              (setq-local devdocs-current-docs '("c"))))
         ((c++-mode c++-ts-mode)
          . (lambda ()
              (setq-local devdocs-current-docs '("cpp")))))
  :custom
  (c-tab-always-indent t)
  (c-auto-align-backslashes nil)
  (c-echo-syntactic-information-p t)
  (c-default-style "my/c-style")
  :config
  (my/add-dash-docsets-hook 'c-mode-common-hook
                            '("C"))
  (c-toggle-auto-newline 1)
  (c-add-style "my/c-style"
               '((c-basic-offset . 4)
                 (c-comment-only-line-offset . 0)
                 (c-hanging-braces-alist
                  . ((brace-if-brace before after)
                     (substatement-open before after)))
                 (c-hanging-colons-alist
                  . ((case-label after)))
                 (c-cleanup-list
                  . (brace-else-brace
                     brace-elseif-brace
                     empty-defun-braces
                     defun-close-semi
                     list-close-comma
                     scope-operator))
                 (c-offsets-alist
                  . ((arglist-intro . +)
                     (arglist-cont-nonempty . c-lineup-arglist)))))
  (c-add-style "my/objc-style"
               '((c-basic-offset . 2)
                 (c-comment-only-line-offset . 0)
                 (c-hanging-braces-alist
                  . ((brace-if-brace before after)
                     (substatement-open before after)))
                 (c-hanging-colons-alist
                  . ((case-label after)))
                 (c-cleanup-list
                  . (brace-else-brace
                     brace-elseif-brace
                     empty-defun-braces
                     defun-close-semi
                     list-close-comma
                     scope-operator))
                 (c-offsets-alist
                  . ((arglist-intro . +)
                     (arglist-cont-nonempty . c-lineup-arglist))))))
#+end_src

***** rust-mode
:PROPERTIES:
:CREATED:  [2024-04-29 Mon 21:35]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-rust-mode"
#+end_src

#+begin_src emacs-lisp
(use-package rust-mode
  :mode "\\.rs$"
  :hook ((rust-mode rust-ts-mode)
         . (lambda ()
             (setq-local devdocs-current-docs '("rust")))))
#+end_src

***** rustic                                :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-24 Fri 17:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-rustic"
#+end_src

#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :custom
  (rustic-lsp-client "eglot")
  :config
  (my/add-dash-docsets-hook 'rustic-mode-hook
                            '("Rust")))
#+end_src

***** python-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter-python"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(python-mode . python-ts-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref combobulate-hook
(python-ts-mode . combobulate-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package python
  :mode "\\.py\\'"
  :interpreter "python"
  :hook
  ((python-mode inferior-python-mode python-ts-mode) .
   (lambda ()
     (setq-local flycheck-checker 'python-pylint)
     (setq-local devdocs-current-docs '("python~3.9"))))
  :config
  (my/add-dash-docsets-hook 'python-mode-hook
                            '("Python 3" "NumPy" "Matplotlib"))
  (my/add-dash-docsets-hook 'inferior-python-mode-hook
                            '("Python 3")))

(defvar python-mode-initialized nil)

(defun my-python-mode-hook ()
  (setq-local flycheck-checker 'python-pylint)
  (jedi:setup)
  (jedi-mode 1)
  (unless python-mode-initialized
    (setq python-mode-initialized t)
    (info-lookup-add-help
     :mode 'python-mode
     :regexp "[a-zA-Z_0-9.]+"
     :doc-spec
     '(("(python)Python Module Index" )
       ("(python)Index"
        (lambda
          (item)
          (cond
           ((string-match
             "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
            (format "%s.%s" (match-string 2 item)
                    (match-string 1 item))))))))))
#+end_src

****** emacs-project

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-company-jedi"
#+end_src

#+begin_src emacs-lisp
(use-package company-jedi
  :after python
  :hook (python-mode . my/python-mode-hook)
  :custom
  (jedi:tooltip-method nil)
  :config
  (defun my/python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi)))
#+end_src

***** ruby-mode

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(ruby-mode . ruby-ts-mode)
#+end_src

#+begin_src emacs-lisp
(use-package ruby
  :mode (("\\.rb$"   . ruby-mode)
         ("Capfile$" . ruby-mode)
         ("Gemfile$" . ruby-mode))
  :interpreter (("ruby"    . ruby-mode)
                ("rbx"     . ruby-mode)
                ("jruby"   . ruby-mode))
  :hook ((ruby-mode ruby-ts-mode)
         . (lambda ()
             (setq-local flycheck-checker 'ruby-rubocop)
             (setq-local devdocs-current-docs '("ruby~3.2"))))
  :config
  (setq ruby-indent-level 2)
  (setq ruby-insert-encoding-magic-comment nil)
  (add-to-list 'hs-special-modes-alist
               `(ruby-mode
                 ,(rx (or "def" "class" "module" "do" "if" "{" "[")) ; Block start
                 ,(rx (or "}" "]" "end"))                       ; Block end
                 ,(rx (or "#" "=begin"))                        ; Comment start
                 ruby-forward-sexp nil))
  (my/add-dash-docsets-hook 'ruby-mode-hook '("Ruby")))
#+end_src

****** inf-ruby

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-inf-ruby"
#+end_src

#+begin_src emacs-lisp
(use-package inf-ruby
  :after ruby
  :config
  (setq inf-ruby-default-implementation "pry")
  (add-to-list 'inf-ruby-implementations '("pry" . "pry"))
  (setq inf-ruby-eval-binding "Pry.toplevel_binding")
  (setq inf-ruby-first-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)> *")
  (setq inf-ruby-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)[>*\"'] *"))
#+end_src

***** java-ts-mode
:PROPERTIES:
:CREATED:  [2024-04-29 Mon 19:58]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(java-mode . java-ts-mode)
#+end_src

#+begin_src emacs-lisp
(use-package java-ts-mode
  :mode "\\.java$"
  :hook (java-ts-mode
         . (lambda ()
             (setq-local devdocs-current-docs '("openjdk~21")))))
#+end_src

***** lua-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
  "emacs-lua-mode"
#+end_src

#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua$"
  :hook ((lua-mode lua-ts-mode)
         . (lambda ()
             (setq-local flycheck-checker 'lua-rubocop)
             (setq-local devdocs-current-docs '("lua~3.2")))))
#+end_src

***** perl-mode

#+begin_src emacs-lisp
(use-package perl-mode
  :delight " PL")
#+end_src

***** web-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-web-mode"
"tree-sitter-html"
"tree-sitter-css"
#+end_src

#+begin_src emacs-lisp
(use-package web-mode
  :delight " WB"
  :mode (("\\.phtml$"     . web-mode)
         ("\\.tpl\\.php$" . web-mode)
         ("\\.jsp$"       . web-mode)
         ("\\.as[cp]x$"   . web-mode)
         ("\\.erb$"       . web-mode)
         ("\\.html?$"     . web-mode))
  :custom
  (web-mode-attr-indent-offset        2)
  (web-mode-attr-value-indent-offset  2)
  (web-mode-code-indent-offset        2)
  (web-mode-css-offset                2)
  (web-mode-markup-indent-offset      2)
  (web-mode-sql-indent-offset         2)
  (web-mode-block-padding             2)
  (web-mode-script-padding            2)
  :config
  (my/add-dash-docsets-hook 'web-mode-hook '("HTML")))
#+end_src

***** css-mode

#+begin_src emacs-lisp
(use-package css-mode
  :mode "\\.css$"
  :hook ((css-mode css-ts-mode)
         . (lambda ()
             (my/add-dash-docsets-hook 'css-mode-hook '("CSS"))
             (setq-local devdocs-current-docs '("css"))))
  :custom
  (css-indent-offset 2))
#+end_src

***** js2-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-js2-mode"
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(js2-mode . js-ts-mode)
(css-mode . css-ts-mode)
#+end_src

#+begin_src emacs-lisp
(use-package js2-mode
  :delight " J2"
  :mode (("\\.js\\(on\\)?\\'" . js2-mode)
         ("\\.eslintrc\\'"    . js2-mode))
  :hook (js2-mode . (lambda ()
                      (setq-local flycheck-checker 'javascript-eslint)
                      (setq-local flycheck-disabled-checkers '(javascript-jshint javascript-jscs))))
  :custom
  (flycheck-javascript-eslint-executable "eslint")
  (my/add-dash-docsets-hook 'js2-mode-hook '("JavaScript")))

(use-package js
  :disabled t
  :delight " JS"
  :custom
  (js-indent-level 2))
#+end_src

***** make
:PROPERTIES:
:CREATED:  [2023-06-02 Fri 19:18]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref treesit-language-source
(cmake "https://github.com/uyha/tree-sitter-cmake")
(make "https://github.com/alemuller/tree-sitter-make")
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-remap-rule
(cmake-mode . cmake-ts-mode)
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package cmake
  :mode (("\\.mk$" . cmake-mode)
         ("^Makefile$" . cmake-mode)))
#+end_src

***** sql-mode

#+begin_src emacs-lisp
(use-package sql
  :delight " SQ"
  :commands (sql-mode)
  :mode (("\\.sql$" . sql-mode))
  :bind (:map sql-interactive-mode-map
              ("C-j" . comint-send-input))
  :hook (sql-mode . (lambda ()
                      (setq-local flycheck-checker 'sql-sqlint))))
#+end_src

***** plantuml-mode

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-plantuml-mode"
#+end_src

#+begin_src emacs-lisp
(use-package plantuml
  :mode "\\.plu$"
  :custom
  (plantuml-jar-path "~/.guix-extra-profiles/emacs/emacs/share/java/plantuml.jar")
  (plantuml-exec-mode 'jar)
  :config
  (my/add-dash-docsets-hook 'plantuml-mode-hook '("PlantUML")))
#+end_src

***** conf

#+begin_src emacs-lisp
(use-package conf-mode
  :delight " CF")
#+end_src

***** generic-x

#+begin_src emacs-lisp
(use-package generic-x
  :mode (("\\.conf$"     . apache-conf-generic-mode)
         ("\\.htaccess$" . apache-conf-generic-mode)))
#+end_src

**** special-mode derivatives
:PROPERTIES:
:CREATED:  [2022-08-23 Tue 18:51]
:END:

***** special mode

#+begin_src emacs-lisp
(keymap-set special-mode-map "C-j" #'push-button)
#+end_src

***** help
:PROPERTIES:
:ID:       a55da7a2-6525-4788-ba56-085eb61928d4
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'help
  (keymap-set help-map "C-?" #'help-for-help)
  (keymap-set help-map "c" #'describe-face)
  (keymap-set help-map "K" #'describe-keymap))
#+end_src

***** woman

#+begin_src emacs-lisp
(autoload #'woman "woman" nil t)
#+end_src

**** Programming

***** sMerge
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 19:57]
:ID:       e28ea681-854e-4972-ad48-ab7e2466c285
:END:

sMerge can be utilized to address merging issues.

#+begin_src emacs-lisp
(use-package smerge-mode
  :custom
  (smerge-command-prefix (kbd "H-m")))
#+end_src

***** Next Error

#+begin_src emacs-lisp
(setopt next-error-message-highlight t)
#+end_src

***** Hideshow

#+begin_src emacs-lisp
(use-package hideshow
  :hook ((emacs-lisp-mode cc-mode python-ts-mode rust-ts-mode ruby-ts-mode scheme-mode)
         . hs-minor-mode)
  :preface
  (defun my/hs-hide-all (&optional show)
    "Hide all top-level blocks unless C-u prefix is provided."
    (interactive "P")
    (cond
     ((equal show '(4)) (hs-show-all))
     (t (hs-hide-all))))
  :bind (:map hs-minor-mode-map
              ("H-i" . hs-toggle-hiding)
              ("C-c TAB" . hs-hide-level)
              ("S-TAB" . my/hs-hide-all)))
#+end_src

***** imenu

#+begin_src emacs-lisp
(use-package imenu
  :custom
  (imenu-auto-rescan t))
#+end_src
***** compile

#+begin_src emacs-lisp
(use-package compile
  :bind (:map compilation-mode-map
              ("C-j" . compile-goto-error)))
#+end_src

***** grep

#+begin_src emacs-lisp
(use-package grep
  :custom
  (grep-program "rg")
  :config
  (bind-keys :map grep-mode-map
             ("C-j" . compile-goto-error)))

(defun my/grep-ripgrep-all ()
  "Grep many kind of files like pdf, epub and more."
  (interactive)
  (let ((grep-find-command '("rga --with-filename --no-heading --line-number --color never -e '' ./* ./**/*" . 66)))
    (call-interactively 'grep-find)))

(keymap-global-set "M-s R" 'my/grep-ripgrep-all)
#+end_src

***** executable

[[https://emacsredux.com/blog/2021/09/29/make-script-files-executable-automatically/][The post]] says it is useful to set executable bit if the saved file seems to be script.

#+begin_src emacs-lisp
(with-eval-after-load 'executable
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p))
#+end_src

***** Paren Showing

#+begin_src emacs-lisp
(use-package paren
  :hook (prog-mode . show-paren-local-mode)
  :custom
  (show-paren-style 'mixed)
  (show-paren-delay 0.2)
  (show-paren-mode nil)
  (show-paren-context-when-offscreen t))
#+end_src

***** project

#+begin_src emacs-lisp
(use-package project
  :custom
  (project-kill-buffers-display-buffer-list t)
  :config
  (add-to-list 'project-switch-commands
               '(project-dired "Dired root"))
  (with-eval-after-load 'magit
    (bind-keys :map project-prefix-map
               ("M" . magit-project-status))
    (add-to-list 'project-switch-commands
                 '(magit-project-status "Magit"))))
#+end_src

***** log-view

#+begin_src emacs-lisp
(use-package log-view
  :delight
  (log-view-mode " LV")
  :mode ("\\.log$" . log-view-mode)
  :hook ((log-view-mode . my/prog-mode-hook-function )
         (log-view-mode . auto-revert-tail-mode)))
#+end_src

***** vc (version control)
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:
***** vc-hooks

#+begin_src emacs-lisp
(use-package vc-hooks
  :custom
  (vc-follow-symlinks t))
#+end_src
**** Tree Sitter
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:00]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"tree-sitter"
#+end_src

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(use-package treesit
  :preface
  (defun my/setup-install-grammars ()
    "Install Tree-sitter grammars if they are absent."
    (interactive)
    (dolist (grammar
             '(<<treesit-language-source>>))
      (add-to-list 'treesit-language-source-alist grammar)
      (unless (treesit-language-available-p (car grammar))
        (treesit-install-language-grammar (car grammar)))))
  :config
  (my/setup-install-grammars))
#+end_src

***** combobulate
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:08]
:END:

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(use-package combobulate
  :disabled t
  :after treesit
  :preface
  (setq combobulate-key-prefix "C-c o")
  :hook (<<combobulate-hook>>)
  :load-path ("~/.emacs.d/site-elisp/combobulate/"))
#+end_src

***** major mode remapping
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 17:12]
:END:

#+begin_src emacs-lisp :noweb tangle :noweb-prefix no
(setq major-mode-remap-alist
      '(<<major-mode-remap-rule>>))
#+end_src

**** Elisp Package Development
:PROPERTIES:
:CREATED:  [2023-06-08 Thu 13:58]
:header-args:emacs-lisp+: :tangle (expand-file-name "elisp-devel.el" tangle/emacs-config-dir)
:END:

***** package build
:PROPERTIES:
:CREATED:  [2024-04-16 Tue 20:50]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-package-build"
#+end_src

#+begin_src emacs-lisp
(let ((default-directory package-user-dir))
  (setopt package-build-recipes-dir
          (expand-file-name "recipes")
          package-build-archive-dir
          (expand-file-name "packages")
          package-build-working-dir
          (expand-file-name "working")))
#+end_src

***** flycheck package
:PROPERTIES:
:CREATED:  [2024-04-17 Wed 19:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-flycheck-package"
#+end_src

#+begin_src emacs-lisp
(eval-after-load 'flycheck
  '(flycheck-package-setup))
#+end_src

***** package lint
:PROPERTIES:
:CREATED:  [2024-04-17 Wed 19:44]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-package-lint"
#+end_src

***** makem.sh                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 23:15]
:END:

#+begin_src emacs-lisp
(require 'makem)
#+end_src

**** Blogging
:PROPERTIES:
:CREATED:  [2023-12-29 Fri 14:36]
:END:

This subtree holds resources for [[https://p-snow.org/][my blog]].

***** org-static-blog                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-12-26 Tue 15:18]
:END:

#+begin_src scheme :tangle no
"emacs-org-static-blog"
#+end_src

#+begin_src emacs-lisp
(use-package org-static-blog
  :defer t
  :after org
  :init
  (defvar my/blog-directory (expand-file-name "~/org/dotlife"))
  :config
  (setq org-static-blog-publish-directory
        (file-name-concat my/blog-directory "public")
        org-static-blog-posts-directory
        (file-name-concat my/blog-directory "content/posts")
        org-static-blog-drafts-directory
        (file-name-concat my/blog-directory "content/posts")))
#+end_src

***** templates for blogging
:PROPERTIES:
:CREATED:  [2023-12-29 Fri 13:14]
:END:

#+NAME: template-blog-post-filename
#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-mode-template
(blog-post-filename (format-time-string "%Y%m%d-%H%M.org"))
(blog-post-dotfile-url "https://p-snow.org/config/dotfiles.html#")
#+end_src

#+NAME: template-blog-post-skeleton
#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(blog-post-skeleton "#+title:" n
                    "#+date:" n
                    "#+description:" n
                    "#+filetags:" n n
                    "#+SETUPFILE: "
                    (pcase (file-name-base (directory-file-name default-directory))
                      ("posts" "diary/header")
                      ("org-content" "header")))
(blog-post-macro-preview "{{{preview-begin}}}" n
                         "{{{preview-end}}}")
(blog-post-macro-accordion (p "Summary: " summary t)
                           (format "{{{accordion-begin(%s)}}}" summary) n
                           "{{{accordion-end}}}")
#+end_src

#+NAME: template-desktop-recording
#+begin_src emacs-lisp :tangle no :noweb-ref eshell-mode-template
(desktop-recording
 "ffmpeg -video_size 2560x1440 -framerate 25 -f x11grab -i :0.0 output.mp4")
#+end_src

***** ox-haunt
:PROPERTIES:
:CREATED:  [2024-04-03 Wed 16:37]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ox-haunt"
#+end_src

#+begin_src emacs-lisp
(use-package ox-haunt
  :after ox)
#+end_src

**** Journaling
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 21:44]
:END:

***** journal entry template
:PROPERTIES:
:CREATED:  [2023-11-08 Wed 21:45]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(journal "- diary" n>
         "#+begin_src text" n> "#+end_src" n
         "- clocktable" n>
         "#+begin: clocktable-by-tag :maxlevel 3 :wstart 1 "
         ":block " (p "year") "-" (p "month") "-" (p "day") n>
         "#+end:" n
         "- agenda" n>
         "#+begin_example" n
         (p "agenda") n>
         "#+end_example")
#+end_src

***** week subtree template
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 16:36]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref org-template
(nw & "- mission [/]" n
    "- clocktable" n>
    "#+begin: clocktable-by-tag :maxlevel 3 "
    ":block " (p "year" year) "-W" (p "isoweek" isoweek) " :wstart 1" n>
    "#+end:" n
    "- meta-projects" n>
    "#+begin: clocktable :maxlevel 3 :scope agenda "
    ":block " year "-W" isoweek
    " :wstart 1 :narrow 40! :tcolumns 3 :formula %" n>
    "#+end:")
#+end_src

**** External Emacs Packages

Packages below are out of categories above. Packages which have ARCHIVE tag is no longer in use. Keywords which package gives in its description are set to tag.

***** git-modes

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-modes"
#+end_src

#+begin_src emacs-lisp
(use-package git-modes)
#+end_src

***** git-annex

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-annex"
#+end_src

#+begin_src emacs-lisp
(use-package git-annex
  :after dired
  :custom-face
  (git-annex-dired-annexed-available ((t (:foreground "green yellow"))))
  (git-annex-dired-annexed-unavailable ((t (:foreground "red3")))))
#+end_src

***** magit-annex                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-24 Sat 15:47]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-magit-annex"
# #+end_src

#+begin_src emacs-lisp :tangle no
(use-package magit-annex)
#+end_src

***** orgit

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-orgit"
#+end_src

#+begin_src emacs-lisp
(use-package orgit
  :after org
  :custom
  (orgit-remote "github"))
#+end_src

***** suggest
:PROPERTIES:
:CREATED:  [2023-10-11 Wed 11:12]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-suggest"
#+end_src

#+begin_src emacs-lisp
(use-package suggest
  :commands suggest
  :custom
  (suggest-insert-example-on-start nil))
#+end_src

***** mastodon
:PROPERTIES:
:CREATED:  [2023-09-24 Sun 02:23]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-mastodon"
#+end_src

#+begin_src emacs-lisp
(use-package mastodon
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("@" . mastodon))
  :hook (mastodon-mode . visual-line-mode)
  :custom
  (mastodon-active-user "p_snow")
  (mastodon-instance-url "https://social.linux.pizza")
  (mastodon-client--token-file
   (no-littering-expand-var-file-name "mastodon.plstore"))
  :config
  (require 'mastodon-views))
#+end_src

***** bookmark+                             :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-09-17 Sun 14:58]
:END:

[[https://github.com/emacsmirror/bookmark-plus][Bookmark-plus]] package is so feature-rich that it is a great package for most people, but a bit overwhelming for me. I realized that the URL bookmarking functionality is the only benefit that I receive from bookmark-plus. Therefore, I have decided to use [[help:eww-add-bookmark][EWW's bookmarking command]] for that purpose.

#+begin_src scheme :tangle no :noweb-ref no
"emacs-bookmark-plus"
#+end_src

#+begin_src emacs-lisp
(use-package bookmark+
  :after bookmark)
#+end_src

***** chatgpt-shell
:PROPERTIES:
:CREATED:  [2023-09-12 Tue 17:42]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-chatgpt-shell"
#+end_src

#+begin_src emacs-lisp
(use-package chatgpt-shell
  :after engine-mode
  :preface
  (defun my/chatgpt-shell-dwim ()
    "docstring"
    (interactive)
    (if (use-region-p)
        (chatgpt-shell-prompt-compose)
      (chatgpt-shell)))
  :bind (:map engine-mode-prefixed-map
              ("p c" . my/chatgpt-shell-dwim)
              ("p C" . chatgpt-shell-prompt)
              ("p e" . chatgpt-shell-explain-code)
              ("p d" . chatgpt-shell-describe-code)
              ("p p" . chatgpt-shell-proofread-region)
              ("p g" . chatgpt-shell-write-git-commit)
              ("p u" . chatgpt-shell-generate-unit-test)
              ("p i" . (lambda (&optional lang)
                         "Ask ChatGPT to interpret into Japanese or some other language if LANG is non-nil."
                         (interactive "P")
                         (when (require 'chatgpt-shell nil t)
                           (chatgpt-shell-send-region-with-header
                            (format "Please help me interpret the following sentence into %s:"
                                    (if (equal lang '(4))
                                        (completing-read "Langauage: " '("Japanese" "English" "German"))
                                      "Japanese"))))))
              :map chatgpt-shell-mode-map
              ("C-M-g" . chatgpt-shell-clear-buffer))
  :custom
  (chatgpt-shell-openai-key 'my/credential-info)
  (chatgpt-shell-system-prompt 3)
  (chatgpt-shell-model-temperature 0.6))

(use-package ob-chatgpt-shell
  :after (chatgpt-shell ob-core)
  :config
  (ob-chatgpt-shell-setup)
  (add-to-list 'org-structure-template-alist
               '("ch" . "src chatgpt-shell")
               t))

(use-package dall-e-shell
  :commands dall-e-shell
  :custom
  (dall-e-shell-openai-key 'my/credential-info))
#+end_src

***** async
:PROPERTIES:
:CREATED:  [2023-07-15 Sat 08:18]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-async"
#+end_src

#+begin_src emacs-lisp
(use-package dired-async
  :after dired
  :config
  (dired-async-mode 1))

(use-package async-bytecomp
  :custom
  (async-bytecomp-package-mode t))
#+end_src

***** visible-mark              :marking:faces:color:
:PROPERTIES:
:CREATED:  [2023-07-01 Sat 13:40]
:END:

#+begin_src emacs-lisp
(use-package visible-mark
  :ensure t
  :config
  (global-visible-mark-mode 1))
#+end_src

***** ement                                    :comm:
:PROPERTIES:
:CREATED:  [2023-06-27 Tue 10:45]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ement"
#+end_src

***** ligature                      :extensions:data:
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 17:21]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ligature"
#+end_src

#+begin_src emacs-lisp
(use-package ligature
  :hook (prog-mode . ligature-mode)
  :config
  ;; ligatures below are supported by `Iosevka' font
  (ligature-set-ligatures 'prog-mode
                          '("-<<" "-<" "-<-" "<--" "<---" "<<-" "<-" "->" "->>" "-->" "--->" "->-" ">-" ">>-"
                            "=<<" "=<" "=<=" "<==" "<===" "<<=" "<=" "=>" "=>>" "==>" "===>" "=>=" ">=" ">>="
                            "<->" "<-->" "<--->" "<---->" "<=>" "<==>" "<===>" "<====>" "::" ":::" "__"
                            "<~~" "</" "</>" "/>" "~~>" "==" "!=" "/=" "~=" "<>" "===" "!==" "!===" "=/=" "=!="
                            "<:" ":=" "*=" "*+" "<*" "<*>" "*>" "<|" "<|>" "|>" "<." "<.>" ".>" "+*" "=*" "=:" ":>"
                            "(*" "*)" "/*" "*/" "[|" "|]" "{|" "|}" "++" "+++" "\\/" "/\\" "|-" "-|" "<!--" "<!---")))
#+end_src

***** meow        :modal_editing:convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-05-31 Wed 12:36]
:END:

[[https://github.com/meow-edit/meow][meow]] offers modal editing functionality and more. I tried it on [2023-05-31 Wed], but overwhelmed a bit. Following configuration for meow will be save for future use.

#+begin_src emacs-lisp
(use-package meow
  :disabled t
  :preface
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))
  :config
  (meow-setup)
  (meow-global-mode 1))
#+end_src

***** enlive                     :selector:query:css:
:PROPERTIES:
:CREATED:  [2023-04-28 Fri 15:49]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-enlive"
#+end_src

***** gptel                             :convenience:
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:53]
:CUSTOM_ID: emacs-gptel
:END:

[[https://github.com/karthink/gptel][gptel]] is decent AI frontend in Emacs as of [2025-01-08 Wed]. It supports a large number of services (LLM models) and offers elaborate usage options.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-gptel"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package gptel
  :after engine-mode
  :bind (:map engine-mode-prefixed-map
              ("G" . gptel)
              ("g RET" . gptel-send)
              ("g r" . gptel-rewrite)
              ("g g" . gptel-menu))
  :custom
  (gptel-api-key (apply-partially #'my/credential-info "openai.com" "apikey"))
  (gptel-max-tokens 1000)
  (gptel-model 'gpt-4o-mini)
  (gptel-default-mode 'org-mode)
  (gptel-rewrite-default-action 'merge)
  :config
  (cl-pushnew '(proofreading
                . "You are a large language model and a professional proofreader. Please proofread the following text.")
              gptel-directives)
  (cl-pushnew '(document
                . "You are a large language model and a software engeneer. Please rewrite the following snippet of the software document as follows.
- If the text begins with a verb, it could be a description for a function, which should also commence with that verb.")
              gptel-directives)
  (cl-pushnew '(commit-message-pr
                . "You are a large language model and a software engeneer. Please rewrite the Git commit message as follows.
- Prefers concise and comprehensible representation as a commit message
- Starts with a verb in present and remove last period of sentence")
              gptel-directives)
  (cl-pushnew '(interpret
                . "You are a large language model and a professional interpreter. Please interpret the text.
- Interpret the sentence in Japanese if it is English and vice versa.")
              gptel-directives)
  (gptel-make-gemini "Gemini"
    :key (apply-partially 'my/credential-info "www.google.com/<<full-name>>" "gemini apikey")
    :stream t)
  (gptel-make-openai "Perplexity"
    :host "api.perplexity.ai"
    :key (apply-partially 'my/credential-info "perplexity.ai")
    :endpoint "/chat/completions"
    :stream t
    :models '("llama-3.1-sonar-small-128k-online"
              "llama-3.1-sonar-large-128k-online"
              "llama-3.1-sonar-small-128k-chat"
              "llama-3.1-sonar-large-128k-chat"
              "llama-3.1-70b-instruct"
              "llama-3.1-8b-instruct")))
#+end_src

***** engine-mode
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 16:27]
:ID:       db630173-d371-45de-a78e-bcc57cb9d50c
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-engine-mode"
#+end_src

#+NAME: config/engine-mode
#+begin_src emacs-lisp
(use-package engine-mode
  :preface
  (defvar engine/minibuffer-history nil
    "Minibuffer history for `engine-mode'.")
  (defun engine--history-search-term (engine-name)
    "Prompt the user for a search term for ENGINE-NAME.
Default to the symbol at point."
    (let ((current-word (or (thing-at-point 'symbol 'no-properties) "")))
      (read-string (engine--search-prompt engine-name current-word)
                   nil 'engine/minibuffer-history current-word)))
  :config
  (advice-add 'engine--prompted-search-term :override
              'engine--history-search-term)
  (engine/set-keymap-prefix (kbd "H-q"))
  (engine-mode 1)
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")
  (defengine google
    "https://www.google.com/search?q=%s"
    :keybinding "@")
  (defengine youtube
    "https://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y")
  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "h")
  (defengine amazon
    "https://www.amazon.co.jp/gp/search/?field-keywords=%s"
    :keybinding "a")
  (defengine melpa
    "https://melpa.org/#/?q=%s"
    :keybinding "m")
  (defengine eijiro
    "https://eow.alc.co.jp/search?q=%s"
    :keybinding "e")
  (defengine weblio
    "https://www.weblio.jp/content/%s"
    :keybinding "l")
  (defengine wikipedia-ja
    "https://ja.wikipedia.org/wiki/%s"
    :keybinding "w")
  (defengine wikipedia
    "https://en.wikipedia.org/wiki/%s"
    :keybinding "W")
  (defengine lyric
    "https://search3.j-lyric.net/index.php?kt=%s"
    :keybinding "u"))
#+end_src

***** tmr                         :timer:convenience:
:PROPERTIES:
:CREATED:  [2023-03-06 Mon 14:16]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-tmr"
#+end_src

#+begin_src emacs-lisp
(use-package tmr
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("t" . tmr)))
#+end_src

***** beframe
:PROPERTIES:
:CREATED:  [2023-03-01 Wed 15:47]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-beframe"
#+end_src

#+begin_src emacs-lisp
(use-package beframe
  :ensure t
  :bind (("C-x B" . beframe-switch-buffer)
         ("C-x C-b" . beframe-buffer-menu))
  :custom
  (beframe-global-buffers '("*Messages*" "*Backtrace*"))
  (beframe-create-frame-scratch-buffer nil)
  :config
  (with-eval-after-load 'consult
    (defface beframe-buffer
      '((t :inherit font-lock-string-face))
      "Face for `consult' framed buffers.")
    (defvar beframe--consult-source
      `( :name     "Frame-specific buffers (current frame)"
         :narrow   ?F
         :category buffer
         :face     beframe-buffer
         :history  beframe-history
         :items    ,#'beframe--buffer-names
         :action   ,#'switch-to-buffer
         :state    ,#'consult--buffer-state))
    (add-to-list 'consult-buffer-sources 'beframe--consult-source))
  (beframe-mode 1))
#+end_src

***** free-keys                         :convenience:
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 21:51]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-free-keys"
#+end_src

#+begin_src emacs-lisp
(use-package free-keys
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("f" . free-keys))
  :config
  (setq free-keys-modifiers (append free-keys-modifiers
                                    '("H"))))
#+end_src

***** consult-recoll               :docs:convenience:
:PROPERTIES:
:CREATED:  [2023-02-11 Sat 22:31]
:END:

#+begin_src emacs-lisp
(use-package consult-recoll
  :ensure t
  :after consult
  :bind ("M-s c" . consult-recoll)
  :preface
  (defun my/consult-recoll--html (file)
    (let ((mime (mailcap-extension-to-mime (file-name-extension file))))
      (cond
       ((string= mime (regexp-quote "application/epub+zip"))
        (my/open-epub-as-html file))
       (t (eww-open-file file)))))
  :custom
  (consult-recoll-open-fns
   '(("text/html" . my/consult-recoll--html)
     ("application/pdf" . my/open-pdf-as-html))))
#+end_src

***** detached                :processes:convenience:
:PROPERTIES:
:CREATED:  [2022-12-27 Tue 15:35]
:END:

How to use detached.el
- in vterm
  1. create a session with S-RET(detached-vterm-send-input)
  2. detach from the session with C-c C-d(detached-detach-key)
  3. attach to the session with C-RET(detached-vterm-attach)
- with shell-command
  - invoke/call detached-shell-command

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"dtach"
"emacs-detached"
#+end_src

#+begin_src emacs-lisp
(use-package detached
  :init
  (detached-init)
  (defvar my/detached-bury-buffer nil)
  :bind
  (([remap async-shell-command] . detached-shell-command)
   ([remap compile] . detached-compile)
   ([remap recompile] . detached-compile-recompile))
  :preface
  (defun my/detached-shell-command-region (start end)
    "Execute shell command between START and END with `detached-shell-command'."
    (interactive (progn
                   (unless (mark)
                     (user-error "The mark is not set now, so there is no region"))
                   (list (region-beginning) (region-end))))
    (detached-shell-command (buffer-substring-no-properties start end)))
  :custom
  (detached-shell-command-initial-input nil)
  (detached-terminal-data-command system-type)
  (detached-terminal-data-command system-type)
  :config
  (with-eval-after-load 'embark
    (keymap-set embark-region-map "&" #'detached-shell-command))
  (add-to-list 'display-buffer-alist
               `((lambda (buffer-or-name arg)
                   (when (and (string-match-p
                               (regexp-opt (list detached--shell-command-buffer))
                               (cond
                                ((stringp buffer-or-name) buffer-or-name)
                                ((bufferp buffer-or-name) (buffer-name buffer-or-name))))
                              my/detached-bury-buffer)
                     (setq my/detached-bury-buffer nil)
                     t))
                 (display-buffer-reuse-window)
                 (body-function
                  . (lambda (window) (interactive)
                      (bury-buffer))))))

(defun my/org-link--open-shell-detached (path _)
  "Open a \"shell\" type.

PATH is the command to execute with `detached-shell-command'."
  (if (or (and (org-string-nw-p org-link-shell-skip-confirm-regexp)
               (string-match-p org-link-shell-skip-confirm-regexp path))
          (not org-link-shell-confirm-function)
          (funcall org-link-shell-confirm-function
                   (format "Execute %s in shell? "
                           (org-add-props path nil 'face 'org-warning))))
      (progn
        (message "Executing %s" path)
        (detached-shell-command path))
    (user-error "Abort")))

(with-eval-after-load 'ol
  (org-link-set-parameters "shell" :follow #'my/org-link--open-shell-detached))

(use-package detached-list
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("d" . detached-list-sessions))
  :config
  (bind-keys :map detached-list-mode-map
             ("C-m" . detached-list-open-session)
             ("C-j" . detached-list-open-session)))
#+end_src

***** emacs-guix                              :tools:
:PROPERTIES:
:CREATED:  [2022-12-23 Fri 14:08]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-guix"
#+end_src

#+begin_src emacs-lisp
(use-package guix
  :commands guix
  :config
  (with-eval-after-load 'my-launch-app
    (bind-keys :map my/launch-app-map
               ("x" . guix))))
#+end_src

***** pcre2el
:PROPERTIES:
:CREATED:  [2022-12-06 Tue 16:50]
:END:

[[https://github.com/joddie/pcre2el][pcre2el]] is not only the converter between PCRE, emacs lisp style regexp and RX representation. It support re-builder as a conversion environment. Great!

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-pcre2el"
#+end_src

#+begin_src emacs-lisp
(use-package pcre2el)
#+end_src

***** iedit :simultaneous:region:refactoring:occurrence:
:PROPERTIES:
:CREATED:  [2022-10-25 Tue 18:02]
:END:

[[https://github.com/victorhge/iedit][IEdit]] is not only replacement for M-%/C-M-% but it highlights symbol occurences to change. [[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][This advise]] would be useful for anyone who needs dedicated command to replace symbols in defun.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-iedit"
#+end_src

#+begin_src emacs-lisp
(use-package iedit
  :bind ("C-\"" . iedit-mode)
  :custom
  (iedit-toggle-key-default (kbd "C-\""))
  (iedit-auto-narrow t))
#+end_src

***** ledger-mode / flycheck-ledger :tools:languages:convenience:
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 21:08]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ledger-mode"
"emacs-flycheck-ledger"
#+end_src

#+begin_src emacs-lisp
(use-package ledger-mode
  :bind (:map ledger-mode-map
              ("C-c C-y" . ledger-copy-transaction-at-point))
  :custom
  (ledger-reconcile-default-commodity "\\")
  :config
  (require 'flycheck-ledger)
  (with-eval-after-load 'ob-core
    (require 'ob-ledger)))
#+end_src

***** mentor              :processes:comm:bittorrent:
:PROPERTIES:
:CREATED:  [2022-10-04 Tue 22:09]
:END:

[[https://github.com/skangas/mentor][mentor]] is a [[id:bdc987ad-419b-4f36-922d-de75207d85c0][rTorrent]] client for emacs.

Typical file downloading workflow:
1. start mentor: M-x mentor
2. add magnet link (URL or torrent file path): M-x mentor-download-load-magnet-link-or-url (l)
3. view downloaded file in dired: M-x mentor-dired-jump (v)
4. shutdown mentor: M-x mentor-shutdown (Q)

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-mentor"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package mentor
  :commands mentor
  :custom
  (mentor-rtorrent-download-directory "<<torrent-dir()>>")
  (mentor-rtorrent-keep-session t)
  (mentor-rtorrent-external-rpc "<<rtorrent-sock()>>"))
#+end_src

***** geiser                :scheme:languages:geiser:
:PROPERTIES:
:CREATED:  [2022-09-06 Tue 15:26]
:END:

[[info:guix#The Perfect Setup][guix#The Perfect Setup]]

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"guile"
"emacs-geiser"
"emacs-geiser-guile"
#+end_src

#+begin_src emacs-lisp :noweb yes
(use-package geiser-guile
  :commands (scheme-mode)
  :config
  ;; (add-to-list 'geiser-guile-load-path
  ;;              (file-name-concat "<<ghq-root()>>" "git.savannah.gnu.org/git/guix"))
  (load-file (file-name-concat "<<ghq-root()>>" "git.savannah.gnu.org/git/guix/etc/copyright.el")))
#+end_src

***** consult-dash                :docs:dash:consult:
:PROPERTIES:
:CREATED:  [2022-08-05 Fri 16:56]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dash-docs"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package dash-docs
  :custom
  (dash-docs-docsets-path
   (file-name-concat "<<share-dir()>>" "dash/docsets")))

(add-to-list 'load-path
             (expand-file-name "elpa/consult-dash-20220621.226" user-emacs-directory))

(use-package consult-dash
  :after dash-docs
  :bind ("M-s M-d" . consult-dash))
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "00-my-early-config.el" tangle/emacs-config-dir)
(defmacro my/add-dash-docsets-hook (hook docsets)
  `(add-hook ,hook
             (lambda ()
               (when (functionp 'consult-dash)
                 (setq-local consult-dash-docsets ,docsets)))))
#+end_src

***** denote
:PROPERTIES:
:CREATED:  [2022-08-02 Tue 20:08]
:ID:       d5bd559a-2cab-4495-993b-f7a21637f0ea
:END:

[[https://protesilaos.com/emacs/denote][Denote]] leverages note taking in org mode by providing file naming scheme and backlink capability.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-denote"
#+end_src

#+begin_src emacs-lisp
(use-package denote
  :bind (("C-c n n" . denote)
         ("C-c n o" . denote-open-or-create))
  :custom
  (denote-directory (expand-file-name "~/org/notes"))
  :config
  (require 'denote-org-extras)
  (with-eval-after-load 'org-capture
    (setq denote-org-capture-specifiers "%l\n%i\n%?")
    (add-to-list 'org-capture-templates
                 '("n" "New note (with denote.el)" plain
                   (file denote-last-path)
                   #'denote-org-capture
                   :no-save t
                   :immediate-finish nil
                   :kill-buffer t
                   :jump-to-captured t))))
#+end_src

***** denote-menu
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 19:00]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-denote-menu"
#+end_src

#+NAME: config/emacs-denote-menu
#+begin_src emacs-lisp
(use-package denote-menu
  :after denote
  :custom
  (denote-menu-date-column-width 12)
  (denote-menu-title-column-width 32)
  (denote-menu-show-file-type nil))
#+end_src

***** tree-sitter                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 10:14]
:END:

Tree-sitter module for Elisp had been incorporated into Emacs core since Emacs 29.

#+begin_src emacs-lisp
(use-package tree-sitter-langs
  :ensure t
  :defer t)

(use-package tree-sitter
  :ensure t
  :after tree-sitter-langs
  :hook ((tree-sitter-after-on . tree-sitter-hl-mode))
  :config
  (global-tree-sitter-mode 1))
#+end_src

***** xr                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-07-30 Sat 16:12]
:END:

[[https://elpa.gnu.org/packages/xr.html][XR]] converts Emacs regular expressions to the structured rx form, thus being an inverse of rx.

#+begin_src scheme :tangle no
"emacs-xr"
#+end_src

***** Whole Line Or Region           :wp:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/purcell/whole-line-or-region/tags.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package whole-line-or-region
  :ensure t
  :config
  (whole-line-or-region-global-mode 1))
#+end_src

***** projectile                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
(use-package projectile
  :hook
  (find-file . projectile-mode-switch-dwim)
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :custom
  (projectile-project-search-path (expand-file-name "~/git"))
  (projectile-switch-project-action 'projectile-dired)
  (projectile-track-known-projects-automatically nil)
  (projectile-mode-line-prefix " P")
  (projectile-mode-line-function 'projectile-short-mode-line)
  :config
  (projectile-load-known-projects)
  (bind-keys :map projectile-command-map
             ("C-s" . projectile-save-project-buffers)))

(defun projectile-mode-switch-dwim ()
  "Intelligently switch on/off projectile mode."
  (when-let* ((bfn (buffer-file-name))
              (vc-registered (buffer-file-name)))
    (setq-local projectile-mode t)))

(defun projectile-short-mode-line ()
  "Report project name and type in the modeline."
  (let ((project-name (projectile-project-name)))
    (format "%s:%s"
            projectile-mode-line-prefix
            (or project-name "-"))))
#+end_src

***** counsel-projectile             :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:10]
:END:

#+begin_src emacs-lisp
(use-package counsel-projectile
  :after projectile
  :config
  (bind-keys :map projectile-command-map
             ("p" . counsel-projectile-switch-project)
             ("sG" . counsel-projectile-grep)
             ("sS" . counsel-projectile-ag)
             ("sR" . counsel-projectile-rg)
             ("si" . counsel-projectile-git-grep)))
#+end_src
***** ag.el                          :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
;; (use-package ag :straight t)
#+end_src

***** ripgrep.el                     :ARCHIVE:ignore:
:PROPERTIES:
:CREATED:  [2022-08-03 Wed 21:11]
:END:

#+begin_src emacs-lisp
;; (use-package ripgrep :straight t)
#+end_src

***** wgrep                    :grep:extensions:edit:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-wgrep"
#+end_src

#+begin_src emacs-lisp
(use-package wgrep
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-enable-key "e"))
#+end_src

***** dumb-jump                         :programming:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:36]
:END:

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is "jump to definition" package without tagging.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-dumb-jump"
#+end_src

#+begin_src emacs-lisp
(use-package dumb-jump
  :after xref
  :config
  (add-to-list 'xref-backend-functions
               #'dumb-jump-xref-activate)
  (bind-keys ("M-g ." . dumb-jump-go)
             ("M-g ," . dumb-jump-back)
             ("M-g l" . dumb-jump-quick-look)))
#+end_src

***** visual-regexp                         :ARCHIVE:

#+begin_src scheme :tangle no
"emacs-visual-regexp"
#+end_src

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind ("C-%" . vr/query-replace))
#+end_src

****** visual-regexp-steroids

#+begin_src emacs-lisp :tangle no
("https://github.com/benma/visual-regexp-steroids.el/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package visual-regexp-steroids
  :straight t
  :after (visual-regexp)
  :config
  (setq vr/engine 'python))
#+end_src

***** avy                            :point:location:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

[[https://karthinks.com/software/avy-can-do-anything/][This post]] tell me how we can concoct efficient editing workflow with avy.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-avy"
#+end_src

#+begin_src emacs-lisp
(use-package avy
  :preface
  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
  :config
  (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)
  (bind-keys ("M-g g" . avy-goto-line)
             ("H-g" . avy-goto-line)))
#+end_src

****** avy-migemo
:PROPERTIES:
:CREATED:  [2025-02-13 Thu 23:23]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-avy-migemo-draft"
#+end_src

#+begin_src emacs-lisp
(use-package avy-migemo
  :after migemo
  :bind (("M-g M-a" . avy-migemo-goto-char-timer)
         ("M-g a" . avy-migemo-goto-char-timer)
         ("H-a" . avy-migemo-goto-char-timer)
         :map isearch-mode-map
         ("M-a" . avy-migemo-isearch)))
#+end_src

***** paredit                                  :lisp:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

Handy commands
- press '(' to insert '()' pair
- C-<left/right> to barf and slurp s-expressions
- call paredit-splice-sexp to strip embracing parenthes
- press M-<up> or M-r to delete upper sexp except pointing one
- DEL, C-d, C-k act like originals but care for parenthes
- press DEL to remedy unbalanced parenthes
- press C-q ( to insert ( char manually

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-paredit"
#+end_src

#+begin_src emacs-lisp
(use-package paredit
  :bind (:map paredit-mode-map
              ("<backspace>" . paredit-backward-delete)
              ("C-M-g" .  paredit-splice-sexp)
              ("M-s" . nil)
              ("C-M-;" . paredit-comment-dwim)
              ("M-;" . nil))
  :hook (((emacs-lisp-mode lisp-mode scheme-mode) . enable-paredit-mode)))
#+end_src

- workaround
  Thanks to [[https://andreyorst.gitlab.io/posts/2021-09-30-why-is-paredit-is-so-un-emacsy/][this blog post]], a couple of commands in paredit.el are fixed with transient-mark-mode

  #+begin_src emacs-lisp
  (defvar my/paredit-delete-region-functions
    '(paredit-forward-delete
      paredit-backward-delete)
    "List of `paredit-mode' functions that should support tmm region deletion.")

  (defvar my/paredit-kill-region-functions
    '(paredit-forward-kill-word
      paredit-backward-kill-word)
    "List of `paredit-mode' functions that should support tmm region killing.")

  (defun my/paredit-fix-transient-mark-mode (orig-fn &rest args)
    "Allow deleting/killing a region if expression is balanced."
    (if (and transient-mark-mode
             mark-active)
        (cond ((memq this-command my/paredit-delete-region-functions)
               (paredit-delete-region (region-beginning) (region-end)))
              ((memq this-command my/paredit-kill-region-functions)
               (paredit-kill-region (region-beginning) (region-end)))
              (t (apply orig-fn args)))
      (apply orig-fn args)))

  (dolist (fun (append my/paredit-delete-region-functions
                       my/paredit-kill-region-functions))
    (advice-add fun :around #'my/paredit-fix-transient-mark-mode))
  #+end_src

***** lsp-mode                              :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 22:10]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-lsp-mode"
# #+end_src

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook ((python-mode) . lsp-deferred))
#+end_src

****** lsp-ivy                      :ARCHIVE:ignore:

#+begin_src emacs-lisp
;; (use-package lsp-ivy
;;   :straight t
;;   :after lsp
;;   :hook (lsp-mode . lsp-ivy-mode))
#+end_src

***** company-mode                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-16 Thu 15:26]
:END:

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-company"
# #+end_src

#+begin_src emacs-lisp :tangle no
(use-package company
  :hook (prog-mode . company-mode)
  :bind (:map company-active-map
              ("C-j" . company-complete-selection)
              ("<backspace>" . backward-delete-char-untabify)
              ("C-h" . company-show-doc-buffer)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)))
#+end_src

***** flycheck          :tools:languages:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-flycheck"
#+end_src

#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :hook (prog-mode . flycheck-mode-on-safe)
  :custom
  (global-flycheck-mode t)
  (flycheck-check-syntax-automatically
   '(save new-line idle-change))
  (flycheck-display-errors-delay 10.0)
  (flycheck-checker-error-threshold 1000)
  (flycheck-textlint-config ".textlintrc")
  :config
  (add-hook 'flycheck-mode-hook
            (lambda ()
              (if (my/ascii-string-p (buffer-string))
                  (setq flycheck-textlint-config ".textlintrc")
                (setq flycheck-textlint-config ".config/textlint/textlintrc_ja"))))
  (add-to-list 'display-buffer-alist
               `(,flycheck-error-message-buffer
                 . (display-buffer-reuse-window
                    display-buffer-in-previous-window
                    display-buffer-pop-up-window
                    . ((window-height . 5))))))
#+end_src

***** twittering-mode           :web:twitter:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:37]
:END:

Twitter API is no longer available thanks to the tyrant.

useful tips:
- invoke twittering-toggle-show-replied-statuses on "in reply to" state to show replied messages
- invoke twittering-view-user-page (C-c C-v) on user name to jump to user profile page in default browser

Disclaimers: An unexpected incident might occur if twittering-icon-mode call lay at :config section of use-package

#+begin_src scheme :tangle no
"emacs-twittering-mode"
#+end_src

#+begin_src emacs-lisp :noweb no
(defvar my/twittering-resource-dir
  (expand-file-name "twmode" user-emacs-directory))

(use-package twittering-mode
  :disabled t
  :delight " TW"
  :commands twit
  :hook
  (twittering-mode . twittering-icon-mode)
  :custom
  (twittering-private-info-file
   (expand-file-name "twittering-mode.gpg" my/twittering-resource-dir))
  (twittering-user-id-db-file
   (expand-file-name "user-info.gz" my/twittering-resource-dir))
  (twittering-use-master-password t)
  (twittering-use-ssl t)
  (twittering-number-of-tweets-on-retrieval 50)
  (twittering-use-icon-storage t)
  (twittering-icon-storage-file
   (expand-file-name "icons.gz" my/twittering-resource-dir))
  (twittering-icon-storage-limit 2000)
  (twittering-convert-fix-size 24)
  (twittering-initial-timeline-spec-string '(":home" ":mentions"))
  (twittering-edit-skeleton 'inherit-any)
  (twittering-display-remaining t)
  (twittering-timeline-header "")
  (twittering-timeline-footer "")
  (twittering-status-format
   (concat "%RT{%FACE[bold]{RT by %S\n}}"
           "%i %S,"
           "%FACE[font-lock-constant-face]{%FIELD-IF-NONZERO[ ↺%d]{retweet_count}}"
           "%FACE[font-lock-warning-face]{%FIELD-IF-NONZERO[ ♡%d]{favorite_count}}"
           " %@{}:\n"
           "%T %r%QT{\n+----\n%i %S, %@{}:\n%T %r%R\n+----}\n "))
  :config
  (bind-keys :map twittering-mode-map
             ("C-c C-l" . nil)
             ;; move cursor
             ("f" . scroll-up-line)
             ("e" . scroll-down-line)
             ("E" . my/twittering-previous-status-and-top)
             ("SPC" . my/twittering-next-status-and-top)
             ;; create/delete tweets(messages)
             ("u" . twittering-update-status-interactive)
             ("j" . twittering-enter)
             ("J" . twittering-reply-to-user)
             ("RET" . twittering-enter)
             ("o" . my/twittering-open)
             ("C-c C-o" . my/twittering-open)
             ("d" . twittering-direct-message)
             ("k" . twittering-delete-status)
             ("y" . twittering-push-uri-onto-kill-ring)
             ("Y" . twittering-push-tweet-onto-kill-ring)
             ;; response to tweets
             ("r" . twittering-native-retweet)
             ("R" . my/twittering-quote-retweet)
             ("b" . twittering-favorite)
             ("B" . twittering-unfavorite)
             ("l" . twittering-follow)
             ("L" . twittering-unfollow)
             ("t" . twittering-toggle-show-replied-statuses)
             ("T" . twittering-toggle-or-retrieve-replied-statuses)
             ;; switch between timelines
             ("n" . twittering-switch-to-next-timeline)
             ("p" . twittering-switch-to-previous-timeline)
             ("." . twittering-visit-timeline)
             ("@" . twittering-other-user-timeline)
             ("/" . my/twittering-search)
             ("?" . twittering-search)
             ("c1" . twittering-home-timeline)
             ("c2" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":mentions")))
             ("c3" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":retweets_of_me")))
             ("c4" . (lambda ()
                       (interactive)
                       (twittering-search "from:_p_snow")))
             ("c5" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":favorites")))
             ("c6" . (lambda ()
                       (interactive)
                       (twittering-visit-timeline ":direct_message_events")))))

(defun my/twittering-next-status-and-top ()
  "docstring"
  (interactive)
  (twittering-goto-next-status)
  (recenter-top-bottom 0))

(defun my/twittering-previous-status-and-top ()
  "docstring"
  (interactive)
  (twittering-goto-previous-status)
  (recenter-top-bottom 0))

(defun my/twittering-quote-retweet ()
  "docstring"
  (interactive)
  (let ((orig-tweet-uri (twittering-push-uri-onto-kill-ring)))
    (twittering-update-status (format "\n%s" orig-tweet-uri))
    (next-line -1 t)))

(defun my/twittering-search (&optional arg)
  ""
  (interactive "P")
  (let* ((spec (get-text-property (point) 'goto-spec))
         (username (get-text-property (point) 'username))
         (word (cond
                ((use-region-p) (buffer-substring (region-beginning) (region-end)))
                ((stringp spec) spec)
                ((eq (car spec) 'user) (format "@%s" (cadr spec)))
                ((stringp username) username))))
    (twittering-search (and (not arg) word))))

(defun my/twittering-open (&optional arg)
  ""
  (interactive "P")
  (let ((uri (or (get-text-property (point) 'uri)
                 (if (get-text-property (point) 'field)
                     (let* ((id (get-text-property (point) 'id))
                            (status (twittering-find-status id)))
                       (twittering-get-status-url-from-alist status))
                   nil))))
    (browse-url uri)))
#+end_src

***** comment-dwim-2                        :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/remyferre/comment-dwim-2/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package comment-dwim-2
  :disabled t
  :defer 1
  :bind ("M-;" . comment-dwim-2)
  :config
  (setf comment-dwim-2--inline-comment-behavior 'reindent-comment
        cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

***** undo-tree :undo:tree:redo:history:files:convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

#+begin_src scheme :tangle no :noweb-ref no
"emacs-undo-tree"
#+end_src

#+name: undo-tree-hist-dir
#+begin_src emacs-lisp :tangle no :eval no-export
(file-name-concat no-littering-var-directory "undo-tree")
#+end_src

#+begin_src conf :noweb yes :noweb-ref no :tangle no
d <<undo-tree-hist-dir()>> - - - 3w
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package undo-tree
  :diminish undo-tree-mode
  :init
  (defvar undo-tree-excludes '("/gnu/store"))
  :custom
  (global-undo-tree-mode t)
  (undo-tree-auto-save-history nil)
  (undo-tree-enable-undo-in-region t)
  (undo-tree-limit 320000)
  (undo-tree-strong-limit 480000)
  (undo-tree-outer-limit 64000000)
  :config
  (bind-keys :map undo-tree-map
             ("M-_" . nil))
  (add-to-list 'undo-tree-history-directory-alist
               '("." . "<<undo-tree-hist-dir()>>"))
  (add-to-list 'display-buffer-alist
               `(,undo-tree-visualizer-buffer-name . (display-buffer-in-side-window
                                                      . ((side . right)
                                                         (window-width . 15))))))
#+end_src

***** quickrun                              :ARCHIVE:

#+begin_src emacs-lisp
;; (use-package quickrun)
#+end_src

***** expand-region

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-expand-region"
#+end_src

#+begin_src emacs-lisp
(use-package expand-region
  :bind (("C-,"   . er/expand-region)
         ("C-M-," . er/contract-region))
  :config
  (push 'er/mark-outside-pairs er/try-expand-list))
#+end_src

***** helpful
:PROPERTIES:
:CREATED:  [2024-02-12 Mon 19:01]
:END:

helpful-mode displays more sources compared to help-mode, including callers, debugging information, and source code.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
  "emacs-helpful"
#+end_src

#+begin_src emacs-lisp
(use-package helpful
  :after help
  :bind (:map help-map
              ("C-u a" . helpful-callable)
              ("C-u f" . helpful-function)
              ("C-u s" . helpful-symbol)
              ("C-u x" . helpful-command)
              ("C-u v" . helpful-variable)
              ("C-u k" . helpful-key)
              ("C-u m" . helpful-macro)))
#+end_src

***** define-word            :dictionary:convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref elfeed-feeds
("https://github.com/abo-abo/define-word/tags.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package define-word
  :ensure t
  :defer t
  :bind (:map engine-mode-prefixed-map
              ("n" . my/define-word))
  :preface
  (defvar my/define-word-minibuffer-history nil)
  (defun my/define-word (word)
    "Invoke `define-word' with dedicated minibuffer history."
    (interactive (list (determine-search-word "Word to define: " 'my/define-word-minibuffer-history)))
    (define-word word define-word-default-service))
  :custom
  (define-word-displayfn-alist
   '((wordnik . my/define-word--display-in-buffer)
     (openthesaurus . my/define-word--display-in-buffer)
     (webster . my/define-word--display-in-buffer)))
  (define-word-default-service 'wordnik)
  :config
  (setf (cdr (assoc 'wordnik define-word-services))
        '("http://wordnik.com/words/%s" my/define-word--parse-wordnik-all))
  (push '("<b>\\(.*?\\)</b>" bold)
        define-word--tag-faces)
  ;; fix issue #31 temporally
  (defun my/define-word--fix-31 (define-word-orig &rest args)
    "Fix `define-word' backends that require a user agent (like wordnik)."
    (let ((url-request-extra-headers
           '(("User-Agent" .
              "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36"))))
      (apply define-word-orig args)))
  (advice-add #'define-word :around #'my/define-word--fix-31))

(defun my/define-word--display-in-buffer (definition)
  "docstring"
  (let* ((buf-name "*DEFINE WORD*")
         (buffer (get-buffer-create buf-name))
         (display-buffer-alist
          `((,buf-name
             (display-buffer-same-window)))))
    (with-current-buffer buffer
      (read-only-mode -1)
      (erase-buffer)
      (insert definition)
      (goto-char (point-min))
      (save-excursion (xml-parse-string))
      (read-only-mode 1))
    (display-buffer buffer)))

(defun my/define-word--parse-wordnik-example ()
  (save-excursion
    (let (beg
          results
          (define-word-limit 10))
      (re-search-forward "<h2>Examples" nil t)
      (save-excursion
        (setq beg (re-search-forward "<div class=\"relatedWords-module\">" nil t)))
      (while (re-search-forward "<p class=\"text\">\\(.*\\)</p>" beg t)
        (push "---" results)
        (push (match-string 1) results))
      (when (setq results (nreverse results))
        (define-word--convert-html-tag-to-face (define-word--join-results results))))))

(defvar my/define-word-part-map-alist '(("adjective" "adj.")
                                        ("adverb" "adv.")
                                        ("intransitive verb" "v.i.")
                                        ("transitive verb" "v.t.")))


(defun my/define-word--parse-wordnik ()
  (let ((str (define-word--parse-wordnik)))
    (with-temp-buffer
      (insert str)
      (mapc (lambda (abbrev-map)
              (goto-char (point-min))
              (while (re-search-forward (format "\\(%s\\)" (car abbrev-map)) nil t)
                (let ((match (match-string 1)))
                  (replace-match
                   (propertize (cadr abbrev-map) 'face (text-properties-at (point)))))))
            my/define-word-part-map-alist)
      (buffer-string))))

(defun my/define-word--parse-wordnik-related-word ()
  "docstring"
  (save-excursion
    (save-match-data
      (seq-reduce
       (lambda (accum group)
         (let (results
               (define-word-limit 20))
           (if (re-search-forward (format "<h3>%s" group) nil t)
               (progn (save-excursion
                        (setq beg (re-search-forward "<div class=\"related-group-header clearfix\">" nil t)))
                      (push (concat group ":") results)
                      (while (re-search-forward "<span data-definition-for=\"\\([^\"]*\\)\"" beg t)
                        (push (concat "- " (match-string 1)) results)
                        (re-search-forward "</span>"))
                      (concat (when accum (concat accum "\n\n"))
                              (when (setq results (nreverse results))
                                (define-word--convert-html-tag-to-face (define-word--join-results results)))))
             accum)))
       '("antonym" "equivalents" "hypernyms" "hyponyms" "same context")
       nil))))

(defun my/define-word--parse-wordnik-all ()
  ""
  (let* ((def (funcall #'my/define-word--parse-wordnik))
         (rel (funcall #'my/define-word--parse-wordnik-related-word))
         (exp (funcall #'my/define-word--parse-wordnik-example)))
    (concat ;; "Definitions:\n" (funcall #'define-word--parse-wordnik) "\n\n"
     (when def (format "Definitions:\n%s\n\n" def))
     (when rel (format "%s\n\n" rel))
     (when exp (format "Examples:\n%s\n" exp)))))
#+end_src

***** synosaurus

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-synosaurus"
#+end_src

#+begin_src emacs-lisp
(use-package synosaurus
  :bind (:map engine-mode-prefixed-map
              ("s" . synosaurus-lookup))
  :custom
  (synosaurus-choose-method 'default))
#+end_src

***** exec-path-from-shell         :unix:environment:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:38]
:END:

A GNU Emacs library to ensure environment variables inside Emacs look the same as in the user's shell.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-exec-path-from-shell"
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config
  (when (memq window-system '(mac))
    (exec-path-from-shell-initialize)))
#+end_src

***** migemo.el
:PROPERTIES:
:CREATED:  [2025-01-29 Wed 23:24]
:END:

migemo allows me to search incrementally Japanese words using roma-ji expression.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-migemo-draft"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package migemo
  :ensure-system-package cmigemo
  :custom
  ;; Replace migemo dictionary with AZIK variant
  (migemo-directory
   "/gnu/store/x33c4smmws75c5yaac1xp88xi7pr5pb6-migemo-dict-azik-1.3e/share/migemo/utf-8"))
#+end_src

****** ivy-migemo                   :ARCHIVE:ignore:

#+begin_src emacs-lisp
(use-package ivy-migemo
  :after migemo)
#+end_src

***** jaword
:PROPERTIES:
:CREATED:  [2022-08-13 Sat 18:01]
:END:

Jaword.elはbackward-wordやforward-wordを日本語に対応させる機能を提供します。これらのコマンドはデフォルトではひらがな・カタカナ・漢字の境界を単語の区切りとするのに対し、jaword.elを使用するとより正確に日本語の単語単位での移動が可能です。

#+begin_src emacs-lisp :tangle no
("https://github.com/zk-phi/jaword/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp
(use-package jaword
  :ensure t
  :custom
  (jaword-enable-subword t)
  :hook ((skk-mode
          . (lambda ()
              (jaword-mode 1)))
         (input-method-activate
          . (lambda ()
              (when (string= current-input-method "japanese-skk")
                (jaword-mode 1))))
         (input-method-deactivate
          . (lambda ()
              (when (string= current-input-method "japanese-skk")
                (jaword-mode -1))))))
#+end_src

***** hungry-delete                         :ARCHIVE:

Aggressively delete successive white spaces.

#+begin_src emacs-lisp :tangle no
("https://github.com/nflath/hungry-delete/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package hungry-delete
  :straight t
  :diminish
  :config
  (global-hungry-delete-mode 1))
#+end_src

***** aggressive-indent-mode :tools:maint:lisp:indent:
:PROPERTIES:
:ID:       4a58219c-74dd-4135-b56d-876b0db2cd83
:CREATED:  [2023-06-11 Sun 18:39]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-aggressive-indent"
#+end_src

#+begin_src emacs-lisp
(use-package aggressive-indent
  :diminish (aggressive-indent-mode . "ai")
  :hook ((emacs-lisp-mode scheme-mode) . aggressive-indent-mode))
#+end_src

***** adaptive-wrap

adaptive-wrap and visual-line-mode are active in a bundle in a bunch of major modes.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-adaptive-wrap"
#+end_src

#+begin_src emacs-lisp
(use-package adaptive-wrap)
#+end_src

***** restart-emacs             :convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

Configuration for shutting down Emacs moved to [[id:1a73e0cf-f851-4f48-9a22-1ec37fdcf960][here]] since M-x [[help:restart-emacs][restart-emacs]] had been built-in at ver.29.1.

# #+begin_src scheme :tangle no :noweb-ref guix-emacs
#   "emacs-restart-emacs"
# #+end_src

#+begin_src emacs-lisp
(use-package restart-emacs
  :bind (("C-M-<delete>"   . restart-emacs)
         ("C-M-S-<delete>" . save-buffers-kill-emacs)))
#+end_src

***** pangu-spacing                         :ARCHIVE:

#+begin_src emacs-lisp :tangle no
("https://github.com/coldnew/pangu-spacing/releases.atom" soft_update)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package pangu-spacing
  :straight t
  :diminish pangu-spacing-mode
  :custom
  (pangu-spacing-real-insert-separtor t)
  :config
  (setq pangu-spacing-chinese-before-english-regexp
        (rx (group-n 1 (category japanese))
            (group-n 2 (in "a-zA-Z0-9"))))
  (setq pangu-spacing-chinese-after-english-regexp
        (rx (group-n 1 (in "a-zA-Z0-9"))
            (group-n 2 (category japanese)))))
#+end_src
***** which-key                             :ARCHIVE:

[[https://github.com/justbur/emacs-which-key][which-key]] guides me "which key is available" after current key stroke in the mini buffer.

#+begin_src scheme :tangle no
"emacs-which-key"
#+end_src

#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :custom
  (which-key-use-C-h-commands t)
  (which-key-max-description-length 43)
  (which-key-idle-delay 0.7)
  (which-key-separator " : ")
  (which-key-side-window-max-height 0.5)
  :config
  (which-key-mode 1)
  (which-key-setup-side-window-bottom))
#+end_src
***** hydra                                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-03-18 Sat 14:16]
:END:

# #+begin_src scheme :tangle no
#   "emacs-hydra"
# #+end_src

#+begin_src emacs-lisp
(use-package hydra
  :custom
  (hydra-is-helpful nil))
#+end_src

***** pass         :store:password:password:keychain:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

Major mode for manupulating password store file.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-pass"
#+end_src

#+begin_src emacs-lisp
(use-package pass
  :commands pass
  :bind (:map pass-mode-map
              ("C-j" . pass-view)))
#+end_src

***** password-store :tools:store:password:password:pass:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-password-store"
#+end_src

#+begin_src emacs-lisp
(use-package password-store
  :custom
  (password-store-time-before-clipboard-restore 25))
#+end_src

***** nov.el             :multimedia:hypermedia:epub:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-nov-el"
#+end_src

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub$" . nov-mode)
  :hook (nov-mode . nov-abbreviate-file-name)
  :custom
  (nov-variable-pitch nil)
  (nov-text-width t)
  :config
  (bind-keys :map nov-mode-map
             ("C-j" . nov-browse-url)))

(defun nov-abbreviate-file-name ()
  "Shorten `nov-file-name' using `directory-abbrev-alist'."
  (setq nov-file-name (abbreviate-file-name nov-file-name)))
#+end_src

***** yasnippet               :emulation:convenience:
:PROPERTIES:
:ID:       e91bfa7e-79be-4abc-ac0c-232aa3ccddda
:CREATED:  [2023-06-11 Sun 18:40]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-yasnippet"
"emacs-yasnippet-snippets"
#+end_src

#+begin_src emacs-lisp
(use-package yasnippet
  :disabled t
  :bind (:prefix "C-c y"
                 :prefix-map my/yas-map
                 :prefix-docstring "Keymap for YASnippet family."
                 ("v" . yas-visit-snippet-file)
                 ("n" . yas-new-snippet)
                 ("i" . yas-insert-snippet)
                 ("TAB" . yas-insert-snippet))
  :hook
  ((prog-mode text-mode) . yas-minor-mode)
  (after-init . yas-reload-all)
  :custom
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :config
  (require 'yasnippet-snippets))
#+end_src

***** auto-yasnippet
:PROPERTIES:
:CREATED:  [2023-06-26 Mon 10:52]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-auto-yasnippet"
#+end_src

#+begin_src emacs-lisp
(use-package auto-yasnippet
  :disabled t
  :after yasnippet
  :config
  (bind-keys :map my/yas-map
             ("a"   . aya-create)
             ("A"   . aya-expand)
             ("C-s" . aya-persist-snippet)))
#+end_src

***** yankpad            :convenience:abbrev:ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-12-18 Sun 16:01]
:END:

[[https://github.com/Kungsgeten/yankpad][Yankpad]] enables us to define snippets in org-mode for [[id:e91bfa7e-79be-4abc-ac0c-232aa3ccddda][yasnippet]] or [[https://www.emacswiki.org/emacs/SkeletonMode][Skeltom]].

#+begin_src emacs-lisp
(use-package yankpad
  :disabled t
  :after (org denote)
  :bind (("C-c y i" . yankpad-insert)
         ("C-c y TAB" . yankpad-expand)
         ("C-c y p" . company-yankpad)
         ("C-c y c" . yankpad-capture-snippet)
         ("C-c y l" . yankpad-reload)
         ("C-c y z" . yankpad-repeat)
         ("C-c y e" . yankpad-edit))
  :custom
  (yankpad-file (denote-get-path-by-id "20230605T175742")))
#+end_src

***** pdf-tools            :multimedia:files:ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no
"emacs-pdf-tools"
#+end_src

#+begin_src emacs-lisp
(use-package pdf-tools
  :delight
  (pdf-view-mode " PV")
  :mode ("\\.pdf$" . pdf-view-mode)
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-page-to-window)
  :custom
  (pdf-view-display-size 'fit-width))
#+end_src

***** rainbow-mode                            :faces:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-rainbow-mode"
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish
  (rainbow-mode . "rb")
  :hook
  ((css-mode scss-mode php-mode html-mode) . rainbow-mode)
  :custom
  (rainbow-html-colors t)
  (rainbow-x-colors t)
  (rainbow-latex-colors t)
  (rainbow-ansi-colors t))
#+end_src
***** alert              :notification:message:emacs:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:41]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-alert"
#+end_src

#+begin_src emacs-lisp
(use-package alert
  :config
  (set-face-background 'alert-saved-fringe-face nil)
  (alert-add-rule :status '(buried)
                  :mode   'mu4e-alert
                  :style  'fringe)
  (alert-add-rule :status '(buried)
                  :mode   'dired-mode
                  :style  'fringe)
  (alert-add-rule :status '(buried)
                  :mode   'org-mode
                  :style  'libnotify))
#+end_src

***** ts                              :lisp:calendar:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ts"
#+end_src

#+begin_src emacs-lisp
(use-package ts)
#+end_src

***** app-launcher
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 21:42]
:END:

#+begin_src scheme :noweb-ref guix-emacs :tangle no
"emacs-app-launcher"
#+end_src

#+begin_src emacs-lisp
(use-package app-launcher
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("a" . app-launcher-run-app)))
#+end_src

***** tldr                               :tools:docs:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

I ran into a problem with downloading TL;DR document. I forcibly download, uncompress and locate that to `tldr-directory-path'.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-tldr"
#+end_src

#+begin_src emacs-lisp
(use-package tldr
  :commands tldr
  :custom
  (tldr-use-word-at-point t))
#+end_src

***** burly                             :convenience:
:PROPERTIES:
:CREATED:  [2023-06-11 Sun 18:42]
:END:

[[https://github.com/alphapapa/burly.el][Burly.el]] is capable of saving and opening Emacs frames and windows by describing them as URL which can be stored in bookmark. You can use Burly as a lightweight workspace tool.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-burly"
#+end_src

#+begin_src emacs-lisp
(require 'burly)
#+end_src
***** tempel              :wp:tools:languages:abbrev:
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 16:07]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-tempel"
;; "emacs-tempel-collection"
#+end_src

#+NAME: config/emacs-tempel
#+begin_src emacs-lisp
(use-package tempel
  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
         ("M-_" . tempel-insert))
  :hook
  ((conf-mode prog-mode text-mode minibuffer-mode) . tempel-setup-capf)
  (mu4e-compose-mode . tempel-abbrev-mode)
  :preface
  (defun tempel-setup-capf ()
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
  :custom
  (tempel-path (list (no-littering-expand-etc-file-name "tempel/templates/*.eld")
                     (no-littering-expand-etc-file-name "tempel/templates/*/*.eld")))
  :config
  (bind-keys :map tempel-map
             ("TAB" . tempel-next)
             ("M-TAB" . tempel-previous)
             ("C->" . tempel-next)
             ("C-<" . tempel-previous))
  (with-eval-after-load 'cape
    (bind-keys :map my/cape-map
               ("t" . tempel-expand))))

(use-package tempel-collection
  :ensure t
  :after tempel)
#+end_src

***** literate calc mode       :tools:languages:calc:
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 21:35]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-literate-calc-mode"
#+end_src

#+begin_src emacs-lisp
(use-package literate-calc-mode
  :bind ("C-c M-=" . literate-calc-mode))
#+end_src

***** git-link
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 21:50]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-git-link"
#+end_src

#+begin_src emacs-lisp
(use-package git-link)
#+end_src

***** jinx
:PROPERTIES:
:CREATED:  [2023-12-07 Thu 12:22]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-jinx"
#+end_src

#+begin_src emacs-lisp
(use-package jinx
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  :config
  (bind-keys :map jinx-mode-map
             ("M-n" . jinx-next)
             ("M-p" . jinx-previous)))
#+end_src
***** simple-httpd
:PROPERTIES:
:CREATED:  [2023-12-23 Sat 20:36]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-simple-httpd"
#+end_src

#+begin_src emacs-lisp
(use-package simple-httpd
  :commands (httpd-start httpd-serve-directory))
#+end_src

***** logos
:PROPERTIES:
:CREATED:  [2024-01-11 Thu 17:57]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-logos"
#+end_src

#+NAME: config/emacs-logos
#+begin_src emacs-lisp
(use-package logos
  :config
  (require 'fingertip)
  :preface
  (defun logos-toggle-read-only ()
    "Toggle read only state in `logos-focus-mode'"
    (interactive)
    (let ((current-ro-state logos-buffer-read-only))
      (logos-focus-mode -1)
      (setq logos-buffer-read-only (not current-ro-state))
      (logos-focus-mode 1)
      (unless logos-buffer-read-only
        (fingertip-mode -1))
      (message "Buffer is %s"
               (if logos-buffer-read-only
                   "read-only" "editable"))))
  :bind (("H-;" . logos-focus-mode)
         ("H-n" . logos-narrow-dwim)
         :map logos-focus-mode-map
         ("H-e" . logos-toggle-read-only))
  :hook (((help-mode helpful-mode Info-mode eww-mode nov-mode mu4e-view-mode
                     woman-mode mastodon-mode Custom-mode devdocs-mode)
          . logos-focus-mode)
         (logos-focus-mode
          . (lambda () (if logos-focus-mode
                       (fingertip-mode 1)
                     (setq logos-buffer-read-only t)
                     (fingertip-mode -1)))))
  :custom
  (logos-scroll-lock nil)
  (logos-variable-pitch nil)
  (logos-hide-cursor nil)
  (logos-hide-mode-line t)
  (logos-hide-buffer-boundaries t)
  (logos-buffer-read-only t)
  (logos-olivetti nil)
  (logos-hide-fringe t))
#+end_src

***** editorconfig
:PROPERTIES:
:CREATED:  [2024-01-13 Sat 15:13]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-editorconfig"
#+end_src

#+begin_src emacs-lisp
(use-package editorconfig)
#+end_src

***** elisp-demos
:PROPERTIES:
:CREATED:  [2024-02-11 Sun 22:02]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-elisp-demos"
#+end_src

#+begin_src emacs-lisp
(use-package elisp-demos
  :bind (:map help-map
              ("O" . elisp-demos-find-demo))
  :config
  (require 'helpful)
  (bind-keys :map helpful-mode-map
             ("O" . elisp-demos-for-helpful)))
#+end_src

***** yeetube
:PROPERTIES:
:CREATED:  [2024-02-26 Mon 20:42]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-yeetube"
#+end_src

#+NAME: config-emacs-yeetube
#+begin_src emacs-lisp :noweb tangle
(use-package yeetube
  :after engine-mode
  :bind (:map engine-mode-prefixed-map
              ("Y" . yeetube-search))
  :custom
  (yeetube-download-directory "<<media-dir()>>")
  (yeetube-default-sort-column "Date")
  (yeetube-display-thumbnails nil)
  :config
  (keymap-set yeetube-mode-map "Y"
              (lambda () (interactive)
                "Dwonload a video at point using `my/yt-dlp-command'"
                (my/yt-dlp-command (yeetube-get-url))))
  (keymap-set yeetube-mode-map "P"
              (lambda () (interactive)
                "Play a video at point using `my/yt-dlp-command'"
                (my/yt-dlp-command (yeetube-get-url) nil nil t)
                (my/tsc-execute-macro))))
#+end_src

***** consult-notes          :wp:convenience:ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-03-05 Tue 14:09]
:END:

#+begin_src emacs-lisp
(use-package consult-notes
  :ensure t
  :after (consult denote))
#+end_src

***** gnuplot
:PROPERTIES:
:CREATED:  [2024-03-11 Mon 16:55]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-gnuplot"
#+end_src

#+begin_src emacs-lisp :noweb tangle
(use-package gnuplot
  :defer t
  :mode ("\\.\\(gnuplot\\|gpt\\|plt\\|gp\\)\\'" . gnuplot-mode)
  :hook
  (gnuplot-mode . (lambda ()
                    (setq-local devdocs-current-docs '("gnuplot")))))
#+end_src

***** treesit-auto
:PROPERTIES:
:CREATED:  [2024-03-13 Wed 16:07]
:END:

#+begin_src emacs-lisp
(use-package treesit-auto
  :ensure t
  :config
  (treesit-auto-add-to-auto-mode-alist 'all))
#+end_src

***** devdocs
:PROPERTIES:
:CREATED:  [2024-03-16 Sat 16:20]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-devdocs"
#+end_src

#+begin_src emacs-lisp
(use-package devdocs
  :bind (:map help-map
              ("M-d" . devdocs-lookup)))
#+end_src

***** unfill
:PROPERTIES:
:CREATED:  [2024-03-22 Fri 17:07]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-unfill"
#+end_src

#+begin_src emacs-lisp
(use-package unfill
  :bind ("M-Q" . unfill-toggle))
#+end_src

***** htmlize
:PROPERTIES:
:CREATED:  [2024-04-13 Sat 14:55]
:ID:       563c138c-7410-4171-ab3f-15d564677620
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-htmlize"
#+end_src

#+name: htmlize-dir
#+header: :var full-path=0
#+begin_src emacs-lisp :noweb yes :eval no-export :tangle no
(funcall (if (= full-path 0) #'identity #'expand-file-name)
         (file-name-concat no-littering-var-directory "htmlize"))
#+end_src

#+begin_src shell :noweb yes :noweb-ref make-dir :tangle no
<<htmlize-dir()>>
#+end_src

#+begin_src conf :noweb yes :noweb-ref tmpfiles-cleanup :tangle no
d <<htmlize-dir(full-path=1)>> - - - 5d
#+end_src

EWW is a nice place for intensive reading. When there are articles or documents in a format other than HTML, I convert them to HTML and browse them in EWW with my/view-htmlized.

#+NAME: config/emacs-htmlize
#+begin_src emacs-lisp :noweb tangle
(use-package htmlize
  :bind ("C-!" . my/view-htmlized)
  :custom
  (Htmlize-force-inline-images t)
  :init
  (with-eval-after-load 'org-keys
    (add-to-list 'org-speed-commands
                 '("!" . my/view-htmlized)
                 t))
  :config
  (defun my/view-htmlized ()
    (interactive)
    (pcase-let* ((`(,fname . ,write-proc)
                  (if (derived-mode-p 'org-mode)
                      (cons (format "%s.html"
                                    (secure-hash 'md5 (org-id-get-create)))
                            (lambda (file)
                              (let ((org-export-show-temporary-export-buffer nil)
                                    (org-export-preserve-breaks t)
                                    (org-export-use-babel nil))
                                (org-html-export-as-html nil (if (org-before-first-heading-p) nil t) nil)
                                (with-current-buffer "*Org HTML Export*"
                                  (write-file file)))))
                    (cons (format "%s.html"
                                  (secure-hash 'md5
                                               (apply 'buffer-substring-no-properties
                                                      (if (region-active-p)
                                                          (list (region-beginning) (region-end))
                                                        (list (point-min) (point-max))))))
                          (lambda (file)
                            (let ((region-text (apply 'htmlize-region-for-paste
                                                      (if (region-active-p)
                                                          (list (region-beginning) (region-end))
                                                        (list (point-min) (point-max))))))
                              (with-temp-buffer
                                (insert region-text)
                                (write-file file nil)))))))
                 (file-path (file-name-concat "<<htmlize-dir()>>" fname)))
      (when (or (not (file-exists-p file-path))
                (derived-mode-p 'org-mode))
        (apply write-proc (list file-path)))
      (browse-url-of-file file-path))))
#+end_src

***** everywhere                 :frames:convenience:
:PROPERTIES:
:CREATED:  [2024-04-28 Sun 12:56]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-everywhere"
"xdotool"
#+end_src

#+begin_src emacs-lisp
(use-package emacs-everywhere
  :hook (emacs-everywhere-mode
         . (lambda () (when emacs-everywhere-mode
                    (set-frame-parameter nil 'fullscreen 'fullboth)))))
#+end_src

#+NAME: bash/emacs-everywhere
#+begin_src sh :noweb tangle :tangle (expand-file-name "emacs-everywhere" tangle/local-bin-dir) :tangle-mode o755
emacsclient -s server-<<hash-string(seed="server", len=6)>> --eval "(emacs-everywhere)"
#+end_src

***** Eat

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-eat"
#+end_src

#+begin_src emacs-lisp
(use-package eat
  :commands (eat eat-eshell-mode)
  :hook (eshell-load . eat-eshell-mode))
#+end_src

***** japanese-holidays                    :calendar:

[[https://github.com/emacs-jp/japanese-holidays/releases.atom][japanese-holidays]]

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-japanese-holidays"
#+end_src

#+begin_src emacs-lisp
(use-package japanese-holidays
  :preface
  (defun my/japanese-holiday-show (&rest _args)
    "Show holiday information in mini buffer if date on which the cursor is any holidays."
    (let* ((date (calendar-cursor-to-date t))
           (calendar-date-display-form '((format "%s年 %s月 %s日（%s）" year month day dayname)))
           (date-string (calendar-date-string date))
           (holiday-list (calendar-check-holidays date)))
      (when holiday-list
        (message "%s: %s" date-string (mapconcat #'identity holiday-list "; ")))))
  :custom-face
  (japanese-holiday-saturday ((t (:foreground "blue" :background nil))))
  :custom
  (japanese-holiday-weekend '(0 6))
  (japanese-holiday-weekend-marker
   '(holiday nil nil nil nil nil japanese-holiday-saturday))
  :config
  (setf calendar-holidays
        (append japanese-holidays holiday-local-holidays holiday-other-holidays))
  (with-eval-after-load 'calendar
    (add-hook 'calendar-today-visible-hook
              #'japanese-holiday-mark-weekend)
    (add-hook 'calendar-today-invisible-hook
              #'japanese-holiday-mark-weekend)
    (add-hook 'calendar-move-hook
              #'my/japanese-holiday-show)))
#+end_src

***** consult-denote

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-consult-denote"
#+end_src

#+begin_src emacs-lisp
(use-package consult-denote
  :after (consult denote)
  :init (consult-denote-mode)
  :bind (("C-c n f" . consult-denote-find)
         ("C-c n g" . consult-denote-grep)))
#+end_src

***** capf-autosuggest                      :ARCHIVE:

[[https://repo.or.cz/emacs-capf-autosuggest.git][capf-autosuggest]] provides auto-suggestion functionality in Eshell and major modes, which is derived from Comint mode. In =capf-autosuggest-mode=, you can use =C-e= to complete the entire command suggested as a placeholder, and =M-f= to complete a single word.

#+begin_src emacs-lisp
(use-package capf-autosuggest
  :ensure t
  :hook ((eshell-mode comint-mode) . capf-autosuggest-mode))
#+end_src

***** denote-explore

#+begin_src emacs-lisp
(use-package denote-explore
  :ensure t
  :after denote)
#+end_src

***** bluetooth
:PROPERTIES:
:CREATED:  [2024-12-15 Sun 19:18]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-bluetooth"
#+end_src

#+begin_src emacs-lisp
(use-package bluetooth
  :after my-launch-app
  :bind (:map my/launch-app-map
              ("B" . bluetooth-list-devices)))
#+end_src

***** ztree
:PROPERTIES:
:CREATED:  [2024-12-19 Thu 22:21]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-ztree"
#+end_src

#+begin_src emacs-lisp
(use-package ztree)
#+end_src

***** try
:PROPERTIES:
:CREATED:  [2025-01-04 Sat 14:04]
:END:

#+begin_src emacs-lisp
(use-package try
  :ensure t)
#+end_src

***** drag-stuff
:PROPERTIES:
:CREATED:  [2025-01-29 Wed 00:00]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-drag-stuff"
#+end_src

#+begin_src emacs-lisp
(use-package drag-stuff
  :bind (("H-p" . drag-stuff-up)
         ("H-n" . drag-stuff-down))
  :config
  (drag-stuff-global-mode 1))
#+end_src

***** exemplify-eval
:PROPERTIES:
:CREATED:  [2025-02-03 Mon 16:19]
:END:

#+begin_src emacs-lisp
(use-package exemplify-eval
  :disabled t
  :vc (:url "https://git.sr.ht/~flandrew/exemplify-eval"
            :rev :newest))
#+end_src

**** My Emacs Packages

***** lfile

#+begin_src emacs-lisp
(use-package lfile
  :after org
  :config
  (put 'lfile-locate 'org-link-abbrev-safe t))
#+end_src

***** open-file

#+begin_src emacs-lisp
(require 'open-file)
#+end_src

***** org-password-store

#+begin_src emacs-lisp
(use-package org-password-store
  :after org
  :bind (:map org-mode-map
              ("C-c p c c" . my/password-store-copy)
              ("C-c p c f" . my/password-store-copy-field)
              ("C-c p s" . my/password-store-show-field)
              ("C-c p w" . my/password-store-url)
              ("C-c p l" . my/password-store-web-login)
              ("C-c p n" . my/password-store-create)
              ("C-c p e" . my/password-store-edit)
              ("C-c p v" . my/password-store-edit)
              ("C-c p k" . my/password-store-remove)))
#+end_src

***** org-english

#+begin_src emacs-lisp
(use-package org-english
  :after (org my-org-global-map)
  :config
  (bind-keys :map my/org-global-map
             ("e e" . my/org-english-capture)
             ("e d" . my/org-english-drill)
             ("e r" . my/org-english-drill-resume)
             ("e l" . my/org-english-link)
             ("E" . my/cloze-deletion-replace)
             ("e q" . my/org-english-search)
             :map engine-mode-prefixed-map
             ("j" . (lambda (word)
                      "Copy Japanese translation as well as the pronunciation to `kill-ring'."
                      (interactive (list (determine-search-word)))
                      (kill-new (message "%s %s"
                                         (my/english-japanese-translate word t)
                                         (my/english-pronunciation word t))))))
  (with-eval-after-load 'denote-org-extras
    (setq my/org-english-file (denote-get-path-by-id "20230605T170959"))))
#+end_src

*** Innovative Customization
:PROPERTIES:
:header-args+: :tangle (expand-file-name "ext-config.el" tangle/emacs-config-dir)
:CREATED:  [2023-01-20 Fri 10:22]
:END:

**** utility macros/functions
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 16:56]
:header-args+: :tangle (expand-file-name "00-my-early-config.el" tangle/emacs-config-dir)
:END:

***** lambda key
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 12:33]
:END:

[[https://www.emacswiki.org/emacs/DocumentingKeyBindingToLambda][lambda-key]] is nice idea to remedy lambda bindings with define-key.

#+begin_src emacs-lisp
(defun lambda-key (keymap key def)
  "Wrap`define-key' to provide documentation."
  (set 'sym (make-symbol (documentation def)))
  (fset sym def)
  (keymap-set keymap key sym))
#+end_src

#+name: template-lambda-key
#+begin_src emacs-lisp :tangle no :noweb-ref emacs-lisp-mode-template
(lambda-key "(lambda-key " (p "keymap") " \"" (p "key") "\"" n>
            "(lambda () \"" (p "desc") "\"" n> "(interactive)" n>
            p "))")
#+end_src

***** computational
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 18:24]
:END:

****** Calculating all combinations in a list
:PROPERTIES:
:CREATED:  [2024-12-28 Sat 16:58]
:END:

#+begin_src emacs-lisp
(defun my/combinations (list)
  "Return all combinations for all elements in LIST."
  (if (null list)
      (list nil)
    (let ((rest-combs (my/combinations (cdr list))))
      (append (mapcar (lambda (combination) (cons (car list) combination))
                      rest-combs)
              rest-combs))))
#+end_src

#+NAME: emacs-combinations-test
#+begin_src emacs-lisp :tnagle no
(ert-deftest test-combinations ()
  "Tests `my/combinations'."
  (should (equal (my/combinations '(base desktop emacs))
                 '((base desktop emacs)
                   (base desktop)
                   (base emacs)
                   (base)
                   (desktop emacs)
                   (desktop)
                   (emacs)
                   nil))))
#+end_src

****** Solving knapsack problem
:PROPERTIES:
:CREATED:  [2024-12-28 Sat 16:59]
:END:

- [[https://rosettacode.org/wiki/Knapsack_problem/0-1][Knapsack problem/0-1 - Rosetta Code]]

#+NAME: emacs-knapsack-test
#+begin_src emacs-lisp
(defun my/knapsack (max-w items)
  "Return a subset of ITEMS that amounts to the maximal value within MAX-W.

Each element in ITEMS must comply with the format '(name weight
value)', where name is a symbol and both weight and value are
integers."
  (let ((cache (make-vector (1+ (length items)) nil)))
    (dotimes (n (1+ (length items)))
      (setf (aref cache n) (make-hash-table :test 'eql)))
    (defun ks-emb (spc items)
      (let ((slot (gethash spc (aref cache (length items)))))
        (cond
         ((null items) (list 0 0 '()))
         (slot slot)
         (t (puthash spc
                     (let*
                         ((i (car items))
                          (w (nth 1 i))
                          (v (nth 2 i))
                          (x (ks-emb spc (cdr items))))
                       (cond
                        ((> w spc) x)
                        (t
                         (let* ((y (ks-emb (- spc w) (cdr items)))
                                (v (+ v (car y))))
                           (cond
                            ((< v (car x)) x)
                            (t
                             (list v (+ w (nth 1 y)) (cons i (nth 2 y)))))))))
                     (aref cache (length items)))))))
    (ks-emb max-w items)))
#+end_src

#+NAME: emacs-knapsack-test
#+begin_src emacs-lisp :tangle no
(ert-deftest test-knapsack ()
  "Tests `my/knapsack'."
  (should (equal (my/knapsack 20
                              '((a 9 4) (b 14 7) (c 8 3)))
                 '(7 17 ((a 9 4)
                         (c 8 3))))))
#+end_src

***** copy line number in kill ring
:PROPERTIES:
:CREATED:  [2023-12-16 Sat 12:07]
:END:

#+begin_src emacs-lisp
(defun my/copy-line-number ()
  "Copy the line number of current point into the kill ring."
  (interactive)
  (let ((line-number (number-to-string (line-number-at-pos))))
    (message "Line number: %s" line-number)
    (kill-new line-number)))
(keymap-global-set "C-M-S-w" 'my/copy-line-number)
#+end_src

***** expand shorthand time string
:PROPERTIES:
:CREATED:  [2023-12-16 Sat 11:40]
:END:

#+begin_src emacs-lisp
(defun my/expand-shorthand-time (time-string)
  "Expand shorthand expressions in TIME-STRING."
  (let ((case-fold-search nil))
    (rx-let ((follow-digit (char)
                           (: (group (+ digit)) (* space) char
                              (group (or eol (not alpha))))))
      (seq-reduce (lambda (result element)
                    (replace-regexp-in-string (car element) (cadr element) result))
                  `((,(rx (follow-digit "y")) "\\1year\\2")
                    (,(rx (follow-digit "M")) "\\1month\\2")
                    (,(rx (follow-digit "w")) "\\1week\\2")
                    (,(rx (follow-digit "d")) "\\1day\\2")
                    (,(rx (follow-digit "h")) "\\1hour\\2")
                    (,(rx (follow-digit "m")) "\\1minute\\2")
                    (,(rx (follow-digit "s")) "\\1second\\2"))
                  time-string))))
#+end_src

unit test
#+begin_src emacs-lisp :tangle no
(ert-deftest test/expand-shorthand-time ()
  "Tests the output string of `my/expand-shorthand-time'."
  (should (string= (my/expand-shorthand-time "1m")
                   "1minute"))
  (should (string= (my/expand-shorthand-time "1m 20s")
                   "1minute 20second"))
  (should (string= (my/expand-shorthand-time " 2h10m ")
                   " 2hour10minute ")))
#+end_src

***** play sound
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 22:55]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"mpg321"
"vorbis-tools"
#+end_src

#+begin_src emacs-lisp
(defun my/play-sound (sound-file &optional background-p)
  "Play SOUND-FILE.

The job is executed in the background if BACKGROUND-P is non-nil."
  (call-process-shell-command
   (concat
    (mapconcat #'shell-quote-argument
               (list (cond
                      ((string-suffix-p ".mp3" sound-file)
                       "mpg321")
                      ((string-suffix-p ".oga" sound-file)
                       "ogg123")
                      (t
                       "mpv --no-config"))
                     sound-file)
               " ")
    (when background-p "&"))))
#+end_src

***** determine search word macro

#+begin_src emacs-lisp
(defmacro determine-search-word (&optional prompt history)
  "Return word at point unless region is active using PROMPT and HISTORY."
  `(downcase
    (if (use-region-p)
        (buffer-substring-no-properties (region-beginning) (region-end))
      (read-string ,(or prompt "Search word: ") (downcase (or (word-at-point t) "")) "" ,history))))
#+end_src

**** patches and workarounds
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 15:56]
:END:

***** disable external IME (fcitx)

As of 28.1, Emacs won't steal keyboard focus at startup which means we can use external input methods. But I'm confortable with shutting out external IM, fcitx in my case. Restarting fcitx makes my desire come true.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (call-process-shell-command "fcitx -r")))
#+end_src

***** ddskk corsor color malfunction in Emacs 28 and later
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 15:57]
:END:

[[https://github.com/skk-dev/ddskk/issues/190][Cursor colour no longer changes to match hiragana/katakana mode. · Issue #190 · skk-dev/ddskk · GitHub]]

#+begin_src emacs-lisp :tangle (expand-file-name "early-init.el" tangle/user-emacs-directory)
(require 'facemenu)
#+end_src

**** repeat maps
:PROPERTIES:
:CREATED:  [2022-10-14 Fri 17:43]
:END:

***** dired subdir repeat map
:PROPERTIES:
:CREATED:  [2023-09-13 Wed 11:06]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'dired
  (defvar-keymap my/dired-subdir-map
    :doc "Keymap to repeat commands on dired-subdir."
    :repeat (:enter (dired-next-subdir
                     dired-prev-subdir
                     dired-goto-subdir)
                    :exit (dired-kill-subdir
                           dired-open-subdir))
    "n" #'dired-next-subdir
    "p" #'dired-prev-subdir
    "k" #'dired-kill-subdir
    "g" #'dired-goto-subdir
    "TAB" #'dired-hide-subdir
    "RET" #'dired-open-subdir))
#+end_src

***** visual cycling repeat map
:PROPERTIES:
:CREATED:  [2023-06-20 Tue 11:31]
:END:

#+begin_src emacs-lisp
(use-package emacs
  :no-require t
  :bind-keymap
  ("H-c" . my/cycle-visual-repeat-map)
  :preface
  (defvar-keymap my/cycle-visual-repeat-map
    :doc "Keymap to repeat toggle/cycling appearance.  Used in `repeat-mode'."
    :repeat t
    "#" #'display-line-numbers-mode
    "SPC" #'cycle-spacing
    "V" #'visual-line-mode
    "F" #'toggle-frame-fullscreen
    "P" #'variable-pitch-mode
    "L" #'line-number-mode
    "C" #'column-number-mode
    "R" #'rainbow-mode
    "TAB" #'adaptive-wrap-prefix-mode
    "+" #'text-scale-adjust
    "-" #'text-scale-adjust
    "0" (lambda () "Set text scale to default level." (interactive)
          (text-scale-set 0))))
#+end_src

***** frame repeat map
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 22:24]
:END:

#+begin_src emacs-lisp
(defvar-keymap my/frame-repeat-map
  :doc "Keymap to repeat frame commands.  Used in `repeat-mode'."
  :repeat (:enter (other-frame))
  "o" #'other-frame
  "0" #'delete-frame
  "1" #'delete-other-frames
  "2" #'make-frame-command
  "5" #'other-frame-prefix
  "B" #'bookmark-jump-other-frame
  "p" #'project-other-frame-command
  "D" #'dired-other-frame
  "m" #'compose-mail-other-frame)
#+end_src

***** delete repeat map
:PROPERTIES:
:CREATED:  [2023-02-17 Fri 22:22]
:END:

Suport successive deletion with C-h/M-h

#+begin_src emacs-lisp
(defun my/delete-char-dwim ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-delete-char 1)
    (delete-char 1)))
(defun my/delete-backward-char-dwim ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-delete-backward-char 1)
    (delete-backward-char 1)))
(defun my/kill-word-dwim ()
  (interactive)
  (if jaword-mode
      (jaword-kill 1)
    (kill-word 1)))
(defun my/backward-kill-word-dwim ()
  (interactive)
  (if jaword-mode
      (jaword-kill -1)
    (backward-kill-word 1)))

(defvar-keymap my/delete-repeat-map
  :doc "Keymap to repeat deletion commands.  Used in `repeat-mode'."
  :repeat (:enter (delete-char
                   org-delete-char
                   kill-word
                   jaword-kill
                   my/delete-char-dwim
                   my/delete-backward-char-dwim
                   my/kill-word-dwim
                   my/backward-kill-word-dwim))
  "C-d" #'my/delete-char-dwim
  "C-h" #'my/delete-backward-char-dwim
  "M-d" #'my/kill-word-dwim
  "M-h" #'my/backward-kill-word-dwim)
#+end_src

**** tailored commands/functions
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:

***** update elfeed feeds automatically
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 21:39]
:END:

elfeed-update will run at morning everyday

#+begin_src sh :eval no :noweb yes :tangle no :noweb-ref morning-batch
emacsclient -s server-<<hash-string(seed="server", len=6)>> --eval "(my/elfeed-update t)"
#+end_src

#+begin_src emacs-lisp
(defun my/elfeed-update (&optional compact)
  "Update Elfeed feeds and compress the database."
  (interactive "P")
  (elfeed)
  (elfeed-update)
  (when compact
    (elfeed-db-compact))
  (when (eq major-mode 'elfeed-search-mode)
    (elfeed-kill-buffer)))
#+end_src

***** frame maximization
:PROPERTIES:
:CREATED:  [2023-10-08 Sun 22:29]
:END:

Every frame will be spawn in maximized and initial frame will be full screen at Emacs start-up time.

#+begin_src emacs-lisp
(use-package frame
  :if (member (window-system) '(x ns w32))
  :init
  (add-to-list 'after-make-frame-functions
               (lambda (frame) (set-frame-parameter frame 'fullscreen 'maximized)))
  :hook
  (emacs-startup . (lambda () (set-frame-parameter nil 'fullscreen 'fullboth))))
#+end_src

***** prune old .eln files at shut down     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-10-06 Fri 23:11]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'comp
  (add-hook 'kill-emacs-hook
            #'native-compile-prune-cache))
#+end_src

***** Increasing the number at point
:PROPERTIES:
:CREATED:  [2023-09-06 Wed 21:53]
:CUSTOM_ID: emacs-increase-number
:END:
:LOGBOOK:
- State "Increasing a number at point" from "operate the number at point" [2024-07-22 Mon 16:56]
:END:

Org Mode offers handy commands, namely org-increase-number-at-point and org-decrease-number-at-point. I often find myself handling zero-padded numbers such as '010'. I thought it would be nice if there was a command that could increase a number at point while preserving the preceding zeros - and this is the solution.

#+begin_src emacs-lisp
(defun my/increase-number-at-point (&optional inc)
  "Increase the number at point by INC."
  (interactive "p")
  (let (number)
    (pcase-let* ((`(,beg . ,end) (save-match-data
                                   (setq number (number-at-point))
                                   (cons (match-beginning 0) (match-end 0)))))
      (when (numberp number)
        (delete-region beg end)
        (insert (number-to-string (+ number inc)))))))

(defun my/decrease-number-at-point (dec)
  "Decrease the number at point by DEC."
  (interactive "p")
  (funcall #'my/increase-number-at-point (* dec -1)))

(keymap-global-set "C-x <up>" #'my/increase-number-at-point)
(keymap-global-set "C-x /" #'my/increase-number-at-point)
(keymap-global-set "C-x <down>" #'my/decrease-number-at-point)
(keymap-global-set "C-x ?" #'my/decrease-number-at-point)
(defvar-keymap my/increase-number-repeat-map
  :doc "Repeat keymap for increasing/decreasing numbers."
  :repeat (:enter (my/increase-number-at-point
                   my/decrease-number-at-point))
  "<up>" #'my/increase-number-at-point
  "/" #'my/increase-number-at-point
  "<down>" #'my/decrease-number-at-point
  "?" #'my/decrease-number-at-point)
#+end_src

***** edit local file as root (sudo)
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 11:58]
:END:

my/sudo-edit-local-file is inspired by [[https://emacsredux.com/blog/2013/04/21/edit-files-as-root/][this thisblog post]].

#+begin_src emacs-lisp
(defun my/sudo-edit-local-file ()
  "Reopen the current buffer file with root privileges."
  (interactive)
  (when (file-exists-p buffer-file-name)
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))

(keymap-global-set "C-x C-#" #'my/sudo-edit-local-file)
#+end_src

***** power management
Shut down emacs automatically when remaining power of laptop PC lower than [[help:battery-load-low][battery-load-low]]
to avoid accidental data loss.

#+begin_src emacs-lisp
(require 'battery)

(run-with-timer 60 60 #'kill-emacs-auto)

(defun kill-emacs-auto ()
  "Kill Emacs if remaining machine power lower than `battery-load-low'."
  (when-let* ((data (and battery-status-function (funcall battery-status-function)))
              (percentage (car (read-from-string (cdr (assq ?p data)))))
              (power (cdr (assq ?L data))))
    (when (and (numberp percentage)
               (< percentage battery-load-low)
               (stringp power)
               (string= power "BAT"))
      (save-buffers-kill-emacs t))))
#+end_src

***** lazy viewing                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-01-12 Fri 23:05]
:END:

It's confortable to read long material such as web page , epub file or email with snappy control. Lazy View offers transient keymap that allow users to move cursor and scroll page with simple key stroke.

#+begin_src emacs-lisp
(use-package emacs
  :disabled t
  :no-require t
  :bind (("C-c z" . my/lazy-view-enter)
         ("H-z" . my/lazy-view-enter))
  :hook ((help-mode Info-mode eww-mode nov-mode mu4e-view-mode woman-mode)
         . my/lazy-view-enter)
  :preface
  (defvar-keymap my/lazy-view-map
    :doc "Keymap to repeat lazy viewing commands.  Used in `repeat-mode'."
    "C-?" (lambda () "Show this keymap list."
            (interactive)
            (describe-keymap 'my/lazy-view-map))
    "<SPC>" #'my/forward-paragraph
    "E" #'my/backward-paragraph
    "f" #'scroll-up-line
    "e" #'scroll-down-line
    "C-f" #'forward-char
    "C-b" #'backward-char
    "C-n" #'next-line
    "C-p" #'previous-line
    "C-a" #'move-beginning-of-line
    "C-e" #'move-end-of-line
    "C-v" #'scroll-up-command
    "M-v" #'scroll-down-command
    ">" '(lambda () "Scroll right one column." (interactive)
           (scroll-left 1))
    "<" '(lambda () "Scroll left one column." (interactive)
           (scroll-right 1)))
  (defun my/lazy-view-enter ()
    "Activate my/lazy-view-map in current buffer."
    (interactive)
    (set-transient-map my/lazy-view-map
                       #'my/lazy-view-keep
                       nil
                       "LAZY VIEW MODE"))
  (defun my/lazy-view-keep ()
    (member this-command
            `(beginning-of-visual-line
              end-of-visual-line
              recenter-top-bottom
              reposition-window
              quit-window
              Info-next-reference
              Info-prev-reference
              Info-up
              Info-history-back
              Info-history-forward
              Info-follow-nearest-node
              Info-forward-node
              Info-backward-node
              forward-button
              backward-button
              shr-next-link
              shr-previous-link
              eww-follow-link
              eww-back-url
              eww-forward-url
              eww-goto-title-heading
              eww-reload
              nov-browse-url
              nov-next-document
              nov-previous-document
              ,@(mapcar (lambda (key-command)
                          (let ((cmd (cdr key-command)))
                            (and (commandp cmd)
                                 cmd)))
                        (cdr my/lazy-view-map))))))
#+end_src

***** lookup functions                      :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-03-15 Wed 21:30]
:END:

lookup functions yield to [[id:db630173-d371-45de-a78e-bcc57cb9d50c][engine-mode]]

#+begin_src emacs-lisp :tangle no
(defmacro define-lookup-function (fun search-prefix)
  "Create lookup function named FUN using SEARCH-PREFIX for querying.

if WORD-FIXED is given, use it as a search word."
  (declare (indent 1))
  `(defun ,fun (word &optional arg)
     "Issue search query with WORD.

Use a string in region for WORD if region is active.
If called with prefix argument, prompt the user to input WORD regardless region is active or not."
     (interactive (let ((region-str (when (use-region-p)
                                      (buffer-substring (region-beginning) (region-end)))))
                    (list (cond
                           ((and (stringp region-str)
                                 (equal current-prefix-arg nil))
                            region-str)
                           (t
                            (read-string "Enter URL or keywords: " region-str))))))
     (let ((eww-search-prefix ,search-prefix))
       (eww word 4))))

(define-lookup-function lookup-google "https://www.google.com/search?q=")
(define-lookup-function lookup-wikipedia-en "https://en.wikipedia.org/wiki/")
(define-lookup-function lookup-wikipedia-ja "https://ja.wikipedia.org/wiki/")
(define-lookup-function lookup-amazon "https://www.amazon.co.jp/gp/search/?field-keywords=")
(define-lookup-function lookup-melpa "https://melpa.org/#/?q=")
(define-lookup-function lookup-duckduckgo "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
(define-lookup-function lookup-eijiro "https://eow.alc.co.jp/search?q=")
(define-lookup-function lookup-weblio "https://www.weblio.jp/content/")
(define-lookup-function lookup-youtube "https://www.youtube.com/results?search_query=")

(with-eval-after-load 'hydra
  (defhydra hydra-lookup (global-map "C-c l"
                                     :color blue)
    "Lookup"
    ("g" lookup-google)
    ("G" lookup-duckduckgo "duckduckgo")
    ("w" lookup-wikipedia-ja)
    ("W" lookup-wikipedia-en)
    ("d" (lambda (&optional arg)
           (interactive "P")
           (if (equal arg '(4))
               (funcall-interactively #'dictionary-search nil)
             (dictionary-lookup-definition))))
    ("a" lookup-amazon "amazon.co.jp")
    ("m" lookup-melpa "melpa")
    ("l" lookup-weblio "weblio")
    ("y" lookup-youtube "youtube")
    ("e" my/define-word)
    ("j" lookup-eijiro)
    ("s" synosaurus-lookup "synosaurus-lookup")
    ("S" synosaurus-choose-and-replace "synosaurus-replace")
    ("q" nil "quit")))
#+end_src

***** tldr

#+begin_src emacs-lisp
(defun my/tldr (command)
  "Show the output of tldr for COMMAND in a dedicated buffer."
  (interactive (list (read-string "Coomand: ")))
  (let* ((buf-name "*TL;DR*")
         (buffer (get-buffer-create buf-name)))
    (with-current-buffer buffer
      (read-only-mode -1)
      (erase-buffer)
      (insert (shell-command-to-string (format "tldr %s"
                                               (shell-quote-argument command))))
      (ansi-color-apply-on-region (point-min) (point-max))
      (goto-char (point-min))
      (read-only-mode 1))
    (display-buffer buffer '((display-buffer-pop-up-window)
                             . ((window-height . 8))))
    (switch-to-buffer-other-window buffer)))
#+end_src

***** download media file                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-12 Sun 18:17]
:END:

#+begin_src emacs-lisp :noweb tangle
(defvar my/download-video-dir
  (file-name-concat "<<media-dir()>>" "downloads")
  "Directory where downloaded video locate.")

(defun my/download-video (url &optional filename playlistp)
  "Download video from `URL'.

With `C-u' prefix, open `my/download-video-dir' instead.
If optional argument `FILENAME' is passed, try to use this as filename.
If optional argument `PLAYLISTP' is passed, try to download all videos in playlist
instead of single video."
  (interactive (list (or current-prefix-arg
                         (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (if (equal url '(4))
      (find-file my/download-video-dir)
    (when (and (stringp url)
               (string-match "https?://www.youtube.com.+" url))
      (let* ((default-directory my/download-video-dir)
             (url-orig (match-string 0 url))
             (urlobj-orig (url-generic-parse-url url-orig))
             (pq-orig (url-path-and-query urlobj-orig))
             (yt-url
              (if (and (not playlistp)
                       (string= (car pq-orig) "/watch")
                       (assoc-string "list" (url-parse-query-string (cdr pq-orig))))
                  (url-recreate-url
                   (url-parse-make-urlobj (url-type urlobj-orig)
                                          (url-user urlobj-orig)
                                          (url-password urlobj-orig)
                                          (url-host urlobj-orig)
                                          (url-portspec urlobj-orig)
                                          (concat (car pq-orig) "?"
                                                  (url-build-query-string
                                                   (list (assoc "v" (url-parse-query-string (cdr pq-orig))))))
                                          (url-target urlobj-orig)
                                          (url-attributes urlobj-orig)
                                          (url-fullness urlobj-orig)))
                url)))
        (detached-shell-command
         (format "yt-dlp %1$s '%2$s'"
                 (mapconcat #'identity
                            (list (format "--format '%s'" (ytdl-format))
                                  (when playlistp "--yes-playlist --ignore-errors --download-archive downloaded.txt"))
                            " ")
                 yt-url))))))

(defvar my/download-audio-dir
  (file-name-concat "<<media-dir()>>" "downloads")
  "Directory where downloaded audio locate.")

(defun my/download-audio (url &optional filename)
  "Download audio from `URL'.

With `C-u' prefix, open `my/download-audio-dir' instead.
If optional argument `FILENAME' is given use this as a filename."
  (interactive (list (or current-prefix-arg
                         (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (let ((default-directory my/download-audio-dir))
    (if (equal url '(4))
        (find-file my/download-audio-dir)
      (detached-shell-command
       (if (string-match-p "https?://www.youtube.com.+" url)
           (format "yt-dlp --extract-audio %s" url)
         (concat (format "curl -LJ -o %s %s"
                         (or (and filename
                                  (format "%s.%s"
                                          (shell-quote-argument
                                           (my/file-name-legitimate filename))
                                          (file-name-extension url)))
                             (file-name-nondirectory
                              (car (url-path-and-query
                                    (url-generic-parse-url url)))))
                         url)))))))

(defun show-media-duration (url)
  "Return a duration value for media located at URL."
  (interactive (list (or (thing-at-point-url-at-point)
                         (read-string "URL: "))))
  (when-let ((duration (cond
                        ((string-match "https?://www.youtube.com.+" url)
                         (car (split-string (shell-command-to-string
                                             (format "yt-dlp --get-duration %s" url)))))
                        ((string-match "https?://.+" url)
                         (car (split-string (shell-command-to-string
                                             (format "ffmpeg -i \"%s\" 2>&1 | grep Duration | awk -F '[ ]+' '{print substr($3, 0, length($3)-1)}'" url))))))))
    (message "Duration: %s" (if (stringp duration)
                                duration "N/A"))))

(defun ytdl-format ()
  "Return appropriate format option value for youtube-dl command."
  (let* ((ipv4-addr (shell-command-to-string "hostname -I | cut -f1 -d' ' | tr -d '\n'"))
         (wifi-ssid (shell-command-to-string "iwgetid -r | tr -d '\n'"))
         (fmt-quality (cond
                       ;; using mobile Wi-Fi
                       ((string-prefix-p "192.168.179." ipv4-addr)
                        "b[filesize<20M] / w")
                       ;; using wired network or broad wifi
                       ((or (string-prefix-p "192.168.100." ipv4-addr)
                            (string-match-p (rx (or "saint_laurent_ap" "FREE_SPOT" "FREESPOT"))
                                            wifi-ssid))
                        "bv*[height<=720]+ba/b")
                       ;; using unknown network
                       (t
                        "wv*+wa/w"))))
    (format "%s" fmt-quality)))

(with-eval-after-load 'my-launch-app
  (keymap-set my/launch-app-map (kbd "d")
              #'my/download-video))
#+end_src

***** Text-to-Speech using AI (tts.el)
:PROPERTIES:
:CREATED:  [2024-06-11 Tue 14:16]
:CUSTOM_ID: emacs-package-tts
:END:

tts.el provides functions to say out given text using [[https://platform.openai.com/docs/guides/text-to-speech][the OpenAI Text to Speech service]] through its API.  The vips project is referenced when implementation.  The [[https://github.com/marcklemp/vips][vips]] project was helpful during the implementation process.

[[https://platform.openai.com/docs/guides/text-to-speech][OpenAI's text to speech API]]

#+header: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle (expand-file-name "tts.el" tangle/emacs-sitelisp-dir)
;;; tts.el --- Text to speech -*- lexical-binding: t -*-

;; Author: p-snow
;; Version: 0.0.1
;; Package-Requires: ((emacs "29.1") (request "0.3.0"))
;; Homepage: https://github.com/p-snow/tts
;; Keywords: media

;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; commentary

;;; Code:

(require 'request)

(defun tts-openai-request (api-key input action &optional voice)
  "Return audio file content from OpenAI API and save it to OUTPUT-FILE or play it.
INPUT is the text string sent to the API.
RESPONSE-FORMAT is the format of the audio file, defaults to 'mp3'.
ACTION is either 'save or 'play, determining what to do with the response."
  (let* ((auth-value (format "Bearer %s" api-key))
         (model "tts-1")
         (voice voice)
         (speed nil)
         (response-format "opus")
         (url "https://api.openai.com/v1/audio/speech")
         (data (json-encode `(("model" . ,model)
                              ("input" . ,input)
                              ("voice" . ,voice)
                              ,@(when response-format `(("response_format" . ,response-format)))
                              ,@(when speed `(("speed" . ,speed)))))))
    (request url
      :type "POST"
      :data data
      :headers `(("Authorization" . ,auth-value) ("Content-Type" . "application/json"))
      :parser 'buffer-string
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (let ((coding-system-for-write 'binary)
                        (speech-file (make-temp-file "tts-" nil ".opus")))
                    (with-temp-file speech-file
                      (insert data))
                    (apply (or action #'tts-play) (list speech-file)))))
      :error (cl-function
              (lambda (&key error-thrown &allow-other-keys)
                (message "Error: %S" error-thrown))))))

(defun tts-play (speech-file)
  ""
  (play-sound-file speech-file))

(provide 'tts)
;;; tts.el ends here
#+end_src

#+begin_src emacs-lisp :noweb tangle
(require 'transient)

(when (require 'tts nil t)
  (keymap-global-set "C-x C-\"" #'my/tts-menu)
  (with-eval-after-load 'embark
    (keymap-set embark-region-map "\"" #'my/tts-menu)))

(transient-define-prefix my/tts-menu (text)
  ""
  :value '("nova")
  [("v" "Voice" ""
    :class transient-switches
    :argument-format "%s"
    :argument-regexp "\\(alloy\\|ash\\|coral\\|echo\\|fable\\|onyx\\|nova\\|sage\\|shimmer\\)"
    :choices ("alloy" "ash" "coral" "echo" "fable" "onyx" "nova" "sage" "shimmer"))]
  [("RET" "" my/tts-suffix)]
  (interactive (list (cond
                      ((region-active-p)
                       (buffer-substring-no-properties (region-beginning) (region-end)))
                      (sentence-at-point))))
  (transient-setup 'my/tts-menu nil nil
                   :scope text))

(transient-define-suffix my/tts-suffix ()
  ""
  :transient nil
  (interactive)
  (tts-openai-request (my/credential-info "openai.com" "apikey")
                      (oref transient-current-prefix scope)
                      (lambda (file)
                        (message "SPEECH-FILE: %s" file)
                        (my/mpv-command file))
                      (seq-some (lambda (obj) (when (equal (oref obj key) "v")
                                            (oref obj value)))
                                (or transient--suffixes transient-current-suffixes))))
#+end_src

****** jsay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/jsay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly DIC="${HOME}/usr/share/hts/dic"
readonly VOICE="${HOME}/usr/share/hts/voice/mei_normal.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/jsay_XXXXXXXX.wav`

open_jtalk -x ${DIC} -m ${VOICE} -ow ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

****** esay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/esay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly VOICE="${HOME}/usr/share/hts/voice/cmu_us_arctic_slt.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/esay_XXXXXXXX.wav`

flite_hts_engine -m ${VOICE} -o ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

***** wrap up launch app commands in single keymap

#+begin_src emacs-lisp
(keymap-global-set "H-x"
                   (define-keymap
                     :prefix 'my/launch-app-map
                     "v" #'my/multi-vterm
                     "d" #'dired-jump
                     "w" #'eww
                     "W" #'eww-switch-to-buffer
                     "m" #'mu4e
                     "p" #'proced
                     "P" #'list-processes
                     "/" #'man
                     "?" #'woman))

(provide 'my-launch-app)
#+end_src

***** show the day in calendar

#+begin_src emacs-lisp
(defun my/calendar-show-items ()
  "Show items on the day pointed in calendar view."
  (interactive)
  (let* ((calendar-date-display-form calendar-iso-date-display-form)
         (date (calendar-date-string (calendar-cursor-to-date)))
         (d (parse-time-string date))
         (year (decoded-time-year d))
         (files (file-expand-wildcards (file-name-concat org-directory "archive" (format "archive_%d.org" year))))
         (buffer-name-prefix "==")
         (buffer-name (concat buffer-name-prefix date))
         (display-buffer-alist
          `((,buffer-name-prefix
             (display-buffer-reuse-mode-window
              display-buffer-pop-up-window)
             (window-height . 7)))))
    (org-ql-search files `(and (or (parent (heading ,date))
                                   (ts-a :on ,date))
                               (not (tags "web" "drill")))
                   :buffer buffer-name)
    (other-window 1)))

(with-eval-after-load 'calendar
  (bind-keys :map calendar-mode-map
             ("v" . my/calendar-show-items)))
#+end_src

***** replace regexp with re-builder and query-replace-regexp trick

Great idea using re-builder when query-replace-regexp borrowed from [[https://karthinks.com/software/bridging-islands-in-emacs-1/][this post]].

#+begin_src emacs-lisp
(defvar my/re-builder-positions nil
  "Store point and region bounds before calling re-builder")

(advice-add 're-builder
            :before
            (defun my/re-builder-save-state (&rest _)
              "Save into `my/re-builder-positions' the point and region
positions before calling `re-builder'."
              (setq my/re-builder-positions
                    (cons (point)
                          (when (region-active-p)
                            (list (region-beginning)
                                  (region-end)))))))

(defun reb-replace-regexp (&optional delimited)
  "Run `query-replace-regexp' with the contents of re-builder. With
non-nil optional argument DELIMITED, only replace matches
surrounded by word boundaries."
  (interactive "P")
  (reb-update-regexp)
  (let* ((re (reb-cook-regexp (reb-read-regexp)))
         (replacement (query-replace-read-to
                       re
                       (concat "Query replace"
                               (if current-prefix-arg
                                   (if (eq current-prefix-arg '-) " backward" " word")
                                 "")
                               " regexp"
                               (if (with-selected-window reb-target-window
                                     (region-active-p)) " in region" ""))
                       t))
         (pnt (car my/re-builder-positions))
         (beg (cadr my/re-builder-positions))
         (end (caddr my/re-builder-positions)))
    (with-selected-window reb-target-window
      (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                                        ; to control where in the buffer the replacement starts
                                        ; with re-builder
      (setq my/re-builder-positions nil)
      (reb-quit)
      (query-replace-regexp re replacement delimited beg end))))

(with-eval-after-load 're-builder
  (keymap-set reb-mode-map "RET" #'reb-replace-regexp)
  (keymap-set reb-lisp-mode-map "RET" #'reb-replace-regexp)
  (keymap-global-set "C-%" #'re-builder))
#+end_src

***** mark and open a file in one go in Dired
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 08:14]
:END:

#+begin_src emacs-lisp
(defun my/dired-mark-and-open-file ()
  "Mark file and open it in one go."
  (interactive)
  (save-excursion
    (dired-mark 1))
  (dired-open-file))

(with-eval-after-load 'dired
  (keymap-set dired-mode-map "M-RET"
              #'my/dired-mark-and-open-file))
#+end_src

***** open space
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 13:00]
:END:

Like C-o (M-x open-line), it is useful open single space ahead of point.

#+begin_src emacs-lisp
(defun my/open-space ()
  "Insert single space ahead of point."
  (interactive)
  (insert " ")
  (backward-char 1))
(keymap-global-set "M-o" 'my/open-space)
#+end_src

***** Reopening the current webpage in org format
:PROPERTIES:
:CREATED:  [2024-11-10 Sun 12:27]
:CUSTOM_ID: emacs-eww-reopen-in-org
:END:

#+begin_src emacs-lisp
(defun my/eww-reopen-in-org (&optional level)
  "Convert the current HTML page source into an org format, then open it with level LEVEL entries displayed."
  (interactive "p")
  (let ((source (plist-get eww-data :source))
        (buffer (get-buffer-create "EWW page in org"))
        (org-startup-folded t))
    (with-current-buffer buffer
      (insert source)
      (shell-command-on-region (point-min) (point-max)
                               "pandoc - -f html -t org"
                               t t)
      (org-mode)
      (org-ctrl-c-tab level))
    (switch-to-buffer buffer)))

(with-eval-after-load 'eww
  (bind-keys :map eww-mode-map
             ("O" . my/eww-reopen-in-org)))
#+end_src

***** Retrieving Credential Information
:PROPERTIES:
:CREATED:  [2024-08-21 Wed 14:18]
:END:

#+begin_src emacs-lisp
(when (require 'auth-source-pass nil t)
  (auth-source-pass-enable)
  (defun my/credential-info (host key)
    "Return API key for HOST or OpenAI."
    (or (cdr (assoc key (auth-source-pass-parse-entry host)))
        (let ((sec (plist-get (car (auth-source-search :host host)) :secret)))
          (if (functionp sec)
              (funcall sec) sec)))))
#+end_src

***** Binding Saved Kmacro under H-k
:PROPERTIES:
:CREATED:  [2024-08-22 Thu 16:44]
:CUSTOM_ID: emacs-function-insert-last-kbd-macro
:END:

Calling my/insert-last-kbd-macro after saving the desired keyboard macro will generate a set of code for persistent use.

#+begin_src emacs-lisp
(keymap-global-set "H-k"
                   (define-keymap
                     :prefix 'my/kmacro-map))
(keymap-global-set "H-j"
                   (define-keymap
                     :prefix 'my/kmacro-jump-map))

(defun my/insert-last-kbd-macro (macroname keys)
  "Customized `insert-kbd-macro' to bind last recorded kbd macro to `my/kmacro-map'.."
  (interactive (list (read-string "Macro name: ")
                     (read-string "Keys (following H-k): ")))
  (kmacro-name-last-macro (intern macroname))
  (insert-kbd-macro (intern macroname))
  (insert (format "(keymap-set %s"
                  (completing-read "Map: " '("my/kmacro-map"
                                             "my/kmacro-jump-map"))))
  (insert (format " \"%s\"" keys))
  (insert (format " #'%s)" macroname)))

(keymap-global-set "C-x C-k i" #'my/insert-last-kbd-macro)

(mapc #'load-file
      (file-expand-wildcards
       (concat (no-littering-expand-etc-file-name "kmacro")
               "/*.el")))
#+end_src

***** Highlighting task performed days
:PROPERTIES:
:CREATED:  [2024-12-22 Sun 19:50]
:END:
:LOGBOOK:
- Heading "Highlighting task performed days" from "Highlighting the days on which the task is in action." [2024-12-22 Sun 20:56]
- Heading "Highlighting the days on which the task is in action." from "Highlight calendar days" [2024-12-22 Sun 20:51]
- Heading "Highlight calendar days" from "Calendar heatmap" [2024-12-22 Sun 20:37]
:END:

[[https://sachachua.com/blog/2023/01/using-the-calendar-date-echo-text-variable-to-help-plot-a-heatmap-on-a-year-long-calendar-in-emacs/][This blog post]] inspired me to write the code that highlights the days on which tasks are performed. This is a profoundly useful feature in my review.

#+begin_src emacs-lisp
(defface my/calendar-highlight-face  '((((background light)) :foreground "black" :background "#eceff1")
                                       (((background dark))  :foreground "white" :background "#263238")) "")

(defvar my/calendar-highlight-dates nil "A list of dates to highlight.")

(defun my/calendar-highlight (month year indent)
  (when my/calendar-highlight-dates
    (dotimes (i 31)
      (let ((date (list month (1+ i) year))
            (highlighted (seq-some (lambda (date)
                                     (string-prefix-p (format "%04d-%02d-%02d" year month (1+ i))
                                                      date))
                                   my/calendar-highlight-dates)))
        (when highlighted
          (calendar-mark-visible-date
           date
           "my/calendar-highlight-face"))))))

(advice-add #'calendar-generate-month :after #'my/calendar-highlight)

(defun my/calendar-visualize (dates)
  (setq my/calendar-highlight-dates dates)
  (calendar))
#+end_src

***** Displaying EPUB cover image in Image Dired
:PROPERTIES:
:CREATED:  [2025-01-10 Fri 19:45]
:END:

It's spectacular if image-dired shows the cover image for EPUB files, as if it were a bookshelf. The following code make that happen.

#+begin_src emacs-lisp
(with-eval-after-load 'image-dired
  (cl-pushnew "epub" image-file-name-extensions)
  (advice-add #'image-dired-create-thumb-1 :around
              #'my/image-dired-create-thumb-epub))

(defun my/image-dired-create-thumb-epub (orig-fun original-file thumbnail-file)
  ""
  (let ((source-file original-file))
    (when (string-suffix-p ".epub" original-file)
      (let ((tmp-png (file-name-concat temporary-file-directory
                                       (concat (make-temp-name "epub-thumb-")
                                               ".png"))))
        (setq source-file tmp-png)
        (save-excursion
          (shell-command (format "xapp-epub-thumbnailer -i %s -o %s -s %d"
                                 (shell-quote-argument original-file)
                                 tmp-png
                                 image-dired-thumb-size)
                         messages-buffer-name))))
    (funcall orig-fun source-file thumbnail-file)))
#+end_src

***** miscellaneous functions/commands

#+begin_src emacs-lisp
(defun my/insert-time-stamp ()
  "Insert time stamp with preferred format."
  (interactive)
  (insert
   (completing-read "Format: "
                    (mapcar #'format-time-string
                            '("%Y%m%d" "%Y-%m-%d" "%Y-%m-%d %H:%M:%S")))))

(defun my/drag-line-backward ()
  "Drag up current line for one."
  (interactive)
  (transpose-lines 1)
  (previous-line 2))

(defun my/drag-line-forward ()
  "Drag down current line for one."
  (interactive)
  (next-line 1)
  (transpose-lines 1)
  (previous-line 1))

(defun my/comment-box (b e)
  "Draw a box comment around the region but arrange for the region
  to extend to at least the fill column. Place the point after the
  comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

(defun my/ascii-string-p (string)
  "Return non-nil if `STRING' seems to be made of ASCII."
  (if (length> string 0)
      (string-match-p
       (format "\\`[%s]+\\'" "[:ascii:]’“”–")
       string)
    t))

(defun my/file-name-legitimate (filename)
  "Substitute legitimate file name for `FILENAME' so as not to have any special charactors."
  (seq-reduce (lambda (takeover replace)
                (replace-regexp-in-string
                 (car replace) (cdr replace) takeover))
              '(("/" . "／")
                ("\"" . "❞")
                ("'" . "❜"))
              filename))

(defun my/kansuji-to-number (kansuuji-string)
  "Translate Japanese Kansuuji(漢数字) KANSUUJI-STRING to number."
  (let* ((kanji-digits '(?一 ?二 ?三 ?四 ?五 ?六 ?七 ?八 ?九))
         (kanji-units '((?十 . 10) (?百 . 100) (?千 . 1000)))
         (rs (cl-reduce (lambda (kansuji val)
                          (let ((digit (cl-position kansuji kanji-digits))
                                (unit (cdr (assoc kansuji kanji-units))))
                            (if (> (cdr val) 0)
                                (cons (+ (car val) (* (cdr val)
                                                      (1+ (or digit 0))))
                                      (or unit 0))
                              (cond
                               (digit (cons (+ (1+ digit) (car val)) 0))
                               (unit (cons (car val) unit))))))
                        kansuuji-string
                        :from-end t :initial-value (cons 0 0))))
    (+ (car rs) (cdr rs))))
#+end_src

**** literate configuration (this file)
:PROPERTIES:
:CREATED:  [2023-10-27 Fri 17:44]
:END:

Configuration files are generated by tangling org source blocks whenever this file is saved defined in [[file:.dir-locals.el][.dir-locals.el]]. Following code suppresses confirmation at file saving.

#+begin_src emacs-lisp
(defun my/compile-default-command ()
  "Compile `compile-command'."
  (let ((default-directory (project-root (project-current t)))
        (compilation-buffer-name-function
         (or project-compilation-buffer-name-function
             compilation-buffer-name-function)))
    (funcall #'compile compile-command))
  (quit-window))

(add-to-list 'safe-local-eval-forms
             '(add-hook 'after-save-hook
                        #'my/compile-default-command nil t))
#+end_src

***** Common Babel Config

I'd share this babel config between literate configuration and main Emacs session.

#+begin_src emacs-lisp :comments no :tangle (expand-file-name "org-babel-config.el" tangle/emacs-config-dir)
(with-eval-after-load 'ob-core
  (setq org-babel-noweb-error-all-langs t)
  (setopt org-babel-python-command (executable-find "python3"))
  (setopt org-babel-ruby-command (executable-find "ruby"))
  (setopt org-confirm-babel-evaluate nil)
  (setopt org-babel-load-languages '((shell      . t)
                                     (emacs-lisp . t)
                                     (python     . t)
                                     (ruby       . t)))
  (setf org-babel-default-header-args
        (append org-babel-default-header-args
                '((:mkdirp . t)
                  (:comments . "link")))))

(with-eval-after-load 'ob-shell
  (add-to-list 'org-babel-default-header-args:shell
               '(:shebang . "#!/bin/sh"))
  (add-to-list 'org-babel-default-header-args:shell
               `(:tangle-mode . ,(identity #o755)))
  (add-to-list 'org-babel-default-header-args:bash
               `(:tangle-mode . ,(identity #o755)))
  (add-to-list 'org-babel-default-header-args:bash
               '(:shebang . "#!/usr/bin/env bash\nset -euo pipefail\n")))

(with-eval-after-load 'ob-emacs-lisp
  (add-to-list 'org-babel-default-header-args:emacs-lisp
               `(:tangle-mode . ,(identity #o444))))

(with-eval-after-load 'ob-python
  (mapc (lambda (header-arg)
          (add-to-list 'org-babel-default-header-args:python
                       header-arg))
        `((:tangle-mode . ,(identity #o755))
          (:shebang . "#!/usr/bin/env python3"))))

(with-eval-after-load 'ob-ruby
  (mapc (lambda (header-arg)
          (add-to-list 'org-babel-default-header-args:ruby
                       header-arg))
        `((:tangle-mode . ,(identity #o755))
          (:shebang . "#!/usr/bin/env ruby"))))
#+end_src

**** custom RX definitions
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 11:25]
:END:

My RX function 'parened' evaluates 'parened-rx' with reb-target-buffer's syntax table since  working buffer with RX in re-builder is reb-lisp-mode which does not hold same syntax table with target-buffer.

#+begin_src emacs-lisp
(defun parened-rx (paren-open-char element)
  `(seq ,paren-open-char
        (group ,element)
        ,(matching-paren paren-open-char)))

(rx-define parened (paren-open-char element)
  (eval (with-syntax-table (cond
                            ((derived-mode-p 'reb-lisp-mode)
                             (with-current-buffer reb-target-buffer (syntax-table)))
                            ((derived-mode-p 'minibuffer-mode)
                             (with-current-buffer (other-buffer nil t) (syntax-table)))
                            (t (syntax-table)))
          (parened-rx paren-open-char 'element))))
#+end_src

**** My Transient Shell Command (my/tsc)
:PROPERTIES:
:CREATED:  [2024-01-15 Mon 20:15]
:ID:       cd86fe03-b295-4cde-8b7c-68d5705b843a
:END:

#+name: my/tsc
#+begin_src emacs-lisp
(require 'transient)
(require 'detached)

(defvar my/tsc-shell-command-buffer "*Shell Command*")
(defvar my/tsc-execute-function 'detached-shell-command)

(defclass my/tsc-shell-command (transient-suffix)
  ((command-format :initarg :command-format :initform "%a")
   (command-format-spec :initarg :command-format-spec :initform nil)
   (suppress-output :initarg :suppress-output :initform nil)))

(cl-defmethod transient-init-value ((obj my/tsc-shell-command))
  (unless (slot-boundp obj :command-format)
    (oset obj command-format "%a")))

(defvar my/tsc-optional-menu
  ["Optional"
   (my/tsc-kill)
   (my/tsc-insert)])

(transient-define-suffix my/tsc-kill ()
  ""
  :key "M-w" :description "Copy the command to kill-ring"
  :transient t
  (interactive)
  (let ((command (my/tsc-build-shell-command)))
    (kill-new command)
    (message "Copied: %s" command)))

(transient-define-suffix my/tsc-insert ()
  ""
  :key "M-i" :description "Insert the command"
  :transient t
  (interactive)
  (let ((command (my/tsc-build-shell-command)))
    (and (length> command 0)
         (with-current-buffer (get-buffer-create my/tsc-shell-command-buffer)
           (switch-to-buffer (current-buffer))
           (sh-mode)
           (insert command ";\n")))))

(transient-define-suffix my/tsc-execute (args)
  :class my/tsc-shell-command
  :key "RET" :description "Execute"
  (interactive (list (transient-args transient-current-command)))
  (let ((my/detached-bury-buffer (oref (transient-suffix-object) suppress-output)))
    (funcall my/tsc-execute-function (my/tsc-build-shell-command))))

(defun my/tsc-build-shell-command ()
  ""
  (let* ((obj (my/tsc-suffix "RET"))
         (command-format-spec (and (slot-boundp obj :command-format-spec)
                                   (oref obj command-format-spec))))
    (format-spec
     (replace-regexp-in-string
      "\\\\\%" "\\\\\%\%"               ; avoid replacing "\%" in shell argument
      (eval (oref obj command-format)))
     (append
      `((?a . ,(string-join (flatten-list
                             (seq-reduce (lambda (li char) (delete char li))
                                         '("M-w" "M-i")
                                         (transient-get-value)))
                            " ")))
      (when command-format-spec
        (mapcar (lambda (key-val) (cons (car key-val) (eval (cdr key-val))))
                command-format-spec))))))

(defun my/tsc-suffix (key)
  ""
  (seq-find (lambda (obj) (equal (oref obj key) key))
            (or transient--suffixes transient-current-suffixes)))

(defun my/tsc-infix-values (keys)
  (mapconcat
   ;; TODO: 'transient--get-wrapped-value may suit better
   'transient-infix-value
   (delq nil (mapcar #'my/tsc-suffix keys))
   " "))

(defmacro my/tsc-determine-file (&optional multi)
  ""
  `(pcase (cond
           ((derived-mode-p 'dired-mode)
            (dired-get-marked-files))
           (t (ffap-file-at-point)))
     ((and (pred listp) li)
      (funcall (if ,multi #'identity #'car) li))
     ((and (pred stringp) str) (if ,multi `(,str) str))
     ((pred null)
      (let ((user-input (read-file-name "File: ")))
        (if ,multi `(,user-input) user-input)))))

(defmacro my/tsc-determine-url ()
  "Determine the URL for dispatch-dwim commands, respecting the conditions."
  '(let ((url-alike (cond
                     ((thing-at-point-url-at-point))
                     ((derived-mode-p 'org-mode)
                      (org-link-at-point-map #'car))
                     ((derived-mode-p 'eww-mode)
                      (or (shr-url-at-point nil)
                          (plist-get eww-data :url))))))
     (if (and url-alike
              (string-match "\\(httpss?://[[:graph:]]+\\)" url-alike))
         (match-string 1 url-alike)
       (read-string "URL: "))))

;; Readers

(defun my/tsc-read-shell-command (&optional prompt default-time history)
  ""
  (completing-read (or prompt
                       "Shell command: ")
                   (split-string
                    (shell-command-to-string "compgen -c") "\n")))

(defun my/tsc-read-time (prompt default-time history)
  "Read time using date command."
  (or (seq-some (lambda (d)
                  (let* ((time-str (string-trim
                                    (shell-command-to-string
                                     (format "date +'%%Y-%%m-%%d %%H:%%M' -d '%s'"
                                             (my/expand-shorthand-time d)))))
                         (time-ts (or (and (string-prefix-p "date: invalid date"
                                                            time-str)
                                           (message "Invalid time"))
                                      (encode-time (parse-time-string time-str)))))
                    ;; Ask the user if the specified time is designated as either past or beyond 12 hours
                    (if (and (or (time-less-p time-ts (current-time))
                                 (time-less-p (time-add nil (seconds-to-time (* 12 60 60)))
                                              time-ts))
                             (not (y-or-n-p (format "Is %s right?: " time-str))))
                        (car (symbol-value history))
                      (format "'%s'" time-str))))
                (delq nil (list (and prompt (read-string prompt)) default-time)))
      ""))

(defun my/tsc-output-reader (&optional prompt initial-input history)
  ""
  (let* ((infile-key-obj (my/tsc-suffix (plist-get (oref transient--prefix scope) :infile-key)))
         (infile (or (when infile-key-obj
                       (oref infile-key-obj value))
                     (plist-get (oref transient--prefix scope) :infile-orig))))
    (string-trim
     (if infile
         (shell-command-to-string
          (format "f=\"%s\"; echo \"%s\""
                  (file-name-nondirectory infile)
                  (or initial-input
                      (read-string "Output ($f is input in Bash): "
                                   "${f%.*}"))))
       (read-string (or prompt "Output file: "))))))

;;; Classes

(defclass my/tsc-file (transient-option)
  ((absolute  :initarg :absolute :initform nil))
  "")

(cl-defmethod transient-infix-value ((obj my/tsc-file))
  ""
  (and-let* ((value (oref obj value)))
    (let ((arg (oref obj argument)))
      (cl-labels ((rel (f) (if (oref obj absolute)
                               f (file-relative-name f default-directory))))
        (pcase-exhaustive (oref obj multi-value)
          ('nil          (concat arg (shell-quote-argument (rel value))))
          ((or 't 'rest) (cons arg (mapconcat 'shell-quote-argument (mapcar #'rel value) " ")))
          ;; FIXME: this may fail
          ('repeat       (mapcar (lambda (v) (concat arg (shell-quote-argument v))) (mapcar #'rel value))))))))

(cl-defmethod transient-format-value ((obj my/tsc-file))
  (let ((argument (oref obj argument)))
    (if-let ((value (oref obj value)))
        (cl-labels ((rel (f) (if (oref obj absolute)
                                 f (file-relative-name f default-directory))))
          (pcase-exhaustive (oref obj multi-value)
            ('nil
             (concat (propertize argument    'face 'transient-argument)
                     (propertize (rel value) 'face 'transient-value)))
            ((or 't 'rest)
             (concat (propertize (if (string-suffix-p " " argument)
                                     argument
                                   (concat argument " "))
                                 'face 'transient-argument)
                     (propertize (mapconcat #'prin1-to-string
                                            (mapcar #'rel value) " ")
                                 'face 'transient-value)))
            ('repeat
             (mapconcat (lambda (value)
                          (concat (propertize argument    'face 'transient-argument)
                                  (propertize (rel value) 'face 'transient-value)))
                        value " "))))
      (propertize argument 'face 'transient-inactive-argument))))

(defclass my/tsc-literal-option (transient-option) ())

(cl-defmethod transient-infix-value ((obj my/tsc-literal-option))
  ""
  (and-let* ((value (oref obj value)))
    (let ((arg (oref obj argument)))
      (pcase-exhaustive (oref obj multi-value)
        ('nil          (concat arg (format "'%s'" value)))
        ((or 't 'rest) (cons arg (mapcar (lambda (v) (concat arg (format "'%s'" v))) value)))
        ('repeat       (mapcar (lambda (v) (concat arg (format "'%s'" v))) value))))))

;;; Misc

(defalias 'my/tsc-execute-macro (kmacro "RET"))
(defalias 'my/tsc-cancel-macro (kmacro "C-g"))
(defalias 'my/tsc-kill-macro (kmacro "M-w"))
(defalias 'my/tsc-insert-macro (kmacro "M-i"))
#+end_src

***** mpv command
:PROPERTIES:
:CREATED:  [2024-01-15 Mon 20:17]
:END:

#+begin_src emacs-lisp
(transient-define-prefix my/mpv-command (file &rest args)
  ""
  :man-page "mpv"
  :value '("--volume=100")
  ["Options"
   ("-R" "noresume" "--no-resume-playback"
    :init-value (lambda (obj) (oset obj value (if (plist-get args :no-resume) "--no-resume-playback" nil))))
   ("-s" "Start" "--start=" :prompt "Start at (relative time): "
    :init-value (lambda (obj) (oset obj value (plist-get args :start))))
   ("-e" "End" "--end=" :prompt "End at: "
    :init-value (lambda (obj) (oset obj value (plist-get args :end))))
   ("-ps" "Playlist start" "--playlist-start=" :prompt "Start at (in playlist): "
    :init-value (lambda (obj) (oset obj value (plist-get args :playlist-start))))
   ("p" "pause" "" :class transient-switches
    :argument-format "%s" :argument-regexp "\\(--pause\\|--no-pause\\)"
    :choices ("--pause" "--no-pause"))
   ("-v" "volume" "--volume=" :prompt "Volume: ")]
  ["Inputs"
   ("f" "files" "-- "
    :class my/tsc-file
    :multi-value rest
    :init-value (lambda (obj) (oset obj value (ensure-list file))))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :suppress-output t
    :command-format "mpv %a")]
  (interactive `(,(my/tsc-determine-file t)))
  (transient-setup 'my/mpv-command))

(with-eval-after-load 'embark
  (mapc (lambda (map)
          (lambda-key map "P"
                      (lambda (file)
                        "play media FILE"
                        (my/mpv-command file t))))
        (list embark-file-map embark-url-map))
  (with-eval-after-load 'org
    (defun my/flink-path (flink)
      (let* ((exp-link (org-link-expand-abbrev flink)))
        (string-trim-right
         (string-trim-left exp-link "file:")
         "::.+$")))
    (mapc (lambda (map)
            (lambda-key map "P"
                        (lambda (link)
                          "play media file written in org LINK"
                          (my/mpv-command (my/flink-path link) t))))
          (list embark-org-link-map))
    (mapc
     (lambda (map)
       (lambda-key map "P"
                   (lambda (list)
                     "play media in LIST"
                     (my/mpv-command (mapcar (lambda (item)
                                               (when (string-match org-link-any-re (car item))
                                                 (my/flink-path (match-string-no-properties 2 (car item)))))
                                             (cdr (org-list-to-lisp list)))
                                     t))))
     (list embark-org-plain-list-map))))
#+end_src

***** ffmpeg-libopus command
:PROPERTIES:
:CREATED:  [2023-11-12 Sun 22:00]
:END:

#+begin_src emacs-lisp
(defvar my/ffmpeg-audio-menu
  ["Audio"
   ("a" "audio codec" "-c:a "
    :class transient-switches
    :argument-format "-c:a %s"
    :argument-regexp "\\(-c:a \\(libopus\\|copy\\)\\)"
    :choices ("libopus" "copy"))
   ("-B" "audio bitrate (e.g. 64k)" "-b:a " :prompt "Audio bitrate: " :class transient-option)])

(transient-define-prefix my/ffmpeg-libopus-command (file)
  ""
  :man-page "ffmpeg-codecs"
  :value '("-c:a libopus")
  my/ffmpeg-audio-menu
  ["Infile"
   ("-i" "input" "-i "
    :class my/tsc-file
    :prompt "Input file: "
    :always-read t
    :init-value (lambda (obj) (oset obj value file)))]
  ["Filters"
   ("-t" "tempo (e.g. 1.5)" "-filter:a atempo="
    :prompt "tempo (floating number): ")]
  ["Outfile"
   ("o" "output" "-- "
    :class my/tsc-file
    :reader my/tsc-output-reader
    :always-read t
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}.opus"))))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "ffmpeg %i -map_metadata 0 %O %o"
    :command-format-spec ((?i . (my/tsc-infix-values '("-i")))
                          (?O . (my/tsc-infix-values '("a" "-B" "-t")))
                          (?o . (my/tsc-infix-values '("o")))))]
  (interactive (list (my/tsc-determine-file nil)))
  (transient-setup 'my/ffmpeg-libopus-command nil nil
                   :scope (cdr `(_ :infile-key "-i"
                                   :infile-orig ,file))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map
              "t a" 'my/ffmpeg-libopus-command))
#+end_src

***** ffmpeg-libvp9 command
:PROPERTIES:
:CREATED:  [2024-02-10 Sat 10:52]
:ID:       6201d879-2237-45a0-a1c3-eb527ec0b701
:CUSTOM_ID: emacs-vp9-command
:END:

#+begin_src emacs-lisp
(transient-define-prefix my/ffmpeg-libvp9-command (file)
  ""
  :man-page "ffmpeg-codecs"
  :value '("-crf 28")
  ["Infile"
   ("-i" "input" "-i "
    :class my/tsc-file
    :prompt "Input file: "
    :always-read t
    :reader transient-read-file
    :init-value (lambda (obj) (oset obj value file)))]
  ["Outfile options"
   ["Video"
    ("-c" "crf" "-crf " :prompt "CRF: " :class transient-option)]
   my/ffmpeg-audio-menu]
  ["Outfile"
   ("o" "output" ""
    :class my/tsc-file
    :reader my/tsc-output-reader
    :always-read t
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}_vp9.mkv"))))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    (concat "ffmpeg %i %O %o /dev/null && ffmpeg %i"
            "-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0"
            "-pass 1 -an -f null"
            "-pass 2 -map_metadata 0"
            "-ac 2 %O %o")
    :command-format-spec ((?i . (my/tsc-infix-values '("-i")))
                          (?O . (my/tsc-infix-values '("-c" "a" "-B")))
                          (?o . (my/tsc-infix-values '("o")))))]
  (interactive (list (my/tsc-determine-file nil)))
  (transient-setup 'my/ffmpeg-libvp9-command nil nil
                   :scope (cdr `(_ :infile-key "-i" :infile-orig ,file))))
#+end_src

***** ffmpeg-libsvtav1 command
:PROPERTIES:
:CREATED:  [2024-12-04 Wed 17:38]
:CUSTOM_ID: emacs-svtav1-command
:ID:       1319a611-4ba5-4afc-9312-fec1a6c0ac04
:END:

- [[lfile:SVT-AV1/Docs/Ffmpeg][SVTAV1 Doc for FFmpeg]]

#+begin_src emacs-lisp
(transient-define-prefix my/ffmpeg-libsvtav1-command (file)
  ""
  :man-page "ffmpeg-codecs"
  :value '("-crf 35" "-preset 4" "-c:a libopus")
  ["Infile"
   ("-i" "input" "-i "
    :class my/tsc-file
    :prompt "Input file: "
    :always-read t
    :reader transient-read-file
    :init-value (lambda (obj) (oset obj value file)))]
  ["Outfile options"
   ["Video"
    ("-c" "crf" "-crf " :prompt "CRF(1-63) " :class transient-option)
    ("-p" "preset" "-preset " :prompt "preset(0-13): " :class transient-option)
    ("-S" "startingd position" "-ss "
     :class transient-option :prompt "Position: ")
    ("-T" "stopping position" "-to "
     :class transient-option :prompt "Position: ")]
   my/ffmpeg-audio-menu]
  ["Outfile"
   ("o" "output" "-- "
    :class my/tsc-file
    :reader my/tsc-output-reader
    :always-read t
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}_av1.mkv"))))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "ffmpeg %i -c:v libsvtav1 -map_metadata 0 %O %o"
    :command-format-spec ((?i . (my/tsc-infix-values '("-i")))
                          (?O . (my/tsc-infix-values '("-c" "-p" "a" "-B" "-S" "-T")))
                          (?o . (my/tsc-infix-values '("o")))))]
  (interactive (list (my/tsc-determine-file nil)))
  (transient-setup 'my/ffmpeg-libsvtav1-command nil nil
                   :scope (cdr `(_ :infile-key "-i" :infile-orig ,file))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map
              "t v" 'my/ffmpeg-libsvtav1-command))
#+end_src

***** handbrake command
:PROPERTIES:
:ID:       17a2939e-a563-4e46-8ba2-10cf14d71efe
:END:

- [[https://handbrake.fr/docs/en/latest/workflow/adjust-quality.html][HandBrake Documentation — Adjusting quality]]

#+begin_src emacs-lisp
(transient-define-prefix my/handbrakecli-command (file)
  ""
  :man-page "HandBrakeCLI"
  :value '("--markers" "--main-feature" "--all-subtitles"
           "--encoder x264" "--encoder-preset medium" "--quality 16.0"
           "--all-audio" "--aencoder copy")
  ["Source Options"
   ("-i" "device" ("-i " "--input ")
    :class my/tsc-file
    :prompt "Input device: "
    :reader transient-read-file
    :always-read t
    :init-value (lambda (obj) (oset obj value file)))
   ("-t" "Titles" "--title "
    :class transient-option :prompt "Titles (0 to scan): ")
   ("-F" "Main feature title" "--main-feature")]
  ["Destination Options"
   ("-o" "Destination file name" ("-o " "--output ")
    :class my/tsc-file
    :reader my/tsc-output-reader
    :always-read t
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}.mp4"))))
   ("-m" "Add chapter markers" ("-m" "--markers"))]
  ["Video Options"
   ("e" "Encoder" ""
    :class transient-switches
    :argument-format "--encoder %s"
    :argument-regexp "\\(--encoder \\(VP8\\|VP9\\|x264\\|x265\\|svt_av1\\)\\)"
    :choices ("VP8" "VP9" "x264" "x265" "svt_av1"))
   ("p" "Preset" ""
    :class transient-switches
    :argument-format "--encoder-preset %s"
    :argument-regexp "\\(--encoder-preset \\(.+\\)\\)"
    :choices ("veryfast" "faster" "fast" "medium" "slow" "slower" "veryslow"))
   ("-q" "Quality" "--quality "
    :class transient-option :prompt "Quality value (float): ")
   ("-b" "Bitrate" ("-b" "--vb ")
    :class transient-option :prompt "Bitrate (in kbps): ")]
  ["Audio Options"
   ("T" "Track" ""
    :class transient-switches
    :argument-format "--%s"
    :argument-regexp "\\(--\\(all-audio\\|first-audio\\)\\)"
    :choices ("all-audio" "first-audio"))
   ("E" "Encoder" ""
    :class transient-switches
    :argument-format "--aencoder %s"
    :argument-regexp "\\(--aencoder \\(opus\\|copy\\)\\)"
    :choices ("opus" "copy"))
   ("-B" "Bitrate" ("-B" "--ab ")
    :class transient-option :prompt "Bitrate (in kbps): ")]
  ["Subtitle Options"
   ("-S" "Subtitle" ""
    :class transient-switches
    :argument-format "--%s"
    :argument-regexp "\\(--\\(all-subtitles\\|first-subtitles\\)\\)"
    :choices ("all-subtitles" "first-subtitles"))]
  [my/tsc-optional-menu
   [(my/tsc-execute
     :command-format "/usr/bin/HandBrakeCLI %a")]]
  (interactive `(,(my/tsc-determine-file)))
  (transient-setup 'my/handbrakecli-command nil nil
                   :scope (cdr `(_ :infile-key "-i" :infile-orig ,file))))
#+end_src

***** dvdbackup command
:PROPERTIES:
:ID:       18821c25-ddf0-424a-9f72-f76ab6022ba5
:END:

#+begin_src emacs-lisp
(transient-define-prefix my/dvdbackup-command ()
  ""
  :man-page "dvdbackup"
  :value '("--input=/dev/sr0" "--output=dvd-out" "--mirror")
  [("-i" "Input device" "--input="
    :class my/tsc-file
    :prompt "Device file: "
    :reader transient-read-existing-file)
   ("-o" "Output directory" "--output="
    :class my/tsc-file
    :prompt "Output directory: "
    :reader transient-read-file)
   ("a" "Action" ""
    :class transient-switches
    :always-read t
    :argument-format "%s"
    :argument-regexp "\\(--mirror\\|--feature\\|--info\\)"
    :choices ("--mirror" "--feature" "--info"))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "dvdbackup %a")]
  (interactive)
  (transient-setup 'my/dvdbackup-command))
#+end_src

***** gm-convert command
:PROPERTIES:
:CREATED:  [2025-01-10 Fri 21:39]
:END:

#+name: gm-convert-command
#+begin_src emacs-lisp
(transient-define-prefix my/gm-convert-command (file)
  ""
  :man-page "gm"
  :value '("-quality 100")
  ["Options"
   ("-g" "geometry" "-geometry "
    :class transient-option
    :prompt "Geometry (e.g. 640x480, 640x): ")
   ("-q" "quality" "-quality "
    :class transient-option
    :reader transient-read-number-N0
    :prompt "Quality (0-100): ")]
  ["Input"
   ("i" "input file" ""
    :class my/tsc-file
    :prompt "Input file: "
    :reader transient-read-file
    :always-read t
    :init-value (lambda (obj) (oset obj value file)))]
  ["Output"
   ("o" "output" ""
    :class my/tsc-file
    :prompt "Output file: "
    :reader my/tsc-output-reader
    :always-read t
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}.jpg" nil))))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format "gm convert %a")]
  (interactive `(,(my/tsc-determine-file)))
  (transient-setup 'my/gm-convert-command nil nil
                   :scope (cdr `(_ :infile-key "i" :infile-orig ,file))))
#+end_src

***** good-night command (rtcwake)
:PROPERTIES:
:CREATED:  [2024-01-24 Wed 13:07]
:END:

#+NAME: good-night-command
#+begin_src emacs-lisp
(transient-define-suffix my/good-night-next (args)
  :class my/tsc-shell-command
  :key "RET" :description "Next"
  (interactive (list (transient-args transient-current-command)))
  (let* ((command (my/tsc-build-shell-command)))
    (and (length> command 0)
         (with-current-buffer (get-buffer-create my/tsc-shell-command-buffer)
           (sh-mode)
           (insert command ";\n")
           (switch-to-buffer (current-buffer))))))

(transient-define-prefix my/sleep-command (&optional number)
  ""
  :man-page "sleep"
  :value '("20m")
  [("t" "amount of time" "" :prompt "Number[SUFFIX(s/m/h/d)]: "
    :class transient-option :always-read t :allow-empty nil)]
  [(my/good-night-next
    :command-format "sleep %a")]
  (interactive)
  (transient-setup 'my/sleep-command))

(transient-define-prefix my/arbitrary-shell-command (command)
  ""
  [("c" "shell command" ""
    :class transient-option
    :init-value (lambda (obj) (oset obj value command))
    :prompt "Shell command: "
    :reader my/tsc-read-shell-command)
   ("o" "option strings" ""
    :class transient-option)]
  [(my/good-night-next
    :command-format "%a")]
  (interactive (list (my/tsc-read-shell-command)))
  (transient-setup 'my/arbitrary-shell-command))

(transient-define-prefix my/rtcwake-command (&optional number)
  ""
  :man-page "rtcwake"
  [("t" "wake-up time" "--date " :prompt "Wake-up time: " :class transient-option
    :init-value (lambda (obj) (oset obj value (my/tsc-read-time nil "+6h40m" nil)))
    :allow-empty nil :reader my/tsc-read-time :always-read t)]
  [(my/good-night-next
    :command-format "pwsudo rtcwake -m mem %a")]
  (interactive)
  (transient-setup 'my/rtcwake-command))

(defun my/good-night-command ()
  ""
  (interactive)
  (setq my/good-night-loop-count 0)
  (my/sleep-command "30m")
  (add-hook 'transient-exit-hook
            'my/transient-next))

(defvar my/good-night-loop-count 0)

(defun my/transient-next ()
  ""
  (pcase my/good-night-loop-count
    (0 (my/arbitrary-shell-command "midnight.sh"))
    (1 (my/rtcwake-command))
    (2 (my/arbitrary-shell-command "morning.sh"))
    (3 (remove-hook 'transient-exit-hook 'my/transient-next)))
  (setq my/good-night-loop-count
        (if (< my/good-night-loop-count 3)
            (1+ my/good-night-loop-count)
          0)))
#+end_src

***** pandoc command
:PROPERTIES:
:CREATED:  [2024-01-22 Mon 14:23]
:CUSTOM_ID: emacs-pandoc-command
:END:

#+name: pandoc-command
#+begin_src emacs-lisp
(transient-define-prefix my/pandoc-command (file)
  ""
  :man-page "pandoc"
  :value '("--to=org")
  ["Options"
   ("-t" "Ootput format" "--to="
    :class my/pandoc-format
    :always-read t
    :choices ("org" "pdf" "epub" "rst" "texinfo" "odt" "docx" "markdown" "asciidoc" "plain"))
   ("-o" "output file" "--output="
    :class my/tsc-file
    :reader my/tsc-output-reader
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}_pandoc.org" nil))))]
  ["Inputs"
   ("f" "file" "-- "
    :class my/tsc-file
    :prompt "Input file: "
    :reader transient-read-file
    :always-read t
    :init-value (lambda (obj) (oset obj value file)))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format "pandoc %a")]
  (interactive `(,(my/tsc-determine-file)))
  (transient-setup 'my/pandoc-command nil nil
                   :scope (cdr `(_ :infile-key "f" :infile-orig ,file))))

(defclass my/pandoc-format (transient-option) ())

(cl-defmethod transient-infix-value ((obj my/pandoc-format))
  ""
  (append (list (concat (oref obj argument) (oref obj value)))
          ;; PDF conversion requires an engine specified
          (and (equal (oref obj value) "pdf")
               (cons "--pdf-engine" "weasyprint"))))
#+end_src

***** yt-dlp command
:PROPERTIES:
:CREATED:  [2024-01-27 Sat 18:25]
:CUSTOM_ID: emacs-yt-dlp-command
:END:

#+name: yt-dlp-command
#+begin_src emacs-lisp :noweb tangle
(transient-define-prefix my/yt-dlp-command (url &optional output duration-p play-p)
  ""
  :man-page "yt-dlp"
  :value '("--paths <<media-dir()>>" "--prefer-free-formats"
           "--format bestvideo*+bestaudio/best"
           "--format-sort codec,ext,size:1.5G")
  ["Options"
   ("-P" "download path" "--paths "
    :class transient-option
    :reader transient-read-existing-directory)
   ("-a" "audio" "-x --embed-thumbnail")
   ("-F" "free format" "--prefer-free-formats")
   ("-d" "duration" "--get-duration --no-warnings"
    :init-value (lambda (obj) (oset obj value (and duration-p "--get-duration --no-warnings"))))
   ("-f" "format" "--format "
    :class my/tsc-literal-option)
   ("-S" "format sort" "--format-sort "
    :class my/tsc-literal-option)
   ("-o" "output" "--output "
    :class my/yt-dlp-output)]
  ["Inputs"
   ("u" "url" ""
    :class my/tsc-literal-option
    :prompt "Contents URL: "
    :init-value (lambda (obj) (oset obj value url)))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :suppress-output t
    :command-format
    "yt-dlp --embed-chapters --live-from-start %a")]
  (interactive `(,(my/tsc-determine-url)))
  (setq my/detached-bury-buffer t)
  (transient-setup 'my/yt-dlp-command))

(defclass my/yt-dlp-output (transient-option) ())

(cl-defmethod transient-infix-value ((obj my/yt-dlp-output))
  ""
  (when-let ((value (oref obj value)))
    (cons (oref obj argument)
          (shell-quote-argument
           (my/file-name-legitimate
            (format "%s.%%\(ext\)s" value))))))

(with-eval-after-load 'embark
  (mapc (lambda (map)
          (lambda-key map "Y"
                      (lambda (thing)
                        "download media file"
                        (let ((url (pcase thing
                                     ((and (pred (lambda (s) (string-match org-link-any-re s))) ol)
                                      (or (match-string-no-properties 0 ol)
                                          (match-string-no-properties 2 ol)))
                                     ((and (pred (lambda (s) (string-match ffap-url-at-point s))) u)
                                      (match-string-no-properties 0 u)))))
                          (my/yt-dlp-command url)
                          (my/tsc-execute-macro)))))
        (list embark-kill-ring-map embark-url-map
              embark-org-link-map)))
#+end_src

***** du command
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 11:13]
:END:

#+begin_src emacs-lisp
(transient-define-prefix my/du-command (file)
  "du command."
  :man-page "du"
  :value '("--summarize" "--total" "--dereference-args" "--human-readable")
  ["Options"
   ("-s" "summarize" "--summarize")
   ("-c" "add total" "--total")
   ("-D" "deref symlinks" "--dereference-args")
   ("-h" "human readable" "--human-readable")]
  ["Inputs"
   ("f" "FILE" "-- "
    :class my/tsc-file
    :multi-value t
    :init-value (lambda (obj) (oset obj value file)))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "ionice -c2 -n7 nice -n19 du %a")]
  (interactive `(,(my/tsc-determine-file t)))
  (transient-setup 'my/du-command))
#+end_src

***** zip command
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 11:13]
:END:

#+name: zip-command
#+begin_src emacs-lisp
(transient-define-prefix my/zip-command (file)
  "zip command."
  :man-page "zip"
  ["Options"
   ("-P" "password" "--password "
    :class transient-option
    :prompt "Password: ")]
  ["Output"
   ("z" "output zipfile" ""
    :class my/tsc-file
    :reader my/tsc-output-reader
    :init-value (lambda (obj) (oset obj value (my/tsc-output-reader nil "${f%.*}.zip" nil))))]
  ["Inputs"
   ("f" "file" "--"
    :class my/tsc-file
    :multi-value rest
    :init-value (lambda (obj) (oset obj value file)))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "zip -r %a")]
  (interactive `(,(my/tsc-determine-file t)))
  (transient-setup 'my/zip-command nil nil
                   :scope (cdr `(_ :infile-orig ,(car file)))))
#+end_src

***** ghq-get command

#+begin_src emacs-lisp
(transient-define-prefix my/ghq-get-command (url)
  "Dispatch ghq get command."
  :man-page "ghq get"
  :value '("--shallow")
  ["Options"
   ("-s" "shallow clone" "--shallow")]
  ["Inputs"
   ("r" "repository url" ""
    :class transient-option
    :init-value (lambda (obj) (oset obj value url)))]
  my/tsc-optional-menu
  [(my/tsc-execute
    :command-format
    "ghq get %a")]
  (interactive `(,(my/tsc-determine-url)))
  (transient-setup 'my/ghq-get-command))
#+end_src

**** TempEL templates for major modes
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:02]
:header-args:emacs-lisp: :eval no
:END:

#+NAME: elisp-region-text
#+begin_src emacs-lisp
(defun my/region-string-trans-buffer ()
  "Return region string in some buffer where region is active."
  (cl-some (lambda (buf)
             (with-current-buffer buf
               (when (region-active-p)
                 (buffer-substring-no-properties (region-beginning)
                                                 (region-end)))))
           (list (current-buffer) (other-buffer nil t))))
#+end_src

***** fundamental-mode templates
:PROPERTIES:
:CREATED:  [2024-02-04 Sun 11:56]
:END:

#+header: :shebang "fundamental-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/fundamental.eld" tangle/emacs-etc-dir)
(timestamp (my/insert-time-stamp))
#+end_src

***** text-mode templates
:PROPERTIES:
:CREATED:  [2023-11-09 Thu 14:33]
:END:

#+header: :shebang "text-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/text.eld" tangle/emacs-etc-dir)
(gma "update on " (my/insert-time-stamp))
#+end_src

***** org-mode templates
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:02]
:END:

#+header: :shebang "org-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/org.eld" tangle/emacs-etc-dir)
(call & "#+CALL: " (p "name" name) "(" (s var) "=\"" (s value) "\")")
(name & "#+NAME: " (p "name" name))
(/ "[/]" (org-update-statistics-cookies nil))
(tsm p " :: " (with-temp-buffer (org-insert-time-stamp (current-time) t t)))

<<org-template>>
#+end_src

***** minibuffer-mode templates
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 20:18]
:END:

#+header: :shebang "minibuffer-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/minibuffer.eld" tangle/emacs-etc-dir)
<<minibuffer-mode-template>>

(version (p "command") " --version")
(curly-bracket-japanese-regexp
 (rx (parened ?｛ (+ (or " "
                         (category japanese-hiragana-two-byte)))))))
#+end_src

***** eshell-mode templates
:PROPERTIES:
:CREATED:  [2024-11-16 Sat 16:07]
:END:

#+header: :shebang "eshell-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/eshell.eld" tangle/emacs-etc-dir)
<<eshell-mode-template>>
#+end_src

***** emacs-lisp-mode templates
:PROPERTIES:
:CREATED:  [2023-11-15 Wed 12:26]
:END:

#+header: :shebang "emacs-lisp-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/emacs-lisp.eld" tangle/emacs-etc-dir)
<<emacs-lisp-mode-template>>

(require "(require '" (p "feature") ")")
(lambda "(lambda () " n>
  (p "docstring: " doc-str t)
  (when (length> doc-str 0)
    (format "\"%s\"\n" doc-str))
  > p ")")
(interactive "(interactive"
             (p "code: " code t)
             (when (length> code 0)
               (format " \"%s\"" code))
             ")")
(bind-keys "(bind-keys " (p (format ":map "))
           "(\"" p "\" . " p "))")
#+end_src

***** sh-base-mode templates
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 19:23]
:END:

#+header: :shebang "sh-base-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/sh-base.eld" tangle/emacs-etc-dir)
(rf "${" p "}")
(function "function " (p "name") " {" n> p n "}")
#+end_src

***** mu4e-compose-mode templates
:PROPERTIES:
:CREATED:  [2023-12-04 Mon 19:52]
:END:

#+header: :shebang "mu4e-compose-mode"
#+begin_src emacs-lisp :noweb yes :tangle (expand-file-name "tempel/templates/mu4e-compose.eld" tangle/emacs-etc-dir)
(よろ "よろしくお願いいたします。")
(いじょう "以上、よろしくお願いいたします。")
#+end_src

**** elisp code from outside of Emacs
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:

This section mainly for elisp code associated with some other programs.

#+begin_src emacs-lisp :noweb yes
<<elisp-code>>
#+end_src

**** obsolete features                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-20 Fri 10:59]
:END:
***** org-archive-datetree                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-08-10 Wed 14:51]
:END:

#+begin_src emacs-lisp :tangle no
(require 'org)
(require 'org-agenda)

(defcustom my/org-archive-before-archive-hook nil
  "Hook that is run right before a archive process begins."
  :group 'org-archive-datetree
  :type 'hook)

(defun my/org-archive-file (&optional year)
  "Return a path of archive file.

If optional argument `YEAR' is passed that year's file is returned instead of current year's."
  (let* ((record-year (or year (ts-year (ts-now))))
         (record-file-cand (format "%s/archive/archive_%s.org" org-directory record-year))
         (record-file
          (if (file-exists-p record-file-cand)
              record-file-cand
            (expand-file-name "archive/archive_0000.org" org-directory))))
    (if (or (file-exists-p record-file)
            (file-symlink-p record-file))
        record-file
      nil)))

(defvar my/org-archive-file (my/org-archive-file))

(defun my/org-archive-files ()
  "Return list of archive files."
  (append (directory-files (expand-file-name "archive" org-directory) t "archive_[[:digit:]]\\{4\\}\\.org" nil)
          org-agenda-files))

(defvar my/org-archive-files (my/org-archive-files))

(defun my/org-archive-find-date (date)
  "Find and visit the location of DATE in archivee file.

DATE must be a string representing the date to find and parsable with `format-time-string'.

If called interactively, it prompt the user to select the date to find."
  (interactive
   (cond
    ((eq major-mode 'calendar-mode)
     (list (calendar-date-string (calendar-cursor-to-date))))
    ((eq major-mode 'org-agenda-mode)
     (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                     (user-error "Don't know which date to open in calendar")))
            (date (calendar-gregorian-from-absolute day)))
       (list (calendar-date-string date))))
    (t (let ((date-select (org-read-date)))
         (list date-select)))))
  (let* ((d (parse-time-string date))
         (day (decoded-time-day d))
         (month (decoded-time-month d))
         (year (decoded-time-year d)))
    (find-file (my/org-archive-file year))
    (org-datetree-find-iso-week-create `(,month ,day ,year))))

(defun my/org-archive-subtree ()
  "Refile current subtree to archive file using latest timestamp."
  (interactive)
  (let* ((ts (car (sort (org-timestamps-in-entry) #'ts>)))
         (year (ts-year (or ts (ts-now))))
         (save-file (my/org-archive-file year))
         (tags (org-get-local-tags))
         (todo (org-get-todo-state)))
    (when-let* ((pos (with-current-buffer (find-file-noselect save-file)
                       (save-excursion
                         (if (and (member "web" tags)
                                  (not (member todo `(,my/org-done-keyword--done
                                                      ,my/org-done-keyword--pending))))
                             (org-find-exact-headline-in-buffer "untouched items")
                           (org-datetree-find-iso-week-create `(,(ts-month ts)
                                                                ,(ts-day ts)
                                                                ,(ts-year ts)))
                           (point))))))
      (run-hooks 'my/org-archive-before-archive-hook)
      (org-refile nil nil (list nil save-file nil pos)))
    (org-save-all-org-buffers)
    (setq this-command 'my/org-archive-subtree)))

(defun my/org-agenda-archive-subtree ()
  "Refile the entry or subtree belonging to the current agenda entry."
  (interactive)
  (org-agenda-archive-with 'my/org-archive-subtree))

(defun my/org-ql-view-archive-subtree ()
  "Refile the entry or subtree belonging to the current agenda entry."
  (interactive)
  (org-agenda-archive-with 'my/org-archive-subtree)
  (org-ql-view-refresh))

(defun my/org-archive-search (query)
  "Search org entries matched QUERY in archive files using `org-ql-search'."
  (interactive (list (read-string "Query: ")))
  (let ((files (my/org-archive-files)))
    (org-ql-search files query)))

(bind-keys :map org-agenda-mode-map
           ("$" . my/org-agenda-archive-subtree)
           ("C" . my/org-archive-find-date)
           :map org-ql-view-map
           ("$" . my/org-ql-view-archive-subtree)
           :map calendar-mode-map
           ("C" . my/org-archive-find-date))

(push '("Archive entries" . my/org-archive-search)
      org-ql-views)

;; TODO: This function can be rewritten with org-ml
;;;###autoload
(defun org-timestamps-in-entry ()
  "Return timestamp objects for all Org timestamps in entry."
  (interactive (list current-prefix-arg))
  (save-excursion
    (goto-char (org-entry-beginning-position))
    (org-show-entry)
    (org-narrow-to-element)
    (let* ((parsetree (org-element-parse-buffer))
           (ts-list nil))
      (org-element-map parsetree '(planning clock timestamp)
        (lambda (elm)
          (cl-case (org-element-type elm)
            ('planning
             (add-to-list 'ts-list (ts-parse-org-element (or (org-element-property :closed elm)
                                                             (org-element-property :scheduled elm)
                                                             (org-element-property :deadline elm)))
                          t))
            ('clock
             (add-to-list 'ts-list (ts-parse-org-element (org-element-property :value elm)) t))
            ('timestamp
             (add-to-list 'ts-list (ts-parse-org-element elm) t)))))
      (widen)
      ts-list)))

(provide 'my/org-archive-datetree)
#+end_src

***** org-capture-derived                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-08 Sun 18:03]
:END:

#+begin_src emacs-lisp :tangle no
(require 'thingatpt)
(require 'whitespace)

(with-eval-after-load 'org-capture
  (mapc (lambda (template)
          (add-to-list 'org-capture-templates
                       template))
        '(("x" "actionable entry for manual input"
           entry
           (function org-capture-derived-target-function)
           "* %(org-capture-derived-insert-todo)%? %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)")
          ("X" "Actionable entry for automated input"
           entry
           (function org-capture-derived-target-function)
           "* %(org-capture-derived-insert-todo)%a %(org-set-tags org-capture-derived-tags)\n%(org-capture-derived-insert-deadline)"
           :immediate-finish t))))

(defvar org-capture-derived-todo nil
  "Todo state to be set to an org entry which org-capture-derived creates.

User should set this value locally, otherwise unexpected results occur.")
(defvar org-capture-derived-tags nil
  "Tags represented with colon(:) to be set to an org entry which org-capture-derived creates.

User should set this value locally, otherwise unexpected results occur.")
(defvar org-capture-derived-target nil "docstring")
(defvar org-capture-derived-deadline-in-day nil "docstring")

(defun org-capture-derived-target-function ()
  ""
  (cond
   ((listp org-capture-derived-target)
    (set-buffer (org-capture-target-buffer (nth 1 org-capture-derived-target)))
    (org-capture-put-target-region-and-position)
    (widen)
    (goto-char (nth 3 org-capture-derived-target)))
   ((and (stringp org-capture-derived-target)
         (string-match-p thing-at-point-uuid-regexp org-capture-derived-target))
    (org-id-goto org-capture-derived-target))))

(defun org-capture-derived (&optional arg)
  "C-u user is asked for all arguments
C-u C-u create manually"
  (interactive "P")
  ;; insert ID property unless existing
  (cond
   ((and (eq major-mode 'org-mode)
         (not (equal arg '(16))))
    (org-id-get nil t)))
  (let* ((todo-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TODO" t)))
         (org-capture-derived-todo
          (or todo-in-org
              org-capture-derived-todo))
         (tags-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TAGS" t)))
         (org-capture-derived-tags
          (or (when (not (equal arg '(4)))
                (or tags-in-org
                    org-capture-derived-tags))
              (read-string "Tags: " tags-in-org)))
         (target-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_TARGET" t)))
         (org-capture-derived-target
          (or (when (not (equal arg '(4)))
                (or target-in-org
                    org-capture-derived-target))
              (org-refile-get-location)))
         (deadline-str-in-org
          (when (derived-mode-p 'org-mode)
            (org-entry-get (point) "DERIVED_DEADLINE_IN_DAY" t)))
         (deadline-num-in-org
          (if (stringp deadline-str-in-org) (string-to-number deadline-str-in-org) nil))
         (org-capture-derived-deadline-in-day
          (if (equal arg '(4))
              (read-number "Deadline in day: "
                           deadline-num-in-org)
            (or deadline-num-in-org
                org-capture-derived-deadline-in-day))))
    (if (equal arg '(16))
        (org-capture nil "x")
      (org-capture nil "X"))))

(defun org-capture-derived-insert-todo ()
  ""
  (if (stringp org-capture-derived-todo)
      (if (string-match-p whitespace-trailing-regexp
                          org-capture-derived-todo)
          org-capture-derived-todo
        (format "%s " org-capture-derived-todo))
    ""))

(defun org-capture-derived-insert-deadline ()
  ""
  (if (numberp org-capture-derived-deadline-in-day)
      (let ((week-ahead (encode-time
                         (seq-map-indexed (lambda (element index)
                                            (if (= index 3)
                                                (+ element org-capture-derived-deadline-in-day)
                                              element))
                                          (decode-time (current-time))))))
        (format-time-string "DEADLINE: <%Y-%m-%d %a>" week-ahead))
    ""))
#+end_src

***** narrow-dwim                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 14:45]
:END:

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/narrow-dwim.el")
(bind-key* "C-x n" 'my/toggle-narrow-dwim)

(defun my/toggle-narrow-dwim (arg)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, org-src-block, org-subtree, or defun,
whichever applies first.
Narrowing to org-src-block actually calls `org-edit-src-code'.

With prefix ARG, don't widen, just narrow even if buffer is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not arg))
         (when (org-buffer-narrowed-p)
           (when org-startup-indented
             (org-indent-mode 1))
           (visual-line-mode -1)
           (adaptive-wrap-prefix-mode -1))
         (widen)
         (setq-local truncate-lines t))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((and (boundp 'org-src-mode) org-src-mode (not arg))
         (org-edit-src-exit))
        ((condition-case err
             (org-edit-src-code)
           (user-error nil)))
        ((derived-mode-p 'org-mode)
         (cond ((org-at-block-p)
                (org-narrow-to-block))
               ((org-at-heading-p)
                (org-narrow-to-subtree)
                (adaptive-wrap-prefix-mode))
               (t (org-narrow-to-element)))
         (org-indent-mode -1)
         (visual-line-mode 1))
        ((eq major-mode 'dired-mode)
         (dired-subtree-narrow))
        (t (narrow-to-defun))))

;; (add-hook 'post-command-hook 'highlight-narrowed-buffer)
;; (defun highlight-narrowed-buffer ()
;;   "Highlight narrowed buffer.

;; Narrowed buffer have a fringe with highlighting color.
;; Plus text size in the buffer becomes a little bit larger."
;;   (unless (or (member last-command
;;                       '(text-scale-adjust))
;;               (eq major-mode 'Info-mode)
;;               (string-match-p (rx (seq line-start "CAPTURE-" (one-or-more ascii) line-end))
;;                               (buffer-name)))
;;     (let ((hl-fringe-color "purple2")
;;           (hl-text-scale (sqrt 2)))
;;       (set-face-attribute
;;        'fringe nil :background (if (buffer-narrowed-p)
;;                                    (progn
;;                                      (text-scale-set hl-text-scale)
;;                                      hl-fringe-color)
;;                                  (progn
;;                                    (when (= text-scale-mode-amount hl-text-scale)
;;                                      (text-scale-set 0))
;;                                    nil))))))
#+end_src
***** view-file (obsolete)                  :ARCHIVE:

#+begin_src emacs-lisp :tangle (expand-file-name ".emacs.d/site-lisp/view-file.el")
(defcustom my/view-file--temp-dir "~/tmp/view-file"
  "Directory in which we will work for uncompresssing, decrypting and htmlize.")
(defvar my/view-file--open-file nil
  "Target file which we will actually open.
User should not change this value.")
(defvar my/view-file--remove-files nil
  "List of files which we will remove afterward.
User should not change this value.")

;; TODO: support line/search args to jump to the desired position
(defun my/view-file (file &optional system)
  "Open FILE in my preferable way.

if SYSTEM is non-nii open FILE using preferable application in system."
  (setq my/view-file--open-file (expand-file-name file))
  (make-directory my/view-file--temp-dir t)

  ;; decrypt file if it is encrypted
  (when-let* ((match (string-match "\\(.+\\)\.gpg$" my/view-file--open-file))
              (decrypt-file (expand-file-name (file-name-base my/view-file--open-file)
                                              (expand-file-name my/view-file--temp-dir)))
              (context (epg-make-context epa-protocol)))
    (epg-context-set-passphrase-callback context
                                         #'epa-passphrase-callback-function)
    (epg-decrypt-file context my/view-file--open-file decrypt-file)
    (setq my/view-file--open-file decrypt-file)
    (add-to-list 'my/view-file--remove-files decrypt-file))

  ;; uncompress file if it is tarball
  (let* (uncompress-file
         (uncompress-command
          (cond
           ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?gz$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "gzip -dc %s | tar -xf - -C %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument uncompress-file)))
           ((string-match "\\(.+\\)\\.t\\(ar\\.\\)?zst$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "unzstd -c %s | tar -xf - -C %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument uncompress-file)))
           ((string-match "\\(.+\\)\\.zip$" my/view-file--open-file)
            (setq uncompress-file (expand-file-name (file-name-base (match-string 1 my/view-file--open-file))
                                                    my/view-file--temp-dir))
            (format "unzip -o -d %s %s"
                    (shell-quote-argument uncompress-file)
                    (shell-quote-argument my/view-file--open-file))))))
    (when (and (stringp uncompress-file)
               (stringp uncompress-command))
      (make-directory uncompress-file t)
      (call-process-shell-command
       uncompress-command)
      (add-to-list 'my/view-file--remove-files uncompress-file)
      (setq my/view-file--open-file uncompress-file)))

  ;; convert pdf/epub to html
  (let* ((dirname-html
          (expand-file-name (file-relative-name my/view-file--open-file "/")
                            (expand-file-name my/view-file--temp-dir)))
         (filename-html
          (concat (file-name-as-directory dirname-html)
                  "index.html"))
         (command
          (cond
           ((= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
            (format "cat %s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument filename-html)))
           ((= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0)
            (format "cat %s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%s - | strip_ruby > %s"
                    (shell-quote-argument my/view-file--open-file)
                    (shell-quote-argument dirname-html)
                    (shell-quote-argument filename-html))))))
    (when (and (null system)
               (stringp command))
      (unless (file-exists-p filename-html)
        (make-directory dirname-html t)
        (call-process-shell-command command)
        ;; reuse html only if pdf/epub file is not ecrypted
        (when (member my/view-file--open-file my/view-file--remove-files)
          (add-to-list 'my/view-file--remove-files dirname-html)))
      (setq my/view-file--open-file filename-html)))

  ;; open file
  (cond
   ((or system
        (string-match-p "\\.midi?$" my/view-file--open-file)
        (= (call-process-shell-command (format "filetype-cli check --type pdf %s" (shell-quote-argument my/view-file--open-file))) 0)
        (= (call-process-shell-command (format "filetype-cli check --type epub %s" (shell-quote-argument my/view-file--open-file))) 0))
    (let ((process-connection-type nil))
      (call-process-shell-command (format "xdg-open %s" (shell-quote-argument my/view-file--open-file)))
      (sleep-for 3)
      (funcall 'my/view-file--finalize-function)))
   ((or (= (call-process-shell-command (format "filetype-cli check --type playable %s" (shell-quote-argument my/view-file--open-file))) 0)
        (seq-some (lambda (suffix)
                    (string-suffix-p suffix my/view-file--open-file t))
                  '(".m3u" ".mts" ".m2ts")))
    (when-let ((mpv-proc (start-process-shell-command
                          "mpv" nil
                          (format "nohup mpv --force-window %s >/dev/null 2>&1" (shell-quote-argument my/view-file--open-file)))))
      (set-process-sentinel
       mpv-proc
       (lambda (process desc)
         (when (eq (process-status process) 'exit)
           (funcall 'my/view-file--finalize-function))))))
   ((= (call-process-shell-command
        (format "filetype-cli check --type html %s"
                (shell-quote-argument my/view-file--open-file))) 0)
    (add-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
    (eww-open-file my/view-file--open-file))
   ((file-directory-p my/view-file--open-file)
    (dired my/view-file--open-file)
    (funcall 'my/view-file--finalize-function))
   (t
    (find-file my/view-file--open-file)
    (funcall 'my/view-file--finalize-function))))

(defun my/view-file--finalize-function ()
  "Remove files and initialize variables."
  (mapc (lambda (file)
          (when (stringp file)
            (cond
             ((file-directory-p file)
              (delete-directory file t nil))
             ((file-exists-p file)
              (let ((delete-by-moving-to-trash t))
                (delete-file file))))))
        my/view-file--remove-files)
  (setq my/view-file--open-file nil
        my/view-file--remove-files nil))

(defun my/view-file--eww-finalize-function ()
  "Finalize function for `EWW'."
  (remove-hook 'eww-after-render-hook 'my/view-file--eww-finalize-function)
  (funcall 'my/view-file--finalize-function))

(defun my/view-file-filter-org-link-store-props (&rest plist-orig)
  "Filter PLIST-ORIG to original file name if value of `eww-current-url'
 is in `my/view-file--temp-dir'."
  (let ((plist-filtered (car plist-orig)))
    (if (plist-member plist-filtered :link)
        (plist-put plist-filtered
                   :link
                   (replace-regexp-in-string (format "%s\\(.*\\)/index.html"
                                                     (expand-file-name my/view-file--temp-dir))
                                             (format "%s\\1"
                                                     (expand-file-name "~"))
                                             (plist-get plist-filtered
                                                        :link))))
    (car plist-orig)))

(advice-add #'org-link-store-props :filter-args
            #'my/view-file-filter-org-link-store-props)

(provide 'my/view-file)
#+end_src

***** shell command builder                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 21:20]
:END:

This mechanism precedes [[id:cd86fe03-b295-4cde-8b7c-68d5705b843a][dispatch-dwim]]

#+begin_src emacs-lisp
(defmacro command-defun (name args docstring builder &optional defun-func)
  (declare (indent 2))
  `(,(or defun-func 'defun) ,name ,args
    ,docstring
    (interactive)
    (if (called-interactively-p 'any)
        (detached-shell-command ,builder)
      ,builder)))

(defmacro cl-command-defun (name args docstring builder)
  (declare (indent 2))
  `(command-defun ,name ,args ,docstring ,builder cl-defun))
#+end_src

****** system sleep                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-07 Tue 21:25]
:END:

#+begin_src emacs-lisp :noweb tangle
(defvar my/pre-command-history nil
  "History list for pre commands that will be executed before sleep.")

(command-defun my/command-system-sleep (wake-at delay)
  "Return a shell command string to sleep system until WAKE-AT with DELAY time."
  (string-trim-right
   (let ((mid-h <<morning-hour>>)
         (ct (current-time)))
     (string-join
      (delq nil
            (list
             (and (stringp delay)
                  (length> delay 0)
                  (format "sleep %s" delay))
             (format "pwsudo rtcwake -v -m mem -l --date '%s';"
                     (string-trim
                      (shell-command-to-string (format "date +'%%Y-%%m-%%d %%H:%%M' -d '%s'"
                                                       (or (and (stringp wake-at) (length> wake-at 0)
                                                                (my/expand-shorthand-time wake-at))
                                                           (concat (when (>= (nth 2 (decode-time ct)) mid-h)
                                                                     "tomorrow ")
                                                                   (format "%02d:00" mid-h)))))))))
      " && "))))
#+end_src

#+begin_src emacs-lisp :tangle no
(system-sleep (p "When to wake: " wake t)
              (p "Extension to sleep: " ext t)
              (my/command-system-sleep wake ext))
(morning-job "morning.sh;")
#+end_src

****** download video/audio                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-10 Fri 20:57]
:END:

command builders
#+begin_src emacs-lisp :noweb tangle
(cl-command-defun my/command-download-media (url &key filename audio play duration)
  "Return a shell command string to download media file from URL using yt-dlp.

If :FILENAME offered, the name of downloaded file will be its value.
If :AUDIO offered, audio file will be extracted from downloaded video file and
 set thumbnail.
if :PLAY offered, the file will be played right after downloading.
If :DURATION offered, return media duration instead."
  (format "yt-dlp %s"
          (string-join
           (delq nil
                 (list (format "-P '%s'" (file-name-concat "<<media-dir()>>" "downloads"))
                       "--embed-chapters"
                       "--live-from-start"
                       (and filename
                            (format "-o '%s.%%\(ext\)s'"
                                    (my/file-name-legitimate filename)))
                       (and play "--exec 'mpv {}'")
                       (and audio "-x --embed-thumbnail")
                       (and duration "--get-duration")
                       (format "'%s'" url)))
           " ")))
#+end_src

tempel templates in minibuffer-mode
#+begin_src emacs-lisp :tangle no :noweb-ref minibuffer-mode-template
(download-video (p "URL: " url t)
                (my/command-download-media url))
(download-audio (p "URL: " url t)
                (my/command-download-media url :audio t))
(media-durationa (p "URL: " url t)
                 (my/command-download-media url :duration t))
#+end_src

****** play media                            :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-12-30 Sat 10:51]
:END:

#+NAME: command-play-media
#+begin_src emacs-lisp :noweb tangle
(cl-command-defun command/play-media (file-or-url &key no-resume start end)
  "Build a shell command string to play media FILE-OR-URL.

If the option :NO-RESUME is provided, disregard any suspended time
during the previous playback."
  (string-join
   (delq nil
         (list "mpv"
               (and no-resume "--no-resume-playback")
               (and start (format "--start=%s" start))
               (and end (format "--end=%s" end))
               (cond
                ((stringp file-or-url)
                 (format "'%s'"
                         (s-chop-suffix "::" ; workaround
                                        (if (file-exists-p file-or-url)
                                            (expand-file-name file-or-url)
                                          file-or-url))))
                ((listp file-or-url)
                 (mapconcat (lambda (f)
                              (format "'%s'" (expand-file-name f)))
                            file-or-url
                            " ")))))
   " "))

(with-eval-after-load 'embark
  (mapc (lambda (map)
          (lambda-key map "P"
                      (lambda (file)
                        "play media FILE"
                        (funcall-interactively 'command/play-media file)))
          (lambda-key map "M-P"
                      (lambda (file)
                        "play media FILE as ignoring resume playback"
                        (funcall-interactively 'command/play-media file :no-resume t))))
        (list embark-file-map embark-url-map))
  (with-eval-after-load 'org
    (mapc (lambda (map)
            (lambda-key map "P"
                        (lambda (link)
                          "play media file written in org LINK"
                          (funcall-interactively 'command/play-media (url-filename (url-generic-parse-url (org-link-expand-abbrev link))))))
            (lambda-key map "M-P"
                        (lambda (link)
                          "play media file written in org LINK as ignoring resume playback"
                          (funcall-interactively 'command/play-media (url-filename (url-generic-parse-url (org-link-expand-abbrev link)))
                                                 :no-resume t))))
          (list embark-org-link-map))
    (mapc (lambda (map)
            (lambda-key map "P"
                        (lambda (list)
                          "play media in LIST"
                          (funcall-interactively
                           'command/play-media
                           (mapcar (lambda (item)
                                     (when (string-match org-link-any-re (car item))
                                       (url-filename (url-generic-parse-url
                                                      (org-link-expand-abbrev
                                                       (or (match-string-no-properties 2 (car item))
                                                           (match-string-no-properties 0 (car item))))))))
                                   (cdr (org-list-to-lisp list))))))
            (lambda-key map "M-P"
                        (lambda (list)
                          "play media in LIST written in org LINK as ignoring resume playback"
                          (funcall-interactively
                           'command/play-media
                           (mapcar (lambda (item)
                                     (when (string-match org-link-any-re (car item))
                                       (url-filename (url-generic-parse-url
                                                      (org-link-expand-abbrev
                                                       (or (match-string-no-properties 2 (car item))
                                                           (match-string-no-properties 0 (car item))))))))
                                   (cdr (org-list-to-lisp list)))
                           :no-resume t))))
          (list embark-org-plain-list-map))))
#+end_src

****** opus transcoder                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-12 Sun 22:00]
:END:

#+begin_src emacs-lisp
(command-defun my/command-transcode-opus (file)
  "Return a shell command string to transcode FILE to opus audio file.."
  (format "parallel ffmpeg -i '{}' -c:a libopus -b:a 64k -ac 2 '{.}'.opus ::: %s"
          file))

(with-eval-after-load 'embark
  (lambda-key embark-file-map "$"
              (lambda (file)
                "convert to opus audio"
                (funcall-interactively 'my/command-transcode-opus file))))
#+end_src

****** regenerate another file format with pandoc :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-12-17 Sun 10:09]
:END:

#+NAME: elisp-pandoc
#+begin_src emacs-lisp
(command-defun my/pandoc (file out-format)
  "Regenerate FILE with desired OUT-FORMAT with pandoc."
  (format "parallel pandoc -o '{.}'.%1$s '{}' %3$s::: %2$s"
          out-format file
          (if (string= out-format "pdf")
              "--pdf-engine weasyprint "
            "")))

(with-eval-after-load 'embark
  (lambda-key embark-file-map "%"
              (lambda (file)
                "regenerate other format"
                (funcall-interactively 'my/pandoc file
                                       (read-string "Format: " "org")))))
#+end_src

#+name: template-pandoc
#+begin_src emacs-lisp :tangle no
(pandoc (my/pandoc
         (if (eq minibuffer-history-variable 'dired-shell-command-history)
             "*" (read-file-name "File: "))
         (read-string "Format: " "org")))
#+end_src

#+NAME: guix-base-pandoc
#+begin_src scheme :noweb-ref guix-base
"weasyprint"
#+end_src

***** text to speech with Festival and OpenJTalk :ARCHIVE:
:PROPERTIES:
:CUSTOM_ID: emacs-tts-old
:END:

#+begin_src emacs-lisp :noweb tangle
(defcustom my/say-maximum-duration 30
  "Maximum speech duration in second for `my/say'.")
(defvar my/say--timer nil "Timer used to cancel speech process.")
(defvar my/say--open-jtalk-process "Say<Open-JTalk>"
  "Fixed name for a process running Open JTalk.")

(defun my/say (string)
  "Say out `STRING'.

If an argument is given as `STRING', speech that text. Otherwise the buffer text
 is spoken unless region is active.

As of now, English and Japanese are supported for speech. Spoken language is
 determined by a string, specifically a string entirely consists of ASCII
 characters is identified as English. Otherwise the string is spoken in Japanese."
  (interactive (list (if (region-active-p)
                         (buffer-substring (region-beginning) (region-end))
                       (buffer-string))))
  (when-let ((fest (require 'festival nil t))
             (my/say-lang 'en))
    (if (string-match-p
         (format "\\`[%s]+\\'" "[:ascii:]’“”–") string)
        ;; festival-say-string is unusable if region is active
        (if (region-active-p)
            (festival-say-region (region-beginning) (region-end))
          (festival-say-string string))
      (my/say--open-jtalk string)
      (setq my/say-lang 'ja))
    (setq my/say--timer
          (cond
           ((eq my/say-lang 'en)
            (run-with-timer my/say-maximum-duration nil
                            (lambda ()
                              (festival-kill-process)
                              (setq my/say--timer nil))))
           ((eq my/say-lang 'ja)
            (run-with-timer my/say-maximum-duration nil
                            (lambda ()
                              (and (get-process my/say--open-jtalk-process)
                                   (interrupt-process my/say--open-jtalk-process))
                              (setq my/say--timer nil))))))))
(with-eval-after-load 'engine-mode
  (keymap-set engine-mode-prefixed-map (kbd "\"")
              #'my/say))

(defun my/say-cancel ()
  "Cancel speech process that has started by `my/say'."
  (interactive)
  (and (require 'festival nil t)
       my/say--timer
       (progn (cancel-timer my/say--timer)
              (setq my/say--timer nil)))
  (if (and festival-process
           (string= (process-status festival-process)
                    "run"))
      (festival-kill-process)
    (and (get-process my/say--open-jtalk-process)
         (interrupt-process my/say--open-jtalk-process))))
(global-set-key (kbd "C-x C-\"") #'my/say-cancel)
(with-eval-after-load 'embark
  (keymap-set embark-region-map "\"" #'my/say))

(defun my/say--open-jtalk (text)
  "Speech TEXT in Japanese using Open JTalk."
  (start-process-shell-command
   my/say--open-jtalk-process nil
   (format "echo %s | open_jtalk -x /var/lib/mecab/dic/open-jtalk/naist-jdic -m <<hts-voice-dir()>>/Voice/mei/mei_angry.htsvoice -ow /tmp/a.wav && aplay /tmp/a.wav"
           (replace-regexp-in-string "[\t\r\n\v\f]+" " " text))))
#+end_src

****** jsay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/jsay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly DIC="${HOME}/usr/share/hts/dic"
readonly VOICE="${HOME}/usr/share/hts/voice/mei_normal.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/jsay_XXXXXXXX.wav`

open_jtalk -x ${DIC} -m ${VOICE} -ow ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

****** esay                                :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/esay") :tangle-mode (identity #o755)
#!/usr/bin/env bash

readonly VOICE="${HOME}/usr/share/hts/voice/cmu_us_arctic_slt.htsvoice"
readonly AUDIO_FILE=`mktemp ${HOME}/tmp/esay_XXXXXXXX.wav`

flite_hts_engine -m ${VOICE} -o ${AUDIO_FILE}
aplay --quiet ${AUDIO_FILE}
rm -f ${AUDIO_FILE}

exit 0
#+end_src

*** Org Tweaks for Specific Needs
:PROPERTIES:
:header-args+: :tangle (expand-file-name "org-config.el" tangle/emacs-config-dir)
:END:

**** org link at point map
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:58]
:END:

#+begin_src emacs-lisp
(defun org-link-at-point-map (function)
  "Call FUNCTION with a list whose elements are the URL and title
obtained from the org-link at the current point."
  (when-let* ((context (org-element-lineage
                        (org-element-context)
                        '(link)
                        t))
              (type (org-element-property :type context))
              (path (org-element-property :path context))
              (desc (when-let ((begin (org-element-property :contents-begin context))
                               (end (org-element-property :contents-end context)))
                      (buffer-substring begin end))))
    (cond
     ((string-match-p "https?" type)
      (funcall function (list (org-link-unescape (concat type ":" path)) desc)))
     ((string-match-p "elfeed" type)
      (save-excursion
        (org-open-at-point)
        (when (eq major-mode 'elfeed-show-mode)
          (when-let ((url (or (caar (elfeed-entry-enclosures elfeed-show-entry))
                              (elfeed-entry-link elfeed-show-entry)))
                     (title (elfeed-entry-title elfeed-show-entry)))
            (funcall function (list url title)))
          (quit-window)))))))
#+end_src

**** keymap for global org commands
:PROPERTIES:
:CREATED:  [2023-08-08 Tue 14:42]
:END:

#+begin_src emacs-lisp
(keymap-global-set "H-o"
                   (define-keymap
                     :prefix 'my/org-global-map
                     "o" #'org-open-at-point
                     "C-s" #'org-save-all-org-buffers
                     "J" #'org-babel-tangle-jump-to-org
                     "i" #'org-info-find-node
                     "m" #'org-mark-ring-goto
                     "@" #'org-previous-link))

(provide 'my-org-global-map)
#+end_src

**** remove empty clock log unless manually clocked out :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-06-06 Tue 10:23]
:END:

(setq org-clock-out-remove-zero-time-clocks t) makes this setting happen.

Removing zero time clock log makes sense that you can exclude undesirable line. But there is some sxception. Suppose you want to make clock log afterwards. Then you must create zero time clock log first and tune beginning and/or end of time. So I decided to retain zero time clock log only if clocked out manually (called org-clock-out interactively).

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (setq org-clock-out-remove-zero-time-clocks t)
  (advice-add #'org-clock-out :around #'my/org-clock-out-force-keep))

(defun my/org-clock-out-force-keep (oldfun &rest r)
  "Clock out with removing zero time clock log if called interactively."
  (let ((org-clock-out-remove-zero-time-clocks
         (if (called-interactively-p) nil t)))
    (apply oldfun r)))
#+end_src

**** embark keymaps for consult-org-heading and consult-location
:PROPERTIES:
:CREATED:  [2023-04-16 Sun 17:13]
:END:

#+begin_src emacs-lisp
(defun my/embark-org-clock-in-with-opening-thing (target)
  "Clock in and open thing for TARGET at once.

If TARGET is an agenda item and `other-window-for-scrolling' is
displaying an org mode buffer, then that is the source window.
If TARGET is a minibuffer completion candidate, then the source
window is the window selected before the command that opened the
minibuffer ran."
  (embark-org--in-source-window
   target
   (lambda (marker)
     (org-with-point-at marker
       (org-clock-in)
       (org-open-at-point)))))

(defun my/embark-org-clock-supersede (target)
  "Cancel the current clocking then clock in TARGET so as to fill out the gap time."
  (embark-org--in-source-window
   target
   (lambda (marker)
     (org-with-point-at marker
       (my/org-clock-supersede)))))

(with-eval-after-load 'embark
  (cl-mapc (lambda (key-def)
             (keymap-set embark-org-heading-map
                         (car key-def) (cdr key-def)))
           '(("M-I" . my/embark-org-clock-in-with-opening-thing)
             ("V" . my/embark-org-clock-supersede))))
#+end_src

**** org move repeat map
:PROPERTIES:
:CREATED:  [2023-03-05 Sun 16:15]
:END:

[[help:my/org-move-repeat-map][my/org-move-repeat-map]] allows to move around org elements and blocks with ease.

#+begin_src emacs-lisp
(defvar-keymap my/org-move-repeat-map
  :doc "Keymap to repeat moving commands in `org-mode'.  Used in `repeat-mode'."
  :repeat t
  "n" #'org-next-item
  "p" #'org-previous-item
  "u" #'org-up-element
  "d" #'org-down-element
  "f" #'org-forward-element
  "b" #'org-backward-element
  ">" #'org-next-link
  "<" #'org-previous-link
  "M-f" #'org-next-block
  "M-b" #'org-previous-block
  "M-F" #'org-forward-paragraph
  "M-B" #'org-backward-paragraph)
#+end_src

**** show org entries pointing to the current (backlink)
:PROPERTIES:
:CREATED:  [2023-03-03 Fri 11:26]
:END:

These commands show back links even in [[id:d5bd559a-2cab-4495-993b-f7a21637f0ea][denote]] files.

#+begin_src emacs-lisp
(defun my/org-backlink-entry ()
  "Show all entries that point to the entry at point."
  (interactive)
  (let ((id (org-entry-get (point) "ID"))
        (heading (org-get-heading t t t t)))
    (org-ql-search
      (directory-files-recursively org-directory "\\.org$" t
                                   (lambda (subdir)
                                     (member (file-relative-name subdir org-directory)
                                             '("agenda" "notes"))))
      `(link ,(or id heading))
      :super-groups '((:auto-parent)))))
(keymap-global-set "C-c b b" #'my/org-backlink-entry)

(defun my/org-backlink-by-tag ()
  "Show all entries that share tag with the entry at point."
  (interactive)
  (let* ((org-use-tag-inheritance
          (if (denote-file-is-note-p (buffer-file-name))
              t nil))
         (tags (org-get-tags)))
    (org-ql-search
      (directory-files-recursively org-directory "\\.org$" t
                                   (lambda (subdir)
                                     (member (file-relative-name subdir org-directory)
                                             '("agenda" "notes"))))
      `(tags ,@tags)
      :super-groups '((:auto-tags)))))
(keymap-global-set "C-c b t" #'my/org-backlink-by-tag)
#+end_src

**** set timer at clocking in

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (add-hook 'org-clock-in-prepare-hook
            #'my/org-clock-in-set-timer))

(defun my/org-clock-in-set-timer ()
  "Start count down timer for a clocked in entry.

If the entry has ATTENTION_SPAN property, use it for `org-timer-default-timer'.
Otherwise count down time is Effort property value.
In neither case, count down time is 25 min which is suggested in the Pomodoro-technique."
  (let* ((todo (org-get-todo-state))
         (attention-span (org-entry-get (point) "ATTENTION_SPAN" 'selective))
         (effort (org-entry-get (point) "Effort" 'selective))
         (countdown-time (or attention-span
                             (and todo "25")))
         (org-timer-default-timer countdown-time))
    (and countdown-time
         (org-timer-set-timer '(16)))))
#+end_src

**** stop timer at clocking out
:PROPERTIES:
:CREATED:  [2023-01-29 Sun 15:08]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (dolist (hook '(org-clock-out-hook org-clock-cancel-hook))
    (add-hook hook
              (lambda ()
                (and (bound-and-true-p  org-timer-countdown-timer)
                     (org-timer-stop))))))
#+end_src

**** supersede clocking task
:PROPERTIES:
:CREATED:  [2023-02-01 Wed 13:01]
:END:

#+begin_src emacs-lisp
(defun my/org-clock-supersede ()
  "Supersede clocking task with the task at point."
  (interactive)
  (let ((org-clock-continuously t))
    (save-excursion
      (and (bound-and-true-p org-clock-current-task)
           (org-clock-cancel)))
    (org-clock-in)))

(with-eval-after-load 'org-keys
  (with-eval-after-load 'my-org-global-map
    (bind-keys :map my/org-global-map
               ("V" . my/org-clock-supersede))
    (setf (map-elt org-speed-commands "V") #'my/org-clock-supersede)))
#+end_src

**** notify the completion of the timer with an alarm

#+begin_src shell :tangle (expand-file-name "volget" tangle/local-bin-dir)
pactl list sinks | grep '^[[:space:]]Volume:' | head -n $(($SINK + 1 )) | tail -n 1 | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,'
#+end_src

#+begin_src emacs-lisp :noweb tangle
(with-eval-after-load 'org-timer
  (add-hook 'org-timer-done-hook
            'my/org-task-timer-finish))

(defun my/org-task-timer-finish ()
  "Notify task timer by appropriate means."
  (when (and (org-clocking-p)
             org-clock-marker)
    (let ((alert (org-entry-get org-clock-marker
                                "ALERT")))
      (and (stringp alert)
           (string= alert "alarm")
           (alert "Timer Done!" :style 'alarm))
      (alert "Timer Done!" :style 'fringe :mode 'org-mode :buffer (org-clocking-buffer) :severity 'trivial))))

(defvar alarm-sound "/usr/share/sounds/freedesktop/stereo/complete.oga")

(with-eval-after-load 'alert
  (alert-define-style 'alarm
                      :title "alarm"
                      :notifier
                      (lambda (info)
                        (my/play-sound alarm-sound t))))
#+end_src

**** org-scrap (jotting down in org)
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 15:32]
:END:

Memo file (memo.org) is useful for jotting down fragmented pieces of text, code and more.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (defvar my/org-capture-scrap-file
    (file-name-concat org-directory "sandbox/scrap.org")
    "File for jotting down with `org-capture'.")
  (with-eval-after-load 'org-capture
    (add-to-list 'org-capture-templates
                 `("j" "Jot down"
                   entry (file ,my/org-capture-scrap-file)
                   "* %U\n#+begin_src %^{Lnaguage|text}\n%(my/org-capture-filter-scrap \"%i\")\n#+end_src"
                   :jump-to-captured t
                   :immediate-finish t)
                 t)))

(defun my/org-capture-filter-scrap (&optional str)
  "Replace semantic representation in `org-mode' with plain string in STR."
  (cond
   ((stringp str)
    (replace-regexp-in-string "^\\(*+ \\)" ",\\1" str))
   (t "")))
#+end_src

**** reset org element contextually
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:23]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c SPC" . my/org-reset-dwim)))

(defun my/org-reset-dwim ()
  "Exert reset procedure depending on org element at point."
  (interactive)
  (cond
   ((org-at-table-p) (org-table-blank-field))
   ((org-in-subtree-not-table-p)
    (org-save-outline-visibility t
      (org-reset-checkbox-state-subtree)))))
#+end_src

**** Copying org property to kill ring
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 13:52]
:CUSTOM_ID: emacs-org-copy-property
:END:

#+begin_src emacs-lisp
(defun my/org-copy-property-as-kill (property)
  "Copy the value of PROPERTY to `kill-ring'.

If the value matches $(...) format, ... will be treated as a
shell command, and the output of the command will be copied to
the `kill-ring' instead."
  (interactive (progn (setq properties (org-entry-properties))
                      (list (completing-read "Property: " properties))))
  (pcase (setq value (alist-get property properties nil nil #'equal))
    ((rx (seq "$(" (group (+ print)) ")"))
     (setq value (shell-command-to-string (match-string 1 value)))))
  (when (stringp value)
    (kill-new value)
    (message "Copied: %s" value)))

(with-eval-after-load 'org
  (keymap-set org-mode-map "C-c K"
              #'my/org-copy-property-as-kill)
  (setf (alist-get "K" org-speed-commands nil nil #'equal)
        #'my/org-copy-property-as-kill))
#+end_src

**** lob ingest all named source blocks
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 12:10]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map my/org-global-map
             ("b i" . my/org-babel-lob-ingest-all))

  (defvar my/org-babel-lob-ingest-files
    (seq-reduce (lambda (org-files dir)
                  (append org-files
                          (directory-files (expand-file-name dir org-directory) "\.org$")))
                '("agenda" "notes")
                nil)
    "A list of org files which is used in `my/org-babel-lob-ingest-all'.")

  (defun my/org-babel-lob-ingest-all ()
    "Add all named soruce blocks in cpecified files."
    (interactive)
    (dolist (org-file my/org-babel-lob-ingest-files)
      (org-babel-lob-ingest org-file))))
#+end_src

**** Altering the Org Heading Text
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 10:55]
:END:

[[https://www.p-snow.org/posts/20231121_1858/][I wrote a blog post]] for this topic.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c C-%" . my/org-alter-heading)))

(defun my/org-alter-heading ()
  "CHange the heading text of the entry at point.

The previous heading is logged as a log note."
  (interactive)
  (let* ((old-heading (org-get-heading t t t t))
         (new-heading (read-string "Heading: " old-heading))
         (org-log-note-headings (append '((heading . "Heading %-12s from %-12S %t"))
                                        org-log-note-headings)))
    (save-excursion
      (org-back-to-heading t)
      (replace-string old-heading new-heading nil
                      (line-beginning-position) (line-end-position))
      (org-align-tags))
    (org-add-log-setup 'heading new-heading old-heading 'state)
    (run-hooks 'post-command-hook)))

(defun my/org-heading-history ()
  ""
  (let ((heading-history (list (substring-no-properties (org-get-heading t t t t)))))
    (org-with-wide-buffer
     (org-save-outline-visibility t
       (org-back-to-heading t)
       (let* ((case-fold-search t)
              (subtree-end (save-excursion
                             (org-next-visible-heading 1)
                             (point)))
              (re (concat (rx "Heading" (+ space)
                              "\"" (+ not-newline) "\"" (+ space)
                              "from" (+ space)
                              "\"" (group (+ not-newline)) "\"" (+ space))
                          org-ts-regexp-inactive)))
         (while (re-search-forward re subtree-end t)
           (push (match-string-no-properties 1)
                 heading-history)))))
    (delete-dups heading-history)))
#+end_src

**** download media files in org             :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 10:43]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (bind-keys :map org-mode-map
             ("C-c D v" . my/org-download-video-link-at-point)
             ("C-c D a" . my/org-download-audio-link-at-point)
             ("C-c D =" . my/org-show-media-duration-at-point)))

(defun my/org-download-video-link-at-point ()
  "Download video file described in org link at point.

With `C-u' prefix find `my/download-video-dir' instead."
  (interactive)
  (cl-multiple-value-bind (url title)
      (ignore-errors
        (org-link-at-point-map
         (lambda (link desc)
           (cl-values link desc))))
    (if (and (not current-prefix-arg)
             url)
        (my/download-video url title)
      (call-interactively #'my/download-video))))

(defun my/org-download-audio-link-at-point ()
  "Download audio file described in org link at point.

With `C-u' prefix find `my/download-audio-dir' instead."
  (interactive)
  (cl-multiple-value-bind (url title)
      (ignore-errors
        (org-link-at-point-map
         (lambda (link desc)
           (cl-values link desc))))
    (if (and (not current-prefix-arg)
             url)
        (my/download-audio url title)
      (call-interactively #'my/download-audio))))

(defun my/org-show-media-duration-at-point ()
  "Show duration of media at point."
  (interactive)
  (org-link-at-point-map (lambda (url title)
                           (show-media-duration url))))
#+end_src

**** Managing Someday Tasks
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 09:14]
:END:

- task lifecycle
  #+HEADER: :file ./task_lifecycle.png
  #+begin_src dot :tangle no
  digraph{
  "web browsing" [shape = hexagon];
  "web browsing" -> task [label = "read later"];
  elfeed [shape = hexagon];
  elfeed -> task [label = "watch later"];
  "web browsing" -> someday [label = "read someday"];
  task -> someday [label = "expired"];
  someday -> task [label = "drill (active)"];
  task -> pending [label = "abandoned"];
  subgraph cluster_0 {
  someday -> someday [label = "drill (inactive)"];
  pending;
  label = "somedays.org";
  }
  }
  #+end_src

***** Reviewing Someday Tasks
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 09:18]
:END:

Someday tasks are encouraged to review and they prohibited to appear in agenda views.

#+begin_src emacs-lisp
(defun my/org-someday-task-review (resume-p)
  "Start or resume (if RESUME-P is non-nil) a session for reviewing tasks."
  (interactive "P")
  (progn
    (org-id-goto "58da20ee-97a9-4463-96b8-6ebb1084b9b7")
    (let ((org-drill-scope 'tree)
          (org-drill-question-tag my/org-review-tag)
          (org-drill-maximum-items-per-session 40)
          (org-drill-hide-item-headings-p nil)
          ;; drill session regulations
          (org-drill-maximum-duration 12)
          (org-drill-maximum-items-per-session 30)
          (org-drill-item-count-includes-failed-items-p t)
          ;; Spaced repetition algorithm
          (org-drill-spaced-repetition-algorithm 'sm5)
          (org-drill-sm5-initial-interval 14.0)
          ;; Random variation of repetition intervals
          (org-drill-add-random-noise-to-intervals-p t)
          ;; Adjusting item difficulty globally
          (org-drill-learn-fraction 0.37)
          (org-startup-indented nil))
      (and (require 'cl nil t)
           (org-drill nil (format "TODO=\"%s\"" my/org-todo-keyword--someday)
                      resume-p)))))
#+end_src

***** Skipping the display of "someday" tasks in the agenda view.
:PROPERTIES:
:CREATED:  [2023-11-04 Sat 12:17]
:END:

#+begin_src emacs-lisp
(defvar my/org-review-tag "review"
  "Tag name set for tasks which is encourged to review.")

(defun my/org-agenda-skip-someday-task ()
  "Skip entries which hold schedule time and review tag in agenda view."
  (let ((tags (org-get-tags)))
    (if (and (member my/org-review-tag (org-get-tags))
             (org-get-scheduled-time (point)))
        (progn (outline-next-heading) (point))
      nil)))

;; (with-eval-after-load 'org-agenda
;;   (setopt org-agenda-skip-function-global
;;           'my/org-agenda-skip-someday-task))
#+end_src

***** Showing SOMEDAY/GIVEUP Tasks
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 22:06]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-ql-view
  (push `("Someday tasks"
          :buffers-files ,(list (file-name-concat org-directory
                                                  "agenda/somedays.org"))
          :query (todo ,my/org-todo-keyword--someday)
          :super-groups ((:auto-property "ARCHIVE_OLPATH"))
          :sort (date))
        org-ql-views)
  (push `("Review: someday tasks"
          :buffers-files ,(list (file-name-concat org-directory
                                                  "agenda/somedays.org"))
          :query (todo ,my/org-todo-keyword--someday)
          :sort (scheduled))
        org-ql-views)
  (push `("Given-up tasks"
          :buffers-files ,(org-agenda-files)
          :query (todo ,my/org-done-keyword--pending)
          :super-groups ((:auto-property "ARCHIVE_OLPATH"))
          :sort (scheduled priority date))
        org-ql-views))
#+end_src

***** Immediate RE-Refiling SOMEDAY Tasks

#+begin_src emacs-lisp
(with-eval-after-load 'org-refile
  (add-hook 'org-after-refile-insert-hook
            #'my/org-archive-suspended-task))

(defun my/org-archive-suspended-task ()
  "Archive this entry to the file for suspended tasks if the TODO state fits the bill."
  (interactive)
  (if (member (org-entry-get nil "TODO")
              `(,my/org-todo-keyword--someday ,my/org-done-keyword--pending))
      (org-archive-subtree)
    (org-toggle-tag my/org-review-tag 'off)))
#+end_src

**** send org subtree via email

#+begin_src emacs-lisp
(with-eval-after-load 'org-keys
  (bind-keys :map org-mode-map
             ("C-c M" . my/org-subtree-send-email))
  (add-to-list 'org-speed-commands
               '("M" . my/org-subtree-send-email)
               t))

(defun my/org-subtree-send-email ()
  "Send an email containing the contents of the subtree at the entry at point."
  (interactive)
  (org-save-outline-visibility t
    (save-excursion
      (org-fold-show-all)
      (let* ((heading (org-get-heading t t t t))
             (org-export-with-toc nil)
             (org-export-with-author nil)
             (org-export-show-temporary-export-buffer nil)
             (message-kill-buffer-on-exit t)
             (exp-buf (org-ascii-export-as-ascii nil t t t)))
        (message-mail (cdr (assoc "login" (auth-source-pass-parse-entry "www.zoho.com")))
                      heading)
        (message-goto-body)
        (insert (with-current-buffer exp-buf (buffer-string)))
        (message-send-and-exit)))))
#+end_src
**** clean up after the task has chenged to DONE
:PROPERTIES:
:CREATED:  [2023-01-30 Mon 13:45]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (add-hook 'org-after-todo-state-change-hook
            #'my/org-todo-cleanup-when-done))

(defun my/org-todo-cleanup-when-done ()
  "Exert several procedure when the state of the task has chnaged to DONE.

Including:
- Remove priority
- Reset DONE state if the task is non-repeated habit
- Close the project of the task"
  ;; when the entry has any org-done-keywords
  (when (member org-state
                `(,my/org-done-keyword--done ,my/org-done-keyword--cancel ,my/org-done-keyword--pending))
    ;; remove priority if exists
    (and ;; the entry has been set any priority
     (/= 21000 (save-excursion
                 (save-match-data
                   (beginning-of-line)
                   (and (looking-at org-heading-regexp)
                        (org-get-priority (match-string 0))))))
     (org-priority 'remove))
    ;; reset done state if the task is non-repeated habit
    (and (org-is-habit-p)
         (not (org-get-scheduled-time (point)))
         (org-todo ""))
    ;; close the project
    (save-excursion
      (org-back-to-heading t)
      (org-speed-move-safe 'outline-up-heading)
      (and (member my/org-project-tag (org-get-tags))
           (org-todo my/org-done-keyword--done)))))
#+end_src

**** flush old clock logs and state changes
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 14:51]
:END:
:LOGBOOK:
- State "flush old clock logs and state changes" from "purge old clock logs and state changes" [2023-11-23 Thu 15:10]
- State "purge old clock logs and state changes" from "tidy up org entry by removing old blobs" [2023-11-23 Thu 15:01]
:END:

The hook functions, which is commented out, provoke malfunction failing to create todo state change logs which is necessary for habit graph.

#+NAME: midnight-flush-blobs
#+begin_src emacs-lisp
(with-eval-after-load 'midnight
  (add-hook 'midnight-hook
            (lambda ()
              (org-map-entries (lambda () (when (org-is-habit-p)
                                        (revert-buffer t t t)
                                        (my/org-flush-blobs)
                                        (basic-save-buffer)))
                               nil
                               'agenda))))
#+end_src

#+NAME: flush-blobs
#+begin_src emacs-lisp
(defvar my/org-flush-blobs-old-timestamp-in-day 90
  "Flush blobs with timestamps that are earlier than this number of days.")

(defvar my/org-flush-blobs-clock-log t
  "Whether `my/org-flush-blobs' flushes old clock logs.")

(defvar my/org-flush-blobs-state-change t
  "Whether `my/org-flush-blobs' flushes old todo state changes.")

(defun my/org-flush-blobs ()
  "Flush old blob."
  (interactive)
  (org-save-outline-visibility t
    (org-show-all)
    (save-excursion
      (let ((case-fold-search t)
            (next-heading (save-excursion
                            (org-next-visible-heading 1)
                            (point-marker))))
        (mapc (lambda (re)
                (org-back-to-heading t)
                (while-let ((ts-time (and (re-search-forward re (marker-position next-heading) t)
                                          (encode-time (parse-time-string (match-string 1))))))
                  (when (time-less-p ts-time
                                     (time-subtract (current-time) (days-to-time my/org-flush-blobs-old-timestamp-in-day)))
                    (kill-whole-line))))
              (append (and my/org-flush-blobs-clock-log
                           (list org-tr-regexp-both))
                      (and my/org-flush-blobs-state-change
                           (list (concat (rx "- State " "\"" (>= 2 upper) "\"" (+ space)
                                             "from " (opt "\"" (>= 2 upper) "\"") (+ space))
                                         org-ts-regexp-inactive)))))
        (when (featurep 'org-clock)
          (org-clock-remove-empty-clock-drawer))))))
#+end_src

**** pad non-clocking time with break task
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 07:36]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org-clock
  (add-hook 'org-clock-out-hook #'my/org-clock-in-break-time))

(defun my/org-clock-in-break-time ()
  "Clock in the 'Break' task automatically as to pat non-clocking time."
  (let ((break-task-id "d49d97de-58ec-4e41-b58c-491a9e216e1c"))
    (when (and (not org-clock-clocking-in)
               (not (string= (or (save-excursion
                                   (org-clock-goto)
                                   (org-id-get))
                                 "")
                             break-task-id)))
      (org-with-point-at (org-id-find break-task-id t)
        (org-clock-in)))))
#+end_src

**** show week number from the timestamp at point
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 15:01]
:END:

#+begin_src emacs-lisp
(defun my/org-iso-week-at-point ()
  "Display ISO 8601 week number correspoinds to time stamp at point."
  (interactive)
  (when-let ((ts-bound (org-in-regexp (org-re-timestamp 'all)))
             (ts (buffer-substring (car ts-bound) (cdr ts-bound))))
    (message "W%s" (format-time-string "%V" (org-read-date nil t ts nil)))))
#+end_src

**** Showing an Outline Path for the Entry
:PROPERTIES:
:CREATED:  [2023-11-01 Wed 14:48]
:CUSTOM_ID: emacs-org-tweak-outline-path
:END:

#+begin_src emacs-lisp
(defun my/org-show-outline-path (pom)
  "Display a sparse tree that shows an outline path for the entry at POM."
  (interactive (list (point)))
  (save-excursion
    (cl-labels ((lookup-parent ()
                  (let* ((heading-raw (substring-no-properties
                                       (org-get-heading t t t t)))
                         (heading (if (string-match org-link-bracket-re heading-raw)
                                      (match-string 2 heading-raw)
                                    heading-raw))
                         (h-li (list heading)))
                    (if (org-up-heading-safe)
                        (append (lookup-parent) h-li)
                      h-li))))
      (org-ql-sparse-tree (format "(olps %s)"
                                  (mapconcat (lambda (str) (format "\"%s\"" str))
                                             (lookup-parent)
                                             " "))))))

(with-eval-after-load 'org-ql
  (keymap-set org-mode-map "C-c M-/"
              #'my/org-show-outline-path))
#+end_src

**** use ISO week tree instead of Y/M/D tree
:PROPERTIES:
:CREATED:  [2023-11-03 Fri 15:03]
:END:

Following code is also responsible for deterministic archive location.

#+begin_src emacs-lisp
(with-eval-after-load 'org-archive
  (advice-add #'org-archive-subtree :around
              #'my/org-archive-subtree--iso-datetree))

(defun my/org-archive-subtree--iso-datetree (oldfun &rest r)
  "Move the current subtree to the archive.

If archiving location is datetree, it supposed to be iso week tree."
  (interactive)
  (when (member (org-get-todo-state)
                `(,my/org-todo-keyword--urgent ,my/org-todo-keyword--todo ,my/org-todo-keyword--next ,my/org-todo-keyword--in-action))
    (org-todo my/org-done-keyword--cancel))
  (when (string= (org-get-todo-state)
                 my/org-todo-keyword--someday)
    (org-toggle-tag my/org-review-tag 'on))
  (let* ((todo-state (org-get-todo-state))
         (closed-time (org-entry-get nil "CLOSED" t))
         (org-archive-location
          (cond
           ((member todo-state
                    `(nil ,my/org-done-keyword--done ,my/org-done-keyword--cancel))
            (format "%s::datetree/"
                    (file-name-concat org-directory "archive"
                                      (format "archive_%s.org"
                                              (if closed-time
                                                  (nth 5
                                                       (parse-time-string
                                                        (substring closed-time 1 -1)))
                                                (format-time-string "%Y"))))))
           ((string= todo-state my/org-todo-keyword--someday)
            (format "%s::* Someday Tasks"
                    (expand-file-name "agenda/somedays.org" org-directory)))
           ((string= todo-state my/org-done-keyword--pending)
            (format "%s::* Given-up Tasks"
                    (expand-file-name "archive/agenda/given-ups.org" org-directory))))))
    (when (stringp org-archive-location)
      (advice-add #'org-datetree-find-date-create :override
                  #'org-datetree-find-iso-week-create)
      (apply oldfun r)
      (advice-remove #'org-datetree-find-date-create
                     #'org-datetree-find-iso-week-create))))

(with-eval-after-load 'org-agenda
  (keymap-set org-agenda-mode-map "C" #'my/org-archive-find--iso-datetree))

(with-eval-after-load 'calendar
  (keymap-set calendar-mode-map "C" #'my/org-archive-find--iso-datetree))

;;;###autoload
(defun my/org-archive-find--iso-datetree (date)
  "Find and visit the location of DATE in archivee file.

DATE must be a string representing the date to find and parsable with `format-time-string'.

If called interactively, it prompt the user to select the date to find."
  (interactive
   (cond
    ((eq major-mode 'calendar-mode)
     (list (calendar-date-string (calendar-cursor-to-date))))
    ((eq major-mode 'org-agenda-mode)
     (let* ((day (or (get-text-property (min (1- (point-max)) (point)) 'day)
                     (user-error "Don't know which date to open in calendar")))
            (date (calendar-gregorian-from-absolute day)))
       (list (calendar-date-string date))))
    (t (let ((date-select (org-read-date)))
         (list date-select)))))
  (let* ((d (parse-time-string date))
         (day (decoded-time-day d))
         (month (decoded-time-month d))
         (year (decoded-time-year d)))
    (find-file (file-name-concat org-directory "archive" (format "archive_%d.org" year)))
    (org-datetree-find-iso-week-create `(,month ,day ,year))))

(with-eval-after-load 'my-org-global-map
  (bind-keys :map my/org-global-map
             ("D" . my/org-archive-find--iso-datetree)))
#+end_src

**** search org entry under 'default-directory'
:PROPERTIES:
:CREATED:  [2023-10-20 Fri 20:14]
:END:

#+begin_src emacs-lisp
(defmacro with-org-files-under (&rest body)
  "Eval `BODY' with providing org file list from `default-directory'."
  (declare (indent defun))
  `(let ((org-files (directory-files-recursively
                     default-directory
                     "\\(?:\\.org\\(?:\\.gpg\\)?$\\)")))
     ,@body))

(defun my/consult-org-heading-under ()
  "Invoke `consult-org-heading' with all org files under `default-directory'."
  (interactive)
  (with-org-files-under
    (let ((org-agenda-files org-files))
      (consult-org-agenda))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map "H"
              (lambda (dir) (interactive "sDir: ")
                (let ((default-directory dir))
                  (my/consult-org-heading-under)))))

(with-eval-after-load 'my-org-global-map
  (keymap-set my/org-global-map "H"
              #'my/consult-org-heading-under))

(defun my/org-ql-search-under ()
  "Invoke `org-ql-search' with all org files under `default-directory'."
  (interactive)
  (with-org-files-under
    (let ((org-agenda-files org-files)
          (query (read-string "Query: ")))
      (org-ql-search (org-agenda-files) query))))

(with-eval-after-load 'embark
  (keymap-set embark-file-map "Q"
              (lambda (dir) (interactive "sDir: ")
                (let ((default-directory dir))
                  (my/org-ql-search-under)))))

(with-eval-after-load 'my-org-global-map
  (keymap-set my/org-global-map "q Q"
              #'my/org-ql-search-under))
#+end_src

**** Opening Large Well-Accessed Org Files Stealthily
:PROPERTIES:
:CREATED:  [2023-11-28 Tue 07:38]
:END:

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (when (require 'denote nil t)
    (run-with-idle-timer
     (* 5 60) nil
     (lambda ()
       "Open large org files."
       (mapc #'find-file-noselect
             (append `(,(denote-get-path-by-id "20230605T170959"))
                     (take 7 (sort
                              (file-expand-wildcards
                               (file-name-concat org-directory "archive/archive_*.org"))
                              #'string>))))))))
#+end_src

**** Creating and showing project-task relationship
:PROPERTIES:
:ID:       6d6c13c6-a724-4476-9f60-84c29e3d41b4
:END:

#+begin_src emacs-lisp
(defun my/project-insert-link ()
  "Insert a org-link pointing to the project entry which locates upper position."
  (interactive)
  (when (org-get-todo-state)
    (save-excursion
      (outline-up-heading 1)
      (call-interactively #'org-store-link))
    (let ((org-log-note-headings (append '((project . "project %s %t"))
                                         org-log-note-headings))
          (link-str (with-temp-buffer
                      (call-interactively #'org-insert-last-stored-link)
                      (concat " " ; workaround for org-ql failing to recognize org-link with preceding "
                              (buffer-substring-no-properties (point-min) (1- (point-max)))
                              " "))))
      (org-add-log-setup 'project link-str
                         nil 'state (format-time-string (org-time-stamp-format t t)))
      (run-hooks 'post-command-hook))))

(defun my/project-list-tasks ()
  "Show a list of tasks belonging to the current project."
  (interactive)
  (when (require 'org-ql nil t)
    (when-let ((id (org-id-get)))
      (org-ql-search
        (append (file-expand-wildcards (file-name-concat org-directory "archive" "archive_*.org"))
                (org-agenda-files))
        `(link :target ,(format "id:%s" id))))))

(with-eval-after-load 'org-refile
  (add-hook 'org-after-refile-insert-hook
            #'my/project-insert-link))
#+end_src

**** Custom Org Link Types
:PROPERTIES:
:CREATED:  [2024-10-30 Wed 20:57]
:END:

***** "project" org link type
:PROPERTIES:
:CREATED:  [2024-10-30 Wed 20:57]
:ID:       949ee712-2ede-4dc0-9b54-555b3e043475
:END:

A "project" link type is designed for local copies of Git or other CVS repositories. It supports auto-completion when creating a new link and opens the local project repository directly. Additionally, it converts the link to the corresponding URL, such as https://github.com/xxx.

#+begin_src emacs-lisp :noweb tangle
(defun my/ghq-root ()
  "Return ghq root directory."
  (let ((ghq-root "<<ghq-root()>>"))
    (expand-file-name
     (if-let ((symlink (file-symlink-p ghq-root)))
         (file-name-concat (file-name-directory ghq-root)
                           (file-symlink-p ghq-root))
       ghq-root))))

(defun my/org-project-complete-link (&optional arg)
  "Prompt to select the project from ghq project list."
  (when (require 'consult-ghq nil t)
    (let* ((proj (completing-read "Project: "
                                  (consult-ghq--list-candidates)))

           (proj-rel (file-relative-name proj
                                         (my/ghq-root))))
      (pcase proj-rel
        ((rx (seq "github.com/" (group (+ print))))
         (concat "project+gh:" (match-string 1 proj-rel)))
        ((rx (seq "gitlab.com/" (group (+ print))))
         (concat "project+gl:" (match-string 1 proj-rel)))))))

(defun my/org-project-follow-link (link _)
  "Open LINK in Emacs."
  (find-file (file-name-concat (my/ghq-root) link)))

(defun my/org-project-export-link (link desc format _)
  "Export LINK to file."
  (setq link
        (concat "https://"
                (file-relative-name (with-current-buffer (find-file-noselect (file-name-concat (my/ghq-root) link))
                                      (project-root (project-current)))
                                    (my/ghq-root))))
  (pcase format
    ('html (format "<a href=\"%s\">%s</a>"
                   link
                   (or desc link)))
    ('md (if desc (format "[%s](%s)" desc link)
           (format "<%s>" link)))
    ('latex (format "\\href{%s}{%s}" link desc))
    ('texinfo (format "@uref{%s,%s}" link desc))
    ('ascii (format "%s (%s)" desc link))
    (_ (format "%s (%s)" desc link))))

(with-eval-after-load 'ol
  (org-link-set-parameters
   "project"
   :complete #'my/org-project-complete-link
   :follow #'my/org-project-follow-link
   :export #'my/org-project-export-link)
  (mapc (apply-partially 'add-to-list 'org-link-abbrev-alist)
        '(("project+gh" . "project:github.com/")
          ("project+gl" . "project:gitlab.com/"))))
#+end_src

***** "dotfile" org link type
:PROPERTIES:
:CREATED:  [2024-10-31 Thu 22:42]
:ID:       c4df5f5e-f7cf-4940-900c-3d6c2cece32d
:END:

#+begin_src emacs-lisp :noweb tangle
(defvar my/dotfile
  (file-name-concat "<<ghq-root()>>" "github.com/p-snow/config/dotfiles.org")
  "My dotfile")

(defun my/org-dotfile-complete-link (&optional arg)
  "Prompt to select org heading."
  (concat "dotfile:"
          (save-excursion
            (with-org-files-under
              (with-current-buffer (find-file-noselect my/dotfile)
                (consult--read
                 (consult--slow-operation "Collecting headings..."
                   (or (consult-org--headings nil nil 'file)
                       (user-error "No headings"))))
                ;; FIXME
                (or (org-entry-get nil "CUSTOM_ID")
                    (org-get-heading t t t t)))))))

(defun my/org-dotfile-follow-link (link _)
  "Open LINK in Emacs."
  (org-link-open-as-file (concat my/dotfile "::#gnu-emacs") nil))

(defun my/org-dotfile-export-link (link desc format _)
  "Export LINK to file."
  (setq link
        (concat "https://p-snow.org/config/dotfiles.html" link))
  (pcase format
    ('html (format "<a href=\"%s\">%s</a>"
                   link
                   (or desc link)))
    ('md (if desc (format "[%s](%s)" desc link)
           (format "<%s>" link)))
    ('latex (format "\\href{%s}{%s}" link desc))
    ('texinfo (format "@uref{%s,%s}" link desc))
    ('ascii (format "%s (%s)" desc link))
    (_ (format "%s (%s)" desc link))))

(with-eval-after-load 'ol
  (org-link-set-parameters
   "dotfile"
   :complete #'my/org-dotfile-complete-link
   :follow #'my/org-dotfile-follow-link
   :export #'my/org-dotfile-export-link))
#+end_src

*** would-be packages
:PROPERTIES:
:CREATED:  [2023-01-12 Thu 14:14]
:header-args:emacs-lisp+: :shebang ";; -*- lexical-binding: t -*-"
:END:

**** Package: lfile (custom org link type)
:PROPERTIES:
:CREATED:  [2023-04-14 Fri 14:24]
:ID:       6c7027a8-b023-4752-967d-c6c0a8834d2c
:END:

lfile is an extended org link type for files in local machine. It is inspired by [[https://karl-voit.at/2022/02/10/lfile/][Kerl Voit's implementation]].
It is implemented using abbrev mechanism since functionality of file: link type such as inline image or exporting can be easily imparted.

#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name "lfile.el" tangle/emacs-sitelisp-dir)
(require 'ol)
(require 'org-element)

(defvar org-lfile-link-re
  (rx "["
      "[lfile" (opt (or "+emacs" "+sys")) ":"
      (group (minimal-match (1+ print))) "]"
      (opt "[" (0+ print) "]")
      "]")
  "Regular expression matching lfile any link.")

(with-eval-after-load 'ol
  (mapc (apply-partially 'add-to-list 'org-link-abbrev-alist)
        '(("lfile" . "file:%(lfile-locate)")
          ("lfile+emacs" . "file+emacs:%(lfile-locate)")
          ("lfile+sys" . "file+sys:%(lfile-locate)"))))

(defun lfile-locate (tag)
  "Return a path found using TAG with locate program."
  (let* ((match-idx (string-match "^\\([^:]*\\)\\(::?\\(.*\\)\\)?$" tag))
         (link (if match-idx (match-string 1 tag) tag)))
    (concat (string-trim
             (shell-command-to-string
              (concat (format "plocate -d <<locate-db-doc()>> -e \"%s\" 2>/dev/null"
                              (shell-quote-argument link))
                      " | head --lines=1")))
            (when match-idx (match-string 2 tag)))))

(defun lfile-store-link ()
  "Store a lfile link.

Prefix argument does matter in this function call.
If `C-u' prefix is given, file: link type will be used instead."
  (when (and (derived-mode-p 'dired-mode)
             (string-match-p
              (format "^%s" (expand-file-name "~"))
              (dired-current-directory nil)))
    (let ((path (dired-get-filename nil t)))
      (if (equal current-prefix-arg '(4))
          (org-link-store-props
           :type "file"
           :link (concat "file:" (abbreviate-file-name
                                  (expand-file-name path))))
        (org-link-store-props
         :type "lfile"
         :link (concat "lfile:" (file-name-nondirectory path)))))))

(defun lfile-abbrev (raw-link &optional path-conv-fn)
  "Return an abbreviated lfile link from RAW-LINK.

RAW-LINK is supposed to be a file link type with a path and the path is
converted by `file-name-nondirectory' unless PATH-CONV-FN is supplied."
  (let* ((link (with-temp-buffer
                 (let ((org-inhibit-startup nil))
                   (insert raw-link)
                   (org-mode)
                   (goto-char (point-min))
                   (org-element-link-parser))))
         (type (org-element-property :type link))
         (path (org-element-property :path link))
         (abbrev-link (cond
                       ((string= type "file")
                        (format "%s:%s"
                                "lfile"
                                (if (functionp path-conv-fn)
                                    (funcall path-conv-fn path)
                                  (file-name-nondirectory path))))
                       ((stringp type)
                        raw-link)
                       (t nil))))
    abbrev-link))

(with-eval-after-load 'org
  (org-link-set-parameters "lfile"
                           :store #'lfile-store-link))

(defun embark-org-target-lfile-link ()
  "Target an org link at point of the form [[lfile:<file-name>][desc]]>."
  (pcase (org-in-regexp org-lfile-link-re)
    (`(,start . ,end)
     (when-let ((file-path (lfile-locate (match-string 1))))
       `(file ,file-path ,start . ,end)))))

(with-eval-after-load 'embark
  (add-to-list 'embark-target-finders 'embark-org-target-lfile-link))

(provide 'lfile)
#+end_src

***** lfile (legacy)                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-04-16 Sun 11:43]
:END:

#+begin_src emacs-lisp :noweb tangle :tangle no
(defcustom my/lfile-root "~/" "docstring")
(defcustom my/lfile-exclude-string ".local/share/Trash" "")

(defmacro my/expand-lfile (file body exclude-search)
  "Evaluate BODY with resolving a path from FILE.

In BODY, caller could refer a resolved file path as `file-resolved'.
If exclude-search is non-nil, search specifier after \"::\" will be removed in `file-resolved'."
  `(let* ((paths (my/lfile--locate ,file ,exclude-search))
          (file-resolved (car paths)))
     (cond
      ((= 0 (length paths))
       (message "Sorry, no results found for query: %s" file))
      ((<= 1 (length paths))
       ,body))))

(defun my/lfile-follow-link (file _)
  "Open FILE given in lfile org link type."
  (my/expand-lfile file
                   (org-link-open-as-file file-resolved current-prefix-arg)
                   nil))

(defun my/lfile-follow-link--emacs (file _)
  "Open FILE in Emacs given in lfile+emacs org link type."
  (my/expand-lfile file
                   (org-open-file file-resolved t)
                   t))

(defun my/lfile-follow-link--sys (file _)
  "Open FILE out of Emacs given in lfile+sys org link type."
  (my/expand-lfile file
                   (org-open-file file-resolved 'system)
                   t))

(defun my/lfile-store-link ()
  "Store a link to the file.

Prefix argument does matter in this function call.
If `C-u' prefix is given, file link is stored instead of lfile link."
  (when (and (derived-mode-p 'dired-mode)
             (string-match-p
              (format "^%s" (expand-file-name my/lfile-root))
              (dired-current-directory nil)))
    (let ((path (dired-get-filename nil t)))
      (if (equal current-prefix-arg '(4))
          (org-link-store-props
           :type "file"
           :link (concat "file:" (abbreviate-file-name
                                  (expand-file-name path))))
        (org-link-store-props
         :type "lfile"
         :link (concat "lfile:" (file-name-nondirectory path)))))))

(defun my/lfile-completing-read (&optional arg)
  "Create a lfile link using completion."
  (let* ((paths (my/lfile--locate nil))
         (files (mapcar #'file-name-nondirectory paths))
         (file (completing-read "Local file: " files nil 'confirm)))
    (concat "lfile:" file)))

(defun my/lfile-export (link description format)
  "Return an exported string from lfile link for format FORMAT.
A link consists of LINK and DESCRIPTION."
  (when-let* ((paths (my/lfile--locate link))
              (path (org-export-file-uri (expand-file-name (car paths))))
              (desc (or description link)))
    (when (stringp path)
      (cond
       ((eq format 'html)
        (if (string-match-p (regexp-opt '(".jpeg" ".jpg" ".png" ".gif" ".svg" ".webp"))
                            path)
            (format "<img src=\"%s\" alt=\"%s\"/>" path desc)
          (format "<a href=\"%s\">%s</a>" path desc)))
       ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
       ((eq format 'ascii) (format "%s (%s)" desc path))
       (t path)))))

(defun my/lfile-from-file-link ()
  "Replace file link type with lfile link type only if hte path in my/lfile-root."
  (interactive)
  (let* ((context (org-element-lineage
                   (org-element-context)
                   '(link desc)
                   t))
         (type (org-element-property :type context))
         (path (org-element-property :path context))
         (app (org-element-property :application context))
         (search-option (org-element-property :search-option context))
         (desc-begin (org-element-property :contents-begin context))
         (desc-end (org-element-property :contents-end context))
         (desc (and (and (integerp desc-begin) (integerp desc-begin))
                    (substring-no-properties (buffer-substring desc-begin desc-end)))))
    (when (and (string= type "file")
               (string-match-p
                (format "^%s" (expand-file-name my/lfile-root))
                (expand-file-name path)))
      (delete-region (org-element-property :begin context)
                     (org-element-property :end context))
      (insert (org-link-make-string (concat "lfile" (and app (concat "+" app)) ":"
                                            (file-name-nondirectory path)
                                            (and search-option (concat "::" search-option)))
                                    desc)))))

(defun my/lfile--locate (pattern &optional exclude-search)
  "Determine an absolute path from given FILE name using `locate' program."
  (if pattern
      (save-match-data
        (let ((match-idx (string-match "\\(.+\\)\\(::.+\\)\\'"
                                       pattern))
              (data (match-data)))
          (mapcar (lambda (resolved-path)
                    (set-match-data data)
                    (concat resolved-path
                            (when (and match-idx
                                       (not exclude-search))
                              (match-string 2 pattern))))
                  (split-string
                   (shell-command-to-string
                    (concat (format "plocate -d <<locate-db-doc()>> -ie \"%s\""
                                    (shell-quote-argument
                                     (or (and match-idx
                                              (match-string 1 pattern))
                                         pattern)))
                            (and (stringp my/lfile-exclude-string)
                                 (format " | grep -v %s"
                                         (shell-quote-argument  my/lfile-exclude-string)))))
                   "\n" t))))
    ""))

(with-eval-after-load 'org
  (org-link-set-parameters "lfile"
                           :follow #'my/lfile-follow-link
                           :store #'my/lfile-store-link
                           :complete #'my/lfile-completing-read
                           :export #'my/lfile-export)
  (org-link-set-parameters "lfile+emacs"
                           :follow #'my/lfile-follow-link--emacs)
  (org-link-set-parameters "lfile+sys"
                           :follow #'my/lfile-follow-link--sys))

(provide 'lfile)
#+end_src

**** Package: open-file
:PROPERTIES:
:CREATED:  [2023-01-28 Sat 13:58]
:END:

Open-file is a feature that allows you to specify the application to open a file based on its type.

By default, PDF and EPUB files are opened in EWW after converted into HTML. Videos and audio files are played in MPV media player.

#+NAME: open-file
#+begin_src emacs-lisp :noweb tangle :tangle (expand-file-name "open-file.el" tangle/emacs-sitelisp-dir)
;; general functions

(defvar my/open-file-dir
  "<<htmlize-dir()>>"
  "Directory where html file is converted into.")

(defvar my/open-file-media-player "mpv"
  "Media player used to play media file in open-file.")

(defvar my/open-file-media-extensions
  '("mpg" "mpeg" "mp3" "mp4" "m4v" "m4a"
    "avi" "wmv" "wav" "mov" "flv" "mkv" "mka" "webm" "3gp"
    "flac" "ogv" "oga" "ogx" "ogg" "spx" "opus"
    "xbm" "pbm" "pgm" "ppm" "pnm" "png" "gif" "bmp" "tif" "jpeg" "jpg" "webp")
  "Extensions files which can play with media player must have.")

(defvar my/open-file-compressed-media-extensions
  '("tar.gz" "tgz" "tar.xz" "txz" "zip" "7z")
  "Extensions compressed files which can play with media player must have.")

;; TODO: This could be achieved by command builder
(defmacro my/open-file-as-html (file convert-cmd)
  `(let* ((cap-command (if (string-match-p url-handler-regexp ,file)
                           "curl"
                         (if (string-suffix-p ".gpg" ,file)
                             "gpg -d"
                           "cat")))
          (dir-name (file-name-base ,file))
          (dirname-html
           (expand-file-name
            dir-name
            my/open-file-dir))
          (filename-html
           (concat (file-name-as-directory dirname-html)
                   "index.html"))
          (command ,convert-cmd))
     (unless (file-exists-p filename-html)
       (make-directory dirname-html t)
       (call-process-shell-command command))
     (browse-url filename-html)))

(defun my/open-pdf-as-html (pdf)
  "Open PDF in `eww' after the process of convertion into html."
  (my/open-file-as-html
   (expand-file-name pdf)
   (format "%1$s %2$s 2>/dev/null | pdftohtml -p -s -noframes -nomerge -nodrm - %3$s"
           cap-command
           (shell-quote-argument (expand-file-name pdf))
           (shell-quote-argument filename-html))))

(defun my/open-epub-as-html (epub)
  "Open EPUB in `eww' after the process of convertion into html."
  (let ((exp-epub (if (file-exists-p epub)
                      (expand-file-name epub)
                    epub)))
    (my/open-file-as-html
     exp-epub
     (format "%1$s %2$s 2>/dev/null | pandoc --from=epub --to=html --extract-media=%3$s - | strip_ruby > %4$s"
             cap-command
             (shell-quote-argument exp-epub)
             (shell-quote-argument dirname-html)
             (shell-quote-argument filename-html)))))

(defun my/open-media (media &optional query)
  "Open MEDIA file in media player with respecting QUERY.

QUERY must comply to RFC 822 format, which holds attribute/value pairs."
  (apply 'funcall-interactively
         'my/mpv-command media
         (and (stringp query)
              (let (mpv-args)
                (mapc (lambda (cons-cell)
                        (pcase cons-cell
                          (`(,val "") (setq mpv-args (plist-put mpv-args :start val)))
                          (`(,(or "s" "start") . (,val)) (setq mpv-args (plist-put mpv-args :start val)))
                          (`(,(or "e" "end") . (,val)) (setq mpv-args (plist-put mpv-args :end val)))
                          (`(,(or "ps" "playlist-start") . (,val)) (setq mpv-args (plist-put mpv-args :playlist-start val)))))
                      (url-parse-query-string query))
                mpv-args))))

;; ==============================================
;; browse-url handling

(with-eval-after-load 'browse-url
  (setopt browse-url-handlers
          `(((lambda (url) (equal current-prefix-arg '(16)))
             . browse-url-firefox)
            ((lambda (url) (equal current-prefix-arg '(4)))
             . browse-url-emacs)
            ("\\.html\\'"
             . (lambda (url &optional same-window)
                 (cond
                  ((file-exists-p url) (eww-open-file url))
                  ((string-match-p url-handler-regexp url)
                   (browse-web url)))))
            ("\\.pdf\\(\\.gpg\\)?\\'" . (lambda (url &optional same-window)
                                          (my/open-pdf-as-html url)))
            ("\\.epub\\'" . (lambda (url &optional same-window)
                              (my/open-epub-as-html url)))
            (,(eval `(rx "." (or ,@my/open-file-media-extensions
                                 ,@my/open-file-compressed-media-extensions)
                         (opt ".gpg")))
             . my/open-media))))

;; ==============================================
;; org-open handling

(defun my/org-open-html (file-path link-string)
  "Open a html file at FILE-PATH via org-open command."
  (browse-url file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-pdf (file-path link-string)
  "Open a pdf file at FILE-PATH via org-open command."
  (my/open-pdf-as-html file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-epub (file-path link-string)
  "Open an epub file at FILE-PATH via org-open command."
  (my/open-epub-as-html file-path)
  (when-let ((search (my/org-link-search link-string)))
    (org-link-search search)))

(defun my/org-open-media (file-path link-string)
  "Open a media file at FILE-PATH via org-open command."
  (my/open-media file-path
                 (my/org-link-search link-string)))

(defun my/org-link-search (link-string)
  (and (stringp link-string)
       (string-match "::\\(.*\\)\\'" link-string)
       (match-string 1 link-string)))

(defun my/org-execute-file-search-line-number (s)
  "A search function responsible for line number inside of S."
  (and (string-match (rx bos
                         (opt "l=")
                         (group-n 1
                           (opt (or ?- ?+))
                           (1+ digit))
                         eos)
                     s)
       (goto-line (string-to-number (match-string 1 s)))))

(add-hook 'org-execute-file-search-functions
          'my/org-execute-file-search-line-number)

(with-eval-after-load 'org
  (setopt org-file-apps
          `(("\\.html\\'" . my/org-open-html)
            ("\\.pdf\\(\\.gpg\\)?\\'" . my/org-open-pdf)
            ("\\.epub\\'" . my/org-open-epub)
            (,(eval `(rx "." (or ,@my/open-file-media-extensions
                                 ,@my/open-file-compressed-media-extensions)
                         (opt ".gpg") string-end))
             . my/org-open-media)
            (auto-mode . emacs)
            (directory . my/org-open-media)
            (system . browse-url-default-browser))))

;; ==============================================
;; dired-open handling

(with-eval-after-load 'dired-open
  (setq dired-open-functions '(dired-open-call-function-by-extension
                               dired-open-by-extension
                               dired-open-subdir)
        dired-open-extensions-elisp `(("pdf" . my/open-pdf-as-html)
                                      ("epub" . my/open-epub-as-html)
                                      ,@(mapcar (lambda (ext)
                                                  (cons ext 'my/open-media))
                                                my/open-file-media-extensions))
        dired-open-find-file-function 'my/dired-find-file))

(defun my/dired-find-file ()
  "A function for `dired-open-find-file-function' dealing with
a `dired-open-file' call with `C-u' or `C-u C-u'."
  (let ((file-for-visit (dired-get-file-for-visit)))
    (cond
     ((equal current-prefix-arg '(16))
      (browse-url-default-browser file-for-visit))
     ((equal current-prefix-arg '(4))
      (dired--find-possibly-alternative-file file-for-visit))
     ((string-match-p (eval `(rx (or ,@my/open-file-compressed-media-extensions)))
                      file-for-visit)
      (my/open-media file-for-visit))
     (t (dired-find-file)))))

(provide 'open-file)
#+end_src

- get original file name from converted html file
  #+begin_src emacs-lisp
  (defun my/open-file-original-file (html)
    "Revert HTML file into original file name."
    (interactive (list (if (use-region-p)
                           (buffer-substring (use-region-beginning)
                                             (use-region-end))
                         (read-string "HTML: "))))
    (when-let* ((regex (rx (group-n 1 (opt (or "file://" "file:~")))
                           (1+ (: "/" (1+ nonl)))
                           (group-n 2 (1+ (: "!" (1+ (: nonl)))))
                           "/index.html"))
                (index (string-match regex html))
                (rep (concat (and (cl-some (lambda (cand)
                                             (string= cand (match-string 1 html)))
                                           '("file://" "file:~"))
                                  "lfile:")
                             (substring (match-string 2 html) 1))))
      (if (use-region-p)
          (replace-string-in-region html rep)
        (princ (replace-regexp-in-string regex rep html)))))
  #+end_src

**** Package: org-password-store
:PROPERTIES:
:CREATED:  [2023-01-27 Fri 17:48]
:END:

#+begin_src emacs-lisp :tangle (expand-file-name "org-password-store.el" tangle/emacs-sitelisp-dir)
(require 'password-store)

(defcustom my/org-password-store-property "PASSWORD_STORE"
  "Property used in my/password-store feature to get password-store entry name attached to current org entry.")

(defmacro with-password-store-entry (entry &rest body)
  "Eval BODY that can refer password-store ENTRY."
  (declare (indent defun))
  `(let ((entry (or ,entry
                    (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                    (password-store--completing-read t))))
     ,@body))

(defmacro with-password-store-entry-field (entry field &rest body)
  "Eval BODY which can refer password-store ENTRY and FIELD..

Plus, OBDY can refer value of FIELD named field-value."
  (declare (indent defun))
  `(let* ((entry (or ,entry
                     (when (derived-mode-p 'org-mode) (org-entry-get (point) my/org-password-store-property))
                     (password-store--completing-read t)))
          (field (or ,field
                     (password-store-read-field entry)))
          (field-value (password-store-get-field entry
                                                 (or (and (string= field "secret")
                                                          'secret)
                                                     (and (stringp field)
                                                          field)))))
     ,@body))

(defun my/password-store-copy ()
  "Add the secret to system clipboard and the login name to primary `x-selection'.

`password-store-copy' is responsible for managing the kill ring."
  (interactive)
  (with-password-store-entry-field nil "login"
    (password-store-copy entry)
    (gui-set-selection 'PRIMARY
                       (or (password-store-get-field entry "login")
                           (password-store-get-field entry "email")
                           (nth 1 (password-store-parse-entry entry))))
    (message "LOGIN NAME => X-SEL, SECRET => CLIPBOARD")))

(defun my/password-store-copy-field ()
  "Add field for entry into the kill ring.

entry and field is determined by appropriate manner."
  (interactive)
  (with-password-store-entry-field nil nil
                                   (password-store-copy-field entry field)))

(defun my/password-store-url (&optional arg)
  "Browse url stored in entry by appropriate manner determined by ARG."
  (interactive "P")
  (with-password-store-entry-field nil "url"
                                   (browse-url field-value)))

(defun my/password-store-show-field ()
  "Show a field value in the minibuffer.

Password-store entry and field used to derive this value are from org property
or selected by user."
  (interactive)
  (with-password-store-entry-field nil nil
                                   (message "%s: %s" field field-value)))

(defun my/password-store-create ()
  (interactive)
  (let* ((input (read-string "Entry-name or URL: "))
         (domain (when (string-match-p browse-url-button-regexp input)
                   (string-trim-right
                    (shell-command-to-string (format "echo %s | awk -F[/:] '{print $4}'"
                                                     (shell-quote-argument input)))))))
    (with-password-store-entry (cond
                                ((> (length domain) 0) domain)
                                (input))
                               (when (derived-mode-p 'org-mode)
                                 (org-entry-put (point) my/org-password-store-property entry))
                               (password-store-edit entry))))

;;;###autoload
(defun my/password-store-edit ()
  (interactive)
  (with-password-store-entry nil
                             (password-store-edit entry)))

;; TODO: make my/password-store-insert as soon after
;;     : password-store--run-insert has been implemented

(defun my/password-store-remove ()
  (interactive)
  (with-password-store-entry nil
                             (password-store-remove entry)
                             (when (derived-mode-p 'org-mode)
                               (org-entry-delete (point) my/org-password-store-property))))

(defun my/password-store-web-login ()
  "Open url for the entry at point.

Additionally the login name and the secret are saved in X selection and clipboard respectively."
  (interactive)
  (my/password-store-copy)
  (funcall-interactively #'my/password-store-url '(16)))

(advice-add #'password-store-clear :before #'my/password-store-clear)

(defun my/password-store-clear (&optional field)
  "Overwrite clipboard data so that password once saved in clipboard is deleted
 for security risk.

FIELD originally for messaging is ignored in this function."
  (interactive)
  (when password-store-kill-ring-pointer
    (kill-new "")
    (setcar kill-ring-yank-pointer "")))

(provide 'org-password-store)
#+end_src

**** text-mail                               :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-27 Mon 14:11]
:END:

#+begin_src emacs-lisp :tangle no
(require 'message)

(defun mail-send-string (mailto subject body)
  "Default function to send a mail with SUBJECT and BODY to myself."
  (save-excursion
    (let ((message-kill-buffer-on-exit t))
      (message-mail mailto subject)
      (message-goto-body)
      (insert body)
      (message-send-and-exit))))

(defun mail-send-buffer (mailto)
  "Send the current buffer contents as a email.

If region is active, send the string in the region instead."
  (let ((mail-subj (buffer-name))
        (mail-body (if (use-region-p)
                       (buffer-substring (region-beginning) (region-end))
                     (buffer-string))))
    (mail-send-string mailto mail-subj mail-body)))

(provide 'text-mail)
#+end_src

**** learning english words/phrases
:PROPERTIES:
:ID:       2bd0c5d2-faed-43d9-b054-3e1ad9b51a76
:END:

My workflow for acquiring English words is:
1. Capture a word which come across in the article I'm reading with my/org-english-capture
   - Captured words will be appended to my English word list
2. Review my English word list with my/org-english-drill everyday
   - Org-drill ask questions to level up my vocabulary

#+begin_src emacs-lisp  :tangle (expand-file-name "org-english.el" tangle/emacs-sitelisp-dir) :comments no
(require 'define-word)
(require 'org)
(require 'org-drill)
(require 'cl-lib)
(require 'request)
(require 'logos)
(require 'org-tidy)

(defvar my/org-english-file "~/documents/english.org"
  "A file where all english words to learn locate.")

(defvar my/org-english-word nil
  "An english word to capture.")

(defvar my/org-english-match-entry nil
  "An org entry which matches search word.")

(defun my/org-english-capture (word)
  "Capture an english WORD as a `org-mode' entry suitable for org-drill.

Capture URL or file currently visiting as well as a sentence at point."
  (interactive (list (determine-search-word "Word to capture: ")))
  (setq org-english-word (downcase word))
  (setq my/org-english-match-entry nil)
  (let* ((sentence-end-double-space nil)
         (my/org-english-match-entry (org-ql-select
                                      `(,my/org-english-file)
                                      `(and (heading-regexp
                                             ,(eval `(rx word-start
                                                         ,org-english-word
                                                         word-end)))
                                            (tags "drill"))
                                      :action 'element-with-markers))
         (sentence (replace-regexp-in-string word
                                             (my/cloze-deletion word)
                                             (or (sentence-at-point) ""))))
    (kill-new (if (stringp sentence) sentence ""))
    (cond
     (my/org-english-match-entry (org-capture nil "!1"))
     (t (org-capture nil "!0")))))

(defun my/cloze-deletion (word)
  "Build cloze deletion string from WORD."
  (seq-reduce (lambda (string chunk)
                (replace-regexp-in-string chunk (format "[%s||%c]" chunk (string-to-char chunk))
                                          string))
              (split-string word "[ -]+")
              word))

(defun my/cloze-deletion-replace (&optional unwrap)
  "Make a word at point cloze deletion format by wrapping brackets or UNWRAP."
  (interactive "P")
  (pcase-let* ((thing (if (equal unwrap '(4)) 'list 'word))
               (word (if (region-active-p)
                         (buffer-substring (region-beginning) (region-end))
                       (thing-at-point thing)))
               (`(,start . ,end)
                (if (region-active-p)
                    (cons (region-beginning) (region-end))
                  (let ((bounds (bounds-of-thing-at-point thing)))
                    (cons (car bounds) (cdr bounds))))))
    (replace-string word
                    (if (equal unwrap '(4))
                        (save-match-data
                          (string-match (rx (seq "[" (group (+ graph)) "||" alnum "]"))
                                        word)
                          (match-string 1 word))
                      (my/cloze-deletion word))
                    nil start end)))

(with-eval-after-load 'org-ql-view
  (push `("English words to learn"
          :buffers-files ,(list my/org-english-file)
          :query (and (tags "drill")
                      (tags "fd_en"))
          :sort (scheduled date))
        org-ql-views))

(with-eval-after-load 'org-capture
  (add-to-list 'org-capture-templates
               '("!0" "drill entry for english word"
                 entry (id "de0983a7-9d1a-4ef8-b882-148c401e862d")
                 "* %i :drill:fd_en:
[%(my/english-japanese-translate org-english-word t) %(my/english-pronunciation org-english-word t)]
%(my/org-english-insert-english-translation)
- %a
  %c"))
  (add-to-list 'org-capture-templates
               '("!1" "drill entry for english word"
                 item (function my/org-english-goto-match)
                 "- %a
  %c")))

(defun my/org-english-goto-match ()
  "Goto function for org-capture-template designed to insert an edditional example
to existing english word entry."
  (org-goto-marker-or-bmk
   (plist-get (cadar my/org-english-match-entry) :org-marker)))

(defun my/org-english-insert-english-translation ()
  "Insert English translation into org capture entry."
  (let* ((url (format "http://wordnik.com/words/%s" (downcase org-english-word)))
         (buffer (url-retrieve-synchronously url t t))
         (vertico-sort-function nil))
    (with-temp-buffer
      (url-insert-buffer-contents buffer url)
      (completing-read "match" (split-string (funcall 'my/define-word--parse-wordnik) "\n")))))

(advice-add #'my/org-english-insert-english-translation :around #'my/define-word--fix-31)

(defun my/english-japanese-translate (word &optional sync)
  "Search Japanese translation for WORD and add it to kill ring.

SYNC handles whether network access procedure is synchronous.
Return translation result as a string If SYNC is non-nil.
If called interactively, display results and add them to kill ring."
  (let (trans)
    (request
      (concat "https://ejje.weblio.jp/content/" (downcase word))
      :sync sync
      :timeout 60
      :parser
      (lambda ()
        (let ((str (buffer-string)))
          (with-temp-buffer
            (insert str)
            (shr-render-region (point-min) (point-max))
            (buffer-substring-no-properties (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (and (string-match
               (rx (seq "意味・対訳 "
                        (group-n 1 (+ (or (category base)
                                          (category combining-diacritic)
                                          (category latin)
                                          (category japanese-katakana-two-byte)
                                          (category korean)
                                          (category greek))))))
               data)
              (setq trans (string-trim (match-string 1 data)))))))
    trans))

(defun my/english-pronunciation (word &optional sync)
  "Search pronunciation information for WORD and add it to kill ring.

SYNC handles whether network access procedure is synchronous.
Return search infromation as a string If SYNC is non-nil.
Display information and add it to kill ring if called interactively."
  (let (pron)
    (request
      (concat "https://eow.alc.co.jp/search?q=" (string-replace " " "+" (downcase word)))
      :sync sync
      :timeout 10
      :parser
      (lambda ()
        (let ((str (buffer-string)))
          (with-temp-buffer
            (insert str)
            (shr-render-region (point-min) (point-max))
            (buffer-substring-no-properties (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (and (string-match
               (rx (seq (opt "【レベル】" (** 1 2 digit) "、")
                        "【発音" (opt "！") "】"
                        (+ (or (category combining-diacritic)
                               (category latin)
                               (category japanese-katakana-two-byte)
                               (category korean)
                               (category greek)))
                        "、"
                        (? (or (seq "【＠】" (opt "[US]")
                                    (+ (or (category japanese-katakana-two-byte)
                                           "（" "）"))
                                    (? "、"))
                               (seq (+ any) "*")))))
               data)
              (setq pron (replace-regexp-in-string
                          "\\[\\(.\\{2\\}\\)\\]" "【\\1】"
                          (string-trim-right (match-string 0 data)
                                             "、")))))))
    pron))

(defmacro with-org-drill-english-config (&rest body)
  "Evaluate BODY with config for Org-Drill for english words review."
  `(progn
     (org-id-goto "de0983a7-9d1a-4ef8-b882-148c401e862d")
     (let (;; imperative settings
           (org-drill-scope 'tree)
           (org-drill-question-tag "drill")
           (org-drill-hide-item-headings-p t)
           ;; drill session regulations
           (org-drill-maximum-duration 25)
           (org-drill-maximum-items-per-session 50)
           ;; Definition of old and overdue items
           (org-drill-overdue-interval-factor 1.4) ; more permissive for overdue than 1.2 (default)
           (org-drill-days-before-old 15)
           ;; Spaced repetition algorithm
           (org-drill-spaced-repetition-algorithm 'sm5)
           (org-drill-sm5-initial-interval 7.0) ; initial step is 7 day
           ;; Random variation of repetition intervals
           (org-drill-add-random-noise-to-intervals-p t)
           ;; Adjustment for early or late review of items
           (org-drill-adjust-intervals-for-early-and-late-repetitions-p t)
           ;; Adjusting item difficulty globally
           (org-drill-learn-fraction 0.43) ; intend not to reschedule drastically forward in 10th+ interval
           (org-drill-leech-method nil)
           (org-startup-indented nil)
           (logos-hide-cursor t)
           (logos-hide-mode-line t)
           (logos-hide-buffer-boundaries t)
           (logos-buffer-read-only nil)
           (logos-olivetti nil)
           (logos-hide-fringe t))
       (org-indent-mode -1)
       (visual-line-mode 1)
       (text-scale-set -1)
       (logos-focus-mode 1)
       ,@body)
     (org-indent-mode 1)
     (text-scale-set 0)
     (visual-line-mode -1)
     (logos-focus-mode -1)))

;;;###autoload
(defun my/org-english-drill ()
  "Invoke Org-Drill for English word review."
  (interactive)
  (with-org-drill-english-config (org-drill)))

(defun my/org-english-drill-resume ()
  "Resume Org-Drill session for english word review."
  (interactive)
  (with-org-drill-english-config (org-drill-resume)))

(defun my/org-english-link ()
  "Make a link pointing the word with context."
  (interactive)
  (save-excursion
    (let ((current-prefix-arg '(4)))
      (call-interactively #'org-refile ))
    (call-interactively #'org-store-link))
  (let* ((contexts '("synonym" "antonym" "collocation"
                     "distinct" "similar" "akin" "relevant"
                     "morphological" "derivative"))
         (context (completing-read "Context: " contexts))
         (org-log-note-headings (append `((context . ,(format "<%s> %%s %%t" context)))
                                        org-log-note-headings))
         (link-str (with-temp-buffer
                     (call-interactively #'org-insert-last-stored-link)
                     (concat " " ; workaround for org-ql failing to recognize org-link with preceding "
                             (buffer-substring-no-properties (point-min) (1- (point-max)))
                             " "))))
    (org-add-log-setup 'context link-str
                       nil 'state (format-time-string (org-time-stamp-format t t)))
    (run-hooks 'post-command-hook)))

;;; Minor modes
;;;###autoload
(define-minor-mode org-english-mode
  "Buffer-local mode for English learning."
  :lighter " Eng"
  (when (boundp 'eldoc-documentation-functions)
    (add-hook 'eldoc-documentation-functions
              #'my/org-english-eldoc-documentation-function nil t)))

(defun my/org-english-eldoc-documentation-function (&rest args)
  "Return description of links both forward and backward "
  (when (and (derived-mode-p 'org-mode)
             (not (org-before-first-heading-p)))
    (string-join (append (my/org-english-links)
                         (my/org-english-backlinks))
                 " ")))

(defun my/org-english-links ()
  "Return description of all links."
  (org-with-wide-buffer
   (org-back-to-heading t)
   (let* ((case-fold-search t)
          (subtree-end (save-excursion
                         (org-end-of-subtree)
                         (point)))
          (re (rx-to-string `(seq
                              "- "
                              "<" (group (1+ alnum)) ">"
                              (1+ space)
                              "\" " (regexp ,org-link-any-re) " \"")))
          link-descs)
     (while (re-search-forward re subtree-end t)
       (push (match-string-no-properties 4)
             link-descs))
     link-descs)))

(defun my/org-english-backlinks ()
  "Return description of all backlinks."
  (mapcar (lambda (elem)
            (org-entry-get elem "ITEM"))
          (let* ((id (org-entry-get nil "ID"))
                 (custom_id (org-entry-get nil "CUSTOM_ID")))
            (when (or id custom_id)
              (org-ql-select (current-buffer)
                             (cond
                              ((and (stringp id) (stringp custom_id))
                               `(or (link :target ,id) (link :target ,custom_id)))
                              ((stringp id)
                               `(link :target ,id))
                              ((stringp custom_id)
                               `(link :target ,custom_id))))))))

(defun my/org-english-list-undrilled ()
  "List english words which haven't been tested before in level ascending order."
  (interactive)
  (with-current-buffer (find-file-noselect my/org-english-file)
    (org-ql-search my/org-english-file
      '(and (tags "drill")
            (tags "fd_en")
            (not (property "DRILL_LAST_REVIEWED")))
      :sort 'my/org-ql--english-level<)))

(defun my/org-english-search (word)
  "Look up WORD in my archive files using `org-ql-search'."
  (interactive (list (if (use-region-p)
                         (buffer-substring (region-beginning) (region-end))
                       (read-string "Word: "))))
  (org-ql-search
    my/org-english-file
    `(heading-regexp ,(eval `(rx word-start
                                 ,(downcase word)
                                 word-end)))))

(defun my/org-english-level (word)
  "Return difficulty level of `WORD' in number."
  (cl-labels ((parse-level (text)
                (if (string-match
                     (rx (seq "【レベル】"
                              (group-n 1 (repeat 1 2 digit))))
                     text)
                    (match-string 1 text)
                  nil)))
    (let ((local-str (with-current-buffer (find-file-noselect my/org-english-file)
                       (let ((headline (org-ql-select
                                         `(,my/org-english-file)
                                         `(and (heading-regexp ,(eval `(rx word-start
                                                                           ,(downcase word)
                                                                           word-end)))
                                               (tags "drill"))
                                         :action 'element-with-markers)))
                         (org-with-point-at (plist-get (cadar headline) :org-marker)
                           (org-get-entry))))))
      (string-to-number (or (and local-str
                                 (parse-level local-str))
                            ;; CAVEAT: getting level from web costs a lot
                            ;; (when-let ((remote-str (my/english-pronunciation word)))
                            ;;   (parse-level remote-str))
                            "99")))))

(defun my/org-ql--english-level< (a b)
  "Return non-nil if A's difficulty level is higher than B's.
A and B are Org headline elements."
  (cl-macrolet ((level (item)
                  `(my/org-english-level
                    (org-element-property :raw-value ,item))))
    (let ((a-level (level a))
          (b-level (level b)))
      (cond ((and (numberp a-level) (numberp b-level))
             (< a-level b-level))
            (a-level t)
            (b-level nil)))))

(provide 'org-english)
#+end_src

Call [[elisp:(call-interactively #'ert)][ERT]] with test-org-english-pron to test this code.

test code
#+begin_src emacs-lisp
(require 'ert)

(ert-deftest test-org-english-pron ()
  "Tests the output string of `my/org-english-insert-japanese-pronunciation'."
  (should (string= (my/org-english-insert-japanese-pronunciation "rife")
                   "【レベル】11、【発音】ráif、【＠】ライフ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "congregate")
                   "【レベル】12、【発音！】【US】《動》kɑ́ngrəgèit 《形》kɑ́ŋgrəgit ｜ 【UK】《動》kɔ́ŋgrigèit 《形》kɔ́ŋgrigit"))
  (should (string= (my/org-english-insert-japanese-pronunciation "unleash")
                   "【レベル】9、【発音】ʌ̀nlíːʃ、【＠】アンリーシュ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "homage")
                   "【レベル】11、【発音】【US】 hɑ́midʒ ｜ 【UK】 hɔ́midʒ、【＠】【US】ハミジ、【UK】ホミジ"))
  (should (string= (my/org-english-insert-japanese-pronunciation "interstitial")
                   "【発音】ìntərstíʃəl、【＠】インタ（ー）スティシャル"))
  (should (string= (my/org-english-insert-japanese-pronunciation "veterinarian")
                   "【レベル】12、【発音】vètərənέəriən、【＠】ヴェトラネアリアン"))
  (should (string= (my/org-english-insert-japanese-pronunciation "warehouse")
                   "【レベル】8、【発音！】《動》wέərhàuz 《名》wέərhàus、【＠】ウェアハウス、ウエアハウス"))
  (should (string= (my/org-english-insert-japanese-pronunciation "lambaste")
                   ""))
  (should (string= (my/org-english-insert-japanese-pronunciation "in a nutshell")
                   ""))
  (should (string= (my/org-english-insert-japanese-pronunciation "traverse")
                   "【レベル】8、【発音！】《名・形》trǽvəːrs 《動》trəvʌ́rs、【＠】トゥラヴァース、トラバース")))
#+end_src

**** org-relate                              :ARCHIVE:

#+begin_src emacs-lisp :tangle (expand-file-name "org-relate.el" tangle/emacs-sitelisp-dir)
(require 'thingatpt)
(require 'org-ql-search)

(defconst org-relate-property "PARENT"
  "Property name for child nodes to look up parent node.")
(defcustom org-relate-parent-tag-list
  `(,my/org-project-tag "refile")
  "A list of tags all parent nodes must have one of them.")
(defcustom org-relate-target-files
  (directory-files-recursively org-directory "\\.org$")
  "A list of target files to search relation nodes.")

(with-eval-after-load 'org
  (bind-key "C-c %" #'org-relate-search
            org-mode-map))

(with-eval-after-load 'org-keys
  (setf (map-elt org-speed-commands "%") #'org-relate-search)
  (setf (map-elt org-speed-commands "&") #'org-relate-interrelate)
  (push '("Org-Relate Operation") org-speed-commands))

(with-eval-after-load 'org-agenda
  (bind-keys :map org-agenda-mode-map
             ("&" . org-agenda-relation-interrelate)))

(defun org-relate-search ()
  "Search for entries related to the entry at point.

User who would like to search for parent and children of that, namely siblings,
 must press 'p'.
User who would like to search for children of this entry must press 'c'.
User who would like to search for friends either pointing to this entry
 or pointed from this entry must be press 'f'.
User who would like to search for all listed above must press 'a'."
  (interactive)
  (let* ((org-super-agenda-properties-inherit nil)
         (char (read-char-from-minibuffer "Target: [a]ll [p]arent [c]hild [f]riend"))
         (queries (seq-remove 'null
                              (cond
                               ((equal char ?a) (list (org-relate--search-parent-org-ql-query)
                                                      (org-relate--search-children-org-ql-query)
                                                      (org-relate--search-friends-refer-org-ql-query)
                                                      (org-relate--search-friends-referred-org-ql-query)
                                                      (org-relate--search-siblings-org-ql-query)))
                               ((equal char ?p) (list (org-relate--search-parent-org-ql-query)
                                                      (org-relate--search-siblings-org-ql-query)))
                               ((equal char ?c) (list (org-relate--search-children-org-ql-query)))
                               ((equal char ?f) (list (org-relate--search-friends-refer-org-ql-query)
                                                      (org-relate--search-friends-referred-org-ql-query)))))))
    (if queries
        (org-ql-search org-relate-target-files
          (seq-reduce (lambda (accum elem)
                        (push elem (cdr (last accum)))
                        accum)
                      (mapcar 'car queries)
                      '(or))
          :super-groups (mapcar 'cdr queries))
      (message "No query found"))))

(defun org-relate--search-children-org-ql-query ()
  (when-let* ((id (org-id-get))
              (rel-prop-link (format "[[id:%s]]" id)))
    `((or (property ,org-relate-property ,id)
          (property ,org-relate-property ,rel-prop-link)) .
          (:name "Children" :auto-property ,org-relate-property))))

(defun org-relate--search-parent-org-ql-query ()
  (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
            (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
            (parent-id (match-string 0 prop-ref)))
      `((property "ID" ,parent-id) .
        (:name "Parent" :auto-property "ID"))))

(defun org-relate--search-siblings-org-ql-query ()
  (if-let* ((prop-ref (org-entry-get (point) org-relate-property))
            (index (string-match (format "\\(%s\\)" thing-at-point-uuid-regexp) prop-ref))
            (parent-id (match-string 0 prop-ref))
            (parent-id-link (format "[[id:%s]]" parent-id)))
      `((or (property ,org-relate-property ,parent-id)
            (property ,org-relate-property ,parent-id-link)) .
            (:name "Siblings" :auto-property ,org-relate-property))))

(defun org-relate--search-friends-refer-org-ql-query ()
  (when-let* ((id (org-id-get))
              (ref-re (format "\\[\\[id:%s\\].*\\]" id)))
    `((regexp ,ref-re) .
      (:name "Friends pointing to this entry" :regexp ,ref-re))))

(defun org-relate--search-friends-referred-org-ql-query ()
  (let* ((id-link-re (format "\\[\\[id:\\(%s\\)\\].*\\]" thing-at-point-uuid-regexp))
         (end (or (save-excursion
                    (outline-next-heading))
                  (point-max))))
    (when (save-excursion
            (re-search-forward id-link-re end t))
      `((property "ID" ,(match-string 1)) .
        (:name "Friends to whom this entry is pointing" :auto-property ("ID" ,(match-string 1)))))))

(defun org-relate-interrelate ()
  "Make parent-child relationship by inserting property.

This command must be called in parent node which should have one of `org-relate-parent-tag-list'."
  (interactive)
  ;; relate the entry at point and its children if the entry has some of `org-relate-parent-tag-list'
  (save-excursion
    (org-back-to-heading)
    (when (cl-some (lambda (parent-tag)
                     (member parent-tag (org-get-tags)))
                   org-relate-parent-tag-list)
      (let* ((ref-id (org-id-get-create))
             (ent-link (format "[[id:%s]]" ref-id)))
        (and (org-goto-first-child)
             (cl-labels ((set-ref-id-to-siblings
                           (ref-link)
                           (org-set-property org-relate-property
                                             ref-link)
                           (and (org-goto-sibling)
                                (set-ref-id-to-siblings ref-link))))
               (set-ref-id-to-siblings ent-link))))))
  ;; relate the entry at point and a parent if the parent has some of `org-relate-parent-tag-list'
  (let (parent-link)
    (save-excursion
      (org-up-heading-safe)
      (when (seq-some (lambda (parent-tag)
                        (member parent-tag (org-get-tags)))
                      org-relate-parent-tag-list)
        (setq parent-link (format "[[id:%s]]" (org-id-get-create)))))
    (and parent-link
         (org-set-property org-relate-property
                           parent-link))))

(defun org-agenda-relation-interrelate ()
  "Invoke `org-relate-interrelate' in agenda view."
  (interactive)
  (org-agenda-check-no-diary)
  (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                       (org-agenda-error)))
         (buffer (marker-buffer hdmarker))
         (pos (marker-position hdmarker))
         (inhibit-read-only t)
         newhead)
    (org-with-remote-undo buffer
      (with-current-buffer buffer
        (widen)
        (goto-char pos)
        (org-show-context 'agenda)
        (call-interactively 'org-relate-interrelate)
        (end-of-line 1)
        (setq newhead (org-get-heading))))))

(provide 'org-relate)
#+end_src

**** org-clocktable-by-tag

Provide a function to Build a clock table summing up time by tag.

#+begin_src emacs-lisp :tangle (expand-file-name "org-config.el" tangle/emacs-config-dir)
(with-eval-after-load 'org
  (require 'org-clocktable-by-tag))
#+end_src

#+begin_src emacs-lisp :tangle (expand-file-name "org-clocktable-by-tag.el" tangle/emacs-sitelisp-dir)
(require 'org-table)
(require 'org-clock)

(defun clocktable-by-tag/shift-cell (n)
  (let ((str ""))
    (dotimes (i n)
      (setq str (concat str "| ")))
    str))

(defun clocktable-by-tag/insert-tag (params)
  (let ((match (plist-get params :match)))
    (insert "|--\n")
    (insert (format "| %s | *Tag time* |\n" match))
    (let ((total 0))
      (mapcar
       (lambda (file)
         (let ((clock-data (with-current-buffer (find-file-noselect file)
                             (org-clock-get-table-data (buffer-name) params))))
           (when (> (nth 1 clock-data) 0)
             (setq total (+ total (nth 1 clock-data)))
             (insert (format "| | File *%s* | %.2f |\n"
                             (file-name-nondirectory file)
                             (/ (nth 1 clock-data) 60.0)))
             (dolist (entry (nth 2 clock-data))
               (insert (format "| | . %s%s | %s %.2f |\n"
                               (org-clocktable-indent-string (nth 0 entry))
                               (replace-regexp-in-string "|" "\\vert\{\}" (nth 1 entry) nil t)
                               (clocktable-by-tag/shift-cell (nth 0 entry))
                               (/ (nth 4 entry) 60.0)))))))
       (org-agenda-files))
      (if (= total 0)
          (save-excursion
            (re-search-backward "*Tag time*")
            (forward-line -1)
            (dotimes (i 2)
              (org-table-kill-row)))
        (save-excursion
          (re-search-backward "*Tag time*")
          (org-table-next-field)
          (org-table-blank-field)
          (insert (format "*%.2f*" (/ total 60.0))))))
    (org-table-align)))

;;;###autoload
(defun org-dblock-write:clocktable-by-tag (params)
  (funcall indent-line-function)
  (insert "| Tag | Headline | Time (h) |\n")
  (insert "|     |          | <r>  |\n")
  (let ((matches
         (org-global-tags-completion-table)))
    (mapcar (lambda (match)
              (let ((match-str (car match))
                    (case-fold-search nil))
                (when (string-match-p "^AC_" match-str)
                  (setq params (plist-put params :match match-str))
                  (clocktable-by-tag/insert-tag params))))
            matches)))

(provide 'org-clocktable-by-tag)
#+end_src

**** weather

#+begin_src emacs-lisp :tangle (expand-file-name "weather.el" tangle/emacs-sitelisp-dir)
;; 気象庁配信の天気情報を加工して表示

(require 'request)
(require 'cl-lib)

(defvar weather-areas
  '(((url . "http://www.drk7.jp/weather/xml/14.xml")
     (pref . "神奈川県")
     (area . "西部"))
    ((url . "http://www.drk7.jp/weather/xml/22.xml")
     (pref . "静岡県")
     (area . "中部"))))

(defun weather-area-show (weather-area-alist weather-buffer)
  (lexical-let ((url (assoc-default 'url weather-area-alist))
                (pref (assoc-default 'pref weather-area-alist))
                (area (assoc-default 'area weather-area-alist))
                (buffer weather-buffer))
    (request
      url
      :parser
      (lambda ()
        (let ((xml-string (string-as-multibyte (string-as-unibyte (buffer-string)))))
          (with-temp-buffer
            (erase-buffer)
            (insert xml-string)
            (libxml-parse-xml-region (point-min) (point-max)))))
      :success
      (cl-function
       (lambda (&key data &allow-other-keys)
         (when data
           (with-current-buffer buffer
             (insert (format "%s %s\n" pref area))
             (mapcar
              (lambda (info-node)
                (insert
                 (format "%s %s %s %s\n"
                         (dom-attr info-node 'date)
                         (apply (lambda (max-temp-node min-temp-node)
                                  (format "%2d/%2d℃"
                                          (string-to-number (dom-text min-temp-node))
                                          (string-to-number (dom-text max-temp-node))))
                                (dom-by-tag (dom-child-by-tag info-node 'temperature) 'range))
                         (apply (lambda (node-1 node-2 node-3 node-4)
                                  (format "%2d-%2d-%2d-%2d％"
                                          (string-to-number (dom-text node-1))
                                          (string-to-number (dom-text node-2))
                                          (string-to-number (dom-text node-3))
                                          (string-to-number (dom-text node-4))))
                                (dom-by-tag (dom-child-by-tag info-node 'rainfallchance) 'period))
                         (dom-text (dom-child-by-tag info-node 'weather)))))
              (dom-by-tag (dom-by-id data area) 'info))
             (insert "\n"))))))))

(defun weather ()
  (interactive)
  (let ((buffer (get-buffer-create "weather")))
    (mapcar (lambda (weather-area)
              (weather-area-show weather-area buffer))
            weather-areas)
    (switch-to-buffer buffer)))

(provide 'weather)
#+end_src

**** Package: dispatch-dwim                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-03-29 Fri 14:57]
:END:

#+NAME: package/dispatch-dwim
#+begin_src emacs-lisp :comments no :tangle no
(require 'transient)
(require 'detached)

;;; Variables

(defvar dispatch-dwim--precedings-followings nil)
(defvar dispatch-dwim--overriding-method nil)

(defvar dispatch-dwim--default-method 'detached-shell-command)

(add-hook 'transient-exit-hook
          (lambda () (unless transient--stack
                   (setq dispatch-dwim--precedings-followings nil
                         dispatch-dwim--overriding-method nil))))

;;; Classes & Objects

(defclass dispatch-shell-command (transient-suffix)
  ((command-format :initarg :command-format :initform "%a")
   (command-format-spec :initarg :command-format-spec :initform nil)
   (dispatch-method :initarg :dispatch-method)))

(cl-defmethod transient-init-value ((obj dispatch-shell-command))
  (unless (slot-boundp obj :command-format)
    (oset obj command-format "%a"))
  (oset obj dispatch-method
        (cond
         ((and transient--stack
               dispatch-dwim--overriding-method))
         ((member major-mode '(minibuffer-mode eshell-mode))
          'insert)
         (t dispatch-dwim--default-method))))

(transient-define-suffix dispatch-dwim-execute ()
  :class dispatch-shell-command
  :transient 'transient--do-return
  :key "RET" :description "execute"
  (interactive)
  (let* ((cur-obj (transient-suffix-object))
         (command-format-spec (and (slot-boundp cur-obj :command-format-spec)
                                   (oref cur-obj command-format-spec)))
         (main-comm (format-spec
                     (replace-regexp-in-string
                      "\\\\\%" "\\\\\%\%" ; avoid replacing "\%" in shell argument
                      (eval (oref cur-obj command-format)))
                     (append
                      `((?a . ,(string-join (transient-get-value) " ")))
                      (when command-format-spec
                        (mapcar (lambda (key-val) (cons (car key-val) (eval (cdr key-val))))
                                command-format-spec)))))
         (comm (mapconcat (lambda (elm)
                            (when (length> (cadr elm) 0)
                              (concat (cadr elm) "; ")))
                          (sort (append dispatch-dwim--precedings-followings
                                        `(("@" ,main-comm 50)))
                                (lambda (a b) (< (nth 2 a) (nth 2 b)))))))
    (apply (oref cur-obj dispatch-method)
           `(,(if transient--stack
                  main-comm comm)))
    (unless transient--stack
      (setq dispatch-dwim--precedings-followings nil))))

(defclass dispatch-dwim-stack-suffix (transient-suffix)
  ((prefix :initarg :prefix)
   (prefix-arg :initarg :prefix-arg :initform nil)
   (priority :initarg :priority :initform 0)
   (default :initarg :default)
   (format :initform " %k %d (%v)")))

(transient-define-suffix dispatch-dwim-fraction-command ()
  :class dispatch-dwim-stack-suffix
  :transient 'transient--do-recurse
  (interactive)
  (let ((cur-obj (transient-suffix-object)))
    (setq dispatch-dwim--overriding-method
          (lambda (shell-command)
            (setf (alist-get (oref cur-obj key) dispatch-dwim--precedings-followings)
                  (list shell-command
                        (oref cur-obj priority)))))
    (apply (oref cur-obj prefix)
           (oref cur-obj prefix-arg))))

(cl-defmethod transient-init-value ((obj dispatch-dwim-stack-suffix))
  (when (slot-boundp obj :default)
    (setf (alist-get (oref obj key) dispatch-dwim--precedings-followings)
          (list (oref obj default)
                (oref obj priority)))))

(cl-defmethod transient-format-value ((obj dispatch-dwim-stack-suffix))
  (if-let ((comm (assoc (oref obj key)
                        dispatch-dwim--precedings-followings)))
      (propertize (cadr comm)
                  'face 'transient-argument)
    ""))

(cl-defmethod transient-format ((obj dispatch-dwim-stack-suffix))
  (format-spec (oref obj format)
               `((?k . ,(transient-format-key obj))
                 (?d . ,(transient-format-description obj))
                 (?v . ,(transient-format-value obj)))))

(defun dispatch-shell-command--key-vals (keys)
  (mapconcat 'transient-infix-value
             (seq-filter (lambda (obj) (and (member (oref obj key) keys) obj))
                         (transient-suffixes (oref transient-current-prefix command)))
             " "))

;;; Functions

(defmacro dispatch-dwim-determine-file-name ()
  "Determine the available file name depending on the condition."
  `(cond
    ((derived-mode-p 'dired-mode)
     (dired-get-marked-files))
    ((derived-mode-p 'minibuffer-mode)
     (cond
      ((equal minibuffer-history-variable 'dired-shell-command-history)
       " * ")
      ((or (member minibuffer-history-variable
                   '(detached-shell-command-history
                     shell-command-history)))
       (with-current-buffer (other-buffer nil t)
         (when (derived-mode-p 'dired-mode)
           (dired-get-marked-files))))))
    (t (ffap-file-at-point))))

(defmacro dispatch-dwim-determine-url ()
  "Determine the URL for dispatch-dwim commands, respecting the conditions."
  '(cond
    ((thing-at-point-url-at-point))
    ((derived-mode-p 'org-mode)
     (org-link-at-point-map #'car))
    ((derived-mode-p 'eww-mode)
     (or (shr-url-at-point nil)
         (plist-get eww-data :url)))))

(defun dispatch-dwim-shell-argument (arg)
  "Return a ARG's valid format for shell arguments."
  (pcase arg
    ((and (pred (lambda (a) (member a `(" * " "?" "`?`")))) file-substitute)
     file-substitute)
    ((and (pred stringp) (pred file-exists-p) file)
     (shell-quote-argument (expand-file-name file)))
    ((and (pred stringp) (pred (string-match ffap-url-regexp)) url)
     (format "'%s'" url))
    ((and (pred listp) li) (mapconcat #'dispatch-dwim-shell-argument li " "))))

(provide 'dispatch-dwim)
#+end_src

**** Package: fingertip mode
:PROPERTIES:
:CREATED:  [2024-04-10 Wed 00:24]
:END:

#+NAME: package/fingertip-mode
#+header: :shebang ""
#+begin_src emacs-lisp :comments no :tangle (expand-file-name "fingertip.el" tangle/emacs-sitelisp-dir)
;;; fingertip.el --- one-handed buffer browsing -*- lexical-binding: t -*-

;; Author: p-snow
;; Version: 0.0.1
;; Package-Requires: no
;; Homepage: homepage
;; Keywords: files

;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; commentary

;;; Code:

(defgroup fingertip nil
  "Customization group for fingertip minor mode."
  :group 'text)

(defvar-keymap fingertip-mode-map
  :doc "Keymap for `fingertip-mode'."
  "f" #'scroll-up-line
  "e" #'scroll-down-line
  "SPC" #'fingertip-forward-paragraph
  "E" #'fingertip-backward-paragraph
  ">" #'fingertip-scroll-left-column
  "<" #'fingertip-scroll-right-column)

;;; Minor modes
;;;###autoload
(define-minor-mode fingertip-mode
  "Buffer-local mode for one-handed file browsing."
  :init-value nil
  :global nil
  :lighter " FGT"
  :keymap fingertip-mode-map)

(defun fingertip-forward-paragraph ()
  (interactive)
  (forward-paragraph 2)
  (backward-paragraph 1)
  (forward-line 1)
  (recenter-top-bottom 0))

(defun fingertip-backward-paragraph ()
  (interactive)
  (backward-paragraph 2)
  (forward-paragraph 1)
  (backward-paragraph 1)
  (forward-line 1)
  (recenter-top-bottom 0))

(defun fingertip-scroll-left-column ()
  (interactive)
  (scroll-left 1))

(defun fingertip-scroll-right-column ()
  (interactive)
  (scroll-right 1))

(provide 'fingertip)
;;; fingertip.el ends here
#+end_src

** Findutils

[[https://www.gnu.org/software/findutils/][GNU Findutils]] offers following commands
- find
- locate
- updatedb
- xargs

'locate' is GNU implementation of mlocate. I prefer '[[id:c56e19dd-d3b1-4595-be74-0ff7c6558bc8][plocate]]', which is fast than mlocate, for indexed file searching,

#+begin_src scheme :noweb-ref guix-base
"findutils"
#+end_src

** plocate
:PROPERTIES:
:CREATED:  [2022-10-11 Tue 16:52]
:ID:       c56e19dd-d3b1-4595-be74-0ff7c6558bc8
:END:

#+begin_src scheme :noweb-ref guix-base
"plocate"
#+end_src

#+name: locate-db-home
#+begin_src sh :noweb yes :tangle no :results output
echo -n '<<share-dir()>>/plocate/home.db'
#+end_src

#+name: locate-db-doc
#+begin_src sh :noweb yes :tangle no :results output
echo -n '<<share-dir()>>/plocate/doc.db'
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
export LOCATE_PATH=<<locate-db-home()>>
#+end_src

#+name: bin/updatedb-home
#+begin_src bash :noweb tangle :tangle (expand-file-name "updatedb-home" tangle/local-bin-dir)
$GUIX_EXTRA_PROFILES/base/base/sbin/updatedb -l 0 -U <<home-dir()>> --prune-bind-mounts 0 \
                                             -e <<htmlize-dir()>> \
                                             -e <<trash-dir()>> \
                                             -o <<locate-db-home()>>

$GUIX_EXTRA_PROFILES/base/base/sbin/updatedb -l 0 -U /mnt/pt-shared/doc-$(hostname)/ --prune-bind-mounts 0 \
                                             -o <<locate-db-doc()>>
#+end_src

#+begin_src conf :noweb yes :noweb-ref cronjob-user
,*/20 * * * * /usr/bin/bash -ci "updatedb-home"
#+end_src

** Git

#+begin_src scheme :noweb-ref guix-base
"git"
#+end_src

*** git ignore

#+BEGIN_SRC conf :tangle (expand-file-name ".config/git/info/ignore")
#
# ~/.gitignote
#
## Compiled object files ##
,*.slo
,*.lo
,*.o
,*.obj

## Compiled Dynamic libraries ##
,*.so
,*.dylib
,*.dll

## Compiled Static libraries ##
,*.lai
,*.la
,*.a
,*.lib

## Executables ##
,*.out
,*.app

## Windows ##
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
,*.cab
,*.msm
,*.msp

## Mac ##
.DS_Store
.AppleDouble
.LSOverride
.Spotlight-V100
.Trashes
._*

## Linux ##
locate.db

## version control system ##
.git/
.hg/
.svn/

## backup,log ##
,*~
~*
,*.swp
.swp.*
,*.tmp
,*.bak
,*.old
,*.log
.cache/
,*.autosave

## Emacs ##
,*.elc

## Vim ##
,*.un~
Session.vim
.netrwhist

## GNU GLOBAL ##
GPATH
GRTAGS
GTAGS

## netbeans ##
nbproject/
## intellij idea ##
.idea/
## eclipse ##
.settings/
.project
.classpath
.buildpath
## XCode ##
,*.xcodeproj/*

## Build dir ##
build/
#+END_SRC

*** git config

[[https://magit.vc/manual/magit/How-to-show-diffs-for-gpg_002dencrypted-files_003f.html][This page]] show you how to get diffs of gpg files in Magit.

#+BEGIN_SRC gitconfig :noweb tangle :tangle (expand-file-name ".config/git/config") :comments no
[core]
	excludesfile = <<home-dir()>>/.config/git/info/ignore
	attributesfile = <<home-dir()>>/.config/git/info/attributes
	editor = emacs
	symlinks = true
	# Unicode
	precomposeunicode = true
	quotepath = true
	autocrlf = false
[push]
	# simple,matching,upstream,current
	default = simple
[color]
	ui = auto
	status = auto
	diff = auto
	branch = auto
	interactive = auto
	grep = auto
[diff]
	patience = true
[diff "gpg"]
	textconv = gpg --no-tty --decrypt
[diff "common-lisp"]
	xfuncname="^\\((def\\S+\\s+\\S+)"
[diff "elisp"]
	xfuncname="^\\((((def\\S+)|use-package)\\s+\\S+)"
[diff "org"]
	xfuncname="^\\*+ +(.*)$"
[help]
	autocorrect = 0
[alias]
	co = checkout
	ca = commit -a -v
	ce = commit -v --amend
	st = status --branch --short
	si = status --ignored --short
	branches = branch -a
	remotes = remote -v
	tags = tag -l
	lg = log --graph --all --decorate --abbrev-commit --branches --date=short --pretty=format:\"%C(red)%h%C(reset) %C(green)[%ad]%C(reset) %s %C(cyan)@%an%C(reset) %C(yellow)%d%C(reset)\"
	fp = fetch --prune
	di = diff
	dh = diff --histogram
	dw = diff --word-diff
	dc = diff --cached
	wc = whatchanged
[user]
	email = <<email-pub>>
	name = p-snow
	signingkey = 0D2BAF0E8AEF0306
[commit]
	gpgsign = true
[github]
	user = p-snow
[gitlab]
	user = p-snow
<<git-config>>
#+END_SRC
*** git attributes

#+BEGIN_SRC gitattributes :tangle (expand-file-name ".config/git/info/attributes") :comments no
,*.c diff=cpp
,*.h diff=cpp
,*.cpp diff=cpp
,*.hpp diff=cpp
,*.cs diff=csharp
,*.m diff=objc
,*.java diff=java
,*.html diff=html
,*.xml diff=html
,*.pl diff=perl
,*.pm diff=perl
,*.t diff=perl
,*.php diff=php
,*.ptml diff=php
,*.py diff=python
,*.rb diff=ruby
,*.js diff=java
,*.csv encoding=cp932
,*.json diff=json
,*.gpg filter=gpg diff=gpg
,*.org diff=org
,*.lisp diff=common-lisp
,*.el diff=elisp
#+END_SRC

** pass-git-helper

[[https://github.com/languitar/pass-git-helper][pass-git-helper]] is a utility program that allows users to use password-store's passwords for git credentials.

#+begin_src scheme :noweb-ref guix-base
"pass-git-helper"
#+end_src

#+begin_src gitconfig :noweb yes :tangle no :noweb-ref git-config
[credential]
	helper = !pass-git-helper -m <<home-dir()>>/.config/pass-git-helper/git-pass-mapping.ini $@
#+end_src

** git-annex

[[https://git-annex.branchable.com/git-annex/][git-annex]] aims to manage large files based on git system. It is alse designed to manage copies of binary in distributed repositories. [[https://git-annex.branchable.com/walkthrough/][walkthrough]] offers handy instruction.

[[https://git-lfs.github.com/][Git-LFS]] is alse designed to manage large files. [[https://lwn.net/Articles/774125/][This article]] compares Git-LFS and git-annex precisely.

#+begin_src scheme :noweb-ref guix-base
"git-annex"
"rclone"
"git-remote-gcrypt"
#+end_src

#+begin_src gitconfig :noweb-ref git-config
[annex]
	youtube-dl-command = yt-dlp
	synccontent = false
[annex.security]
	allowed-ip-addresses = all
[safe]
	directory = /mnt/ns01/doc
#+end_src

*** sync annex repos
:PROPERTIES:
:CREATED:  [2023-12-06 Wed 16:59]
:ID:       e9524731-4acc-4f4c-bc61-0226990a654a
:END:

#+begin_src conf :noweb yes :noweb-ref cronjob-user
15 */2 * * * /usr/bin/bash -ci "sync-doc 2>&1 | tee -a <<log-dir()>>/sync-git-annex.log"
#+end_src

#+name: sync-doc
#+begin_src bash :noweb tangle :tangle (expand-file-name "sync-doc" tangle/local-bin-dir)
function sync_doc {
  if cd $1; then
    if [ $2 -ne 0 ]; then
      (git rev-parse --is-inside-work-tree 2>/dev/null && git annex sync && git annex get)
    else
      (git rev-parse --is-inside-work-tree 2>/dev/null && git annex sync)
    fi
  fi
}

sync_doc /mnt/vt-m/doc/ 0
sync_doc /mnt/vt-h/doc/ 0
sync_doc /mnt/vt-j/doc/ 0
sync_doc /mnt/pt-shared/doc-$(hostname)/ 0
sync_doc /mnt/vt-m/doc/ 1
sync_doc /mnt/vt-h/doc/ 1
sync_doc /mnt/vt-j/doc/ 1
#+end_src

** ghq

[[https://github.com/x-motemen/ghq][ghq]] is management system for remote git repositories.

#+begin_src scheme :noweb-ref guix-base
"ghq"
#+end_src

#+begin_src gitconfig :noweb yes :noweb-ref git-config
[ghq]
	root = <<ghq-root()>>
#+end_src

#+begin_src conf :tangle (expand-file-name "ghq" tangle/config-dir)
[github.com*]
username_extractor=specific_line
line_username=2
target=github.com
# username_extractor=entry_name
#+end_src

#+NAME: ghq-proj-path
#+HEADER: :var name="p-snow/guix-channel"
#+begin_src shell :tangle no
ghq list --full-path $name | head -n 1 | sed "s:$HOME:~:"
#+end_src

*** personal ghq environment
:PROPERTIES:
:CREATED:  [2024-04-15 Mon 16:41]
:END:

#+name: ghq-root
#+begin_src sh :noweb yes :eval no-export
echo -n '<<share-dir()>>/ghq'
#+end_src

** Pass

[[https://www.passwordstore.org/][Pass]] is a simple password manager.

I've chosen to use gpg/gpg-agent and pass on Ubuntu system since pass (password-store) spouts a warning saying there's gpg version mismatch persistently.
#+begin_src scheme :noweb-ref guix-base
;; "password-store"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/pass-git-helper/git-pass-mapping.ini")
[github.com*]
username_extractor=specific_line
line_username=2
target=github.com
# username_extractor=entry_name
#+end_src

- additional environment variables
  #+BEGIN_SRC shell :noweb-ref bashrc
  export PASSWORD_STORE_CLIP_TIME=25
  #+END_SRC
** mpv

#+begin_src scheme :noweb-ref guix-base
"mpv-libarchive"
#+end_src

- mpv.conf
  #+begin_src conf :tangle (expand-file-name ".config/mpv/mpv.conf")
  ##################
  # video settings #
  ##################

  # Start in fullscreen mode by default.
  fs=yes


  ###########
  # General #
  ###########

  quiet
  save-position-on-quit
  no-border                               # no window title bar
  msg-module                              # prepend module name to log messages
  msg-color                               # color log messages on terminal
  term-osd-bar                            # display a progress bar on the terminal
  use-filedir-conf                        # look for additional config files in the directory of the opened file
  pause                                   # no autoplay
  force-window=immediate
  keep-open                               # keep the player open when a file's end is reached
  autofit-larger=100%x95%                 # resize window in case it's larger than W%xH% of the screen
  cursor-autohide-fs-only                 # don't autohide the cursor in window mode, only fullscreen
  # input-media-keys=no                     # enable/disable OSX media keys
  cursor-autohide=1000                    # autohide the curser after 1s

  screenshot-format=png
  screenshot-png-compression=8
  screenshot-template='~/Pictures/%F (%p)'

  hls-bitrate=max                         # use max quality for HLS streams


  #########
  # Cache #
  #########

  cache=yes
  cache-secs=10                           # how many seconds of audio/video to prefetch if the cache is active


  #############
  # OSD / OSC #
  #############

  osd-level=1                             # enable osd and display --osd-status-msg on interaction
  osd-duration=2500                       # hide the osd after x ms
  osd-status-msg='${time-pos} / ${duration}${?percent-pos: (${percent-pos}%)}${?frame-drop-count:${!frame-drop-count==0: Dropped: ${frame-drop-count}}}\n${?chapter:Chapter: ${chapter}}'
  # osd-status-msg='${=time-pos}'         # show raw position

  osd-font='Source Sans Pro'
  osd-font-size=96
  osd-color='#CCFFFFFF'                   # ARGB format
  osd-border-color='#DD322640'            # ARGB format
  #osd-shadow-offset=1                    # pixel width for osd text and progress bar
  osd-bar-align-y=0                       # progress bar y alignment (-1 top, 0 centered, 1 bottom)
  osd-border-size=2                       # size for osd text and progress bar
  osd-bar-h=2                             # height of osd bar as a fractional percentage of your screen height
  osd-bar-w=60                            # width of " " "


  #############
  # Subtitles #
  #############

  sub-use-margins
  sub-ass-force-margins

  demuxer-mkv-subtitle-preroll            # try to correctly show embedded subs when seeking
  sub-auto=fuzzy                          # external subs don't have to match the file name exactly to autoload
  embeddedfonts=yes                       # use embedded fonts for SSA/ASS subs
  sub-fix-timing=no                       # do not try to fix gaps (which might make it worse in some cases)
  sub-ass-style-overrides=Kerning=yes     # allows you to override style parameters of ASS scripts

  # the following options only apply to subtitles without own styling (i.e. not ASS but e.g. SRT)
  sub-font="Source Sans Pro Semibold"
  sub-font-size=36
  sub-color="#FFFFFFFF"
  sub-border-color="#FF262626"
  sub-border-size=3.2
  sub-shadow-offset=1
  sub-shadow-color="#33000000"
  sub-spacing=0.5


  #############
  # Languages #
  #############

  slang=enm,en,eng,de,deu,ger             # automatically select these subtitles (decreasing priority)
  alang=ja,jp,jpn,en,eng,de,deu,ger       # automatically select these audio tracks (decreasing priority)

  #########
  # Image #
  #########

  image-display-duration=4

  #########
  # Audio #
  #########

  audio-file-auto=fuzzy                   # external audio doesn't has to match the file name exactly to autoload
  audio-pitch-correction=yes              # automatically insert scaletempo when playing with higher speed
  volume-max=200                          # maximum volume in %, everything above 100 results in amplification
  volume=100                              # default volume, 100 = unchanged


  ################
  # Video Output #
  ################

  # Active VOs (and some other options) are set conditionally
  # See here for more information: https://github.com/wm4/mpv-scripts/blob/master/auto-profiles.lua
  # The script was modified to import functions from scripts/auto-profiles-functions.lua

  # Defaults for all profiles
  tscale=catmull_rom                      # sharp: oversample <-> linear (triangle) <-> catmull_rom <-> mitchell <-> gaussian <-> bicubic : smooth
  opengl-early-flush=no
  opengl-pbo=yes


  [high-quality]
  profile-desc=cond:is_desktop() and get('width', math.huge) < 3840
  scale=ewa_lanczossharp
  cscale=ewa_lanczossoft
  dscale=mitchell
  scale-antiring=0.7
  cscale-antiring=0.7
  dither-depth=auto
  correct-downscaling=yes
  sigmoid-upscaling=yes
  deband=yes
  hwdec=no

  [mid-quality]
  profile-desc=cond:(is_laptop() and not on_battery() and get('width', math.huge) < 1920) or (is_desktop() and get('width', math.huge) >= 3840)
  scale=spline36
  cscale=bilinear
  dscale=mitchell
  scale-antiring=1.0
  cscale-antiring=1.0
  dither-depth=auto
  correct-downscaling=yes
  sigmoid-upscaling=yes
  deband=yes
  hwdec=no

  [low-quality]
  profile-desc=cond:is_laptop() and (on_battery() or get('width', math.huge) >= 1920)
  scale=bilinear
  cscale=bilinear
  dscale=bilinear
  scale-antiring=0.0
  cscale-antiring=0.0
  dither-depth=no
  correct-downscaling=no
  sigmoid-upscaling=no
  deband=no
  hwdec=auto

  [60FPS]
  profile-desc=cond:is_laptop() and get('container-fps', 0) >= 59
  scale=bilinear
  cscale=bilinear

  [4K]
  profile-desc=cond:get('width', -math.huge) >= 3840
  vd-lavc-threads=32

  [4K-inverted]
  profile-desc=cond:get('width', -math.huge) < 3840
  vd-lavc-threads=0


  [default]


  ###################################
  # Protocol Specific Configuration #
  ###################################

  [protocol.https]
  #cache=yes
  #cache-default=500000                    # size in KB
  #cache-backbuffer=250000                 # size in KB
  cache-secs=100                          # how many seconds of audio/video to prefetch
  user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

  [protocol.http]
  #cache=yes
  #cache-default=500000                    # size in KB
  #cache-backbuffer=250000                 # size in KB
  cache-secs=100                          # how many seconds of audio/video to prefetch
  user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0'

  [extension.gif]
  cache=no
  no-pause
  loop-file=yes

  [extension.webm]
  #cache=no
  #no-pause
  #loop-file=yes
  #+end_src
- input.conf
  [[~/data/home/.local/share/ghq/github.com/mpv-player/mpv/etc/input.conf][input.conf (sample)]]
  #+begin_src conf  :tangle (expand-file-name "mpv/input.conf" tangle/config-dir)
  RIGHT  seek  5
  LEFT   seek -5
  UP     seek -60
  DOWN   seek  60

  Ctrl+f seek  5
  Ctrl+b seek -5
  Ctrl+p seek -60
  Ctrl+n seek  60

  Ctrl+m playlist-next
  Ctrl+M playlist-prev

  PGUP add chapter -1
  PGDWN add chapter 1

  / add volume 2
  ? add volume -2

  % playlist-shuffle
  ENTER playlist-next
  Shift+ENTER playlist-prev

  r cycle_values video-rotate 90 180 270 0
  R cycle_values video-rotate 270 180 90 0
  #+end_src
- scripts
  #+begin_src lua :tangle (expand-file-name ".config/mpv/scripts/delete_file.lua") :comments no
    local utils = require "mp.utils"

    del_list = {}

    function contains_item(l, i)
       for k, v in pairs(l) do
          if v == i then
             mp.osd_message("undeleting current file")
             l[k] = nil
             return true
          end
       end
       mp.osd_message("deleting current file")
       return false
    end

    function mark_delete()
       local work_dir = mp.get_property_native("working-directory")
       local file_path = mp.get_property_native("path")
       local s = file_path:find(work_dir, 0, true)
       local final_path
       if s and s == 0 then
          final_path = file_path
       else
          final_path = utils.join_path(work_dir, file_path)
       end
       if not contains_item(del_list, final_path) then
          table.insert(del_list, final_path)
       end
    end

    function delete(e)
       if e.reason == "quit" then
          for i, v in pairs(del_list) do
             print("deleting: "..v)
             os.remove(v)
          end
       end
    end

    mp.add_key_binding("ctrl+DEL", "delete_file", mark_delete)
    mp.register_event("end-file", delete)
  #+end_src

** Unison

#+begin_src scheme :noweb-ref guix-base
"unison"
#+end_src

*** Unison preference to sync files between machines
:PROPERTIES:
:CREATED:  [2024-12-19 Thu 23:19]
:END:

Carrying out file synchronization.
: $ unison pc-t480s

#+begin_src conf :noweb tangle :tangle (expand-file-name ".unison/pc-t480s.prf" tangle/home)
# Roots of the synchronization
root = /home/<<login-name()>>/
root = ssh://<<login-name()>>@pc-t480s//home/<<login-name()>>/

# Paths to synchronize
path = .config/emacs/var/ddskk/jisyo.txt
path = .config/emacs/var/bookmark-default.el
path = .local/state/cinnamon/desktop.conf
path = Pictures/

# Overwrite by newer file on confliction
prefer = newer

# Use this command for displaying diffs
diff = diff -y -W 79 --suppress-common-lines

# Write down synchronization activity on log file rather than show in stdout
auto = true
confirmbigdel = false
# silent = true
log = true

# Use inode number to verify identity rather than ckeck whole byte sequence
fastcheck = true
#+end_src

** Aspell
aspell - interactive spell checker
#+begin_src conf :tangle (expand-file-name ".aspell.conf")
lang en_US
#+end_src
** textlint
:PROPERTIES:
:CREATED:  [2022-07-31 Sun 14:53]
:ID:       decef153-596d-4821-996e-53cfafe83c8f
:END:

#+begin_src shell :tangle no :noweb-ref npm-pkg
textlint @textlint/ast-node-types textlint-rule-preset-ja-spacing textlint-rule-preset-ja-technical-writing textlint-rule-spellcheck-tech-word textlint-rule-ginger textlint-rule-write-good textlint-rule-prh textlint-filter-rule-node-types textlint-plugin-org traverse
#+end_src

- config for English
  #+begin_src json :tangle (expand-file-name ".textlintrc") :comments no
  {
    "rules": {
      "ginger": true,
      "write-good": true,
    }
  }
  #+end_src

- config for Japanese
  #+begin_src json :tangle (expand-file-name ".config/textlint/textlintrc_ja") :comments no
  {
    "rules": {
      "preset-ja-technical-writing": {
        "no-exclamation-question-mark": false,
        "sentence-length": {
          "max": 200
        }
      },
      "spellcheck-tech-word": true,
      "textlint-rule-ginger": {
        "skipPatterns": [
          "`(.*)`"
        ]
      },
      "textlint-rule-write-good": true,
      "preset-ja-spacing": true
    }
  }
  #+end_src

** xkeysnail                                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-04-27 Sat 09:39]
:END:

#+begin_src scheme :noweb-ref no
"xkeysnail"
#+end_src

- config.py
  #+begin_src python :tangle (expand-file-name ".config/xkeysnail/config.py")
  # -*- coding: utf-8 -*-

  import re
  from xkeysnail.transform import *

  define_multipurpose_modmap({
      # SandS
      Key.SPACE: [Key.SPACE, Key.LEFT_SHIFT],

      # Enter is enter when pressed and released. Control when held down.
      Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL],

      Key.LEFT_SHIFT: [Key.EQUAL, Key.LEFT_SHIFT],
      Key.RIGHT_SHIFT: [Key.MINUS, Key.RIGHT_SHIFT],
  })

  define_modmap({
      Key.LEFT_CTRL: Key.CAPSLOCK,
      Key.CAPSLOCK: Key.LEFT_CTRL,
      Key.SYSRQ: Key.RIGHT_META,
  })

  define_keymap(None, {
      K("C-Shift-a"): K("KEY_1"),
      K("C-Shift-s"): K("KEY_2"),
      K("C-Shift-d"): K("KEY_3"),
      K("C-Shift-f"): K("KEY_4"),
      K("C-Shift-g"): K("KEY_5"),
      K("C-Shift-h"): K("KEY_6"),
      K("C-Shift-j"): K("KEY_7"),
      K("C-Shift-k"): K("KEY_8"),
      K("C-Shift-l"): K("KEY_9"),
      K("C-Shift-semicolon"): K("KEY_0"),
  })


  # # [Conditional modmap] Change modifier keys in certain applications
  # define_conditional_modmap(re.compile(r'Emacs'), {
  #     Key.RIGHT_CTRL: Key.ESC,
  # })

  # # [Multipurpose modmap] Give a key two meanings. A normal key when pressed and
  # # released, and a modifier key when held down with another key. See Xcape,
  # # Carabiner and caps2esc for ideas and concept.
  # define_multipurpose_modmap(
  #     # Enter is enter when pressed and released. Control when held down.
  #     {Key.ENTER: [Key.ENTER, Key.RIGHT_CTRL]}

  #     # Capslock is escape when pressed and released. Control when held down.
  #     # {Key.CAPSLOCK: [Key.ESC, Key.LEFT_CTRL]
  #     # To use this example, you can't remap capslock with define_modmap.
  # )


  # # Keybindings for Firefox/Chrome
  # define_keymap(re.compile("Firefox|Google-chrome"), {
  #     # Ctrl+Alt+j/k to switch next/previous tab
  #     K("C-M-j"): K("C-TAB"),
  #     K("C-M-k"): K("C-Shift-TAB"),
  #     # Type C-j to focus to the content
  #     K("C-j"): K("C-f6"),
  #     # very naive "Edit in editor" feature (just an example)
  #     K("C-o"): [K("C-a"), K("C-c"), launch(["gedit"]), sleep(0.5), K("C-v")]
  # }, "Firefox and Chrome")

  # # Keybindings for Zeal https://github.com/zealdocs/zeal/
  # define_keymap(re.compile("Zeal"), {
  #     # Ctrl+s to focus search area
  #     K("C-s"): K("C-k"),
  # }, "Zeal")

  # # Emacs-like keybindings in non-Emacs applications
  # define_keymap(lambda wm_class: wm_class not in ("Emacs", "URxvt"), {
  #     # Cursor
  #     K("C-b"): with_mark(K("left")),
  #     K("C-f"): with_mark(K("right")),
  #     K("C-p"): with_mark(K("up")),
  #     K("C-n"): with_mark(K("down")),
  #     K("C-h"): with_mark(K("backspace")),
  #     # Forward/Backward word
  #     K("M-b"): with_mark(K("C-left")),
  #     K("M-f"): with_mark(K("C-right")),
  #     # Beginning/End of line
  #     K("C-a"): with_mark(K("home")),
  #     K("C-e"): with_mark(K("end")),
  #     # Page up/down
  #     K("M-v"): with_mark(K("page_up")),
  #     K("C-v"): with_mark(K("page_down")),
  #     # Beginning/End of file
  #     K("M-Shift-comma"): with_mark(K("C-home")),
  #     K("M-Shift-dot"): with_mark(K("C-end")),
  #     # Newline
  #     K("C-m"): K("enter"),
  #     K("C-j"): K("enter"),
  #     K("C-o"): [K("enter"), K("left")],
  #     # Copy
  #     K("C-w"): [K("C-x"), set_mark(False)],
  #     K("M-w"): [K("C-c"), set_mark(False)],
  #     K("C-y"): [K("C-v"), set_mark(False)],
  #     # Delete
  #     K("C-d"): [K("delete"), set_mark(False)],
  #     K("M-d"): [K("C-delete"), set_mark(False)],
  #     # Kill line
  #     K("C-k"): [K("Shift-end"), K("C-x"), set_mark(False)],
  #     # Undo
  #     K("C-slash"): [K("C-z"), set_mark(False)],
  #     K("C-Shift-ro"): K("C-z"),
  #     # Mark
  #     K("C-space"): set_mark(True),
  #     K("C-M-space"): with_or_set_mark(K("C-right")),
  #     # Search
  #     K("C-s"): K("F3"),
  #     K("C-r"): K("Shift-F3"),
  #     K("M-Shift-key_5"): K("C-h"),
  #     # Cancel
  #     K("C-g"): [K("esc"), set_mark(False)],
  #     # Escape
  #     K("C-q"): escape_next_key,
  #     # C-x YYY
  #     K("C-x"): {
  #         # C-x h (select all)
  #         K("h"): [K("C-home"), K("C-a"), set_mark(True)],
  #         # C-x C-f (open)
  #         K("C-f"): K("C-o"),
  #         # C-x C-s (save)
  #         K("C-s"): K("C-s"),
  #         # C-x k (kill tab)
  #         K("k"): K("C-f4"),
  #         # C-x C-c (exit)
  #         K("C-c"): K("C-q"),
  #         # cancel
  #         K("C-g"): pass_through_key,
  #         # C-x u (undo)
  #         K("u"): [K("C-z"), set_mark(False)],
  #     }
  # }, "Emacs-like keys")
  #+end_src
- xkeysnail.service

  #+begin_src conf :noweb yes :noweb-ref no :tangle no
  systemctl --user enable xkeysnail
  systemctl --user start xkeysnail
  #+end_src

  #+begin_src conf :tangle (expand-file-name ".config/systemd/user/xkeysnail.service")
  [Unit]
  Description=xkeysnail

  [Service]
  KillMode=process
  ExecStart=/bin/bash -ic 'pwsudo xkeysnail --watch --quiet %h/.config/xkeysnail/config.py'
  Type=simple
  Restart=always
  # Update DISPLAY to be the same as `echo $DISPLAY` on your graphical terminal.
  Environment=DISPLAY=:0

  [Install]
  WantedBy=default.target
  #+end_src

** SKK
:PROPERTIES:
:ID:       97b009df-7d14-452f-8e39-3da290a01792
:END:

SKK is Simple Kana to Kanji conversion program, an input method of Japanese.

#+begin_src scheme :tangle no :noweb-ref guix-base
"skk-jisyo"
;; "skktools"
#+end_src

#+name: skk-jisyo-path
#+begin_src shell :noweb yes :tangle no
echo -n '<<guix/ex-prof()>>/base/base/share/skk/'
#+end_src

- TODO: following programs have no guix package.
  It is better to write my own one for my reproducible system.
  + [X] [[https://github.com/skk-dev/skktools][skktools]]
  + [ ] ibus-skk

*** derive unique entries in user-jisyo       :ARCHIVE:

# #+begin_src shell :eval no :tangle no :noweb-ref morning-batch
# skkdic_uniq.sh
# #+end_src

#+begin_src bash :noweb tangle :tangle (expand-file-name "skkdic_uniq.sh" tangle/local-bin-dir)
tmp_euc=$(mktemp)
tmp_utf8=$(mktemp)
skk_dir="<<share-dir()>>"/skk
skk_get_dir=${skk_dir}/get-jisyo
dic_orig=$XDG_CONFIG_HOME/emacs/var/ddskk/jisyo.txt
dic_uniq=${skk_dir}/jisyo.uniq

skkdic-expr2 ${skk_get_dir}/SKK-JISYO.* > ${tmp_euc}
nkf -w -Lu ${tmp_euc} > ${tmp_utf8}
skkdic-expr2 ${dic_orig} - ${tmp_utf8} > ${dic_uniq}

rm -f ${tmp_euc}
rm -f ${tmp_utf8}

echo ${dic_uniq}
#+end_src
** Festival                                    :ARCHIVE:
:PROPERTIES:
:ID:       379230e4-dec0-4f96-becf-7d62159ff598
:CREATED:  [2024-11-25 Mon 17:58]
:END:

[[http://festvox.org/festival/][Festival]] is a framework for building and manipulating speech synthesis engine.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"festival"
#+end_src

- configuration
  #+begin_src scheme :noweb tangle :tangle (expand-file-name ".festivalrc" tangle/home) :shebang ";; -*- mode:scheme; -*-"
  (Parameter.set 'Audio_Required_Format 'aiff)
  (Parameter.set 'Audio_Method 'Audio_Command)
  (Parameter.set 'Audio_Command "paplay $FILE --client-name=Festival --stream-name=Speech")

  ;; add SLT voice and use it as a default one
  (voice-location 'cmu_us_slt_cg
                  (path-as-directory
                   (let ((path "~/.local/share/festival/lib/voices/us/cmu_us_slt_cg"))
                     (if (string-equal (substring path 0 1) "~")
                         (string-append (getenv "HOME") (substring path 1 (length path)))
                         path)))
                  "English American Female")
  (set! voice_default voice_cmu_us_slt_cg)
  #+end_src
- a script to download voices

  # #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  # download-festival-voices
  # #+end_src

  #+begin_src bash :tangle (expand-file-name "download-festival-voices" tangle/local-bin-dir)
  work_dir=~/.local/share/festival
  voices=(
    cmu_us_aew_cg
    cmu_us_rxr_cg
    cmu_us_slt_cg
  )

  if [ ! -d "${work_dir}" ]; then
    mkdir -p "${work_dir}"
  fi

  cd "${work_dir}"
  for voice in "${voices[@]}"; do
    voice_pack_file=festvox_${voice}.tar.gz
    if [ ! -e ${voice_pack_file} ]; then
      wget -c http://festvox.org/packed/festival/2.5/voices/${voice_pack_file}
      tar zxf "${voice_pack_file}" -C ../../share
    fi
  done

  echo "${work_dir}"
  #+end_src
- festival.el

  #+begin_src emacs-lisp :noweb-ref elisp-code
  (use-package festival
    :defer t
    :config
    (say-minor-mode 1)
    (setq festival-tmp-file (make-temp-file "festival-")))
  #+end_src

** Open JTalk                                  :ARCHIVE:
:PROPERTIES:
:ID:       ce99b0cf-dd07-4b9e-86b3-b492a8cfb354
:CREATED:  [2024-11-25 Mon 18:00]
:END:

#+name: hts-voice-dir
#+begin_src emacs-lisp :noweb yes
(file-name-concat "<<share-dir()>>" "hts-voice")
#+end_src

#+begin_src shell :noweb yes :noweb-ref make-dir
<<hts-voice-dir()>>
#+end_src

- install on Ubuntu
  # #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
  # open-jtalk open-jtalk-mecab-naist-jdic hts-voice-nitech-jp-atr503-m001
  # #+end_src
- download hts voices

  # #+begin_src conf :noweb yes :noweb-ref ubuntu-setup :tangle no
  # download-hts-voices
  # #+end_src

  #+begin_src bash :noweb tangle :tangle (expand-file-name "download-hts-voices" tangle/local-bin-dir)
  data_dir=<<hts-voice-dir()>>
  hts_workdir=/tmp
  hts_fname=MMDAgent_Example-1.8.zip

  if [ ! -d "${data_dir}" ]; then
    mkdir -p "${data_dir}"
  fi

  cd "${hts_workdir}" \
    && curl -sLO http://sourceforge.net/projects/mmdagent/files/MMDAgent_Example/${hts_fname%.zip}/${hts_fname} \
    && unzip -o -d ${data_dir} ${hts_fname} \
    && ln -sfv ${data_dir}/${hts_fname%.zip}/Voice ${data_dir}/
  #+end_src

** Jack                                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2024-04-27 Sat 09:34]
:END:

#+begin_src scheme :noweb-ref no
"qjackctl"
"qsynth"
"jack-keyboard"
#+end_src

#+begin_src conf :tangle (expand-file-name ".jackdrc")
/usr/bin/jackd -dalsa -dhw:0 -r44100 -p1024 -n3 -Xseq
#+end_src

** XRandR

XRandR is a command line utility for changing display options without restarting X server.

[[https://wiki.archlinux.org/title/xrandr][xrandr - ArchWiki]]

- show avaulable modes for all displays
  #+begin_src shell :results verbatim
  xrandr
  #+end_src

- change mode (resolution) to 1920x1080 for a display identified as "HDMI-2"
  #+begin_src shell
  xrandr --output HDMI-2 --mode 1920x1080
  #+end_src

- change mode back to preferred (maximum)
  #+begin_src shell
  xrandr --output HDMI-2 --auto
  #+end_src

#+begin_src scheme :noweb-ref guix-desktop
"xrandr"
#+end_src
** C/Migemo
:PROPERTIES:
:ID:       9ac77d59-90bd-4054-89c9-dcab29bd7462
:END:

[[https://github.com/koron/cmigemo][C/Migemo]] allows us to search Japanese with incremental ASCII charactor input.

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"cmigemo"
"migemo-dict"
"migemo-dict-azik"
#+end_src

#+name: migemo-dict-path
#+begin_src shell :noweb yes :tangle no
echo -n '<<guix/ex-prof()>>/emacs/emacs/share/migemo/'
#+end_src

*** C/Migemo in apt                           :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-08 Wed 16:57]
:END:

As of [2023-02-08 Wed] C/Migemo is installed via guix package system since [[https://gitlab.com/guix-jp/guix-jp][guix-jp]] has offered that.

# #+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
#   cmigemo
# #+end_src

*** AZIK-compliant C/Migemo                   :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-02-05 Sun 12:02]
:END:

Caveat: The effect in this section can be made happen to use 'migemo-dict-azik' guix package.

If you are AZIK lover, replace /usr/share/cmigemo/utf-8/roma2hira.dat with the content below to activate AZIK key assign in migemo.

# #+begin_src shell :noweb-ref ubuntu-setup :tangle no
# MIGEMO_DAT_SYSTEM_DIR=/usr/share/cmigemo/utf-8
# MIGEMO_DAT_LOCAL_DIR=~/.local/share/cmigemo/utf-8
# ROMA_2_HIRA=roma2hira.dat

# if [ -f "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
#   (
#     cd "${MIGEMO_DAT_SYSTEM_DIR}" \
#       && sudo mv ${ROMA_2_HIRA} ${ROMA_2_HIRA}.orig
#   )
# fi
# if [ -h "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}" ]; then
#   sudo unlink "${MIGEMO_DAT_SYSTEM_DIR}/${ROMA_2_HIRA}"
# fi
# sudo ln -s "${MIGEMO_DAT_LOCAL_DIR}/${ROMA_2_HIRA}" ${MIGEMO_DAT_SYSTEM_DIR}
# #+end_src

#+begin_src text :tangle (expand-file-name ".local/share/cmigemo/utf-8/roma2hira.dat")
# vi:set ts=8 sts=8 sw=8 tw=0:
#
# roma2hira.dat - ローマ字→平仮名変換表
#
# Last Change: 18-Oct-2003.
# Written By:  Muraoka Taro  <koron@tka.att.ne.jp>

# こいつをカスタマイズすることでローマ字の入力方式が変わります。
# 現在はMS-IME2000を参考に決定しています。
# 漢字コードの違いを吸収する役割も果たします。
# xnとxtuには「ん」と「っ」を指定する役割があります。
# {from} {to}の形式です。
# 現在は{from}は最大7バイトまで{to}は6バイトまでとなっています。
# {from}と{to}の間は空白文字(isspace())で区切ります。

# http://asiamoth.com/mt/archives/2006-08/05_2313.php

-	ー
~	〜
,	、
.	。
:	ー
[	「
]	」
;	っ
a	あ
ba	ば
bd	べん
be	べ
bh	ぶう
bi	び
bj	ぶん
bk	びん
bl	ぼん
bn	ばん
bo	ぼ
bp	ぼう
bq	ばい
bt	びと
bu	ぶ
bv	びゅう
bw	べい
bx	びょう
bya	びゃ
byj	びゅん
byo	びょ
byp	びょう
byu	びゅ
bz	ばん
ca	ちゃ
cd	ちぇん
ce	ちぇ
cf	ちぇ
ch	ちゅう
ci	ち
cj	ちゅん
ck	ちん
cl	ちょん
cn	ちゃん
co	ちょ
cp	ちょう
cq	ちゃい
cu	ちゅ
cz	ちゃん
da	だ
dch	どぅー
dci	でぃ
dcj	どぅん
dck	でぃん
dcu	どぅ
dd	でん
de	で
df	で
dga	ぢゃ
dge	ぢぇ
dgj	ぢゅん
dgl	ぢょん
dgo	ぢょ
dgq	ぢゃい
dgu	ぢゅ
dgz	ぢゃん
dh	づう
di	ぢ
dj	づん
dk	ぢん
dl	どん
dm	でも
dn	だん
do	ど
dp	どう
dq	だい
dr	である
ds	です
dt	だち
du	づ
dv	ぢゅう
dw	でい
dx	ぢょう
dya	でゃ
dyh	でゅー
dyj	でゅん
dyq	でゃい
dyu	でゅ
dyz	でゃん
dz	だん
e	え
fa	ふぁ
fd	ふぇん
fe	ふぇ
fh	ふう
fi	ふぃ
fj	ふん
fk	ふぃん
fl	ふぉん
fn	ふぁん
fo	ふぉ
fq	ふぁい
fu	ふ
fv	ふゅー
fw	ふぇい
fyh	ふゅー
fyj	ふゅん
fyu	ふゅ
fz	ふぁん
ga	が
gd	げん
ge	げ
gh	ぐう
gi	ぎ
gj	ぐん
gk	ぎん
gl	ごん
gn	がん
go	ご
gp	ごう
gq	がい
gr	がら
gt	ごと
gu	ぐ
gv	ぎゅう
gw	げい
gx	ぎょう
gya	ぎゃ
gyh	ぎゅう
gyj	ぎゅん
gyl	ぎょん
gyo	ぎょ
gyp	ぎょう
gyq	ぎゃい
gyu	ぎゅ
gyz	ぎゃん
gz	がん
ha	は
hd	へん
he	へ
hf	ふ
hga	ひゃ
hgd	ひぇん
hge	ひぇ
hgh	ひゅう
hgj	ひゅん
hgl	ひょん
hgn	ひゃん
hgo	ひょ
hgp	ひょう
hgq	ひゃい
hgu	ひゅ
hgz	ひゃん
hh	ふう
hi	ひ
hj	ふん
hk	ひん
hl	ほん
ho	ほ
hp	ほう
hq	はい
ht	ひと
hu	ふ
hv	ひゅう
hw	へい
hx	ひょう
hya	ひゃ
hyd	ひぇん
hye	ひぇ
hyh	ひゅう
hyj	ひゅん
hyl	ひょん
hyo	ひょ
hyp	ひょう
hyq	ひゃい
hyu	ひゅ
hyz	ひゃん
hz	はん
i	い
ja	じゃ
jd	じぇん
je	じぇ
jf	じゅ
jh	じゅう
ji	じ
jj	じゅん
jk	じん
jl	じょん
jo	じょ
jp	じょう
jq	じゃい
ju	じゅ
jw	じぇい
jz	じゃん
ka	か
kd	けん
ke	け
kf	き
kga	きゃ
kgh	きゅう
kgj	きゅん
kgl	きょん
kgn	きゃん
kgo	きょ
kgp	きょう
kgq	きゃい
kgu	きゅ
kgz	きゃん
kh	くう
ki	き
kj	くん
kk	きん
kl	こん
km	かも
kn	かん
ko	こ
kp	こう
kq	かい
kr	から
kt	こと
ku	く
kv	きゅう
kw	けい
kx	きょう
kya	きゃ
kyh	きゅう
kyj	きゅん
kyl	きょん
kyo	きょ
kyp	きょう
kyq	きゃい
kyu	きゅ
kyz	きゃん
kz	かん
la	ぁ
le	ぇ
li	ぃ
lo	ぉ
ltsu	っ
ltu	っ
lu	ぅ
lwa	ゎ
lya	ゃ
lye	ぇ
lyi	ぃ
lyo	ょ
lyu	ゅ
ma	ま
md	めん
me	め
mf	む
mgn	みゃん
mh	むう
mi	み
mj	むん
mk	みん
ml	もん
mn	もの
mo	も
mp	もう
mq	まい
ms	ます
mt	また
mu	む
mv	みゅう
mw	めい
mx	みょう
mya	みゃ
myh	みゅう
myj	みゅん
myl	みょん
myo	みょ
myp	みょう
myq	みゃい
myu	みゅ
myz	みゃん
mz	まん
na	な
nb	ねば
nd	ねん
ne	ね
nf	ぬ
nga	にゃ
ngh	にゅう
ngj	にゅん
ngl	にょん
ngn	にゃん
ngo	にょ
ngp	にょう
ngq	にゃい
ngu	にゅ
ngz	にゃん
nh	ぬう
ni	に
nj	ぬん
nk	にん
nl	のん
nn	ん
no	の
np	のう
nq	ない
nr	なる
nt	にち
nu	ぬ
nv	にゅう
nw	ねい
nx	にょう
nya	にゃ
nyh	にゅう
nyj	にゅん
nyl	にょん
nyo	にょ
nyp	にょう
nyq	にゃい
nyu	にゅ
nyz	にゃん
nz	なん
o	お
pa	ぱ
pd	ぺん
pe	ぺ
pf	ぽん
pga	ぴゃ
pgh	ぴゅう
pgj	ぴゅん
pgl	ぴょん
pgn	ぴゃん
pgo	ぴょ
pgp	ぴょう
pgq	ぴゃい
pgu	ぴゅ
pgz	ぴゃん
ph	ぷう
pi	ぴ
pj	ぷん
pk	ぴん
pl	ぽん
po	ぽ
pp	ぽう
pq	ぱい
pu	ぷ
pv	ぴゅう
pw	ぺい
px	ぴょう
pya	ぴゃ
pyh	ぴゅう
pyj	ぴゅん
pyl	ぴょん
pyo	ぴょ
pyp	ぴょう
pyq	ぴゃい
pyu	ぴゅ
pz	ぱん
q	ん
ra	ら
rd	れん
re	れ
rh	るう
ri	り
rj	るん
rk	りん
rl	ろん
rn	らん
ro	ろ
rp	ろう
rq	らい
rr	られ
ru	る
rv	りゅう
rw	れい
rx	りょう
rya	りゃ
ryh	りゅう
ryj	りゅん
ryl	りょん
ryo	りょ
ryp	りょう
ryq	りゃい
ryu	りゅ
ryz	りゃん
rz	らん
sa	さ
sd	せん
se	せ
sf	さい
sh	すう
si	し
sj	すん
sk	しん
sl	そん
sn	さん
so	そ
sp	そう
sq	さい
sr	する
ss	せい
st	した
su	す
sv	しゅう
sw	せい
sx	しょう
syi	すぃ
syk	すぃん
sz	さん
ta	た
tb	たび
td	てん
te	て
tgh	とぅー
tgi	てぃ
tgj	とぅん
tgk	てぃん
tgu	とぅ
th	つう
ti	ち
tj	つん
tk	ちん
tl	とん
tm	ため
tn	たん
to	と
tp	とう
tq	たい
tr	たら
tsa	つぁ
tsd	つぇん
tse	つぇ
tsh	つう
tsi	つぃ
tsj	つん
tsk	つぃん
tsl	つぉん
tso	つぉ
tsq	つぁい
tst	として
tsu	つ
tsz	つぁん
tt	たち
tu	つ
tw	てい
tya	てゃ
tyh	てゅー
tyj	てゅん
tyq	てゃい
tyu	てゅ
tyz	てゃん
tz	たん
u	う
va	う゛ぁ
vd	う゛ぇん
ve	う゛ぇ
vh	う゛ー
vi	う゛ぃ
vj	う゛ん
vk	う゛ぃん
vl	う゛ぉん
vn	う゛ぁん
vo	う゛ぉ
vp	う゛ぉう
vq	う゛ぁい
vu	う゛
vv	う゛ゅー
vw	う゛ぇい
vyh	う゛ゅー
vyj	う゛ゅん
vyu	う゛ゅ
vz	う゛ぁん
wa	わ
wd	うぇん
we	うぇ
wi	うぃ
wk	うぃん
wl	うぉん
wn	わん
wo	を
wp	うぉー
wq	わい
wr	われ
wse	ゑ
wsi	ゐ
wso	うぉ
wt	わた
ww	うぇい
wz	わん
xa	しゃ
xd	しぇん
xe	しぇ
xh	しゅう
xi	し
xj	しゅん
xk	しん
xl	しょん
xn	しゃん
xo	しょ
xp	しょう
xq	しゃい
xu	しゅ
xw	しぇい
xz	しゃん
ya	や
yd	いぇん
ye	いぇ
yf	ゆ
yh	ゆう
yj	ゆん
yl	よん
yo	よ
yp	よう
yq	やい
yr	よる
yu	ゆ
yw	いぇい
yz	やん
za	ざ
zc	ざ
zd	ぜん
ze	ぜ
zh	ずう
zi	じ
zj	ずん
zk	じん
zl	ぞん
zn	ざん
zo	ぞ
zp	ぞう
zq	ざい
zr	ざる
zu	ず
zv	ざい
zw	ぜい
zx	ぜい
zyi	ずぃ
zz	ざん
#+end_src

** LilyPond                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2025-01-15 Wed 19:59]
:END:

[[https://lilypond.org/unix.html][LilyPond]] elisp package is included in source tarball available at [[https://lilypond.org/download/source][here]],
you are required to locate that package where emacs can search.

#+begin_src scheme :tangle no
"lilypond"
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package lilypond-mode
  :delight (LilyPond-mode " LP")
  :mode ("\\.ly$" . LilyPond-mode)
  :custom
  (LilyPond-pdf-command "firefox")
  (LilyPond-midi-command "fluidsynth -a alsa -m alsa_seq -l"))
#+end_src

** Graphviz
:PROPERTIES:
:CREATED:  [2022-12-12 Mon 13:36]
:END:

Documentation is available at [[https://graphviz.org/documentation/][here]] and [[https://graphviz.org/gallery/][gallery]] is also useful.

#+begin_src scheme :tangle no :noweb-ref guix-base
"graphviz"
"xdot"
#+end_src

#+begin_src scheme :tangle no :noweb-ref guix-emacs
"emacs-graphviz-dot-mode"
#+end_src

#+begin_src emacs-lisp :noweb-ref elisp-code
(use-package graphviz-dot-mode
  :after eglot
  :custom
  (graphviz-dot-indent-width 2)
  :config
  (add-to-list 'eglot-server-programs
               '(graphviz-dot-mode "dot-language-server" "--stdio")))
#+end_src

#+begin_src shell :noweb-ref npm-pkg :tangle no
dot-language-server
#+end_src

** Rsync

#+begin_src scheme :noweb-ref guix-base
"rsync"
#+end_src

*** sync server data                          :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-01-19 Thu 10:07]
:END:

#+begin_src conf :noweb yes :tangle no
12 1 * * * /bin/bash -ci "sync_sv04 >> $LOG_DIR/sync_sv04.log 2>&1"
#+end_src

#+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/sync_sv04") :shebang #!/usr/bin/env bash :tangle-mode (identity #o755)
ssh -q -o BatchMode="yes" -o ConnectTimeout=10 sv04 "exit 0" \
  && rsync -arhv sv04:~/var/backup <<share-dir()>>/sv04
#+end_src

*** backup script                             :ARCHIVE:

#+begin_src shell :tangle (expand-file-name ".local/bin/back_rsync.sh")
#!/usr/bin/env bash

OPT="-aPh"
LINK="--link-dest=../last/"
DEST="ns01:~/data/share/backups"
DATETIME=`date "+%Y%m%d-%H%M"`

ssh -q -o BatchMode="yes" -o ConnectTimeout=10 ns01 "(cd ~/data/share/backups; mkdir -p pc01 sv04; exit)" || exit 1

# take a snapshot for pc01
# if ssh ns01 "[ -h ~/share/backups/pc01/last ]"; then
#   rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
#   ssh ns01 "(cd share/backups/pc01; unlink last; ln -s ${DATETIME} last)"
# else
#   rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_pc01.txt ${HOME}/ ${DEST}/pc01/${DATETIME}
#   ssh ns01 "(cd share/backups/pc01; ln -s ${DATETIME} last)"
# fi

# take a snapshot for sv04
if mountpoint /mnt/sv04 >/dev/null 2>&1; then
  if ssh ns01 "[ -h ~/data/share/backups/sv04/last ]"; then
    rsync -aPhrv $LINK --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
    ssh ns01 "(cd share/backups/sv04; unlink last; ln -s ${DATETIME} last)"
  else
    rsync -aAXrv --exclude-from=${HOME}/.config/rsync/exclude_sv04.txt /mnt/sv04/ ${DEST}/sv04/${DATETIME}
    ssh ns01 "(cd share/backups/sv04; ln -s ${DATETIME} last)"
  fi
fi
#+end_src

+ rsync exclude file for pc01
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_pc01.txt") :tangle-mode (identity #o644)
  + var
  + var/log
  + var/log/**
  - var/lib/dash
  + var/lib
  + var/lib/**
  + work
  + work/**
  + git
  + git/**
  - *
  #+end_src
+ rsync exclude file for sv04
  #+begin_src conf :tangle (expand-file-name ".config/rsync/exclude_sv04.txt") :tangle-mode (identity #o644)
  + var
  + var/backup
  + var/backup/**
  - *
  #+end_src
** libvirt
:PROPERTIES:
:ID:       4736bf4d-4185-4683-818d-700f980bc6ca
:END:

#+begin_src scheme :noweb-ref guix-desktop
"libvirt"
"virt-manager"
#+end_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
qemu-kvm libvirt-clients libvirt-daemon libvirt-daemon-system virtinst virt-manager virt-top bridge-utils
#+end_src

#+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
systemctl enable libvirtd
systemctl start libvirtd
#+end_src

#+begin_src conf :tangle (expand-file-name "libvirt/libvirt.conf" tangle/config-dir)
uri_default = "qemu:///system"
#+end_src

- how to set up local storage pool (named 'local')
  : $ virsh pool-define ~/.config/libvirt/pool.xml
  : $ virsh pool-autostart local
  : $ virsh pool-start local

  #+begin_src xml :noweb tangle :tangle (expand-file-name "libvirt/pool.xml" tangle/config-dir)
  <pool type='dir'>
    <name>local</name>
    <source>
    </source>
    <target>
      <path>/mnt/pt-shared/virt</path>
      <permissions>
        <mode>0711</mode>
        <owner>0</owner>
        <group>0</group>
      </permissions>
    </target>
  </pool>
  #+end_src

** Calibre

[[https://calibre-ebook.com/download_linux][Calibre for linux]] is a e-book reader. I use it in the mood of reading epub in GUI app.

#+begin_src scheme :noweb-ref guix-desktop
"calibre"
#+end_src

** yt-dlp
:PROPERTIES:
:CREATED:  [2022-08-19 Fri 08:06]
:END:

#+begin_src scheme :noweb-ref guix-base
"yt-dlp"
#+end_src

#+begin_src conf :tangle (expand-file-name ".config/yt-dlp/config")
--output %(title)s.%(ext)s
--trim-filenames 70
#+end_src

** rTorrent                                    :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-10-05 Wed 15:26]
:ID:       bdc987ad-419b-4f36-922d-de75207d85c0
:END:

[[https://github.com/rakshasa/rtorrent/wiki][rTorrent]] is a bittorrent client using ncurses.

#+begin_src scheme :noweb-ref guix-base
"rtorrent-xmlrpc"
#+End_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
rtorrent
#+end_src

#+name: rtorrent-sock
#+begin_src emacs-lisp :eval no-export :noweb yes
(file-name-concat "<<share-dir()>>" "rtorrent/rpc.socket")
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".rtorrent.rc" tangle/home)
network.scgi.open_local = <<rtorrent-sock()>>
execute.nothrow = chmod,770,<<rtorrent-sock()>>
encoding.add = utf8
#+end_src

# #+begin_src conf :noweb yes :noweb-ref systemd-service :tangle no
# systemctl --user enable rtorrent.service
# systemctl --user start rtorrent.service
# #+end_src

#+name: torrent-dir
#+begin_src sh :noweb yes :eval no-export
echo -n '~/.local/share/rtorrent/files'
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name "systemd/user/rtorrent.service" tangle/config-dir)
[Unit]
Description=rTorrent
After=network.target

[Service]
Type=simple
WorkingDirectory=<<torrent-dir()>>
ExecStart=<<which(filename="rtorrent")>> -o system.daemon.set=true
Restart=on-failure
RestartSec=3

[Install]
WantedBy=default.target
#+end_src

** Ledger
:PROPERTIES:
:CREATED:  [2022-10-21 Fri 20:55]
:END:

[[https://www.ledger-cli.org/3.0/doc/ledger-mode.html][Ledger]] is double-entry accounting cli tool. [[https://hledger.org/][hledger]] is feature rich reimplementation of ledger in Haskell. User data in ledger is interoperable for hledger and vice versa.

#+begin_src scheme :noweb-ref guix-base
"ledger"
"hledger"
#+end_src

** ripgrep-all                                 :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-10-26 Wed 10:39]
:END:

Ripgrep-all was superceded by its competitor [[id:ef80cf7c-7fa3-4e4d-8387-c6caa9bb7751][Recoll]].

[[https://github.com/phiresky/ripgrep-all][ripgrep-all]] or rga command enables to search media files such as pdf documents or epub files in grep-like way.

# #+begin_src shell :noweb yes :noweb-ref ubuntu-setup :tangle no
# rga_url=https://github.com/phiresky/ripgrep-all/releases/download/v0.9.6
# rga_fname=ripgrep_all-v0.9.6-x86_64-unknown-linux-musl.tar.gz
# rga_workdir=/tmp
# rga_lbinpath=<<home-dir()>>/.local/bin

# curl -sL "${rga_url}/${rga_fname}" | tar zxf - -C ${rga_workdir} \
#   && cp -fv ${rga_workdir}/${rga_fname%.tar.gz}/{rga,rga-preproc} ${rga_lbinpath}
# #+end_src

** Recoll
:PROPERTIES:
:CREATED:  [2023-02-11 Sat 22:11]
:ID:       ef80cf7c-7fa3-4e4d-8387-c6caa9bb7751
:END:

#+begin_src scheme :noweb-ref guix-base
"recoll"
#+end_src

#+begin_src shell :noweb-ref apt-pkg :noweb-sep " \\\n" :tangle no
recollcmd
#+end_src

Indexing all contents in doc directory every midnight so that recoll can search through
#+begin_src sh :eval no :noweb yes :tangle no :noweb-ref midnight-batch
recollindex > <<log-dir()>>/recolltrace.log 2>&1
#+end_src

#+begin_src conf :noweb tangle :tangle (expand-file-name ".recoll/recoll.conf") :comments no
topdirs = /mnt/pt-shared/doc-%%HOSTNAME%%

[/mnt/pt-shared/doc-%%HOSTNAME%%]
followLinks = 1

skippedNames = .git

indexstemminglanguages = english
#+end_src

** Enchant
:PROPERTIES:
:CREATED:  [2023-12-07 Thu 15:53]
:END:

[[https://abiword.github.io/enchant/src/enchant.html][ENCHANT]] offers efficient spell checking mechanism by using checker in order.

#+begin_src scheme :noweb-ref guix-base
"enchant"
"hunspell"
"hunspell-dict-en"
"hunspell-dict-en-us"
"nuspell"
"aspell"
"aspell-dict-en"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
export ENCHANT_CONFIG_DIR=<<home-dir()>>/.config/enchant
#+end_src

#+begin_src conf :comments no :noweb tangle :tangle (expand-file-name ".config/enchant/enchant.ordering")
,*:hunspell,nuspell,aspell
en:hunspell,nuspell,aspell
en_US:hunspell,nuspell,aspell
#+end_src

#+begin_src text :comments no :noweb tangle :tangle (expand-file-name ".config/enchant/en_US.dic")
TempEL
#+end_src

** Modern alternative command line tools
:PROPERTIES:
:CREATED:  [2023-12-17 Sun 13:56]
:END:

They are mostly written in Rust. [[https://github.com/mhoye/moderntools/][moderntools]] offers updated info for this category.

#+begin_src scheme :noweb-ref guix-base
"bat"
"du-dust"
"eza"
"fd"
"zoxide"
"just"
"tmux"
"moreutils"
#+end_src

** Haunt
:PROPERTIES:
:CREATED:  [2024-04-02 Tue 11:15]
:END:

#+begin_src scheme :noweb-ref guix-base
"haunt"
#+end_src

** Wine

#+begin_src scheme :noweb-ref guix-desktop
"wine64"
"winetricks"
#+end_src

#+begin_src shell :tangle no :noweb-ref bashrc
export WINEARCH=win64
export WINEPREFIX=~/.wine
#+end_src

** Font Viewer
:PROPERTIES:
:CREATED:  [2022-09-13 Tue 16:24]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-desktop
"gnome-font-viewer"
#+end_src

** Gnuplot
:PROPERTIES:
:CREATED:  [2024-11-13 Wed 17:31]
:END:

#+begin_src scheme :tangle no :noweb-ref guix-base
"gnuplot"
#+end_src

#+begin_src gnuplot :tangle (expand-file-name ".gnuplot") :comments no
set colorsequence podo
#+end_src

* Development Infrastructures
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:55]
:END:

** C/C++
:PROPERTIES:
:CREATED:  [2024-04-30 Tue 00:52]
:END:

#+begin_src scheme :noweb-ref guix-base
"tree-sitter-c"
"tree-sitter-cpp"
#+end_src

** Ruby                                        :ARCHIVE:
:PROPERTIES:
:CREATED:  [2025-01-18 Sat 21:04]
:END:

#+begin_src scheme :tangle no
"ruby"
"ruby-pry"
"ruby-rubocop"
"ruby-thor"
"tree-sitter-ruby"
#+end_src

#+begin_src shell :tangle no
export RUBYLIB=${HOME}/.local/lib

# set path for ruby gems in local
if which ruby >/dev/null && which gem >/dev/null; then
  PATH="$(ruby -r rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
#+end_src

** Lua
:PROPERTIES:
:CREATED:  [2024-04-29 Mon 21:50]
:END:

#+begin_src scheme :noweb-ref guix-base
"tree-sitter-lua"
#+end_src

** Common Lisp
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 13:11]
:END:

#+begin_src scheme :noweb-ref guix-base
"sbcl"
"sbcl-slynk"
#+end_src

** Node.js
:PROPERTIES:
:CREATED:  [2022-08-01 Mon 13:52]
:END:

#+name: npm-prefix
#+begin_src shell :eval no-export
echo -n '~/.npm-global'
#+end_src

#+begin_src scheme :noweb-ref guix-base
"node"
#+end_src

#+begin_src shell :noweb yes :noweb-ref bashrc
NODE_PATH="<<npm-prefix()>>/lib/node_modules:${NODE_PATH}"
PATH="<<npm-prefix()>>/bin:${PATH}"
MANPATH="<<npm-prefix()>>/share/man:${MANPATH}"
#+end_src

#+begin_src shell :noweb yes :tangle (expand-file-name ".npmrc")
prefix=<<npm-prefix()>>
#+end_src

- make a directory for global npm packages
  #+begin_src shell :tangle no :noweb yes
  mkdir -pv <<npm-prefix()>>
  #+end_src
- install npm packages
  #+begin_src shell :noweb tangle :tangle (expand-file-name "npm-install" tangle/local-bin-dir)
  npm install -g <<npm-pkg>>
  #+end_src

** asdf-vm                                     :ARCHIVE:
Extendable version manager
- call for init script in bashrc
  #+begin_src shell
  . $HOME/.asdf/asdf.sh
  . $HOME/.asdf/completions/asdf.bash

  export RUBYLIB=${RUBYLIB}:${HOME}/.local/lib
  #+end_src
- define versions
  #+begin_src conf :comments noweb :tangle (expand-file-name ".tool-versions")
  ruby 2.6.8
  python 3.8.5
  #+end_src

  steps to install tools for specific versions
  1. install plugins
     : $ asdf plugin add ruby
     : $ asdf plugin add python

  2. install tools
     : $ cd ~ && asdf install

*** asdf-ruby
#+begin_src conf :comments noweb :tangle (expand-file-name ".default-gems")
thor 1.2.1
pry 0.14.1
rubocop 1.26
exifr 1.2.6
streamio-ffmpeg
#+end_src
*** asdf-python
#+begin_src python :tangle (expand-file-name ".default-python-packages")
lxml
jedi
ical2orgpy
Send2Trash
#+end_src
** Language Servers

*** Bash Language Server
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 13:49]
:END:

[[https://github.com/bash-lsp/bash-language-server][Bash Language Server]]

#+begin_src shell :noweb-ref npm-pkg :tangle no
bash-language-server
#+end_src

*** Solargraph                                :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-08-04 Thu 14:16]
:END:

[[https://github.com/castwide/solargraph][Solargraph]] is Ruby Language Server.

#+begin_src scheme :tangle no
"ruby-solargraph"
#+end_src

* Stuffs for Dedicated Tasks

** Batch Processing
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 20:29]
:END:

*** Morning Batch
:PROPERTIES:
:CREATED:  [2023-10-31 Tue 14:03]
:END:

#+NAME: morning-batch
#+begin_src bash :noweb tangle :tangle (expand-file-name "morning.sh" tangle/local-bin-dir)
<<morning-batch>>
#+end_src

*** Midnight Batch
:PROPERTIES:
:CREATED:  [2023-10-31 Tue 14:03]
:END:

#+begin_src bash :noweb tangle :tangle (expand-file-name "midnight.sh" tangle/local-bin-dir)
<<midnight-batch>>
#+end_src

** Transcode Video Files
:PROPERTIES:
:CREATED:  [2022-09-15 Thu 14:44]
:END:

Transcoding my local video files with open codec, like VP9 and AV1, is effective for disc space usage.

#+begin_src shell :noweb-ref transc-shared
#!/usr/bin/env bash
set -euo pipefail

CRF=28
KBITRATE_AUDIO=128

function usage() {
  cat <<_EOT_
Usage:
  $(basename $0) [OPTIONS] <video_in> [<video_out>]

Description:
  $(basename $0) encodes <video_in> to <video_out> in specified codec.

Options:
  -c <CRF>      CRF value instead of ${CRF} (DEFAULT)
  -B <AUDIO_BR> Audio Bitrate in kbps

_EOT_
}

if [ "${OPTIND}" = 1 ]; then
  while getopts c:B:h OPT
  do
    case ${OPT} in
    c)
      CRF=${OPTARG}
      ;;
    B)
      CRF=${OPTARG}
      ;;
    h)
      usage
      ;;
    \?)
      echo "Try to enter the h option." 1>&2
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi

shift $((OPTIND - 1))

if [ $# -lt 1 ] || [ $# -gt 2 ]; then
  usage
  exit -1
fi

INPUT_VIDEO=$1
if [ ! -e "${INPUT_VIDEO}" ]; then
  echo "${INPUT_VIDEO} does not exist." 1>&2
  exit -1
fi

if [[ $# -eq 2 ]]; then
  output_cand=$2
else
  output_cand=$(basename "${INPUT_VIDEO}").webm
fi
if [ -e "${output_cand}" ]; then
  OUTPUT_VIDEO=${output_cand%.*}_$(date +%Y%m%d_%H%M).webm
else
  OUTPUT_VIDEO="${output_cand}"
fi

WORK_DIR="${INPUT_VIDEO%.*}"
#+end_src

*** vp9 transcoding

- transcode video to vp9
  : $ vp9transc -c 32 video_orig.mkv video_vp9.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name "vp9transc" tangle/local-bin-dir) :comments no
<<transc-shared>>

vp9_opts_pass1="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 1 -an -f null"
vp9_opts_pass2="-c:v libvpx-vp9 -cpu-used 4 -threads 3 -row-mt 1 -speed 1 -b:v 0 -crf ${CRF} -pass 2 -map_metadata 0"
opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
  && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass1} /dev/null \
  && ffmpeg -i "../${INPUT_VIDEO}" ${vp9_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src
*** av1 transcoding

- transcode video to av1
  : $ av1transc video_orig.mkv video_av1.webm

#+begin_src shell :noweb tangle :tangle (expand-file-name "av1transc" tangle/local-bin-dir) :comments no
<<transc-shared>>

av1_opts_common="-c:v libaom-av1 -cpu-used 2 -row-mt 1 -threads $(nproc) -b:v 0 -crf ${CRF}"
av1_opts_pass1="${av1_opts_common} -pass 1 -an -f null"
av1_opts_pass2="${av1_opts_common} -pass 2 -map_metadata 0"
opus_opts="-c:a libopus -b:a ${KBITRATE_AUDIO}k -ac 2"

mkdir -p "${WORK_DIR}" && cd "${WORK_DIR}" \
  && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass1} /dev/null \
  && ffmpeg -i "../${INPUT_VIDEO}" ${av1_opts_pass2} ${opus_opts} "../${OUTPUT_VIDEO}"
#+end_src

** Transcode Audio Files                       :ARCHIVE:
:PROPERTIES:
:CREATED:  [2023-11-13 Mon 18:05]
:END:

- usage
  + encode bulk podcast files for 64kb/s (in Dired)
    : $ nohup parallel opusencode "{}" "{.}".oga ::: *

#+begin_src bash :tangle (expand-file-name "opusencode" tangle/local-bin-dir)
set -euo pipefail

if [[ $# -ge 1 ]]; then
  INPUT_VIDEO=$1
  if [[ $# -eq 2 ]]; then
    OUTPUT_VIDEO=$2
  else
    OUTPUT_VIDEO=$(basename "${INPUT_VIDEO}").oga
  fi
fi

opus_opts="-c:a libopus -b:a 64k -ac 2"

ffmpeg -i "${INPUT_VIDEO}" ${opus_opts} "${OUTPUT_VIDEO}"
#+end_src

** DVD Packing

#+begin_src scheme :noweb-ref guix-base
"dvdbackup"
"libdvdnav"
"libdvdcss"
"libdvdread"
"handbrake"
#+end_src

#+begin_src bash :tangle (expand-file-name "dvdpack" tangle/local-bin-dir)
set -euo pipefail

if [ "${OPTIND}" = 1 ]; then
  while getopts t: OPT
  do
    case ${OPT} in
    t)
      TITLE=${OPTARG}
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi
shift $((OPTIND - 1))

if [[ $# -ge 1 ]]; then
  DVD_DIR=$1
  if [[ $# -eq 2 ]]; then
    DVD_PACK_VIDEO=$2
  else
    DVD_PACK_VIDEO=$(basename "${DVD_DIR}").mkv
  fi
fi

if [ -v TITLE ]; then
  title_opt="--title ${TITLE}"
else
  title_opt='--main-feature'
fi

hb_opts="--x264-preset veryslow --quality 18 --aencoder copy ${title_opt} --markers --all-audio --all-subtitles"

HandBrakeCLI --input "${DVD_DIR}" --output "${DVD_PACK_VIDEO}" ${hb_opts}
#+end_src
** CD Ripping

#+begin_src scheme :noweb-ref guix-base
"abcde"
"eyed3"
"lame"
"opus-tools"
"cdrtools"
"easytag"
#+end_src

*** abcde

#+BEGIN_SRC conf :tangle (expand-file-name ".abcde.conf")
# .flac is only desired output format
OUTPUTTYPE="flac"
# or .flac and .opus (bitrate is 256 kbps) will be generated at the same time
# OUTPUTTYPE="flac,opus"
# OPUSENCOPTS='--bitrate 256'

# .flac files will be utterly compressed with verification
FLACOPTS="-V8"

MAXPROCS=4

OUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${TRACKNUM}.${TRACKFILE}'
#+END_SRC

** Tutorial Video Creation
:PROPERTIES:
:CREATED:  [2022-08-15 Mon 20:13]
:END:

#+begin_src scheme :noweb-ref guix-desktop
"slop"
"gimp"
"obs"
"kdenlive"
"audacity"
#+end_src

*** Screenkey
:PROPERTIES:
:CREATED:  [2023-03-19 Sun 16:43]
:END:

#+begin_src scheme :noweb-ref guix-desktop
"python-screenkey"
#+end_src

#+begin_src json :tangle no :tangle (expand-file-name ".config/screenkey.json")  :tangle-mode (identity #o644) :comments no
{
  "timeout": 0.8,
  "key_mode": "composed",
  "bak_mode": "normal",
  "mods_mode": "emacs",
  "opacity": 0.3,
  "screen": 0
}
#+end_src

** Sync Git Repos Automatically
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 16:43]
:END:

#+begin_src conf :noweb yes :noweb-ref cronjob-user
30 23 */3 * * /usr/bin/bash -ci "ghq-sync >> $LOG_DIR/ghq-sync.log 2>&1"
#+end_src

#+name: ghq-sync
#+begin_src bash :tangle (expand-file-name "ghq-sync" tangle/local-bin-dir)
function git-one-go {
  local _branch=$(git symbolic-ref -q HEAD | sed 's/refs\/heads\///')
  local _remote=$(git config --get branch.$_branch.pushRemote)
  local _commit_msg="auto-commit by $(whoami) on $(uname -n) at $(date +"%H:%M %b %d")"

  echo -e "\nStarting git syncing at $(pwd)"

  git add -u
  if [ -n "$(git status --porcelain)" ]; then
    git commit --allow-empty -m "${_commit_msg}"
  fi

  if [ -n "$(git log origin/main..HEAD)" ]; then
    git push $_remote $_branch
    if [ $? != 0 ]; then
      echo "ghq-sync: git push returned non-zero. Likely a connection failure." >&2
      exit 1
    fi
  else
    echo "No unpushed commits found. Nothing to push."
  fi
}

for repo in $(ghq list --full-path); do
  cd $repo && git pull
done

# cd $(ghq list --full-path p-snow/env) && git-one-go
# cd $(ghq list --full-path -e p-snow/org) && git-one-go
#+end_src

*** git-sync                                  :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-09-26 Mon 15:14]
:END:

[[https://github.com/simonthum/git-sync][git-sync]] enables to sync (stage, commit and pull/push) git repositories. I use it for my org-file repo in daily basis.

# #+begin_src gitconfig :noweb-ref git-config
#   [branch "main"]
#           syncCommitMsg = "on $(LC_TIME=en_GB.UTF-8 date) from $(uname -n)"
# #+end_src

#+header: :shebang "#!/usr/bin/env bash"
#+begin_src bash :noweb tangle :tangle (expand-file-name "git-sync" tangle/local-bin-dir)
#
# git-sync
#
# synchronize tracking repositories
#
# 2012-20 by Simon Thum and contributors
# Licensed as: CC0
#
# This script intends to sync via git near-automatically
# in "tracking" repositories where a nice history is not
# crucial, but having one at all is.
#
# Unlike the myriad of scripts to do just that already available,
# it follows the KISS principle: It is small, requires nothing but
# git and bash, but does not even try to shield you from git.
#
# Mode sync (default)
#
# Sync will likely get from you from a dull normal git repo with trivial
# changes to an updated dull normal git repo equal to origin. No more,
# no less. The intent is to do everything that's needed to sync
# automatically, and resort to manual intervention as soon
# as something non-trivial occurs. It is designed to be safe
# in that it will likely refuse to do anything not known to
# be safe.
#
# Mode check
#
# Check only performs the basic checks to make sure the repository
# is in an orderly state to continue syncing, i.e. committing
# changes, pull etc. without losing any data. When check returns
# 0, sync can start immediately. This does not, however, indicate
# that syncing is at all likely to succeed.

# command used to auto-commit file modifications
DEFAULT_AUTOCOMMIT_CMD="git add -u ; git commit -m \"%message\";"

# command used to auto-commit all changes
ALL_AUTOCOMMIT_CMD="git add -A ; git commit -m \"%message\";"

# default commit message substituted into autocommit commands
DEFAULT_AUTOCOMMIT_MSG="changes from $(uname -n) on $(date)"


# AUTOCOMMIT_CMD="echo \"Please commit or stash pending changes\"; exit 1;"
# TODO mode for stash push & pop

print_usage() {
  cat << EOF
usage: $0 [-h] [-n] [-s] [MODE]

Synchronize the current branch to a remote backup
MODE may be either "sync" (the default) or "check", to verify that the branch is ready to sync

OPTIONS:
   -h      Show this message
   -n      Commit new files even if branch.\$branch_name.syncNewFiles isn't set
   -s      Sync the branch even if branch.\$branch_name.sync isn't set
EOF
}
sync_new_files_anyway="false"
sync_anyway="false"

while getopts "hns" opt ; do
  case $opt in
  h )
    print_usage
    exit 0
    ;;
  n )
    sync_new_files_anyway="true"
    ;;
  s )
    sync_anyway="true"
    ;;
  esac
done
shift $((OPTIND-1))

#
#    utility functions, some adapted from git bash completion
#

__log_msg()
{
  echo git-sync: $1
}

# echo the git dir
__gitdir()
{
  if [ "true" = "$(git rev-parse --is-inside-work-tree "$PWD" | head -1)" ]; then
    git rev-parse --git-dir "$PWD" 2>/dev/null
  fi
}

# echos repo state
git_repo_state ()
{
  local g="$(__gitdir)"
  if [ -n "$g" ]; then
    if [ -f "$g/rebase-merge/interactive" ]; then
      echo "REBASE-i"
    elif [ -d "$g/rebase-merge" ]; then
      echo "REBASE-m"
    else
      if [ -d "$g/rebase-apply" ]; then
        echo "AM/REBASE"
      elif [ -f "$g/MERGE_HEAD" ]; then
        echo "MERGING"
      elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
        echo "CHERRY-PICKING"
      elif [ -f "$g/BISECT_LOG" ]; then
        echo "BISECTING"
      fi
    fi
    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        echo "|BARE"
      else
        echo "|GIT_DIR"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      git diff --no-ext-diff --quiet --exit-code || echo "|DIRTY"
      #			if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
      #			        git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      #			fi
      #
      #			if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
      #			   if [ -n "$(git ls-files --others --exclude-standard)" ]; then
      #			      u="%"
      #			   fi
      #			fi
      #
      #			if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #				__git_ps1_show_upstream
      #			fi
    fi
  else
    echo "NOGIT"
  fi
}

# check if we only have untouched, modified or (if configured) new files
check_initial_file_state()
{
  local syncNew="$(git config --get --bool branch.$branch_name.syncNewFiles)"
  if [[ "true" == "$syncNew" || "true" == "$sync_new_files_anyway" ]]; then
    # allow for new files
    if [ ! -z "$(git status --porcelain | grep -E '^[^ \?][^M\?] *')" ]; then
      echo "NonNewOrModified"
    fi
  else
    # also bail on new files
    if [ ! -z "$(git status --porcelain | grep -E '^[^ ][^M] *')" ]; then
      echo "NotOnlyModified"
    fi
  fi
}

# look for local changes
# used to decide if autocommit should be invoked
local_changes()
{
  if [ ! -z "$(git status --porcelain | grep -E '^(\?\?|[MARC] |[ MARC][MD])*')" ]; then
    echo "LocalChanges"
  fi
}

# determine sync state of repository, i.e. how the remote relates to our HEAD
sync_state()
{
  local count="$(git rev-list --count --left-right $remote_name/$branch_name...HEAD)"

  case "$count" in
  "") # no upstream
    echo "noUpstream"
    false
    ;;
  "0	0")
    echo "equal"
    true
    ;;
  "0	"*)
    echo "ahead"
    true
    ;;
  ,*"	0")
    echo "behind"
    true
    ;;
  ,*)
    echo "diverged"
    true
    ;;
  esac
}

# exit, issue warning if not in sync
exit_assuming_sync() {
  if [ "equal" == "$(sync_state)" ] ; then
    __log_msg "In sync, all fine."
    exit 0;
  else
    __log_msg "Synchronization FAILED! You should definitely check your repository carefully!"
    __log_msg "(Possibly a transient network problem? Please try again in that case.)"
    exit 3
  fi
}

#
#        Here git-sync actually starts
#

# first some sanity checks
rstate="$(git_repo_state)"
if [[ -z "$rstate" || "|DIRTY" = "$rstate" ]]; then
  __log_msg "Preparing. Repo in $(__gitdir)"
elif [[ "NOGIT" = "$rstate" ]] ; then
  __log_msg "No git repository detected. Exiting."
  exit 128 # matches git's error code
else
  __log_msg "Git repo state considered unsafe for sync: $(git_repo_state)"
  exit 2
fi

# determine the current branch (thanks to stackoverflow)
branch_name=$(git symbolic-ref -q HEAD)
branch_name=${branch_name##refs/heads/}

if [ -z "$branch_name" ] ; then
  __log_msg "Syncing is only possible on a branch."
  git status
  exit 2
fi

# while at it, determine the remote to operate on
remote_name=$(git config --get branch.$branch_name.pushRemote)
if [ -z "$remote_name" ] ; then
  remote_name=$(git config --get remote.pushDefault)
fi
if [ -z "$remote_name" ] ; then
  remote_name=$(git config --get branch.$branch_name.remote)
fi

if [ -z "$remote_name" ] ; then
  __log_msg "the current branch does not have a configured remote."
  echo
  __log_msg "Please use"
  echo
  __log_msg "  git branch --set-upstream-to=[remote_name]/$branch_name"
  echo
  __log_msg "replacing [remote_name] with the name of your remote, i.e. - origin"
  __log_msg "to set the remote tracking branch for git-sync to work"
  exit 2
fi

# check if current branch is configured for sync
if [[ "true" != "$(git config --get --bool branch.$branch_name.sync)" && "true" != "$sync_anyway" ]] ; then
  echo
  __log_msg "Please use"
  echo
  __log_msg "  git config --bool branch.$branch_name.sync true"
  echo
  __log_msg "to enlist branch $branch_name for synchronization."
  __log_msg "Branch $branch_name has to have a same-named remote branch"
  __log_msg "for git-sync to work."
  echo
  __log_msg "(If you don't know what this means, you should change that"
  __log_msg "before relying on this script. You have been warned.)"
  echo
  exit 1
fi

# determine mode
if [[ -z "$1" || "$1" == "sync" ]]; then
  mode="sync"
elif [[ "check" == "$1" ]]; then
  mode="check"
else
  __log_msg "Mode $1 not recognized"
  exit 100
fi

__log_msg "Mode $mode"

__log_msg "Using $remote_name/$branch_name"

# check for intentionally unhandled file states
if [ ! -z "$(check_initial_file_state)" ] ; then
  __log_msg "There are changed files you should probably handle manually."
  git status
  exit 1
fi

# if in check mode, this is all we need to know
if [ $mode == "check" ] ; then
  __log_msg "check OK; sync may start."
  exit 0
fi

# check if we have to commit local changes, if yes, do so
if [ ! -z "$(local_changes)" ]; then
  autocommit_cmd=""
  config_autocommit_cmd="$(git config --get branch.$branch_name.autocommitscript)"

  # discern the three ways to auto-commit
  if [ ! -z "$config_autocommit_cmd" ]; then
    autocommit_cmd="$config_autocommit_cmd"
  elif [[ "true" == "$(git config --get --bool branch.$branch_name.syncNewFiles)" || "true" == "$sync_new_files_anyway" ]]; then
    autocommit_cmd=${ALL_AUTOCOMMIT_CMD}
  else
    autocommit_cmd=${DEFAULT_AUTOCOMMIT_CMD}
  fi

  commit_msg="$(git config --get branch.$branch_name.syncCommitMsg)"
  if [ "" == "$commit_msg" ]; then
    commit_msg=${DEFAULT_AUTOCOMMIT_MSG}
  fi
  autocommit_cmd=$(echo "$autocommit_cmd" | sed "s/%message/$commit_msg/")

  __log_msg "Committing local changes using ${autocommit_cmd}"
  eval $autocommit_cmd

  # after autocommit, we should be clean
  rstate="$(git_repo_state)"
  if [[ ! -z "$rstate" ]]; then
    __log_msg "Auto-commit left uncommitted changes. Please add or remove them as desired and retry."
    exit 1
  fi
fi

# fetch remote to get to the current sync state
# TODO make fetching/pushing optional
__log_msg "Fetching from $remote_name/$branch_name"
git fetch $remote_name $branch_name
if [ $? != 0 ] ; then
  __log_msg "git fetch $remote_name returned non-zero. Likely a network problem; exiting."
  exit 3
fi

case "$(sync_state)" in
"noUpstream")
  __log_msg "Strange state, you're on your own. Good luck."
  exit 2
  ;;
"equal")
  exit_assuming_sync
  ;;
"ahead")
  __log_msg "Pushing changes..."
  git push $remote_name $branch_name:$branch_name
  if [ $? == 0 ]; then
    exit_assuming_sync
  else
    __log_msg "git push returned non-zero. Likely a connection failure."
    exit 3
  fi
  ;;
"behind")
  __log_msg "We are behind, fast-forwarding..."
  git merge --ff --ff-only $remote_name/$branch_name
  if [ $? == 0 ]; then
    exit_assuming_sync
  else
    __log_msg "git merge --ff --ff-only returned non-zero ($?). Exiting."
    exit 2
  fi
  ;;
"diverged")
  __log_msg "We have diverged. Trying to rebase..."
  git rebase $remote_name/$branch_name
  if [[ $? == 0 && -z "$(git_repo_state)" && "ahead" == "$(sync_state)" ]] ; then
    __log_msg "Rebasing went fine, pushing..."
    git push $remote_name $branch_name:$branch_name
    exit_assuming_sync
  else
    __log_msg "Rebasing failed, likely there are conflicting changes. Resolve them and finish the rebase before repeating git-sync."
    exit 1
  fi
  # TODO: save master, if rebasing fails, make a branch of old master
  ;;
esac
#+end_src

** Controlling Emacs from Desktop
:PROPERTIES:
:CREATED:  [2024-01-30 Tue 21:11]
:END:

Using the Emacs server capability, the following actions can be executed from a Linux desktop:
- Download media files
- Browse URLs in EWW

#+NAME: bash/emacs-server
#+begin_src bash :noweb tangle :tangle (expand-file-name "emacs-server" tangle/local-bin-dir)
command=$1
opt=$(xclip -out)

emacsclient -s server-<<hash-string(seed="server", len=6)>> \
            --eval "(my/emacs-batch \"${command}\" \"${opt}\")"
#+end_src

#+NAME: elisp/emacs-batch
#+begin_src emacs-lisp :noweb-ref elisp-code
(defun my/emacs-batch (command &optional args)
  ""
  (pcase command
    ("download"
     (my/yt-dlp-command args)
     (my/tsc-execute-macro))
    ("browse"
     (eww args))))
#+end_src

* Babel Utility Functions
:PROPERTIES:
:header-args+: :tangle-mode (identity #o755)
:END:
** which path

Return the absolute path for the 'filename' without expansion, allowing for user-agnostic configuration.

#+name: which
#+begin_src bash :var filename=""
which ${filename} | sed "s:$HOME:~:"
#+end_src

** Generate hash string
:PROPERTIES:
:CREATED:  [2023-10-15 Sun 18:41]
:END:

Return hash string from 'seed'. You can cull the output to desired length by 'len'.

#+name: hash-string
#+header: :var seed="str" len=8
#+begin_src python
import hashlib

sha256_hash = hashlib.sha256(seed.encode("utf-8"))
return sha256_hash.hexdigest()[:len]
#+end_src

** random number

return random number between 0 and max

#+name: random
#+header: :var max=10
#+begin_src emacs-lisp
(calc-eval (format "random(%d)" (1+ max)))
#+end_src

** Hours in seconds

#+name: hours-in-sec
#+begin_src emacs-lisp :var h=1
(* h 60 60)
#+end_src

* Specialized Scripts
:PROPERTIES:
:CREATED:  [2023-10-30 Mon 20:22]
:END:

** Declutters                                  :ARCHIVE:

These scripts (declutter_xxx) keep things decluttered.

- trash
  #+begin_src conf
  0 2 * * * /bin/bash -ci "declutter_trash >> $LOG_DIR/declutter_trash.log 2>&1"
  #+end_src

  #+begin_src python :noweb yes :tangle no
  #!/usr/bin/env python3

  import os
  import time
  import datetime
  import shutil
  import glob
  from send2trash import send2trash

  TRASH_DIR = os.environ['HOME'] + '/.local/share/Trash/files/'
  TIDY_DIRS = filter(lambda x: os.path.isdir(x),
                     list(map(lambda x: os.path.join(os.environ['HOME'], x), ['tmp', 'Downloads']))
                     + glob.glob(os.path.join(os.environ['HOME'], 'tmp/*')))

  MAX_STAY_DAYS_IN_TRASH = 7
  MAX_NEGLECTED_DAYS_IN_TIDY_DIRS = 14

  suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
  def humansize(nbytes):
      i = 0
      while nbytes >= 1024 and i < len(suffixes)-1:
          nbytes /= 1024.
          i += 1
          f = ('%.2f' % nbytes).rstrip('0').rstrip('.')
      return '%s %s' % (f, suffixes[i])

  def get_size(start_path = '.'):
      total_size = 0
      for dirpath, dirnames, filenames in os.walk(start_path):
          for f in filenames:
              fp = os.path.join(dirpath, f)
              # skip if it is symbolic link
              if not os.path.islink(fp):
                  total_size += os.path.getsize(fp)

      return total_size

  print('{0} starts at {1}\n'.format(os.path.basename(__file__),
                                     datetime.datetime.now()))

  NOW = time.time()

  print('--{0} starts to move files neglected more than {1} days to trash box.\n'
        .format(os.path.basename(__file__),
                MAX_NEGLECTED_DAYS_IN_TIDY_DIRS))

  tidyup_lists = map(lambda x: map(lambda y: os.path.join(x, y), os.listdir(x)), TIDY_DIRS)
  for a_file in [item for sublist in tidyup_lists for item in sublist]:
      atime = os.lstat(a_file).st_atime
      delta_atime = datetime.timedelta(seconds=(NOW - atime))
      if delta_atime > datetime.timedelta(days = MAX_NEGLECTED_DAYS_IN_TIDY_DIRS):
          try:
              send2trash(a_file)
          except OSError as error:
              print(error)
          else:
              print('moveed to trash: {}'.format(a_file))

  print('--{0} starts to remove files staying more than {1} days in trash box.'
        .format(os.path.basename(__file__),
                MAX_STAY_DAYS_IN_TRASH))

  rbytes_total = 0
  for trash_file in map(lambda fname: os.path.join(TRASH_DIR, fname), os.listdir(TRASH_DIR)):
      lstat = os.lstat(trash_file)
      delta_time = datetime.timedelta(seconds=(NOW - max(lstat.st_atime, lstat.st_ctime)))
      if delta_time > datetime.timedelta(days = MAX_STAY_DAYS_IN_TRASH):
          method = 'removed'
          fname = os.path.basename(trash_file)
          if os.path.islink(trash_file):
              method = 'unlinked'
              fsize = 'N/A'
              os.unlink(trash_file)
          elif os.path.isfile(trash_file):
              rbytes = os.path.getsize(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              os.remove(trash_file)
          elif os.path.isdir(trash_file):
              rbytes = get_size(trash_file)
              rbytes_total += rbytes
              fsize = humansize(rbytes)
              fname += '/'
              shutil.rmtree(trash_file)
              print('{}: [{:>9}] {}'.format(method, fsize, fname))

  print('--{0} removes [{1}] in total.\n'
        .format(os.path.basename(__file__),
                humansize(rbytes_total)))

  print('{0} ends at {1}\n'.format(os.path.basename(__file__),
                                   datetime.datetime.now()))
  #+end_src
- home directory (ruby implementation)
  #+begin_src ruby :tangle no
  #!/usr/bin/env ruby
  # coding: utf-8

  TRASHES = ["*~", "#*#", ".#*#", "._*", ".DS_Store"]

  class Sweep
    def self.sweep(base_dir)
      puts base_dir
      TRASHES.each do |trash|
        tfiles = File.join("%s/**" % base_dir, trash)
        Dir.glob(tfiles).each do |f|
          if File.delete(f) > 0
            puts "Removed: " + f
          else
            puts "CANNOT Removed: " + f
          end
        end
      end
    end
  end

  ARGV.each do |arg|
    if Dir.exist?(arg) then
      Sweep.sweep(arg)
    end
  end
  #+end_src
- home directory (python implementation)
  #+begin_src python :tangle no
  #!/usr/bin/env python3

  import sys
  import os
  import glob
  import argparse

  TRASH_REGEXPS = ["*~", "#*", ".#*", "._*", ".DS_Store", "*.dvi", "*.aux", "*.bbl"]

  class Sweepy:
      @classmethod
      def sweep_with_regexp(self, base_dir, recursive=False):
          for trash_regexp in TRASH_REGEXPS:
              files = glob.glob("%s/**/" % base_dir + trash_regexp, recursive=recursive)
              for file in files:
                  if os.path.isfile(file):
                      os.remove(file)
                      print("Removed: " + file)
                      @classmethod
      def sweep_broken_symlink(self, base_dir, recursive=False):
          files = glob.glob("%s/*" % base_dir, recursive=recursive)
          dotfiles = glob.glob("%s/.*" % base_dir, recursive=recursive)
          for file in (files + dotfiles):
              if os.path.islink(file):
                  if not os.path.exists(os.readlink(file)):
                      os.unlink(file)
                      print("Unlinked: " + file)

  parser = argparse.ArgumentParser(description='Removes all desired files')
  parser.add_argument('dir', metavar='dir', nargs='?', action='store',
                      help='base directory to search')
  parser.add_argument('-r', dest='recursive', action="store_true", default=False)
  args = parser.parse_args()
  if args.recursive:
      Sweepy.sweep_with_regexp(args.dir, recursive=True)
      Sweepy.sweep_broken_symlink(args.dir, recursive=True)
  else:
      Sweepy.sweep_with_regexp(args.dir, recursive=False)
      Sweepy.sweep_broken_symlink(args.dir, recursive=False)
  #+end_src

** Database back-up scripts
- PostgreSQL
  #+begin_src bash :tangle (expand-file-name ".local/bin/postgres_backup")
  #!/usr/bin/env bash

  # Usage: $ postgres_backup <db_name> <backup_dir>

  POSTGRES_DBNAME=$1
  BACKUP_DIR=$2
  DATE="$(date +%Y%m%d_%H%M)"

  pg_dump --format=custom ${POSTGRES_DBNAME} > ${BACKUP_DIR}/${DATE}_${POSTGRES_DBNAME}.custom || exit 1

  exit 0
  #+end_src

- MySQL
  #+begin_src shell :tangle (expand-file-name ".local/bin/mysql_backup") :shebang #!/usr/bin/env bash
  BACKUP_DIR=~/data/share/backups/mysql
  RAW_SQL="$(date +%Y%m%d_%H%M)_backup.sql"
  TAR_SQL="${RAW_SQL}.txz"

  (
    cd "${BACKUP_DIR}" || exit 1
    mysqldump --opt --all-databases --events --default-character-set=binary -u root > "${RAW_SQL}"
    tar cfJ "${TAR_SQL}" "${RAW_SQL}"
    rm -f "${RAW_SQL}"
  ) || exit 1

  exit 0
  #+end_src

** filetype

This program determine type of the file.

#+begin_src ruby :tangle (expand-file-name ".local/lib/filetype.rb")
#!/usr/bin/env ruby

require 'pathname'
require 'uri'
require 'shellwords'

class FileType
  ZIP_PREFIXES = ['Zip archive data']

  def self.type(filename, file_cmd_opt = "")
    if  File.exist?(filename)
      local_opt = ""
      if File.symlink?(filename)
        local_opt += "--dereference"
      end
      `file --brief #{file_cmd_opt} #{local_opt} #{Shellwords.shellescape(filename)}`.strip
    elsif filename =~ /https?:\/\/www\.youtube\.com.*/
      `yt-dlp -f worst -q #{Shellwords.shellescape(filename)} -o - 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
    elsif filename =~ URI::DEFAULT_PARSER.make_regexp
      `curl --location --range 0-9999 #{Shellwords.shellescape(filename)} 2>/dev/null | file --brief #{file_cmd_opt} -`.strip
    else
      ''
    end
  end

  def self.mime_type(filename)
    type(filename, "--mime-type")
  end

  def self.block_device?(file)
    type(file).start_with?('block special') &&
      mime_type(file) == 'inode/blockdevice'
  end

  def self.iso9660?(file)
    mime_type(file) == 'application/x-iso9660-image'
  end

  def self.video_dvd_image?(file)
    iso9660?(file) && type(file).start_with?('UDF filesystem data')
  end

  def self.html?(file)
    type(file).start_with?("HTML document")
  end

  def self.pdf?(file)
    type(file).start_with?("PDF document")
  end

  def self.epub?(file)
    type(file) == "EPUB document"
  end

  def self.mobi?(file)
    type(file).start_with?("Mobipocket E-book")
  end

  def self.pgp?(file)
    type(file).start_with?("PGP")
  end

  def self.tarpgp?(file)
    pgp?(file) && file.end_with?('.tar.gpg')
  end

  def self.zip?(file)
    type(file).start_with?(*ZIP_PREFIXES)
  end

  def self.video?(file)
    mime_type(file).start_with?("video/")
  end

  def self.audio?(file)
    mime_type(file).start_with?('audio/')
  end

  def self.image?(file)
    mime_type(file).start_with?("image/")
  end

  def self.playable?(file)
    if File.directory?(file)
      Dir.foreach(file) do |fname|
        next if [".", ".."].include?(fname)
        return false unless playable?("#{file}/#{fname}")
      end
      true
    elsif file =~ /https?:\/\/www\.youtube\.com.*/
      true
    else
      type(file).start_with?("ISO Media", "Audio file") ||
        mime_type(file).start_with?("video", "audio", "image")
    end
  end

  def self.dvd_dir?(file)
    false unless mime_type(file) == 'inode/directory'
    File.exist?(Pathname.new(file).join("VIDEO_TS")) ||
      File.exist?(Pathname.new(file).join("video_ts"))
  end
end
#+end_src
** mediautil

Utility ruby program for manipulating image, audio and video file.

#+begin_src scheme :noweb-ref guix-base
"dvd+rw-tools"
#+end_src

#+begin_src ruby :tangle (expand-file-name "mediautil" tangle/local-bin-dir)
require 'thor'
require 'open3'
require 'fileutils'
require 'tempfile'
require 'tmpdir'

require 'filetype'

class MediaUtil < Thor
  OUTFILE_SUFFIX = "_out"
  DEFAULT_VIDEO_EXT = ".mkv"

  class Names < Struct.new(:in_f, :out_f)
    def in_file()
      in_f
    end
    def out_file(extension = nil)
      if out_f
        out_f
      else
        bn = File.basename(in_f, ".*").gsub(/ /, '_')
        ext = ((extension) ? extension : File.extname(in_file))
        default_out = bn + ext
        if File.file?(default_out)
          10.times do |i|
            try_name = bn + "_" + (i+1).to_s + ext
            unless File.file?(try_name)
              return try_name
            end
          end
        end
        default_out
      end
    end
    def title()
      File.basename(out_file, ".*")
    end
  end
  class Commander < Struct.new(:log, :dry)
    def execute(command)
      if dry
        puts command
      else
        log_str, s_code = Open3.capture2e(command)
        if log
          user_cmd = caller.first.scan(/`(.*)'/).flatten.first.to_s
          log_fname = Time.now.strftime("%Y%m%d_%H%M%S_") + user_cmd + ".log"
          File.open(log_fname, "w") do |f|
            f.puts(log_str)
          end
        else
          puts log_str
        end
        exit false unless s_code.success?
        # exit false
      end
    end
  end

  class_option :log, aliases: "L", :type => :boolean,
               :desc => "log stdout and stderr instead they reveal in terminal"
  class_option :dryrun, aliases: "D", :type => :boolean

  desc "info <file>", "show information about the video file or DVD directory"
  option :short, aliases: "s", :type => :boolean
  def info(target)
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(target) || FileType.audio?(target)
      commander.execute("ffprobe \"#{target}\" -hide_banner -show_entries format")
    elsif FileType.image?(target)
      if options[:short]
        commander.execute("identify #{target}")
      else
        commander.execute("identify -verbose #{target}")
      end
    elsif FileType.block_device?(target) ||
          FileType.video_dvd_image?(target) ||
          FileType.dvd_dir?(target)
      commander.execute("HandBrakeCLI -i \"#{target}\" --title 0")
    else
      STDERR.puts "Unknown Media Format"
      exit false
    end
  end

  default_command :encode
  desc "encode", "encode video file"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :vencoder, aliases: "e", :type => :string,
         :banner => "libx265|libx264",
         :desc => "video encoder"
  option :vquality, aliases: "q", :type => :string,
         :banner => "24.0",
         :desc => "video encoding quality"
  option :vbitrate, aliases: "b", :type => :string,
         :banner => "1000",
         :desc => "video encoding bitrate in kbps"
  option :aencoder, aliases: "E", :type => :string,
         :banner => "fdk_aac",
         :desc => "audio encoder"
  option :aquality, aliases: "Q", :type => :string,
         :banner => "100.0",
         :desc => "audio encoding quality"
  option :abitrate, aliases: "B", :type => :string,
         :banner => "128",
         :desc => "audio encoding bitrate in kbps"
  option :display, aliases: "d", :type => :string,
         :banner => "1920:1080",
         :desc => 'display (width:height) in which encoded video fit'
  option :fps, aliases: "f", :type => :string,
         :banner => "30",
         :desc => 'max frame rate'
  option :ffmpeg, :type => :string
  def encode()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    vconf = aconf = pconf = nil
    if options[:vencoder] || options[:vquality]
      vconf = VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
    end
    if options[:aencoder] || options[:aquality]
      aconf = AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
    end
    if options[:display] || options[:fps]
      pconf = PictureConfig.new
      pconf.fit_size(options[:display]) if options[:display]
      pconf.decrease_framerate(options[:fps]) if options[:fps]
    end

    if FileType.video?(equip.in_file) then
      commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                       [FFMPEGOptSet.new(equip.out_file, [vconf, aconf, pconf, "-map_metadata 0", options[:ffmpeg]])]))
    elsif FileType.audio?(equip.in_file) then
      commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, [])],
                                       [FFMPEGOptSet.new(equip.out_file, [aconf])]))
    elsif FileType.image?(equip.in_file) then
      pconf = ImageConfig.new
      commander.execute(ImageMagick.command(equip.in_file,
                                            equip.out_file,
                                            pconf))
    else
      STDERR.puts "Unknown Media Format"
      exit false
    end
  end

  desc 'cdencode', 'rip and encode CD contents'
  option :device, aliases: 'd', :type => :string,
         :desc => 'Device file'
  option :format, aliases: 'f', :type => :string,
         :banner => 'flac,ogg,m4a', :default => 'flac:-8',
         :desc => 'formats with additinal argument like compression level'
  def cdencode()
    commander = Commander.new(options[:log], options[:dryrun])

    abcde_args = []
    abcde_args << "-d #{options[:device]}" if options[:device]
    abcde_args << '-a default'
    if options[:format] then
      abcde_args << "-o '#{options[:format]}'"
    end
    abcde_args << '-G' # getalbumart
    abcde_args << '-x' # Eject CD

    commander.execute("abcde #{abcde_args.join(' ')}")
  end

  desc 'dvdrip', 'rip(backup) DVD contents'
  option :device, aliases: 'd', :type => :string,
         :desc => 'DVD device file'
  option :out, aliases: 'o', :type => :string,
         :desc => 'output directory name'
  option :name, aliases: 'n', :type => :string,
         :desc => 'root directory name of backup data'
  def dvdrip()
    commander = Commander.new(options[:log], options[:dryrun])

    dvdbackup_opts = ['dvdbackup']
    dvdbackup_opts << '--input=%s' % options[:device] if options[:device]
    dvdbackup_opts << '--output=%s' % options[:out] if options[:out]
    dvdbackup_opts << '--name=%s' % options[:name] if options[:name]
    dvdbackup_opts << '--mirror'
    dvdbackup_opts << '--progress'
    dvdbackup_opts << '--verbose'

    commander.execute(dvdbackup_opts.join(' '))
  end

  desc 'dvdencode', 'encode DVD contents'
  option :in, aliases: 'i', :type => :string, :required => true,
         :desc => 'input source, DVD device file or backuped DVD file'
  option :out, aliases: 'o', :type => :string,
         :desc => 'output directory name'
  option :vencoder, aliases: "e", :type => :string,
         :banner => "x265|x264",
         :desc => "video encoder"
  option :vquality, aliases: "q", :type => :string,
         :banner => "24.0",
         :desc => "video encoding quality"
  option :vbitrate, aliases: "b", :type => :string,
         :banner => "1000",
         :desc => "video bitrate in kbps"
  option :aencoder, aliases: "E", :type => :string,
         :banner => "fdk_aac",
         :desc => "audio encoder"
  option :aquality, aliases: "Q", :type => :string,
         :banner => "100.0",
         :desc => "audio encoding quality"
  option :abitrate, aliases: "B", :type => :string,
         :banner => "128",
         :desc => "audio bitrate in kbps"
  option :title, aliases: 't', :type => :string,
         :banner => '1|2|3|...',
         :desc => 'title number'
  option :chapters, aliases: 'c', :type => :string,
         :banner => '1|1-3|1,3,5|...',
         :desc => 'chapter numbers'
  option :audio, aliases: 'a', :type => :string,
         :banner => '1,2,3',
         :desc => 'audio channel'
  option :subtitle, aliases: 's', :type => :string,
         :banner => '1,2',
         :desc => 'subtitle channel'
  option :handbrake, :type => :string,
         :banner => '--handbrake \"--mixdown 5point1,stereo\"',
         :desc => 'HandBrakeCLI options'
  def dvdencode()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.block_device?(equip.in_file) ||
       FileType.video_dvd_image?(equip.in_file) ||
       FileType.dvd_dir?(equip.in_file)
      configs = []
      configs << VideoConfig.new(options[:vencoder], options[:vquality], options[:vbitrate])
      configs << AudioConfig.new(options[:aencoder], options[:aquality], options[:abitrate])
      dconf = DVDConfig.new
      dconf.title = options[:title] if options[:title]
      dconf.chapters = options[:chapters] if options[:chapters]
      dconf.audio = options[:audio] if options[:audio]
      dconf.subtitle = options[:subtitle] if options[:subtitle]
      configs << dconf
      commander.execute(HandBrakeCLI.command(equip.in_file,
                                             equip.out_file(DEFAULT_VIDEO_EXT),
                                             configs,
                                             options[:handbrake]))
    end
  end

  desc 'mount <dir>', 'Mount CD/DVD media to dir.'
  option :device, aliases: "d", :type => :string, :required => true,
         :desc => 'device or iso file to mount',
         :banner => '--mount /dev/dvd|image.iso'
  option :type, aliases: 't', :type => :string,
         :desc => 'mount DVD-Video',
         :banner => '--type data|video'
  def mount(dir)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['mount']
    if options[:type] == 'video' || FileType.video_dvd_image?(options[:device])
      cmd_opts << ['-t', 'iso9660', '-o', 'loop']
    end
    cmd_opts << options[:device]
    cmd_opts << dir

    Dir.mkdir(dir) if !Dir.exist?(dir) && !options[:dryrun]
    commander.execute("sudo #{cmd_opts.join(' ')}")
  end

  desc 'umount', 'unmount dir'
  option :remove, aliases: 'r', :type => :boolean,
         :desc => 'remove dir after unmounting'
  def umount(dir)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['umount']
    cmd_opts << dir

    commander.execute("sudo #{cmd_opts.join(' ')}")

    if options[:remove]
      FileUtils.rmdir(dir)
    end
  end

  desc 'mkiso', 'make ISO image file.'
  option :type, aliases: 't', :type => :string, :required => true,
         :desc => 'DVD image type. Data or Video DVD.',
         :banner => '--type data|video'
  option :volume, aliases: 'V', :type => :string,
         :desc => 'Volume Label'
  option :out, aliases: 'o', :type => :string,
         :desc => 'ISO image file name.',
         :banner => '--out movie.iso'
  def mkiso(file)
    names = Names.new(file, options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    mkisofs_opts = ['mkisofs']
    mkisofs_opts << ["-V", "\"#{options[:volume]}\""] if options[:volume]
    if options[:type] == "data"
      mkisofs_opts << ["-r", "-l", "-J"]
    elsif options[:type]
      mkisofs_opts << "-dvd-video"
    else
      exit 1
    end
    mkisofs_opts << ["-o", "\"#{names.out_file('.iso')}\""]
    mkisofs_opts << "\"#{file}\""

    commander.execute(mkisofs_opts.join(" "))
  end

  desc 'dvdburn <file>', 'Burn file to DVD.'
  option :iso, aliases: 'I', :type => :boolean,
         :desc => 'Set this option if <file> is ISO 9660 compliant.'
  option :volume, aliases: 'V', :type => :string, :default => 'DVD_VIDEO',
         :desc => 'Volume Label'
  option :video, aliases: 'v', :type => :boolean,
         :desc => 'Create DVD video image file to burn.'
  option :speed, aliases: 's', :type => :string, :default => '4',
         :desc => 'Burning Speed',
         :banner => 'n'
  option :device, aliases: 'd', :type => :string,
         :desc => 'Device file', :default => '/dev/sr0'
  def dvdburn(file)
    commander = Commander.new(options[:log], options[:dryrun])

    cmd_opts = ['growisofs']
    cmd_opts << '-dvd-compat'
    cmd_opts << '-speed=%s' % options[:speed]
    if FileType.iso9660?(file) || options[:iso]
      cmd_opts << '-Z %s=%s' % [options[:device], file]
    else
      cmd_opts << '-Z %s' % options[:device]
      mkisofs_opts = []
      mkisofs_opts << ['-V', "\"#{options[:volume]}\""] if options[:volume]
      if options[:video]
        mkisofs_opts << '-dvd-video'
      else # Data-DVD
        mkisofs_opts << ['-r', '-l', '-R']
      end
      mkisofs_opts << file
      cmd_opts << mkisofs_opts
    end

    commander.execute(cmd_opts.join(' '))
  end

  desc "cdburn", "burn files to CD device"
  option :in, aliases: "i", :type => :string, :required => true,
         :desc => "Root Directory for image file"
  option :volume, aliases: "v", :type => :string, :required => true,
         :desc => "Volume ID"
  option :device, aliases: "d", :type => :string,
         :desc => "Device file", :default => "/dev/sr0"
  def cdburn()
    commander = Commander.new(options[:log], options[:dryrun])

    commander.execute("mkisofs -V \"#{options[:volume]}\" -J -r #{options[:in]} | cdrecord -v dev=#{options[:device]} -waiti -")
  end

  desc "screenshot", "take a screenshot of a video at a time"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :time, aliases: "t", :type => :string,
         :desc => "ex. 00:10:22.300"
  def screenshot()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])
    if FileType.video?(equip.in_file) then
      args = ['ffmpeg']
      args << ('-ss %s' % options[:time]) if options[:time]
      args << '-i %s' % equip.in_file
      args << '-vframes 1'
      args << '-q:v 2'
      args << equip.out_file('.jpg')
      commander.execute(args.join(' '))
    end
  end

  desc "clip", "clip a video with specific time span"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :time_begin, aliases: "b", :type => :string,
         :desc => "ex. 00:10:22.300"
  option :time_end, aliases: "e", :type => :string
  def clip()
    equip = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(equip.in_file) then
      if options[:time_begin] or options[:time_end] then
        in_opts = []
        in_opts << "-ss #{options[:time_begin]}" if options[:time_begin]
        in_opts << "-to #{options[:time_end]}" if options[:time_end]
        out_opts = []
        out_opts << "-vcodec copy"
        out_opts << "-acodec copy"
        out_opts << "-map_metadata 0"
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(equip.in_file, in_opts)],
                                         [FFMPEGOptSet.new(equip.out_file, out_opts)]))
      end
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "crop", "extract a specific rectangle of a image/video"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :width, aliases: "w", :type => :numeric, :required => true
  option :height, aliases: "h", :type => :numeric, :required => true
  option :xpos, aliases: "x", :type => :numeric,
         :desc => "x coordinate of an original image where cropped image of top-left corner overlaps"
  option :ypos, aliases: "y", :type => :numeric
  def crop()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    width = options[:width]
    height = options[:height]
    xpos = options[:xpos] ? options[:xpos] : 0
    ypos = options[:ypos] ? options[:ypos] : 0
    if FileType.image?(names.in_file) then
      opt = '-crop %dx%d+%dx%d' % [width, height, xpos, ypos]
      commander.execute("convert #{opt} #{names.in_file} #{names.out_file}")
    elsif FileType.video?(names.in_file) then
      args = ['ffmpeg']
      args << '-i %s' % names.in_file
      args << '-vf crop=%d:%d:%d:%d' % [width, height, xpos, ypos]
      args << "-map_metadata 0"
      args << names.out_file
      commander.execute(args.join(' '))
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "trim", "trim a image/video with automated detection"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :threshold, aliases: "t", :type => :string,
         :desc => "threshold where trimming begin and end"
  def trim()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.image?(names.in_file) then
      commander.execute("convert -trim #{names.in_file} #{names.out_file}")
    elsif FileType.audio?(names.in_file) then
      threshold = (options[:threshold]) ? options[:threshold] : "-40dB"
      commander.execute("ffmpeg -i #{names.in_file} -af \"silenceremove=start_periods=1:start_duration=0:start_threshold=#{threshold}:detection=peak\" #{names.out_file}")
    end
  end

  desc "resize", "resize the image"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  option :width, aliases: "w", :type => :string,
         :banner => "e.g. 300",
         :desc => "resized image width"
  option :height, aliases: "h", :type => :string,
         :banner => "e.g. 200",
         :desc => "resized image height"
  option :operation, aliases: "p", :type => :string,
         :banner => "enlarge|shrink",
         :desc => "permitted operation for resizing"
  def resize()
    names = Names.new(options[:in], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    if FileType.video?(names.in_file) then
      if options[:width] and options[:height]
        out_opts = []
        out_opts << format("-vf scale=%s:%s,setsar=1:1", options[:width], options[:height])
        commander.execute(FFMPEG.command([FFMPEGOptSet.new(names.in_file, [])],
                                         [FFMPEGOptSet.new(names.out_file, out_opts)]))
      end
    elsif FileType.image?(names.in_file) then
      return if options[:width] == nil && options[:height] == nil
      if options[:operation] == "enlarge"
        op = "<"
      elsif options[:operation] == "shrink"
        op = ">"
      else
        op = ""
      end
      geometry = format("%sx%s%s", options[:width], options[:height], op)
      commander.execute("convert -resize #{geometry} #{names.in_file} #{names.out_file}")
    end
  end

  desc "concat", "concat multiple files"
  option :in, aliases: "i", :type => :array, :required => true
  option :out, aliases: "o", :type => :string
  def concat()
    names = Names.new(options[:in][0], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    srcs = options[:in]
    output = names.out_file

    if srcs.all? { |src| FileType.video?(src) }
      src_list = ""
      src_file = Tempfile.open()
      chap_file = Tempfile.open()
      chap_file.write("### Create Chapterfile ###\n")
      files_to_remove = []
      time_accumulated = Time.new(0)
      srcs.each_with_index do |src, index|
        valid_src =
          if src =~ /^\p{Ascii}+$/
            src
          else
            Dir::Tmpname.create('base') do |src_dup|
              FileUtils.cp(src, src_dup)
              files_to_remove << src_dup
              src_dup
            end
          end
        src_file.write("file '#{File.expand_path(valid_src)}'\n")
        chap_file.write("CHAPTER#{index + 1}=#{time_accumulated.strftime('%H:%M:%S.%L')}\n")
        chap_file.write("CHAPTER#{index + 1}NAME=#{File.basename(src, File.extname(src))}\n")
        duration = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "#{src}"`.strip().to_f()
        time_accumulated += duration
      end
      src_file.flush
      commander.execute("ffmpeg -n -f concat -safe 0 -i #{src_file.path} -c:v copy -c:a copy -c:s copy -map 0:v -map 0:a -map 0:s? #{output}")
      src_file.close
      chap_file.flush
      commander.execute("MP4Box -chap #{chap_file.path} #{output}")
      chap_file.close
      src_file.unlink
      chap_file.unlink
      FileUtils.rm_f(files_to_remove)
    elsif srcs.all? { |src| FileType.image?(src) }
      commander.execute "convert #{srcs.join(' ')} #{output}"
    else
      STDERR.puts "This Media Format is not supported on this function"
      exit false
    end
  end

  desc "diff", "measure the difference by providing SSIM value"
  option :out, aliases: "o", :type => :string
  def diff(file1, file2)
    commander = Commander.new(options[:log], options[:dryrun])

    if ((FileType.video?(file1) and FileType.video?(file2)) or
        (FileType.image?(file1) and FileType.image?(file2))) then
      if options[:out] then
        commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim=#{options[:out]} -an -f null -")
      else
        commander.execute("ffmpeg -i #{file1} -i #{file2} -filter_complex ssim -an -f null -")
      end
    end
  end

  desc "mux", "mux to one file which has streams correspond with input files"
  option :video, aliases: "v", :type => :string, :required => true
  option :audio, aliases: "a", :type => :string, :required => true
  option :audio_delay, aliases: "d", :type => :string
  option :out, aliases: "o", :type => :string
  def mux()
    names = Names.new(options[:video], options[:out])
    commander = Commander.new(options[:log], options[:dryrun])

    in_optsets = []
    in_optsets << FFMPEGOptSet.new(options[:video], [])
    aconf = []
    aconf << "-itsoffset #{options[:audio_delay]}" if options[:audio_delay]
    in_optsets << FFMPEGOptSet.new(options[:audio], aconf)
    commander.execute(FFMPEG.command(in_optsets,
                                     [FFMPEGOptSet.new(names.out_file, [])]))
  end
end

class MainConfig
  attr_accessor :start, :end
end

class VideoConfig
  attr_accessor :encode, :quality, :bitrate, :preset, :tune, :profile, :level

  DEFAULT_ENCODE = 'vp9'
  DEFAULT_QUALITY = '26'
  DEFAULT_BITRATE = '1000'

  def initialize(encode, quality=nil, bitrate=nil)
    @encode = encode
    @quality = quality
    @bitrate = bitrate

    case @encode
    when "x265"
      @preset = "veryslow"
      @tune = "ssim"
      @profile = "main"
      @level = nil
    when "x264"
      @preset = "veryslow"
      @tune = "film"
      @profile = "main"
      @level = "4.1"
    end
  end
end

class PictureConfig
  # conversion options
  attr_accessor :vf_opts, :fps

  def initialize()
    @vf_opts = []
    @vf_opts << "format=yuv420p"
  end

  # down-size to fit to display (width:heigh) in keeping aspect ratio
  def fit_size(display_size)
    @vf_opts << "scale=#{display_size}:force_original_aspect_ratio=decrease"
    @vf_opts << "pad=((iw+1)/2)*2:((ih+1)/2)*2" # avoid width/height to odd
  end

  def decrease_framerate(fps)
    @fps = fps
  end
end

class AudioConfig
  attr_accessor :encode, :quality, :bitrate

  DEFAULT_ENCODE = 'opus'
  DEFAULT_QUALITY = '100'
  DEFAULT_BITRATE = '128'

  def initialize(encode, quality=nil, bitrate=nil)
    # @encode = (encode ? encode : DEFAULT_ENCODE)
    @encode = encode
    @quality = quality
    @bitrate = bitrate
  end

  def quality
    case @encode
    when 'opus'
    else
      @quality
    end
  end

  def bitrate
    case @encode
    when 'opus'
      (@bitrate ? @bitrate : DEFAULT_BITRATE)
    else
      @bitrate
    end
  end
end

class DVDConfig
  attr_accessor :title, :chapters, :audio, :subtitle, :options
  attr_accessor :chapter_marker

  def initialize
    @chapter_marker = true
  end
end

class ImageConfig
  attr_reader :quality # 1~100
end

class FFMPEGOptSet < Struct.new(:fname, :optset)
end

class FFMPEG
  def self.command(in_optsets, out_optsets)
    opts = ["ffmpeg"]

    infilep = proc do |fname, optset|
      opt_arr = []
      optset.each do |opt|
        if opt.instance_of?(String)
          opt_arr << opt
        end
      end
      opt_arr << ["-i", "\"#{fname}\""]
      next opt_arr
    end
    in_optsets.each do |in_optset|
      opts << infilep.call(in_optset.fname, in_optset.optset)
    end

    outfilep = proc do |fname, optset|
      oopts = []
      optset.each do |opt|
        if opt.instance_of?(VideoConfig)
          case opt.encode
          when 'av1'
            oopts << format("-c:v librav1e")
            if opt.bitrate
              oopts << format("-b:v %sk", opt.bitrate)
            end
          when 'vp9'
            oopts << format("-c:v libvpx-vp9")
            if opt.quality
              oopts << format("-crf %s", opt.quality)
              oopts << format("-b:v 0")
            elsif opt.bitrate
              oopts << format("-b:v %s", opt.bitrate)
            end
          when 'h265'
            oopts << format("-c:v libx265")
            oopts << format("-crf %s", opt.quality)
            oopts << format("-preset %s", opt.preset) if opt.preset
            oopts << format("-tune %s", opt.tune) if opt.tune
            # Currently, ffmpeg ​does not support setting profiles on x265
            oopts << format("-profile:v %s", opt.profile) if opt.profile && opt.encoder == 'x264'
            oopts << format("-level %s", opt.level) if opt.level
          else
            oopts << format("-c:v copy")
          end
        elsif opt.instance_of?(AudioConfig)
          case opt.encode
          when 'opus'
            oopts << format("-c:a lib%s", opt.encode)
            oopts << format("-b:a %sk", opt.bitrate) if opt.bitrate
          when 'aac'
            oopts << format("-c:a libfdk_aac")
            if opt.quality
              oopts << format("-aq %s", opt.quality)
              oopts << format("-b:a 0")
            elsif opt.bitrate
              oopts << format("-b:a %s", opt.bitrate)
            end
          else
            oopts << format("-c:a copy")
          end
        elsif opt.instance_of?(PictureConfig)
          oopts << format("-vf \"%s\"", opt.vf_opts.join(",")) if opt.vf_opts && opt.vf_opts.any?
          oopts << format("-r %s", opt.fps) if opt.fps
        elsif opt.instance_of?(String)
          oopts << opt
        end
      end
      oopts << "\"#{fname}\""
      next oopts
    end
    out_optsets.each do |out_optset|
      opts << outfilep.call(out_optset.fname, out_optset.optset)
    end

    opts.join(" ")
  end
end

class HandBrakeCLI
  def self.command(input, output, configs, raw_option)
    cmd_opts = ["HandBrakeCLI"]
    cmd_opts << format("--input \"%s\"", input)
    cmd_opts << format("--output \"%s\"", output)
    configs.each do |config|
      if config.instance_of?(VideoConfig)
        case config.encode
        when 'vp9'
          cmd_opts << format("--encoder VP9")
          if config.quality
            cmd_opts << format("--quality %s", config.quality)
            cmd_opts << format("--vb 0")
          elsif config.bitrate
            cmd_opts << format("--vb %s", config.bitrate)
          end
          cmd_opts << format("--encoder-preset veryslow")
        when 'h265' || 'hevc'
          cmd_opts << format("--encoder x265")
          if config.quality
            cmd_opts << format("--quality %s", config.quality)
            cmd_opts << format("--vb 0")
          elsif config.bitrate
            cmd_opts << format("--vb %s", config.bitrate)
          end
          cmd_opts << format("--encoder-preset %s", config.preset) if config.preset
          cmd_opts << format("--encoder-tune %s", config.tune) if config.tune
          cmd_opts << format("--encoder-profile %s", config.profile) if config.profile
          cmd_opts << format("--encoder-level %s", config.level) if config.level
        else
          cmd_opts << format("--encoder %s", config.encode) if config.encode
          cmd_opts << format("--quality %s", config.quality) if config.quality
          cmd_opts << format("--vb %s", config.bitrate) if config.bitrate
        end
      elsif config.instance_of?(AudioConfig)
        case config.encode
        when 'opus'
          cmd_opts << format("--aencoder %s", config.encode)
          cmd_opts << format("--aq %s", config.quality) if config.quality
          cmd_opts << format("--ab %s", config.bitrate) if config.bitrate
        when 'aac'
          cmd_opts << format("--aencoder ca_haac")
          if config.quality
            cmd_opts << format("--aq %s", config.quality)
            cmd_opts << format("--ab 0")
          elsif config.bitrate
            cmd_opts << format("--ab %s", config.bitrate)
          end
        else
          cmd_opts << format("--aencoder copy")
        end
      elsif config.instance_of?(DVDConfig)
        cmd_opts << (config.title ? format("--title %s", config.title) : "--main-feature")
        cmd_opts << format("--chapters %s", config.chapters) if config.chapters
        cmd_opts << "--markers" if config.chapter_marker
        cmd_opts << (config.audio ? format("--audio %s", config.audio) : "--all-audio" )
        cmd_opts << (config.subtitle ? format("--subtitle %s", config.subtitle) : "--all-subtitles" )
      end
    end

    cmd_opts << raw_option if raw_option

    cmd_opts.join(" ")
  end
end

class ImageMagick
  COMMAND = "convert %s %s %s %s "

  def self.command(input, output, pconfig, raw_option="")
    input_opt = ""
    output_opt = ""
    if pconfig.instance_of?(ImageConfig) then
      input_opt += "-quality %s" % pconfig.quality if pconfig.quality
      s = COMMAND % [input, input_opt, output, output_opt]
      s
    end
  end
end

MediaUtil.start(ARGV)
#+end_src
** genalbum

Personal script for encoding family pictures and movies.

#+begin_src ruby :tangle (expand-file-name "genalbum" tangle/local-bin-dir)
require 'fileutils'
require 'time'
require 'exifr'
require 'streamio-ffmpeg'
require 'pathname'
require 'thor'

PICTURE_FILE_EXTS = [".jpg"]
MOVIE_FILE_EXTS = [".mp4"]
ALBUM_DIR_NAME = "album/"
RENAME_DIR_NAME = "rename/"
WEB_DIR_NAME = "album_web/"
IMG_PREFIX = "img_"

class GenAlbum < Thor
  default_command :album
  desc "[album] -i <img_dir>", "generate album"
  option :in, aliases: "i", :type => :string, :required => true
  def album
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = ALBUM_DIR_NAME

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    Dir.glob(src_path + "/*").each do |img_file|
      basename = File::basename(img_file)
      src_file = src_path + "/" + basename
      dest_file = dest_path + "/" + basename
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        system("convert -resize \"4096x>\" -quality 92 #{src_file} #{dest_file}")
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        system("mediautil encode -i #{src_file} -o #{dest_file} -q 22.0 -Q 100.0")
      end
    end
  end

  desc "web -i <img_dir>", "generate lightweight album for web"
  option :in, aliases: "i", :type => :string, :required => true
  def web
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = WEB_DIR_NAME

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    Dir.glob(src_path + "/*").each do |img_file|
      basename = File::basename(img_file)
      src_file = src_path + "/" + basename
      dest_file = dest_path + "/" + basename
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        system("convert -resize \"1024x>\" -quality 80 #{src_file} #{dest_file}")
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        system("mediautil encode -i #{src_file} -o #{dest_file} -q 26.0 -Q 100.0")
      end
    end
  end

  desc "renmae -i <img_dir>", "rename image files in chlonological order"
  option :in, aliases: "i", :type => :string, :required => true
  option :out, aliases: "o", :type => :string
  def rename
    src_path = File.expand_path(options[:in], Dir.pwd)
    dest_path = ((options[:out]) ? options[:out] : RENAME_DIR_NAME)

    FileUtils.mkdir_p(dest_path) unless FileTest.exist?(dest_path)

    img_time = {}
    Dir.glob(src_path + "/*").each do |img_file|
      ext = File.extname(img_file)
      if PICTURE_FILE_EXTS.index(ext.downcase) != nil then
        pic = EXIFR::JPEG.new(img_file)
        if pic.exif? && pic.date_time_original then
          img_time[img_file] = pic.date_time_original
        else
          img_time[img_file] = Time.now
        end
      elsif MOVIE_FILE_EXTS.index(ext.downcase) != nil then
        movie = FFMPEG::Movie.new(img_file)
        time = movie.creation_time
        if time then
          img_time[img_file] = time
        else
          img_time[img_file] = Time.now
        end
      end
    end
    img_time = img_time.sort_by{ |_, v| v }

    digit = img_time.length.to_s.length
    digit = 2 if digit < 2
    img_time.each_with_index do |(img, time), i|
      ext = File.extname(img).downcase
      base = IMG_PREFIX + "%0#{digit}d" % (i + 1) + ext
      src_file = img
      dest_file = dest_path + "/" + base
      system("cp #{src_file} #{dest_file}")
    end
  end
end

GenAlbum.start(ARGV)
#+end_src

** nhp                                         :ARCHIVE:
Exec command in background
#+begin_src bash :noweb tangle :tangle (expand-file-name ".local/bin/nhp")
#!/usr/bin/env bash

readonly MAIL_FROM="<<email>>"
readonly MAIL_TO="<<email>>"

function usage() {
  cat <<_EOT_
Usage:
  $(basename "$0") [options] command|exefile

Description:
  $(basename "$0") executes command(s) in back-ground process continueing after the user logs out

Options:
  -l <logfile>  log file name
  -p <pidfile>  process id file name
  -h            help

_EOT_
  exit 1
}

if [ "${OPTIND}" = 1 ]; then
  while getopts l:p:h OPT
  do
    case ${OPT} in
    l)
      opt_logfile=${OPTARG}
      ;;
    p)
      opt_pidfile=${OPTARG}
      ;;
    h)
      usage
      ;;
    \?)
      echo "Try to enter the h option." 1>&2
      ;;
    esac
  done
else
  echo "No installed getopts-command." 1>&2
  exit 1
fi

shift $((OPTIND - 1))

function mailtome() {
  local _command=$1
  local _whole_command=$2
  local _logfile_rel=$4

  if [ "$3" -eq 0 ]; then
    _result='success'
  else
    _result='failed'
  fi
  _logfile=$(type realpath >/dev/null && realpath "${_logfile_rel}" || echo "${_logfile_rel}")

  mailfrom=${MAIL_FROM}
  mailto=${MAIL_TO}
  subject="${_result}: ${_command} @ $(uname -n)"
  msg1="command line      : ${_whole_command}"
  msg2="exit status(nohup): $3"
  msg3="execution time    : $5"
  msg4="pwd               : $(pwd)"
  msg5="Log data (stdout/stderr) is stored in following file:"
  msg6="${_logfile}"

  {
    echo "${msg1}"
    echo "${msg2}"
    echo "${msg3}"
    echo "${msg4}"
    echo "${msg5}"
    echo "${msg6}"
  } | sendmail.py -f "${mailfrom}" -s "${subject}" "${mailto}"
}
export -f mailtome

if [ $# -eq 1 ] && [ -x "$1" ]; then
  utility="$1"
elif [ $# -gt 0 ] && type "$1" >/dev/null; then
  utility="$*"
else
  exit 1
fi

LOG_DIR=${HOME}/.local/state/log/$(basename "$0")
fname_default=$(date '+%Y%m%d_%H%M%S')_$(basename "$0")-$(basename "$1")

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p "${LOG_DIR}"
fi

if [ -v "opt_logfile" ]; then
  logfile=${opt_logfile}
else
  logfile="${LOG_DIR}/${fname_default}.log"
fi

if [ -v "opt_pidfile" ]; then
  pidfile=${opt_pidfile}
else
  pidfile="${LOG_DIR}/${fname_default}.pid"
fi

(
  start_time=$(date +%s)
  nohup nice -n 10 ${utility} >>"${logfile}" </dev/null 2>&1 &
  PID=$!
  echo $PID >"${pidfile}"
  wait $PID
  EXIT_STATUS=$?
  end_time=$(date +%s)
  exec_time=$((end_time-start_time))
  ((h=exec_time/3600))
  ((m=(exec_time%3600)/60))
  ((s=exec_time%60))
  exec_time_str=$(printf "%02d:%02d:%02d" $h $m $s)
  mailtome "$1" "${utility}" $EXIT_STATUS "${logfile}" ${exec_time_str}
)
echo "$1 has finished successfully"

exit 0
#+end_src

** sendmail.py
Utility for sendind email programatically
#+begin_src python :noweb tangle :tangle (expand-file-name "sendmail.py" tangle/local-bin-dir)
import sys
import argparse
import subprocess
import smtplib
import ssl
from email.mime.text import MIMEText
from email.utils import formatdate

def sendmail(mail_to, mail_from, subject, message):
    smtp_host = 'smtp.<<my-domain()>>'
    smtp_port = '465'
    smtp_user = '<<email>>'.split(sep='@')[0]
    smtp_pass = subprocess.run(["pass {}:{}/{} | head -1".format(smtp_host, smtp_port, smtp_user)], stdout=subprocess.PIPE, shell=True).stdout.decode().strip()

    mime_msg = MIMEText(message)
    mime_msg['Subject'] = subject
    mime_msg['From'] = mail_from
    mime_msg['To'] = mail_to
    mime_msg["Date"] = formatdate(None, True)

    if smtp_port == '465':
        context = ssl.create_default_context()
        smtp = smtplib.SMTP_SSL(smtp_host, smtp_port, context=context)

    if smtp is not None:
        smtp.login(smtp_user, smtp_pass)
        smtp.sendmail(mail_from, mail_to, mime_msg.as_string())
        smtp.quit()


DESC = 'sendmail.py sends mail'
parser = argparse.ArgumentParser(description=DESC)
parser.add_argument('-s', '--subject')
parser.add_argument('-f', '--mailfrom')
parser.add_argument('to')
args = parser.parse_args()

message = sys.stdin.read()
sendmail(args.to, args.mailfrom, args.subject, message)
#+end_src

** pwsudo

Nifty script that executes command with elevating privilege using password from pass command.

#+NAME: pwsudo
#+begin_src bash :noweb tangle :tangle (expand-file-name "pwsudo" tangle/local-bin-dir)
_userid=$(whoami)
_hostname=$(hostname)
_exec_path=$(which $1)

pas=$(pass show "${_hostname}/${_userid}" 2>/dev/null) \
  && ( echo "${pas}" | head -1 | sudo -S -p "" "$_exec_path" "${@:2}" ) \
  || sudo -S "$_exec_path" "${@:2}"

exit $?
#+end_src

** gitsync                                     :ARCHIVE:
:PROPERTIES:
:CREATED:  [2022-09-29 Thu 16:42]
:END:

- gitsync-local
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-local")
  #!/usr/bin/env bash

  function usage() {
    cat <<_EOT_
  Usage:
    $0 <prj_root>

  Description:
    $0 adds file changes in git projects under root_dir to the repository

  Options:
    prj_root:  a root directory that has git projects as children

  _EOT_
    exit 1
  }

  # parameter check
  if [ $# -ne 1 ]; then
    usage
    exit 1
  fi
  root_dir=$1

  if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
      while read repo
      do
        cd ${repo} || continue

        # skip if this is not git repo
        git rev-parse || continue

        echo "repository: ${repo}"

        cd `git rev-parse --show-toplevel`
        sync_mode=`git config sync.mode`
        case "${sync_mode}" in
        "auto" )
          # Remove deleted files
          git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
          # Add new files
          git add . >/dev/null 2>&1
          git commit -m "$(date)";;
        "manual" )
          git add -u >/dev/null 2>&1
          git commit -m "$(date)";;
        "none" )
        ;;
        esac
      done
    }
  then
    printf "\nAll done.\n"
  else
    printf "\nFix and redo.\n"
  fi
  #+end_src

- gitsync-remote
  #+begin_src shell :noweb tangle :tangle (expand-file-name ".local/bin/gitsync-remote")
  #!/usr/bin/env bash

  # Local bare repository name
  syncrepo=origin

  # Display repository name only once
  log_repo() {
    [ "x$lastrepo" == "x$repo" ] || {
      printf "\nREPO: ${repo}\n"
      lastrepo="$repo"
    }
  }

  # Log a message for a repository
  log_msg() {
    log_repo
    printf "  $1\n"
  }

  # fast-forward reference $1 to $syncrepo/$1
  fast_forward_ref() {
    log_msg "fast-forwarding ref $1"
    current_ref=$(cat .git/HEAD)
    if [ "x$current_ref" = "xref: refs/heads/$1" ]
    then
      # Check for dirty index
      files=$(git diff-index --name-only HEAD --)
      git merge refs/remotes/$syncrepo/$1
    else
      git branch -f $1 refs/remotes/$syncrepo/$1
    fi
  }

  # Push reference $1 to $syncrepo
  push_ref() {
    log_msg "Pushing ref $1"
    if ! git push --tags --quiet $syncrepo $1
    then
      exit 1
    fi
  }

  # Check if a ref can be moved
  #   - fast-forwards if behind the sync repo and is fast-forwardable
  #   - Does nothing if ref is up to date
  #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
  #   - Fails if ref and $syncrop/ref have diverged
  check_ref() {
    revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
    revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
    if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
    then
      # Ref $1 is up to date.
      :
    elif [ "x$revlist1" = "x" ]
    then
      # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
      fast_forward_ref $1 || exit 1
    elif [ "x$revlist2" = "x" ]
    then
      # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
      push_ref $1 || exit 1
    else
      log_msg "Ref $1 and $syncrepo/$1 have diverged."
      exit 1
    fi
  }

  # Check all local refs with matching refs in the $syncrepo
  check_refs () {
    git for-each-ref refs/heads/* | while read sha1 commit ref
    do
      ref=${ref/refs\/heads\//}
      git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
      do
        if [ "x$sha1" != "x" -a "x$sha2" != "x" ]
        then
          check_ref $ref || exit 1
        fi
      done
    done
  }

  # parameter check
  if [ $# -ne 1 ]; then
    usage
    exit 1
  fi
  root_dir=$1

  # For all repositories under $reporoot
  #   Check all refs matching $syncrepo and fast-forward, or push as necessary
  #   to synchronize the ref with $syncrepo
  #   Bail out if ref is not fastforwardable so user can fix and rerun
  retval=0
  if find ${root_dir} -mindepth 1 -maxdepth 1 \( -type l -o -type d \) | {
      while read repo
      do
        cd ${repo}

        # continue if this is not git repo
        git rev-parse 2> /dev/null || continue

        upd=$(git remote update $syncrepo 2>&1 || retval=1)
        [ "x$upd" = "xFetching $syncrepo" ] || {
          log_repo
          printf "$upd\n"
        }
        check_refs || retval=1
      done
      exit $retval
    }
  then
    printf "\nAll done.\n"
  else
    printf "\nFix and redo.\n"
  fi

  exit $retval
  #+end_src

** filetype-cli                                :ARCHIVE:
Wrapper script for [[* filetype][filetype.rb]].

#+begin_src ruby :tangle (expand-file-name "filetype-cli" tangle/local-bin-dir)
#!/usr/bin/env ruby

require 'thor'
require 'filetype'

class FileTypeCLI < Thor
  default_command :check
  desc "check", "check whether the file is the speicfied type."
  option :type, aliases: "t", :type => :string, :required => true,
         :bannar => '--type image'
  def check(file)
    unless FileType.respond_to?("#{options[:type]}?")
      $stderr.print("file type '#{options[:type]}' is not valid.")
      exit 1
    end

    status = FileType.send("#{options[:type]}?", file)
    unless status
      $stderr.print("#{file} is not of #{options[:type]}?")
      exit 1
    end

    exit 0
  end
end

FileTypeCLI.start(ARGV)
#+end_src
** strip ruby
A program strips all ruby tags in a HTML stream. All HTML contents are expected to be from STDIN and go out as STDOUT. This procedure is mainly for html files converted from pdf and epub files.
Stripping rules are:
- <ruby> tag will be stripped
- <rt> tree for furigana tree will be removed
- <rp> tree contains parenthes for non-ruby-support brouwser will be removed
- <rb> tag for delimiter will be stripped
- <rtc> tree for semantic word will be removed

#+begin_src python :tangle (expand-file-name "strip_ruby" tangle/local-bin-dir)
import sys
import lxml.html as html

INPUT_STR = sys.stdin.read()
ROOT = html.fromstring(INPUT_STR).getroottree()

for ruby in ROOT.xpath('//ruby'):
    for rt in ruby.xpath('//rt'):
        rt.drop_tree()
    for rp in ruby.xpath('//rp'):
        rp.drop_tree()
    for rb in ruby.xpath('//rb'):
        rb.drop_tag()
    for rtc in ruby.xpath('//rtc'):
        rtc.drop_tree()
        ruby.drop_tag()

CONTENT = html.tostring(ROOT, encoding="utf-8", method='html', pretty_print=True)
print(CONTENT.decode())
#+end_src
* Local Variables
:PROPERTIES:
:CREATED:  [2023-12-14 Thu 21:36]
:END:

# Local Variables:
# compile-command: "make tangle"
# eval: (add-hook 'after-save-hook #'my/compile-default-command nil t)
# auto-save-visited-mode: nil
# buffer-save-without-query: t
# End:
